// src/config.ts
import { resolve } from "path";
import { existsSync as existsSync2 } from "fs";

// src/route-scanner.ts
import { readdirSync, statSync, existsSync } from "fs";
import { join, relative, parse } from "path";
import pc from "picocolors";
function scanViewsDirectory(cwd) {
  const viewsDir = join(cwd, "src", "views");
  if (!existsSync(viewsDir)) {
    console.log(pc.yellow(`\u26A0 Views directory not found: ${viewsDir}`));
    return [];
  }
  console.log(pc.cyan(`
\u{1F4C2} Scanning views directory...`));
  const routes = [];
  function scanDirectory(dir, basePath = "") {
    const files = readdirSync(dir);
    for (const file of files) {
      const fullPath = join(dir, file);
      const stat = statSync(fullPath);
      if (stat.isDirectory()) {
        const subPath = basePath ? `${basePath}/${file}` : file;
        scanDirectory(fullPath, subPath);
      } else if (file.endsWith(".vue")) {
        const route = parseVueFile(fullPath, viewsDir, basePath);
        if (route) {
          routes.push(route);
        }
      }
    }
  }
  scanDirectory(viewsDir);
  routes.sort((a, b) => {
    if (a.path === "/") return -1;
    if (b.path === "/") return 1;
    return a.path.localeCompare(b.path);
  });
  console.log(pc.green(`\u2713 Found ${routes.length} routes:`));
  routes.forEach((route) => {
    console.log(pc.dim(`  ${route.path} \u2192 ${route.component}.vue`));
  });
  console.log();
  return routes;
}
function parseVueFile(filePath, viewsDir, basePath) {
  const relativePath = relative(viewsDir, filePath);
  const parsed = parse(relativePath);
  const component = relativePath.replace(/\.vue$/, "");
  let path = generateRoutePath(parsed.dir, parsed.name);
  const title = generateTitle(parsed.name);
  return {
    path,
    component,
    meta: {
      title
    }
  };
}
function generateRoutePath(dir, name) {
  if (!dir && (name === "HomePage" || name === "Index" || name === "Home")) {
    return "/";
  }
  const processSegment = (segment) => {
    if (segment.startsWith("[") && segment.endsWith("]")) {
      return ":" + segment.slice(1, -1);
    }
    return kebabCase(segment);
  };
  const segments = [];
  if (dir) {
    dir.split(/[/\\]/).forEach((segment) => {
      segments.push(processSegment(segment));
    });
  }
  if (name !== "Index" && name !== "index") {
    segments.push(processSegment(name));
  }
  return "/" + segments.join("/");
}
function generateTitle(name) {
  name = name.replace(/(Page|View|Component)$/, "");
  const words = name.replace(/([A-Z])/g, " $1").trim();
  return words;
}
function kebabCase(str) {
  return str.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
}
function mergeRoutes(autoRoutes, manualRoutes) {
  const routeMap = /* @__PURE__ */ new Map();
  autoRoutes.forEach((route) => {
    routeMap.set(route.path, route);
  });
  manualRoutes.forEach((route) => {
    routeMap.set(route.path, route);
  });
  return Array.from(routeMap.values());
}

// src/config.ts
var CONFIG_FILES = [
  "gress-dev.config.js",
  "gress-dev.config.mjs",
  "gress-dev.config.ts"
];
async function loadConfig(cwd = process.cwd()) {
  let userConfig;
  for (const configFile of CONFIG_FILES) {
    const configPath = resolve(cwd, configFile);
    if (existsSync2(configPath)) {
      try {
        const module = await import(`file://${configPath}`);
        userConfig = module.default || module;
        break;
      } catch (error) {
        console.warn(`Failed to load config from ${configFile}:`, error);
      }
    }
  }
  if (!userConfig) {
    throw new Error(
      `No config file found. Please create one of: ${CONFIG_FILES.join(", ")}`
    );
  }
  if (!userConfig.pluginName) {
    throw new Error("pluginName is required in config");
  }
  const autoScanRoutes = userConfig.autoScanRoutes !== false;
  let finalRoutes = userConfig.devRoutes || [];
  if (autoScanRoutes) {
    const scannedRoutes = scanViewsDirectory(cwd);
    finalRoutes = mergeRoutes(scannedRoutes, userConfig.devRoutes || []);
  }
  const config = {
    pluginName: userConfig.pluginName,
    backendUrl: userConfig.backendUrl || "http://localhost:8080",
    port: userConfig.port || 3e3,
    apiPrefix: userConfig.apiPrefix || `/api/plugin/${userConfig.pluginName}`,
    hmr: userConfig.hmr !== false,
    open: userConfig.open || false,
    base: userConfig.base || "/",
    vite: userConfig.vite,
    proxy: userConfig.proxy || {},
    autoScanRoutes,
    devRoutes: finalRoutes,
    devMenus: userConfig.devMenus || []
  };
  return config;
}
function createProxyConfig(config) {
  const defaultProxy = {
    [config.apiPrefix]: {
      target: config.backendUrl,
      changeOrigin: true,
      ws: true,
      configure: (proxy, options) => {
        proxy.on("error", (err) => {
          console.error("Proxy error:", err);
        });
        proxy.on("proxyReq", (proxyReq, req) => {
          console.log(`[Proxy] ${req.method} ${req.url} -> ${options.target}${req.url}`);
        });
      }
    }
  };
  return {
    ...defaultProxy,
    ...config.proxy
  };
}

// src/server.ts
import { createServer, mergeConfig } from "vite";
import { resolve as resolve3 } from "path";
import pc2 from "picocolors";

// src/vite-plugin.ts
import { resolve as resolve2 } from "path";

// src/virtual-app.ts
function generateComponentImports(routes) {
  const imports = [];
  const seen = /* @__PURE__ */ new Set();
  function collectComponents(routeList) {
    routeList.forEach((route) => {
      const component = route.component;
      if (!seen.has(component)) {
        seen.add(component);
        const importName = component.replace(/[\/\-]/g, "_");
        imports.push(`import ${importName} from '../src/views/${component}.vue'`);
      }
      if (route.children) {
        collectComponents(route.children);
      }
    });
  }
  collectComponents(routes);
  return imports.join("\n");
}
function generateComponentMap(routes) {
  const entries = [];
  const seen = /* @__PURE__ */ new Set();
  function collectComponents(routeList) {
    routeList.forEach((route) => {
      const component = route.component;
      if (!seen.has(component)) {
        seen.add(component);
        const importName = component.replace(/[\/\-]/g, "_");
        entries.push(`  '${component}': ${importName}`);
      }
      if (route.children) {
        collectComponents(route.children);
      }
    });
  }
  collectComponents(routes);
  return `{
${entries.join(",\n")}
}`;
}
function generateVirtualRouter(pluginName, projectRoot, routes) {
  const componentImports = generateComponentImports(routes);
  const componentMap = generateComponentMap(routes);
  return `import { createRouter, createWebHistory } from 'vue-router'

// \u5BFC\u5165\u6240\u6709\u9700\u8981\u7684\u7EC4\u4EF6
${componentImports}

// \u7EC4\u4EF6\u6620\u5C04\u8868
const componentMap = ${componentMap}

console.log('[Gress Dev Router] Available components:', Object.keys(componentMap))
console.log('[Gress Dev Router] Project root: ${projectRoot}')

/**
 * \u89E3\u6790\u7EC4\u4EF6\u8DEF\u5F84
 */
function resolveComponent(componentPath) {
  const component = componentMap[componentPath]
  
  if (!component) {
    console.error(\`[Gress Dev Router] Component not found: \${componentPath}\`)
    console.log('[Gress Dev Router] Available:', Object.keys(componentMap))
    return () => Promise.resolve({
      template: \`<div style="padding: 20px; color: red;">
        <h2>\u7EC4\u4EF6\u672A\u627E\u5230</h2>
        <p>\u8DEF\u5F84: \${componentPath}</p>
        <details>
          <summary>\u53EF\u7528\u7EC4\u4EF6</summary>
          <pre>\${Object.keys(componentMap).join('\\n')}</pre>
        </details>
      </div>\`
    })
  }
  
  return component
}

/**
 * \u4ECE\u5F00\u53D1\u670D\u52A1\u5668\u83B7\u53D6\u8DEF\u7531\u914D\u7F6E
 */
async function fetchRoutes() {
  try {
    console.log('[Gress Dev Router] Fetching routes from /v2/plugins/${pluginName}/routes')
    const response = await fetch('/v2/plugins/${pluginName}/routes')
    const data = await response.json()
    console.log('[Gress Dev Router] Routes response:', data)
    return data.data || []
  } catch (error) {
    console.error('[Gress Dev Router] Failed to fetch routes:', error)
    return []
  }
}

/**
 * \u8F6C\u6362\u8DEF\u7531\u914D\u7F6E\u4E3A Vue Router \u683C\u5F0F
 */
function convertToVueRoutes(routes) {
  return routes.map(route => {
    const vueRoute = {
      path: route.path,
      name: route.component.replace(/[\\/]/g, '-'),
      component: resolveComponent(route.component),
      meta: route.meta || {}
    }
    
    // \u5904\u7406\u5B50\u8DEF\u7531
    if (route.children && route.children.length > 0) {
      vueRoute.children = convertToVueRoutes(route.children)
    }
    
    return vueRoute
  })
}

// \u521B\u5EFA\u8DEF\u7531\u5B9E\u4F8B
const router = createRouter({
  history: createWebHistory(),
  routes: [] // \u521D\u59CB\u4E3A\u7A7A\uFF0C\u52A8\u6001\u52A0\u8F7D
})

// \u521D\u59CB\u5316\u8DEF\u7531
export async function initRouter() {
  console.log('[Gress Dev Router] Initializing...')
  
  const routeConfigs = await fetchRoutes()
  console.log('[Gress Dev Router] Fetched route configs:', routeConfigs)
  
  if (routeConfigs.length === 0) {
    console.warn('[Gress Dev Router] No routes found, adding fallback route')
    router.addRoute({
      path: '/:pathMatch(.*)*',
      component: () => Promise.resolve({
        template: \`<div style="padding: 20px;">
          <h2>\u672A\u627E\u5230\u8DEF\u7531\u914D\u7F6E</h2>
          <p>\u8BF7\u68C0\u67E5 gress-dev.config.js \u4E2D\u7684 devRoutes \u914D\u7F6E</p>
          <p>\u6216\u786E\u4FDD src/views \u76EE\u5F55\u4E0B\u6709 .vue \u6587\u4EF6</p>
        </div>\`
      })
    })
    return
  }
  
  const vueRoutes = convertToVueRoutes(routeConfigs)
  console.log('[Gress Dev Router] Converted Vue routes:', vueRoutes)
  
  // \u52A8\u6001\u6DFB\u52A0\u8DEF\u7531
  vueRoutes.forEach(route => {
    router.addRoute(route)
    console.log(\`[Gress Dev Router] Added route: \${route.path} -> \${route.name}\`)
  })
  
  console.log('[Gress Dev Router] Total routes registered:', router.getRoutes().length)
  console.log('[Gress Dev Router] Route paths:', router.getRoutes().map(r => r.path))
}

export default router
`;
}

// src/vite-plugin.ts
var VIRTUAL_ROUTER_ID = "virtual:gress-dev-router";
var RESOLVED_ROUTER_ID = "\0" + VIRTUAL_ROUTER_ID;
function createVirtualAppPlugin(config, projectRoot) {
  return {
    name: "vite-plugin-gress-dev-virtual-app",
    // 解析虚拟模块 ID
    resolveId(id, importer) {
      if (id === VIRTUAL_ROUTER_ID) {
        return RESOLVED_ROUTER_ID;
      }
      if (importer === RESOLVED_ROUTER_ID && id.startsWith("../src/views/")) {
        const componentPath = id.replace("../src/views/", "");
        const absolutePath = resolve2(projectRoot, "src/views", componentPath);
        return absolutePath;
      }
      return null;
    },
    // 加载虚拟模块内容
    load(id) {
      if (id === RESOLVED_ROUTER_ID) {
        return generateVirtualRouter(config.pluginName, projectRoot, config.devRoutes);
      }
      return null;
    },
    // 配置 Vite
    config() {
      return {
        // 设置入口文件
        build: {
          rollupOptions: {
            input: {
              main: `${projectRoot}/.gress-dev/index.html`
            }
          }
        }
      };
    }
  };
}

// src/scaffold.ts
import { mkdirSync, writeFileSync, existsSync as existsSync3 } from "fs";
import { join as join3 } from "path";
function generateScaffold(config, cwd) {
  const scaffoldDir = join3(cwd, ".gress-dev");
  if (!existsSync3(scaffoldDir)) {
    mkdirSync(scaffoldDir, { recursive: true });
  }
  const indexHtml = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gress Plugin Dev - ${config.pluginName}</title>
</head>
<body>
  <div id="app"></div>
  <script type="module" src="./main.ts"></script>
</body>
</html>
`;
  const mainTs = `import { createApp } from 'vue'
import App from './App.vue'
import router, { initRouter } from 'virtual:gress-dev-router'

// \u521B\u5EFA\u6A21\u62DF\u7684 GressBridge
function createMockGressBridge() {
  const bridge = {
    http: {
      request: async (config) => {
        console.log('[Mock Bridge] HTTP request:', config)
        return { data: null, status: 200, statusText: 'OK' }
      },
      get: async (url, config) => {
        console.log('[Mock Bridge] GET:', url)
        return { data: null, status: 200, statusText: 'OK' }
      },
      post: async (url, data, config) => {
        console.log('[Mock Bridge] POST:', url, data)
        return { data: null, status: 200, statusText: 'OK' }
      },
      put: async (url, data, config) => {
        console.log('[Mock Bridge] PUT:', url, data)
        return { data: null, status: 200, statusText: 'OK' }
      },
      delete: async (url, config) => {
        console.log('[Mock Bridge] DELETE:', url)
        return { data: null, status: 200, statusText: 'OK' }
      },
      getBaseURL: () => '${config.backendUrl}'
    },
    router: {
      push: (to) => {
        console.log('[Mock Bridge] Router push:', to)
        return router.push(to)
      },
      replace: (to) => {
        console.log('[Mock Bridge] Router replace:', to)
        return router.replace(to)
      },
      back: () => {
        console.log('[Mock Bridge] Router back')
        router.back()
      },
      forward: () => {
        console.log('[Mock Bridge] Router forward')
        router.forward()
      },
      currentRoute: router.currentRoute
    },
    events: {
      on: (event, handler) => {
        console.log('[Mock Bridge] Event on:', event)
        return { unsubscribe: () => {} }
      },
      emit: (event, data) => {
        console.log('[Mock Bridge] Event emit:', event, data)
      },
      off: (event, handler) => {
        console.log('[Mock Bridge] Event off:', event)
      }
    },
    notification: {
      success: (message, options) => {
        console.log('[Mock Bridge] Notification success:', message)
        alert(\`\u2713 \${message}\`)
      },
      error: (message, options) => {
        console.error('[Mock Bridge] Notification error:', message)
        alert(\`\u2717 \${message}\`)
      },
      warning: (message, options) => {
        console.warn('[Mock Bridge] Notification warning:', message)
        alert(\`\u26A0 \${message}\`)
      },
      info: (message, options) => {
        console.info('[Mock Bridge] Notification info:', message)
        alert(\`\u2139 \${message}\`)
      }
    },
    storage: {
      get: (key) => {
        const value = localStorage.getItem(\`gress_plugin_\${key}\`)
        return value ? JSON.parse(value) : null
      },
      set: (key, value) => {
        localStorage.setItem(\`gress_plugin_\${key}\`, JSON.stringify(value))
      },
      remove: (key) => {
        localStorage.removeItem(\`gress_plugin_\${key}\`)
      },
      clear: () => {
        Object.keys(localStorage).forEach(key => {
          if (key.startsWith('gress_plugin_')) {
            localStorage.removeItem(key)
          }
        })
      }
    },
    ui: {
      message: {
        success: (msg) => alert(\`\u2713 \${msg}\`),
        error: (msg) => alert(\`\u2717 \${msg}\`),
        warning: (msg) => alert(\`\u26A0 \${msg}\`),
        info: (msg) => alert(\`\u2139 \${msg}\`)
      }
    },
    version: '1.0.0-mock'
  }
  
  // \u6CE8\u5165\u5230\u5168\u5C40
  window.GressBridge = bridge
  
  return bridge
}

async function bootstrap() {
  console.log('[Gress Dev] Initializing plugin: ${config.pluginName}')
  
  // \u521B\u5EFA\u5E76\u6CE8\u5165\u6A21\u62DF Bridge
  const bridge = createMockGressBridge()
  console.log('[Gress Dev] Mock GressBridge injected')
  
  const app = createApp(App)
  
  // \u521D\u59CB\u5316\u8DEF\u7531
  await initRouter()
  
  // \u6CE8\u518C\u8DEF\u7531
  app.use(router)
  
  // \u6302\u8F7D\u5E94\u7528
  app.mount('#app')
  
  console.log('[Gress Dev] Application mounted')
  console.log('[Gress Dev] Available routes:', router.getRoutes().map(r => r.path))
  console.log('[Gress Dev] GressBridge available at window.GressBridge')
}

bootstrap().catch(err => {
  console.error('[Gress Dev] Bootstrap failed:', err)
  document.body.innerHTML = \`
    <div style="padding: 20px; color: red;">
      <h2>\u542F\u52A8\u5931\u8D25</h2>
      <pre>\${err.stack || err.message}</pre>
    </div>
  \`
})
`;
  const appVue = `<template>
  <div id="gress-dev-app">
    <router-view v-slot="{ Component }">
      <transition name="fade" mode="out-in">
        <component :is="Component" />
      </transition>
    </router-view>
  </div>
</template>

<script setup lang="ts">
import { onMounted } from 'vue'
import { useRouter } from 'vue-router'

const router = useRouter()

onMounted(() => {
  console.log('[Gress Dev] App mounted')
})
</script>

<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

#gress-dev-app {
  width: 100%;
  min-height: 100vh;
}

.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.2s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>
`;
  writeFileSync(join3(scaffoldDir, "index.html"), indexHtml);
  writeFileSync(join3(scaffoldDir, "main.ts"), mainTs);
  writeFileSync(join3(scaffoldDir, "App.vue"), appVue);
  console.log(`[Gress Dev] Scaffold files generated in ${scaffoldDir}`);
  return scaffoldDir;
}

// src/server.ts
function createMockApiMiddleware(config) {
  return (req, res, next) => {
    const url = req.url || "";
    if (url === `/v2/plugins/${config.pluginName}/routes` || url.startsWith(`/api/v2/plugins/${config.pluginName}/routes`)) {
      console.log(pc2.cyan(`[Mock API] GET ${url}`));
      res.setHeader("Content-Type", "application/json");
      res.end(JSON.stringify({
        code: 200,
        data: config.devRoutes,
        message: "success"
      }));
      return;
    }
    if (url === `/v2/plugins/${config.pluginName}/menus` || url.startsWith(`/api/v2/plugins/${config.pluginName}/menus`)) {
      console.log(pc2.cyan(`[Mock API] GET ${url}`));
      res.setHeader("Content-Type", "application/json");
      res.end(JSON.stringify({
        code: 200,
        data: config.devMenus,
        message: "success"
      }));
      return;
    }
    next();
  };
}
async function startServer(config, cwd = process.cwd()) {
  console.log(pc2.cyan(`
\u{1F680} Starting Gress Plugin Dev Server...
`));
  console.log(pc2.gray(`Plugin: ${pc2.bold(config.pluginName)}`));
  console.log(pc2.gray(`Backend: ${config.backendUrl}`));
  console.log(pc2.gray(`API Prefix: ${config.apiPrefix}`));
  if (config.autoScanRoutes) {
    console.log(pc2.gray(`Auto Scan: ${pc2.bold("enabled")}`));
  }
  if (config.devRoutes.length > 0) {
    console.log(pc2.gray(`Routes: ${pc2.bold(config.devRoutes.length)} routes configured`));
  }
  if (config.devMenus.length > 0) {
    console.log(pc2.gray(`Menus: ${pc2.bold(config.devMenus.length)} menus configured`));
  }
  console.log();
  const scaffoldDir = generateScaffold(config, cwd);
  const baseConfig = {
    root: scaffoldDir,
    // 使用脚手架目录作为根目录
    base: config.base,
    server: {
      port: config.port,
      strictPort: false,
      open: config.open,
      hmr: config.hmr,
      proxy: createProxyConfig(config),
      fs: {
        // 允许访问项目根目录的文件
        allow: [cwd, scaffoldDir]
      }
    },
    plugins: [
      // 动态导入 @vitejs/plugin-vue
      (async () => {
        try {
          const { default: vue } = await import("@vitejs/plugin-vue");
          return vue();
        } catch (error) {
          console.error(pc2.red("\n\u2717 @vitejs/plugin-vue not found"));
          console.error(pc2.yellow("Please install it: npm install @vitejs/plugin-vue --save-dev\n"));
          throw error;
        }
      })(),
      createVirtualAppPlugin(config, cwd)
      // 传入项目根目录
    ],
    define: {
      "__PLUGIN_NAME__": JSON.stringify(config.pluginName),
      "__API_PREFIX__": JSON.stringify(config.apiPrefix),
      "__BACKEND_URL__": JSON.stringify(config.backendUrl)
    },
    optimizeDeps: {
      include: ["vue", "vue-router", "pinia"]
    },
    resolve: {
      alias: {
        "@": resolve3(cwd, "src"),
        // 关键：让虚拟模块中的 /src 指向项目根目录的 src
        "/src": resolve3(cwd, "src")
      }
    }
  };
  const finalConfig = config.vite ? mergeConfig(baseConfig, config.vite) : baseConfig;
  try {
    const server = await createServer(finalConfig);
    if (config.devRoutes.length > 0 || config.devMenus.length > 0) {
      server.middlewares.stack.unshift({
        route: "",
        handle: createMockApiMiddleware(config)
      });
      console.log(pc2.green(`\u2713 Mock API middleware enabled`));
    }
    await server.listen();
    const info = server.config.logger.info;
    const serverUrl = server.resolvedUrls?.local[0] || `http://localhost:${config.port}`;
    console.log();
    info(pc2.green(`\u2713 Dev server running at:`));
    info(pc2.cyan(`  ${serverUrl}`));
    console.log();
    info(pc2.gray(`Backend proxy: ${pc2.bold(config.backendUrl)}`));
    info(pc2.gray(`API requests to ${pc2.bold(config.apiPrefix)} will be proxied`));
    if (config.devRoutes.length > 0) {
      console.log();
      info(pc2.gray(`Mock routes available:`));
      config.devRoutes.forEach((route) => {
        info(pc2.dim(`  ${route.path} \u2192 ${route.component}.vue`));
      });
    }
    console.log();
    info(pc2.dim(`Press ${pc2.bold("h")} to show help, ${pc2.bold("q")} to quit`));
    console.log();
    process.on("SIGTERM", () => server.close());
    process.on("SIGINT", () => server.close());
    return server;
  } catch (error) {
    console.error(pc2.red("\n\u2717 Failed to start dev server:\n"));
    console.error(error);
    process.exit(1);
  }
}
export {
  createProxyConfig,
  loadConfig,
  startServer
};
//# sourceMappingURL=index.js.map