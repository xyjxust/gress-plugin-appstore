"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const axios = require("axios");
const defaultHeaderConfig = (_config) => {
  const headers = {};
  const token = localStorage.getItem("token");
  if (token) {
    headers.Authorization = `Bearer ${token}`;
  }
  const namespace = localStorage.getItem("namespace") || "default";
  {
    headers["X-Namespace"] = namespace;
  }
  const clientId = localStorage.getItem("gress_sse_client_id");
  if (clientId) {
    headers["X-Client-Id"] = clientId;
  }
  return headers;
};
const defaultMessageHandler = {
  success: (msg) => console.log("[Success]", msg),
  error: (msg) => console.error("[Error]", msg),
  warning: (msg) => console.warn("[Warning]", msg),
  info: (msg) => console.info("[Info]", msg)
};
const defaultRouterHandler = {
  push: (path) => {
    if (typeof window !== "undefined") {
      window.location.href = path;
    }
  }
};
class RequestClient {
  constructor(options = {}) {
    const {
      headerConfig = defaultHeaderConfig,
      messageHandler = defaultMessageHandler,
      routerHandler = defaultRouterHandler,
      ...axiosConfig
    } = options;
    this.headerConfig = headerConfig;
    this.messageHandler = messageHandler;
    this.routerHandler = routerHandler;
    this.instance = axios.create({
      timeout: 3e4,
      ...axiosConfig
    });
    this.setupInterceptors();
  }
  /**
   * 设置 Header 配置函数
   */
  setHeaderConfig(headerConfig) {
    this.headerConfig = headerConfig;
  }
  /**
   * 设置消息处理器
   */
  setMessageHandler(messageHandler) {
    this.messageHandler = messageHandler;
  }
  /**
   * 设置路由处理器
   */
  setRouterHandler(routerHandler) {
    this.routerHandler = routerHandler;
  }
  setupInterceptors() {
    this.instance.interceptors.request.use(
      (config) => {
        if (this.headerConfig) {
          const dynamicHeaders = this.headerConfig(config);
          config.headers = config.headers || {};
          Object.assign(config.headers, dynamicHeaders);
        }
        return config;
      },
      (error) => {
        return Promise.reject(error);
      }
    );
    this.instance.interceptors.response.use(
      (response) => {
        return this.handleResponse(response);
      },
      (error) => {
        return this.handleError(error);
      }
    );
  }
  handleResponse(response) {
    const config = response.config;
    const { isReturnNativeResponse, isTransformResponse = true } = config;
    if (isReturnNativeResponse) {
      return response;
    }
    if (!isTransformResponse) {
      return response.data;
    }
    const responseData = response.data;
    if (!responseData) {
      console.error("响应数据为空:", response);
      throw new Error("请求失败，未返回数据");
    }
    if (typeof responseData !== "object") {
      console.error("响应数据类型错误:", typeof responseData, responseData);
      throw new Error("响应数据格式错误");
    }
    const { code, data, errorMessage: msg } = responseData;
    if (code === void 0 || code === null) {
      console.error("响应数据缺少 code 字段:", responseData);
      throw new Error("响应数据格式错误：缺少 code 字段");
    }
    const hasSuccess = code === 200;
    if (hasSuccess) {
      if (config.successMessageMode === "message" && msg) {
        this.messageHandler.success(msg);
      }
      return data;
    }
    return this.handleBusinessError(code, msg, config);
  }
  handleBusinessError(code, msg, config) {
    const errorMessageMode = config.errorMessageMode ?? "message";
    switch (code) {
      case 401: {
        localStorage.removeItem("token");
        this.messageHandler.error("登录已过期，请重新登录");
        this.routerHandler.push("/login");
        break;
      }
      case 403: {
        this.messageHandler.error("没有权限访问该资源");
        break;
      }
      case 404: {
        this.messageHandler.error("请求的资源不存在");
        break;
      }
      default: {
        if (errorMessageMode === "message" && msg) {
          this.messageHandler.error(msg);
        }
      }
    }
    throw new Error(msg || "请求失败");
  }
  handleError(error) {
    const config = error.config;
    const errorMessageMode = (config == null ? void 0 : config.errorMessageMode) ?? "message";
    let errorMessage = "请求失败";
    if (error.response) {
      const { status, data } = error.response;
      errorMessage = (data == null ? void 0 : data.message) || `请求失败 (${status})`;
    } else if (error.request) {
      errorMessage = "网络错误，请检查网络连接";
    } else {
      errorMessage = error.message || "请求配置错误";
    }
    if (errorMessageMode === "message") {
      this.messageHandler.error(errorMessage);
    }
    return Promise.reject(error);
  }
  // GET 请求
  get(url, config) {
    return this.instance.get(url, config);
  }
  // POST 请求
  post(url, data, config) {
    return this.instance.post(url, data, config);
  }
  // PUT 请求
  put(url, data, config) {
    return this.instance.put(url, data, config);
  }
  // DELETE 请求
  delete(url, config) {
    return this.instance.delete(url, config);
  }
  // PATCH 请求
  patch(url, data, config) {
    return this.instance.patch(url, data, config);
  }
  // 获取原始 axios 实例
  getAxiosInstance() {
    return this.instance;
  }
}
function createRequestClient(options = {}) {
  return new RequestClient(options);
}
const requestClient = createRequestClient({
  baseURL: "/api",
  headers: {
    "Content-Type": "application/json"
  },
  headerConfig: defaultHeaderConfig
});
const request = {
  get: (url, config) => requestClient.get(url, config),
  post: (url, data, config) => requestClient.post(url, data, config),
  put: (url, data, config) => requestClient.put(url, data, config),
  delete: (url, config) => requestClient.delete(url, config),
  patch: (url, data, config) => requestClient.patch(url, data, config)
};
function getGressBridge() {
  if (typeof window !== "undefined" && window.GressBridge) {
    return window.GressBridge;
  }
  throw new Error("GressBridge未初始化");
}
const http = {
  /**
   * GET请求
   */
  async get(url, params) {
    const bridge = getGressBridge();
    let fullUrl = url;
    if (params) {
      const filteredParams = {};
      for (const [key, value] of Object.entries(params)) {
        if (value !== void 0 && value !== null && value !== "") {
          filteredParams[key] = String(value);
        }
      }
      if (Object.keys(filteredParams).length > 0) {
        const queryString = new URLSearchParams(filteredParams).toString();
        fullUrl = `${url}?${queryString}`;
      }
    }
    try {
      const response = await bridge.http.get(fullUrl);
      if (response && response.success === false) {
        const errorMessage = response.message || "请求失败";
        throw new Error(errorMessage);
      }
      return response;
    } catch (error) {
      throw error;
    }
  },
  /**
   * POST请求
   */
  async post(url, data) {
    const bridge = getGressBridge();
    try {
      const response = await bridge.http.post(url, data);
      if (response && response.success === false) {
        const errorMessage = response.message || "请求失败";
        throw new Error(errorMessage);
      }
      return response;
    } catch (error) {
      throw error;
    }
  },
  /**
   * PUT请求
   */
  async put(url, data) {
    const bridge = getGressBridge();
    try {
      const response = await bridge.http.put(url, data);
      if (response && response.success === false) {
        const errorMessage = response.message || "请求失败";
        throw new Error(errorMessage);
      }
      return response;
    } catch (error) {
      throw error;
    }
  },
  /**
   * DELETE请求
   */
  async delete(url) {
    const bridge = getGressBridge();
    try {
      const response = await bridge.http.delete(url);
      if (response && response.success === false) {
        const errorMessage = response.message || "请求失败";
        throw new Error(errorMessage);
      }
      return response;
    } catch (error) {
      throw error;
    }
  }
};
class Storage {
  /**
   * 设置值
   * 
   * @param key 键名
   * @param value 值（会自动序列化为 JSON）
   * @param expire 过期时间（毫秒），可选
   */
  static set(key, value, expire) {
    try {
      const item = {
        value,
        timestamp: Date.now(),
        expire
      };
      localStorage.setItem(key, JSON.stringify(item));
    } catch (error) {
      console.error(`[Storage] 设置值失败: ${key}`, error);
      throw error;
    }
  }
  /**
   * 获取值
   * 
   * @param key 键名
   * @param defaultValue 默认值，如果键不存在或已过期则返回此值
   * @returns 值或默认值
   */
  static get(key, defaultValue) {
    try {
      const itemStr = localStorage.getItem(key);
      if (!itemStr) {
        return defaultValue;
      }
      const item = JSON.parse(itemStr);
      if (item.expire && item.timestamp) {
        const now = Date.now();
        const expireTime = item.timestamp + item.expire;
        if (now > expireTime) {
          localStorage.removeItem(key);
          return defaultValue;
        }
      }
      return item.value;
    } catch (error) {
      console.error(`[Storage] 获取值失败: ${key}`, error);
      localStorage.removeItem(key);
      return defaultValue;
    }
  }
  /**
   * 获取值（必须存在，否则抛出错误）
   * 
   * @param key 键名
   * @returns 值
   * @throws 如果键不存在或已过期
   */
  static getRequired(key) {
    const value = this.get(key);
    if (value === void 0) {
      throw new Error(`Storage key "${key}" is required but not found`);
    }
    return value;
  }
  /**
   * 删除值
   * 
   * @param key 键名
   */
  static remove(key) {
    try {
      localStorage.removeItem(key);
    } catch (error) {
      console.error(`[Storage] 删除值失败: ${key}`, error);
    }
  }
  /**
   * 检查键是否存在且未过期
   * 
   * @param key 键名
   * @returns 是否存在
   */
  static has(key) {
    try {
      const itemStr = localStorage.getItem(key);
      if (!itemStr) {
        return false;
      }
      const item = JSON.parse(itemStr);
      if (item.expire && item.timestamp) {
        const now = Date.now();
        const expireTime = item.timestamp + item.expire;
        if (now > expireTime) {
          localStorage.removeItem(key);
          return false;
        }
      }
      return true;
    } catch (error) {
      console.error(`[Storage] 检查键失败: ${key}`, error);
      return false;
    }
  }
  /**
   * 清空所有存储（谨慎使用）
   */
  static clear() {
    try {
      localStorage.clear();
    } catch (error) {
      console.error("[Storage] 清空存储失败", error);
    }
  }
  /**
   * 获取所有键名
   * 
   * @returns 键名数组
   */
  static keys() {
    try {
      return Object.keys(localStorage);
    } catch (error) {
      console.error("[Storage] 获取键名列表失败", error);
      return [];
    }
  }
  /**
   * 获取存储大小（字节，近似值）
   * 
   * @returns 存储大小
   */
  static size() {
    try {
      let total = 0;
      for (const key in localStorage) {
        if (localStorage.hasOwnProperty(key)) {
          const item = localStorage.getItem(key);
          if (item) {
            total += item.length + key.length;
          }
        }
      }
      return total;
    } catch (error) {
      console.error("[Storage] 计算存储大小失败", error);
      return 0;
    }
  }
}
class SimpleStorage {
  /**
   * 设置简单值
   */
  static set(key, value) {
    try {
      localStorage.setItem(key, String(value));
    } catch (error) {
      console.error(`[SimpleStorage] 设置值失败: ${key}`, error);
      throw error;
    }
  }
  /**
   * 获取简单值
   */
  static get(key, defaultValue) {
    try {
      const value = localStorage.getItem(key);
      return value ?? defaultValue;
    } catch (error) {
      console.error(`[SimpleStorage] 获取值失败: ${key}`, error);
      return defaultValue;
    }
  }
  /**
   * 获取数字值
   */
  static getNumber(key, defaultValue) {
    const value = this.get(key);
    if (value === void 0) {
      return defaultValue;
    }
    const num = Number(value);
    return isNaN(num) ? defaultValue : num;
  }
  /**
   * 获取布尔值
   */
  static getBoolean(key, defaultValue) {
    const value = this.get(key);
    if (value === void 0) {
      return defaultValue;
    }
    return value === "true";
  }
  /**
   * 删除值
   */
  static remove(key) {
    try {
      localStorage.removeItem(key);
    } catch (error) {
      console.error(`[SimpleStorage] 删除值失败: ${key}`, error);
    }
  }
  /**
   * 检查键是否存在
   */
  static has(key) {
    return localStorage.getItem(key) !== null;
  }
}
function formatDate(date, format = "YYYY-MM-DD HH:mm:ss") {
  const d = typeof date === "string" || typeof date === "number" ? new Date(date) : date;
  if (isNaN(d.getTime())) {
    return "";
  }
  const year = d.getFullYear();
  const month = String(d.getMonth() + 1).padStart(2, "0");
  const day = String(d.getDate()).padStart(2, "0");
  const hours = String(d.getHours()).padStart(2, "0");
  const minutes = String(d.getMinutes()).padStart(2, "0");
  const seconds = String(d.getSeconds()).padStart(2, "0");
  return format.replace("YYYY", String(year)).replace("MM", month).replace("DD", day).replace("HH", hours).replace("mm", minutes).replace("ss", seconds);
}
function getRelativeTime(date) {
  const d = typeof date === "string" || typeof date === "number" ? new Date(date) : date;
  const now = /* @__PURE__ */ new Date();
  const diff = now.getTime() - d.getTime();
  const seconds = Math.floor(diff / 1e3);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);
  if (days > 0) return `${days}天前`;
  if (hours > 0) return `${hours}小时前`;
  if (minutes > 0) return `${minutes}分钟前`;
  if (seconds > 0) return `${seconds}秒前`;
  return "刚刚";
}
function capitalize(str) {
  if (!str) return "";
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function kebabCase(str) {
  return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function camelCase(str) {
  return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
}
function truncate(str, length, suffix = "...") {
  if (str.length <= length) return str;
  return str.slice(0, length) + suffix;
}
function randomString(length = 8) {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let result = "";
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}
function deepClone(obj) {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }
  if (obj instanceof Array) {
    return obj.map((item) => deepClone(item));
  }
  if (obj instanceof Object) {
    const clonedObj = {};
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        clonedObj[key] = deepClone(obj[key]);
      }
    }
    return clonedObj;
  }
  return obj;
}
function deepMerge(target, ...sources) {
  if (!sources.length) return target;
  const source = sources.shift();
  if (!source) return target;
  for (const key in source) {
    const sourceValue = source[key];
    const targetValue = target[key];
    if (isObject(sourceValue) && isObject(targetValue)) {
      target[key] = deepMerge(targetValue, sourceValue);
    } else {
      target[key] = sourceValue;
    }
  }
  return deepMerge(target, ...sources);
}
function isObject(value) {
  return value !== null && typeof value === "object" && !Array.isArray(value);
}
function get(obj, path, defaultValue) {
  const keys = path.split(".");
  let result = obj;
  for (const key of keys) {
    if (result === null || result === void 0) {
      return defaultValue;
    }
    result = result[key];
  }
  return result === void 0 ? defaultValue : result;
}
function set(obj, path, value) {
  const keys = path.split(".");
  const lastKey = keys.pop();
  let current = obj;
  for (const key of keys) {
    if (!(key in current) || !isObject(current[key])) {
      current[key] = {};
    }
    current = current[key];
  }
  current[lastKey] = value;
}
function compact(obj) {
  const result = {};
  for (const key in obj) {
    if (obj[key] !== void 0 && obj[key] !== null) {
      result[key] = obj[key];
    }
  }
  return result;
}
function isEmail(email) {
  const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return regex.test(email);
}
function isPhone(phone) {
  const regex = /^1[3-9]\d{9}$/;
  return regex.test(phone);
}
function isUrl(url) {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}
function isIdCard(idCard) {
  const regex = /(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/;
  return regex.test(idCard);
}
function isEmpty(value) {
  if (value === null || value === void 0) return true;
  if (typeof value === "string") return value.trim().length === 0;
  if (Array.isArray(value)) return value.length === 0;
  if (typeof value === "object") return Object.keys(value).length === 0;
  return false;
}
function isNumber(value) {
  return typeof value === "number" && !isNaN(value);
}
function isInteger(value) {
  return Number.isInteger(value);
}
exports.RequestClient = RequestClient;
exports.SimpleStorage = SimpleStorage;
exports.Storage = Storage;
exports.camelCase = camelCase;
exports.capitalize = capitalize;
exports.compact = compact;
exports.createRequestClient = createRequestClient;
exports.deepClone = deepClone;
exports.deepMerge = deepMerge;
exports.defaultHeaderConfig = defaultHeaderConfig;
exports.formatDate = formatDate;
exports.get = get;
exports.getRelativeTime = getRelativeTime;
exports.http = http;
exports.isEmail = isEmail;
exports.isEmpty = isEmpty;
exports.isIdCard = isIdCard;
exports.isInteger = isInteger;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isPhone = isPhone;
exports.isUrl = isUrl;
exports.kebabCase = kebabCase;
exports.randomString = randomString;
exports.request = request;
exports.requestClient = requestClient;
exports.set = set;
exports.truncate = truncate;
//# sourceMappingURL=index.cjs.map
