var __GRESS_PLUGIN__ = function(exports, vue, naiveUi) {
  "use strict";var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

  var __vite_style__ = document.createElement("style");
  __vite_style__.textContent = `@charset "UTF-8";
.application-management-page[data-v-6096b87c] {
  height: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background: #f5f5f5;
}
.page-content[data-v-6096b87c] {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

/* 加载和空状态 */
.loading-state[data-v-6096b87c] {
  display: flex;
  align-items: center;
  justify-content: center;
  flex: 1;
  padding: 60px;
}
.empty-state[data-v-6096b87c] {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  flex: 1;
  padding: 60px;
  text-align: center;
  color: #999;
  gap: 16px;
}
.empty-state__icon[data-v-6096b87c] {
  opacity: 0.5;
}
.empty-state__text[data-v-6096b87c] {
  font-size: 14px;
}

/* 应用列表 */
.app-list[data-v-6096b87c] {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(380px, 1fr));
  gap: 16px;
  margin-top: 12px;
}
.app-card[data-v-6096b87c] {
  transition: all 0.3s ease;
  cursor: pointer;
  position: relative;
  z-index: 1;
  display: flex;
  flex-direction: column;
}
.app-card[data-v-6096b87c] .n-card {
  height: 100%;
  display: flex;
  flex-direction: column;
}
.app-card[data-v-6096b87c]:hover {
  transform: translateY(-4px);
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
  z-index: 2;
}
.app-card[data-v-6096b87c] .n-card__content {
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  height: 100%;
}

/* 应用卡片头部 */
.app-header[data-v-6096b87c] {
  display: flex;
  align-items: center;
  gap: 12px;
  flex-shrink: 0;
}
.app-icon[data-v-6096b87c] {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 44px;
  height: 44px;
  border-radius: 8px;
  flex-shrink: 0;
}
.app-icon--integrated[data-v-6096b87c] {
  background: rgba(99, 102, 241, 0.1);
  color: #6366f1;
}
.app-icon--plugin[data-v-6096b87c] {
  background: rgba(16, 185, 129, 0.1);
  color: #10b981;
}
.app-info[data-v-6096b87c] {
  flex: 1;
  min-width: 0;
}
.app-name[data-v-6096b87c] {
  font-size: 15px;
  font-weight: 600;
  color: #1f2937;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  margin-bottom: 2px;
  display: flex;
  align-items: center;
}
.app-code[data-v-6096b87c] {
  font-size: 12px;
  color: #6b7280;
  font-family: monospace;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.app-status[data-v-6096b87c] {
  flex-shrink: 0;
}

/* 应用卡片主体 */
.app-body[data-v-6096b87c] {
  display: flex;
  flex-direction: column;
  gap: 12px;
  flex: 1;
}
.app-meta[data-v-6096b87c] {
  display: flex;
  flex-direction: column;
  gap: 6px;
}
.meta-item[data-v-6096b87c] {
  font-size: 13px;
  color: #6b7280;
  display: flex;
  align-items: center;
  gap: 4px;
}
.meta-label[data-v-6096b87c] {
  color: #9ca3af;
}
.meta-value[data-v-6096b87c] {
  color: #1f2937;
  font-family: monospace;
  font-size: 12px;
}
.app-description[data-v-6096b87c] {
  font-size: 13px;
  color: #6b7280;
  line-height: 1.5;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* 应用卡片底部 */
.app-footer[data-v-6096b87c] {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 8px;
  border-top: 1px solid #e5e7eb;
  font-size: 12px;
  color: #9ca3af;
  margin-top: auto;
  flex-shrink: 0;
}
.app-time[data-v-6096b87c] {
  display: flex;
  align-items: center;
  gap: 4px;
}
.app-actions[data-v-6096b87c] {
  display: flex;
  align-items: center;
  gap: 8px;
}

/* 分页 */
.pagination[data-v-6096b87c] {
  display: flex;
  justify-content: flex-end;
  padding: 16px 0;
  margin-top: 8px;
}

/* 详情抽屉 */
.app-detail[data-v-6096b87c] {
  display: flex;
  flex-direction: column;
  gap: 16px;
}
.detail-section[data-v-6096b87c] {
  margin-bottom: 16px;
}

/* 响应式设计 */
@media (max-width: 768px) {
.page-content[data-v-6096b87c] {
    padding: 12px;
}
.app-list[data-v-6096b87c] {
    grid-template-columns: 1fr;
}
}

/* 升级信息弹窗 */
.upgrade-info[data-v-6096b87c] {
  padding: 4px 0;
}
.upgrade-info[data-v-6096b87c] .n-descriptions {
  margin-top: 0;
}
.upgrade-info[data-v-6096b87c] .n-descriptions-item-label {
  font-weight: 500;
}
.upgrade-log-list[data-v-6096b87c] {
  max-height: 480px;
  overflow-y: auto;
  padding-right: 4px;
}
.upgrade-log-item[data-v-6096b87c] {
  margin-top: 4px;
  font-size: 13px;
  color: #4b5563;
}
.upgrade-log-row[data-v-6096b87c] {
  display: flex;
  gap: 4px;
  line-height: 1.6;
}

/* 配置对话框样式 */
.config-modal-content[data-v-6096b87c] {
  display: flex;
  flex-direction: column;
  gap: 16px;
  padding-right: 8px; /* 为滚动条留出空间 */
}
.app-info-card[data-v-6096b87c] {
  background: #f8f9fa;
}
.app-info-row[data-v-6096b87c] {
  display: flex;
  gap: 32px;
  flex-wrap: wrap;
}
.app-info-item[data-v-6096b87c] {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
}
.info-label[data-v-6096b87c] {
  color: #6b7280;
  font-weight: 500;
}
.info-value[data-v-6096b87c] {
  color: #1f2937;
  font-weight: 600;
}
.config-section[data-v-6096b87c] {
  margin-bottom: 0;
}
.advanced-config-grid[data-v-6096b87c] {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 16px 24px;
  margin-bottom: 16px;
}
.advanced-config-grid[data-v-6096b87c] .n-form-item {
  margin-bottom: 0;
}
.advanced-config-grid[data-v-6096b87c] .n-form-item-label {
  font-size: 13px;
}

/* 滚动条样式优化 */
[data-v-6096b87c] .n-scrollbar-rail {
  right: 0;
}
[data-v-6096b87c] .n-scrollbar-rail__scrollbar {
  width: 6px;
  border-radius: 3px;
}

/* 操作日志样式 */
.operation-log-list[data-v-6096b87c] {
  padding: 16px 0;
}
.log-header[data-v-6096b87c] {
  display: flex;
  align-items: center;
  font-size: 14px;
}
.log-content[data-v-6096b87c] {
  margin-top: 8px;
  font-size: 13px;
}
.log-row[data-v-6096b87c] {
  display: flex;
  gap: 8px;
  margin-bottom: 4px;
  line-height: 1.6;
}
.log-label[data-v-6096b87c] {
  color: #9ca3af;
  font-weight: 500;
  min-width: 60px;
}
.log-value[data-v-6096b87c] {
  color: #1f2937;
  flex: 1;
}
.config-diff[data-v-6096b87c] {
  margin-top: 12px;
}
.config-compare[data-v-6096b87c] {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
  margin-top: 8px;
}
.config-column[data-v-6096b87c] {
  border: 1px solid #e5e7eb;
  border-radius: 4px;
  overflow: hidden;
}
.config-title[data-v-6096b87c] {
  background: #f3f4f6;
  padding: 8px 12px;
  font-weight: 600;
  font-size: 13px;
  color: #374151;
  border-bottom: 1px solid #e5e7eb;
}
.config-content[data-v-6096b87c] {
  padding: 12px;
  margin: 0;
  font-size: 12px;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  background: #fafafa;
  overflow-x: auto;
  max-height: 300px;
  overflow-y: auto;
}
@media (max-width: 768px) {
.advanced-config-grid[data-v-6096b87c] {
    grid-template-columns: 1fr;
}
.config-modal-content[data-v-6096b87c] {
    padding-right: 4px;
}
.config-compare[data-v-6096b87c] {
    grid-template-columns: 1fr;
}
}

.operation-log-page[data-v-1f12c0f3] {
  display: flex;
  flex-direction: column;
  height: 100%;
  background: #f5f5f5;
}
.page-header-wrapper[data-v-1f12c0f3] {
  background: white;
  border-bottom: 1px solid #e8e8e8;
}
.page-content[data-v-1f12c0f3] {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 16px;
  padding: 16px;
  overflow: auto;
}
.table-container[data-v-1f12c0f3] {
  flex: 1;
  background: white;
  border-radius: 8px;
  padding: 16px;
  overflow: auto;
  display: flex;
  flex-direction: column;
}
.pagination-container[data-v-1f12c0f3] {
  display: flex;
  justify-content: flex-end;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid #f0f0f0;
}
.log-detail[data-v-1f12c0f3] {
  display: flex;
  flex-direction: column;
  gap: 16px;
}
.detail-section[data-v-1f12c0f3] {
  margin-bottom: 16px;
}
.config-diff[data-v-1f12c0f3] {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
}
.config-column[data-v-1f12c0f3] {
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.config-header[data-v-1f12c0f3] {
  font-weight: 600;
  font-size: 14px;
  color: #333;
  padding: 8px 0;
  border-bottom: 2px solid #e8e8e8;
}
.empty-config[data-v-1f12c0f3] {
  padding: 16px;
  text-align: center;
  color: #999;
  background: #f5f5f5;
  border-radius: 4px;
}

.middleware-management-page[data-v-de190af1] {
  width: 100%;
  display: flex;
  flex-direction: column;
  height: 100%;
}
.page-content[data-v-de190af1] {
  flex: 1;
  padding: 16px;
  overflow: auto;
}
.loading-state[data-v-de190af1] {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 60px 0;
}
.empty-state[data-v-de190af1] {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 60px 0;
  color: #999;
}
.empty-state__icon[data-v-de190af1] {
  margin-bottom: 16px;
}
.empty-state__text[data-v-de190af1] {
  font-size: 14px;
}
.middleware-list[data-v-de190af1] {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
  gap: 16px;
  margin-bottom: 16px;
}
.middleware-card[data-v-de190af1] {
  cursor: pointer;
  transition: all 0.2s;
}
.middleware-card[data-v-de190af1]:hover {
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}
.middleware-header[data-v-de190af1] {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 12px;
}
.middleware-icon[data-v-de190af1] {
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #f5f5f5;
  border-radius: 8px;
  flex-shrink: 0;
}
.middleware-info[data-v-de190af1] {
  flex: 1;
  min-width: 0;
}
.middleware-name[data-v-de190af1] {
  font-size: 16px;
  font-weight: 500;
  margin-bottom: 4px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.middleware-id[data-v-de190af1] {
  font-size: 12px;
  color: #999;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.middleware-body[data-v-de190af1] {
  margin-bottom: 12px;
}
.middleware-meta[data-v-de190af1] {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-bottom: 12px;
}
.meta-item[data-v-de190af1] {
  display: flex;
  align-items: center;
  font-size: 13px;
}
.meta-label[data-v-de190af1] {
  color: #666;
  margin-right: 8px;
  flex-shrink: 0;
}
.meta-value[data-v-de190af1] {
  color: #333;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.middleware-description[data-v-de190af1] {
  font-size: 13px;
  color: #666;
  line-height: 1.5;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}
.middleware-footer[data-v-de190af1] {
  display: flex;
  justify-content: flex-end;
  padding-top: 12px;
  border-top: 1px solid #f0f0f0;
}
.middleware-actions[data-v-de190af1] {
  display: flex;
  gap: 8px;
}
.pagination[data-v-de190af1] {
  display: flex;
  justify-content: center;
  margin-top: 24px;
}
.install-drawer__body[data-v-de190af1] {
  height: 100%;
  display: flex;
  flex-direction: column;
}
.install-drawer__logs[data-v-de190af1] {
  flex: 1;
  background: #000;
  color: #0f0;
  padding: 12px;
  border-radius: 4px;
  font-family: Menlo, Monaco, Consolas, 'Courier New', monospace;
  font-size: 12px;
  overflow: auto;
  white-space: pre-wrap;
}

/* 配置对话框样式 */
.config-modal-content[data-v-de190af1] {
  display: flex;
  flex-direction: column;
  gap: 16px;
  padding-right: 8px;
}
.app-info-card[data-v-de190af1] {
  background: #f8f9fa;
}
.app-info-row[data-v-de190af1] {
  display: flex;
  gap: 32px;
  flex-wrap: wrap;
}
.app-info-item[data-v-de190af1] {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
}
.info-label[data-v-de190af1] {
  color: #6b7280;
  font-weight: 500;
}
.info-value[data-v-de190af1] {
  color: #1f2937;
  font-weight: 600;
}
.config-section[data-v-de190af1] {
  margin-bottom: 0;
}

.node-management-page[data-v-f5a8cbe7] {
  width: 100%;
  display: flex;
  flex-direction: column;
  height: 100%;
}
.page-content[data-v-f5a8cbe7] {
  flex: 1;
  padding: 16px;
  overflow: auto;
}

.plugin-monitor-history .time-range-selector[data-v-2d9dee19] {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}
.plugin-monitor-history .time-range-selector .refresh-btn[data-v-2d9dee19] {
  margin-left: 12px;
}
.plugin-monitor-history .charts-container .chart-card[data-v-2d9dee19] {
  margin-bottom: 16px;
}
.plugin-monitor-history .charts-container .chart-card[data-v-2d9dee19]:last-child {
  margin-bottom: 0;
}
.plugin-monitor-history .charts-container .chart-card .chart[data-v-2d9dee19] {
  height: 300px;
  width: 100%;
}
.plugin-monitor-history .charts-container .chart-card .timeline-chart[data-v-2d9dee19] {
  height: 250px;
}
.plugin-monitor-history .empty-state[data-v-2d9dee19] {
  padding: 60px 0;
}

/* 平板端样式 (768px - 1024px) */
@media screen and (max-width: 1024px) {
.plugin-monitor-history .time-range-selector[data-v-2d9dee19] {
    margin-bottom: 12px;
}
.plugin-monitor-history .time-range-selector[data-v-2d9dee19] .n-radio-group .n-radio-button {
    font-size: 13px;
}
.plugin-monitor-history .charts-container .chart-card[data-v-2d9dee19] {
    margin-bottom: 12px;
}
.plugin-monitor-history .charts-container .chart-card .chart[data-v-2d9dee19] {
    height: 280px;
}
.plugin-monitor-history .charts-container .chart-card .timeline-chart[data-v-2d9dee19] {
    height: 230px;
}
}
/* 移动端样式 (< 768px) */
@media screen and (max-width: 768px) {
.plugin-monitor-history .time-range-selector[data-v-2d9dee19] {
    flex-direction: column;
    align-items: stretch;
    gap: 10px;
    margin-bottom: 12px;
}
.plugin-monitor-history .time-range-selector .refresh-btn[data-v-2d9dee19] {
    margin-left: 0;
    width: 100%;
}
.plugin-monitor-history .time-range-selector[data-v-2d9dee19] .n-radio-group {
    width: 100%;
    display: flex;
}
.plugin-monitor-history .time-range-selector[data-v-2d9dee19] .n-radio-group .n-radio-button {
    flex: 1;
    font-size: 12px;
}
.plugin-monitor-history .charts-container .chart-card[data-v-2d9dee19] {
    margin-bottom: 12px;
}
.plugin-monitor-history .charts-container .chart-card[data-v-2d9dee19] .n-card__header {
    padding: 12px;
    font-size: 15px;
}
.plugin-monitor-history .charts-container .chart-card[data-v-2d9dee19] .n-card__content {
    padding: 12px;
}
.plugin-monitor-history .charts-container .chart-card .chart[data-v-2d9dee19] {
    height: 250px;
}
.plugin-monitor-history .charts-container .chart-card .timeline-chart[data-v-2d9dee19] {
    height: 200px;
}
.plugin-monitor-history .empty-state[data-v-2d9dee19] {
    padding: 40px 0;
}
}
/* 小屏移动端样式 (< 480px) */
@media screen and (max-width: 480px) {
.plugin-monitor-history .time-range-selector[data-v-2d9dee19] .n-radio-group .n-radio-button {
    font-size: 11px;
    padding: 0 8px;
}
.plugin-monitor-history .charts-container .chart-card[data-v-2d9dee19] {
    margin-bottom: 10px;
}
.plugin-monitor-history .charts-container .chart-card[data-v-2d9dee19] .n-card__header {
    padding: 10px;
    font-size: 14px;
}
.plugin-monitor-history .charts-container .chart-card[data-v-2d9dee19] .n-card__content {
    padding: 10px;
}
.plugin-monitor-history .charts-container .chart-card .chart[data-v-2d9dee19] {
    height: 220px;
}
.plugin-monitor-history .charts-container .chart-card .timeline-chart[data-v-2d9dee19] {
    height: 180px;
}
.plugin-monitor-history .empty-state[data-v-2d9dee19] {
    padding: 30px 0;
}
.plugin-monitor-history .empty-state[data-v-2d9dee19] .n-empty__description {
    font-size: 13px;
}
}
.plugin-monitor-detail .error-alert[data-v-5b2f9972] {
  margin-bottom: 16px;
}
.plugin-monitor-detail .info-card[data-v-5b2f9972] {
  margin-bottom: 16px;
}
.plugin-monitor-detail .info-card[data-v-5b2f9972]:last-child {
  margin-bottom: 0;
}
.plugin-monitor-detail .memory-warning[data-v-5b2f9972] {
  color: #f0a020;
  font-weight: bold;
  display: inline-flex;
  align-items: center;
  gap: 4px;
}
.plugin-monitor-detail .dependency-tag[data-v-5b2f9972] {
  margin-right: 8px;
  margin-bottom: 8px;
}

/* 平板端样式 (768px - 1024px) */
@media screen and (max-width: 1024px) {
.plugin-monitor-detail .info-card[data-v-5b2f9972] {
    margin-bottom: 12px;
}
.plugin-monitor-detail[data-v-5b2f9972] .n-descriptions .n-descriptions-table-wrapper {
    font-size: 14px;
}
}
/* 移动端样式 (< 768px) */
@media screen and (max-width: 768px) {
.plugin-monitor-detail .error-alert[data-v-5b2f9972] {
    margin-bottom: 12px;
}
.plugin-monitor-detail .error-alert[data-v-5b2f9972] .n-alert__content {
    font-size: 13px;
}
.plugin-monitor-detail .info-card[data-v-5b2f9972] {
    margin-bottom: 12px;
}
.plugin-monitor-detail .info-card[data-v-5b2f9972] .n-card__header {
    padding: 12px;
    font-size: 15px;
}
.plugin-monitor-detail .info-card[data-v-5b2f9972] .n-card__content {
    padding: 12px;
}
.plugin-monitor-detail[data-v-5b2f9972] .n-descriptions .n-descriptions-table-wrapper {
    font-size: 13px;
}
.plugin-monitor-detail[data-v-5b2f9972] .n-descriptions .n-descriptions-table-content__label {
    padding: 8px;
}
.plugin-monitor-detail[data-v-5b2f9972] .n-descriptions .n-descriptions-table-content__content {
    padding: 8px;
}
.plugin-monitor-detail[data-v-5b2f9972] .n-tabs .n-tabs-nav {
    font-size: 14px;
}
.plugin-monitor-detail .dependency-tag[data-v-5b2f9972] {
    margin-right: 6px;
    margin-bottom: 6px;
    font-size: 12px;
}
.plugin-monitor-detail[data-v-5b2f9972] .n-code {
    font-size: 11px;
}
}
/* 小屏移动端样式 (< 480px) */
@media screen and (max-width: 480px) {
.plugin-monitor-detail .info-card[data-v-5b2f9972] {
    margin-bottom: 10px;
}
.plugin-monitor-detail .info-card[data-v-5b2f9972] .n-card__header {
    padding: 10px;
    font-size: 14px;
}
.plugin-monitor-detail .info-card[data-v-5b2f9972] .n-card__content {
    padding: 10px;
}
.plugin-monitor-detail[data-v-5b2f9972] .n-descriptions .n-descriptions-table-wrapper {
    font-size: 12px;
}
.plugin-monitor-detail[data-v-5b2f9972] .n-descriptions .n-descriptions-table-content__label {
    padding: 6px;
    min-width: 80px;
}
.plugin-monitor-detail[data-v-5b2f9972] .n-descriptions .n-descriptions-table-content__content {
    padding: 6px;
}
.plugin-monitor-detail .dependency-tag[data-v-5b2f9972] {
    font-size: 11px;
}
.plugin-monitor-detail[data-v-5b2f9972] .n-code {
    font-size: 10px;
}
}
.plugin-monitor-dashboard[data-v-9372efef] {
  width: 100%;
  display: flex;
  flex-direction: column;
  height: 100%;
}
.page-content[data-v-9372efef] {
  flex: 1;
  padding: 16px;
  overflow: auto;
}
.refresh-interval-text[data-v-9372efef] {
  color: #666;
  font-size: 14px;
  white-space: nowrap;
}
.overview-cards[data-v-9372efef] {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
  margin-bottom: 20px;
}
.overview-card[data-v-9372efef] .n-statistic .n-statistic-value {
  font-size: 32px;
  font-weight: 600;
}
.error-alert[data-v-9372efef] {
  margin-bottom: 20px;
}

/* 平板端样式 (768px - 1024px) */
@media screen and (max-width: 1024px) {
.page-content[data-v-9372efef] {
    padding: 12px;
}
.overview-cards[data-v-9372efef] {
    grid-template-columns: repeat(2, 1fr);
    gap: 12px;
    margin-bottom: 16px;
}
.overview-card[data-v-9372efef] .n-statistic .n-statistic-value {
    font-size: 28px;
}
.error-alert[data-v-9372efef] {
    margin-bottom: 16px;
}
}
/* 移动端样式 (< 768px) */
@media screen and (max-width: 768px) {
.page-content[data-v-9372efef] {
    padding: 8px;
}
.overview-cards[data-v-9372efef] {
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
    margin-bottom: 12px;
}
.overview-card[data-v-9372efef] .n-statistic .n-statistic-value {
    font-size: 24px;
}
.overview-card[data-v-9372efef] .n-statistic .n-statistic-label {
    font-size: 12px;
}
.refresh-interval-text[data-v-9372efef] {
    font-size: 12px;
}
.error-alert[data-v-9372efef] {
    margin-bottom: 12px;
}
.error-alert[data-v-9372efef] .n-alert__content {
    font-size: 13px;
}
  /* 抽屉在移动端全屏显示 */
[data-v-9372efef] .n-drawer .n-drawer-body-content-wrapper {
    width: 100% !important;
    max-width: 100% !important;
}
}
/* 小屏移动端样式 (< 480px) */
@media screen and (max-width: 480px) {
.page-content[data-v-9372efef] {
    padding: 8px;
}
.overview-cards[data-v-9372efef] {
    grid-template-columns: 1fr;
    gap: 8px;
    margin-bottom: 12px;
}
.overview-card[data-v-9372efef] .n-statistic .n-statistic-value {
    font-size: 28px;
}
.overview-card[data-v-9372efef] .n-statistic .n-statistic-label {
    font-size: 13px;
}
}/*$vite$:1*/`;
  document.head.appendChild(__vite_style__);
  var PluginPermission = /* @__PURE__ */ ((PluginPermission2) => {
    PluginPermission2["NETWORK_ACCESS"] = "network:access";
    PluginPermission2["STORAGE_READ"] = "storage:read";
    PluginPermission2["STORAGE_WRITE"] = "storage:write";
    PluginPermission2["ROUTER_NAVIGATE"] = "router:navigate";
    PluginPermission2["ROUTER_REGISTER"] = "router:register";
    PluginPermission2["COMPONENT_REGISTER"] = "component:register";
    PluginPermission2["COMPONENT_GLOBAL"] = "component:global";
    PluginPermission2["DATA_READ"] = "data:read";
    PluginPermission2["DATA_WRITE"] = "data:write";
    PluginPermission2["UI_MENU"] = "ui:menu";
    PluginPermission2["UI_TOOLBAR"] = "ui:toolbar";
    PluginPermission2["UI_PANEL"] = "ui:panel";
    PluginPermission2["SYSTEM_NOTIFICATION"] = "system:notification";
    PluginPermission2["SYSTEM_CLIPBOARD"] = "system:clipboard";
    return PluginPermission2;
  })(PluginPermission || {});
  function useIcon(iconName) {
    const Ionicons5 = window.Ionicons5;
    if (!Ionicons5) {
      console.warn("[useIcon] Ionicons5 not found on window");
      return null;
    }
    const icon = Ionicons5[iconName];
    if (!icon) {
      console.warn(`[useIcon] Icon not found: ${iconName}`);
      return null;
    }
    return icon;
  }
  function getHostBridge() {
    if (typeof window === "undefined") {
      throw new Error("[useHostBridge] Window is not defined");
    }
    const bridge = window.GressBridge;
    if (!bridge) {
      throw new Error("[useHostBridge] GressBridge is not available. Make sure the plugin is loaded in the host application.");
    }
    return bridge;
  }
  function createMessageApi(bridge) {
    const naiveUI = window.NaiveUI;
    if (naiveUI && naiveUI.useMessage) {
      return {
        success: (content, options) => {
          bridge.notification.success(content, options);
        },
        error: (content, options) => {
          bridge.notification.error(content, options);
        },
        warning: (content, options) => {
          bridge.notification.warning(content, options);
        },
        info: (content, options) => {
          bridge.notification.info(content, options);
        },
        loading: (content, options) => {
          bridge.notification.info(content, { ...options, duration: 0 });
        }
      };
    }
    return {
      success: (content, options) => {
        bridge.notification.success(content, options);
      },
      error: (content, options) => {
        bridge.notification.error(content, options);
      },
      warning: (content, options) => {
        bridge.notification.warning(content, options);
      },
      info: (content, options) => {
        bridge.notification.info(content, options);
      },
      loading: (content, options) => {
        bridge.notification.info(content, { ...options, duration: 0 });
      }
    };
  }
  function createDialogApi(_bridge) {
    const naiveUI = window.NaiveUI;
    if (naiveUI && naiveUI.useDialog) {
      return {
        success: (options) => {
          window.alert(options.content || options.title || "Success");
        },
        error: (options) => {
          window.alert(options.content || options.title || "Error");
        },
        warning: (options) => {
          if (window.confirm(options.content || options.title || "Warning")) {
            const callback = options.onPositiveClick || options.positiveClick;
            callback == null ? void 0 : callback();
          } else {
            const callback = options.onNegativeClick || options.negativeClick;
            callback == null ? void 0 : callback();
          }
        },
        info: (options) => {
          window.alert(options.content || options.title || "Info");
        },
        create: (options) => {
          const result = window.confirm(options.content || options.title || "");
          if (result) {
            const callback = options.onPositiveClick || options.positiveClick;
            callback == null ? void 0 : callback();
          } else {
            const callback = options.onNegativeClick || options.negativeClick;
            callback == null ? void 0 : callback();
          }
          return {
            destroy: () => {
            }
          };
        }
      };
    }
    return {
      success: (options) => {
        window.alert(options.content || options.title || "Success");
      },
      error: (options) => {
        window.alert(options.content || options.title || "Error");
      },
      warning: (options) => {
        if (window.confirm(options.content || options.title || "Warning")) {
          const callback = options.onPositiveClick || options.positiveClick;
          callback == null ? void 0 : callback();
        } else {
          const callback = options.onNegativeClick || options.negativeClick;
          callback == null ? void 0 : callback();
        }
      },
      info: (options) => {
        window.alert(options.content || options.title || "Info");
      },
      create: (options) => {
        const result = window.confirm(options.content || options.title || "");
        if (result) {
          const callback = options.onPositiveClick || options.positiveClick;
          callback == null ? void 0 : callback();
        } else {
          const callback = options.onNegativeClick || options.negativeClick;
          callback == null ? void 0 : callback();
        }
        return {
          destroy: () => {
          }
        };
      }
    };
  }
  function createNotificationApi(bridge) {
    return {
      success: (options) => {
        bridge.notification.success(options.content || options.title, options);
      },
      error: (options) => {
        bridge.notification.error(options.content || options.title, options);
      },
      warning: (options) => {
        bridge.notification.warning(options.content || options.title, options);
      },
      info: (options) => {
        bridge.notification.info(options.content || options.title, options);
      },
      create: (options) => {
        const type = options.type || "info";
        bridge.notification[type](options.content || options.title, options);
        return {
          destroy: () => {
          }
        };
      }
    };
  }
  function createLoadingBarApi(_bridge) {
    let loadingElement = null;
    return {
      start: () => {
        if (!loadingElement) {
          loadingElement = document.createElement("div");
          loadingElement.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          height: 2px;
          background: #18a058;
          z-index: 9999;
          transition: width 0.3s;
        `;
          document.body.appendChild(loadingElement);
        }
        loadingElement.style.width = "70%";
      },
      finish: () => {
        if (loadingElement) {
          loadingElement.style.width = "100%";
          setTimeout(() => {
            loadingElement == null ? void 0 : loadingElement.remove();
            loadingElement = null;
          }, 300);
        }
      },
      error: () => {
        if (loadingElement) {
          loadingElement.style.background = "#d03050";
          loadingElement.style.width = "100%";
          setTimeout(() => {
            loadingElement == null ? void 0 : loadingElement.remove();
            loadingElement = null;
          }, 300);
        }
      }
    };
  }
  function useHostBridge() {
    const bridge = getHostBridge();
    return {
      bridge,
      router: bridge.router,
      route: bridge.router.currentRoute,
      message: createMessageApi(bridge),
      dialog: createDialogApi(),
      notification: createNotificationApi(bridge),
      loadingBar: createLoadingBarApi(),
      http: bridge.http,
      events: bridge.events,
      utils: bridge.utils
    };
  }
  const useMessage = () => useHostBridge().message;
  function bind$2(fn, thisArg) {
    return function wrap() {
      return fn.apply(thisArg, arguments);
    };
  }
  const { toString } = Object.prototype;
  const { getPrototypeOf } = Object;
  const { iterator: iterator$1, toStringTag } = Symbol;
  const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null));
  const kindOfTest = (type) => {
    type = type.toLowerCase();
    return (thing) => kindOf(thing) === type;
  };
  const typeOfTest = (type) => (thing) => typeof thing === type;
  const { isArray: isArray$1 } = Array;
  const isUndefined = typeOfTest("undefined");
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$2(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  const isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  const isString$1 = typeOfTest("string");
  const isFunction$2 = typeOfTest("function");
  const isNumber$1 = typeOfTest("number");
  const isObject$3 = (thing) => thing !== null && typeof thing === "object";
  const isBoolean = (thing) => thing === true || thing === false;
  const isPlainObject$1 = (val) => {
    if (kindOf(val) !== "object") {
      return false;
    }
    const prototype2 = getPrototypeOf(val);
    return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator$1 in val);
  };
  const isEmptyObject = (val) => {
    if (!isObject$3(val) || isBuffer(val)) {
      return false;
    }
    try {
      return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
    } catch (e2) {
      return false;
    }
  };
  const isDate = kindOfTest("Date");
  const isFile = kindOfTest("File");
  const isBlob = kindOfTest("Blob");
  const isFileList = kindOfTest("FileList");
  const isStream = (val) => isObject$3(val) && isFunction$2(val.pipe);
  const isFormData = (thing) => {
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$2(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction$2(thing.toString) && thing.toString() === "[object FormData]"));
  };
  const isURLSearchParams = kindOfTest("URLSearchParams");
  const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
  const trim$1 = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function forEach(obj, fn, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i;
    let l;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray$1(obj)) {
      for (i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      if (isBuffer(obj)) {
        return;
      }
      const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len2 = keys2.length;
      let key2;
      for (i = 0; i < len2; i++) {
        key2 = keys2[i];
        fn.call(null, obj[key2], key2, obj);
      }
    }
  }
  function findKey(obj, key2) {
    if (isBuffer(obj)) {
      return null;
    }
    key2 = key2.toLowerCase();
    const keys2 = Object.keys(obj);
    let i = keys2.length;
    let _key;
    while (i-- > 0) {
      _key = keys2[i];
      if (key2 === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  const _global = (() => {
    if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
  })();
  const isContextDefined = (context) => !isUndefined(context) && context !== _global;
  function merge$1() {
    const { caseless, skipUndefined } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key2) => {
      const targetKey = caseless && findKey(result, key2) || key2;
      if (isPlainObject$1(result[targetKey]) && isPlainObject$1(val)) {
        result[targetKey] = merge$1(result[targetKey], val);
      } else if (isPlainObject$1(val)) {
        result[targetKey] = merge$1({}, val);
      } else if (isArray$1(val)) {
        result[targetKey] = val.slice();
      } else if (!skipUndefined || !isUndefined(val)) {
        result[targetKey] = val;
      }
    };
    for (let i = 0, l = arguments.length; i < l; i++) {
      arguments[i] && forEach(arguments[i], assignValue);
    }
    return result;
  }
  const extend$1 = (a, b, thisArg, { allOwnKeys } = {}) => {
    forEach(b, (val, key2) => {
      if (thisArg && isFunction$2(val)) {
        Object.defineProperty(a, key2, {
          value: bind$2(val, thisArg),
          writable: true,
          enumerable: true,
          configurable: true
        });
      } else {
        Object.defineProperty(a, key2, {
          value: val,
          writable: true,
          enumerable: true,
          configurable: true
        });
      }
    }, { allOwnKeys });
    return a;
  };
  const stripBOM = (content) => {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  };
  const inherits$1 = (constructor, superConstructor, props, descriptors) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors);
    Object.defineProperty(constructor.prototype, "constructor", {
      value: constructor,
      writable: true,
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };
  const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
    let props;
    let i;
    let prop;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null) return destObj;
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i = props.length;
      while (i-- > 0) {
        prop = props[i];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };
  const endsWith = (str, searchString, position) => {
    str = String(str);
    if (position === void 0 || position > str.length) {
      position = str.length;
    }
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };
  const toArray = (thing) => {
    if (!thing) return null;
    if (isArray$1(thing)) return thing;
    let i = thing.length;
    if (!isNumber$1(i)) return null;
    const arr = new Array(i);
    while (i-- > 0) {
      arr[i] = thing[i];
    }
    return arr;
  };
  const isTypedArray$1 = /* @__PURE__ */ ((TypedArray) => {
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
  const forEachEntry = (obj, fn) => {
    const generator = obj && obj[iterator$1];
    const _iterator = generator.call(obj);
    let result;
    while ((result = _iterator.next()) && !result.done) {
      const pair = result.value;
      fn.call(obj, pair[0], pair[1]);
    }
  };
  const matchAll = (regExp, str) => {
    let matches;
    const arr = [];
    while ((matches = regExp.exec(str)) !== null) {
      arr.push(matches);
    }
    return arr;
  };
  const isHTMLForm = kindOfTest("HTMLFormElement");
  const toCamelCase$1 = (str) => {
    return str.toLowerCase().replace(
      /[-_\s]([a-z\d])(\w*)/g,
      function replacer(m2, p1, p2) {
        return p1.toUpperCase() + p2;
      }
    );
  };
  const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
  const isRegExp$1 = kindOfTest("RegExp");
  const reduceDescriptors = (obj, reducer) => {
    const descriptors = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors, (descriptor, name) => {
      let ret;
      if ((ret = reducer(descriptor, name, obj)) !== false) {
        reducedDescriptors[name] = ret || descriptor;
      }
    });
    Object.defineProperties(obj, reducedDescriptors);
  };
  const freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor, name) => {
      if (isFunction$2(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
        return false;
      }
      const value = obj[name];
      if (!isFunction$2(value)) return;
      descriptor.enumerable = false;
      if ("writable" in descriptor) {
        descriptor.writable = false;
        return;
      }
      if (!descriptor.set) {
        descriptor.set = () => {
          throw Error("Can not rewrite read-only method '" + name + "'");
        };
      }
    });
  };
  const toObjectSet = (arrayOrString, delimiter) => {
    const obj = {};
    const define = (arr) => {
      arr.forEach((value) => {
        obj[value] = true;
      });
    };
    isArray$1(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
    return obj;
  };
  const noop$1 = () => {
  };
  const toFiniteNumber = (value, defaultValue) => {
    return value != null && Number.isFinite(value = +value) ? value : defaultValue;
  };
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction$2(thing.append) && thing[toStringTag] === "FormData" && thing[iterator$1]);
  }
  const toJSONObject = (obj) => {
    const stack = new Array(10);
    const visit = (source, i) => {
      if (isObject$3(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }
        if (isBuffer(source)) {
          return source;
        }
        if (!("toJSON" in source)) {
          stack[i] = source;
          const target = isArray$1(source) ? [] : {};
          forEach(source, (value, key2) => {
            const reducedValue = visit(value, i + 1);
            !isUndefined(reducedValue) && (target[key2] = reducedValue);
          });
          stack[i] = void 0;
          return target;
        }
      }
      return source;
    };
    return visit(obj, 0);
  };
  const isAsyncFn = kindOfTest("AsyncFunction");
  const isThenable = (thing) => thing && (isObject$3(thing) || isFunction$2(thing)) && isFunction$2(thing.then) && isFunction$2(thing.catch);
  const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
    if (setImmediateSupported) {
      return setImmediate;
    }
    return postMessageSupported ? ((token, callbacks) => {
      _global.addEventListener("message", ({ source, data }) => {
        if (source === _global && data === token) {
          callbacks.length && callbacks.shift()();
        }
      }, false);
      return (cb) => {
        callbacks.push(cb);
        _global.postMessage(token, "*");
      };
    })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
  })(
    typeof setImmediate === "function",
    isFunction$2(_global.postMessage)
  );
  const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
  const isIterable = (thing) => thing != null && isFunction$2(thing[iterator$1]);
  const utils$1 = {
    isArray: isArray$1,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString: isString$1,
    isNumber: isNumber$1,
    isBoolean,
    isObject: isObject$3,
    isPlainObject: isPlainObject$1,
    isEmptyObject,
    isReadableStream,
    isRequest,
    isResponse,
    isHeaders,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp: isRegExp$1,
    isFunction: isFunction$2,
    isStream,
    isURLSearchParams,
    isTypedArray: isTypedArray$1,
    isFileList,
    forEach,
    merge: merge$1,
    extend: extend$1,
    trim: trim$1,
    stripBOM,
    inherits: inherits$1,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase: toCamelCase$1,
    noop: noop$1,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable,
    setImmediate: _setImmediate,
    asap,
    isIterable
  };
  let AxiosError$1 = class AxiosError2 extends Error {
    static from(error2, code, config, request, response, customProps) {
      const axiosError = new AxiosError2(error2.message, code || error2.code, config, request, response);
      axiosError.cause = error2;
      axiosError.name = error2.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    }
    /**
     * Create an Error with the specified message, config, error code, request and response.
     *
     * @param {string} message The error message.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [config] The config.
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     *
     * @returns {Error} The created error.
     */
    constructor(message, code, config, request, response) {
      super(message);
      this.name = "AxiosError";
      this.isAxiosError = true;
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      if (response) {
        this.response = response;
        this.status = response.status;
      }
    }
    toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils$1.toJSONObject(this.config),
        code: this.code,
        status: this.status
      };
    }
  };
  AxiosError$1.ERR_BAD_OPTION_VALUE = "ERR_BAD_OPTION_VALUE";
  AxiosError$1.ERR_BAD_OPTION = "ERR_BAD_OPTION";
  AxiosError$1.ECONNABORTED = "ECONNABORTED";
  AxiosError$1.ETIMEDOUT = "ETIMEDOUT";
  AxiosError$1.ERR_NETWORK = "ERR_NETWORK";
  AxiosError$1.ERR_FR_TOO_MANY_REDIRECTS = "ERR_FR_TOO_MANY_REDIRECTS";
  AxiosError$1.ERR_DEPRECATED = "ERR_DEPRECATED";
  AxiosError$1.ERR_BAD_RESPONSE = "ERR_BAD_RESPONSE";
  AxiosError$1.ERR_BAD_REQUEST = "ERR_BAD_REQUEST";
  AxiosError$1.ERR_CANCELED = "ERR_CANCELED";
  AxiosError$1.ERR_NOT_SUPPORT = "ERR_NOT_SUPPORT";
  AxiosError$1.ERR_INVALID_URL = "ERR_INVALID_URL";
  const httpAdapter = null;
  function isVisitable(thing) {
    return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
  }
  function removeBrackets(key2) {
    return utils$1.endsWith(key2, "[]") ? key2.slice(0, -2) : key2;
  }
  function renderKey(path, key2, dots) {
    if (!path) return key2;
    return path.concat(key2).map(function each2(token, i) {
      token = removeBrackets(token);
      return !dots && i ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils$1.isArray(arr) && !arr.some(isVisitable);
  }
  const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter2(prop) {
    return /^is[A-Z]/.test(prop);
  });
  function toFormData$1(obj, formData, options) {
    if (!utils$1.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new FormData();
    options = utils$1.toFlatObject(options, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils$1.isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
    if (!utils$1.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
      if (value === null) return "";
      if (utils$1.isDate(value)) {
        return value.toISOString();
      }
      if (utils$1.isBoolean(value)) {
        return value.toString();
      }
      if (!useBlob && utils$1.isBlob(value)) {
        throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
      }
      if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
        return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function defaultVisitor(value, key2, path) {
      let arr = value;
      if (value && !path && typeof value === "object") {
        if (utils$1.endsWith(key2, "{}")) {
          key2 = metaTokens ? key2 : key2.slice(0, -2);
          value = JSON.stringify(value);
        } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key2, "[]")) && (arr = utils$1.toArray(value))) {
          key2 = removeBrackets(key2);
          arr.forEach(function each2(el, index2) {
            !(utils$1.isUndefined(el) || el === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key2], index2, dots) : indexes === null ? key2 : key2 + "[]",
              convertValue(el)
            );
          });
          return false;
        }
      }
      if (isVisitable(value)) {
        return true;
      }
      formData.append(renderKey(path, key2, dots), convertValue(value));
      return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build(value, path) {
      if (utils$1.isUndefined(value)) return;
      if (stack.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path.join("."));
      }
      stack.push(value);
      utils$1.forEach(value, function each2(el, key2) {
        const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
          formData,
          el,
          utils$1.isString(key2) ? key2.trim() : key2,
          path,
          exposedHelpers
        );
        if (result === true) {
          build(el, path ? path.concat(key2) : [key2]);
        }
      });
      stack.pop();
    }
    if (!utils$1.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build(obj);
    return formData;
  }
  function encode$1(str) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
      return charMap[match];
    });
  }
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && toFormData$1(params, this, options);
  }
  const prototype = AxiosURLSearchParams.prototype;
  prototype.append = function append(name, value) {
    this._pairs.push([name, value]);
  };
  prototype.toString = function toString2(encoder) {
    const _encode = encoder ? function(value) {
      return encoder.call(this, value, encode$1);
    } : encode$1;
    return this._pairs.map(function each2(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
  };
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
  }
  function buildURL(url, params, options) {
    if (!params) {
      return url;
    }
    const _encode = options && options.encode || encode;
    const _options = utils$1.isFunction(options) ? {
      serialize: options
    } : options;
    const serializeFn = _options && _options.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, _options);
    } else {
      serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, _options).toString(_encode);
    }
    if (serializedParams) {
      const hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  }
  class InterceptorManager {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     * @param {Object} options The options for the interceptor, synchronous and runWhen
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {void}
     */
    eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn) {
      utils$1.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    }
  }
  const transitionalDefaults = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
  const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
  const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
  const platform$2 = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams$1,
      FormData: FormData$1,
      Blob: Blob$1
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
  };
  const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
  const _navigator = typeof navigator === "object" && navigator || void 0;
  const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
  const hasStandardBrowserWebWorkerEnv = (() => {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();
  const origin = hasBrowserEnv && window.location.href || "http://localhost";
  const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    hasBrowserEnv,
    hasStandardBrowserEnv,
    hasStandardBrowserWebWorkerEnv,
    navigator: _navigator,
    origin
  }, Symbol.toStringTag, { value: "Module" }));
  const platform$1 = {
    ...utils,
    ...platform$2
  };
  function toURLEncodedForm(data, options) {
    return toFormData$1(data, new platform$1.classes.URLSearchParams(), {
      visitor: function(value, key2, path, helpers) {
        if (platform$1.isNode && utils$1.isBuffer(value)) {
          this.append(key2, value.toString("base64"));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      },
      ...options
    });
  }
  function parsePropPath(name) {
    return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
      return match[0] === "[]" ? "" : match[1] || match[0];
    });
  }
  function arrayToObject(arr) {
    const obj = {};
    const keys2 = Object.keys(arr);
    let i;
    const len2 = keys2.length;
    let key2;
    for (i = 0; i < len2; i++) {
      key2 = keys2[i];
      obj[key2] = arr[key2];
    }
    return obj;
  }
  function formDataToJSON(formData) {
    function buildPath2(path, value, target, index2) {
      let name = path[index2++];
      if (name === "__proto__") return true;
      const isNumericKey = Number.isFinite(+name);
      const isLast = index2 >= path.length;
      name = !name && utils$1.isArray(target) ? target.length : name;
      if (isLast) {
        if (utils$1.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }
        return !isNumericKey;
      }
      if (!target[name] || !utils$1.isObject(target[name])) {
        target[name] = [];
      }
      const result = buildPath2(path, value, target[name], index2);
      if (result && utils$1.isArray(target[name])) {
        target[name] = arrayToObject(target[name]);
      }
      return !isNumericKey;
    }
    if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
      const obj = {};
      utils$1.forEachEntry(formData, (name, value) => {
        buildPath2(parsePropPath(name), value, obj, 0);
      });
      return obj;
    }
    return null;
  }
  function stringifySafely(rawValue, parser, encoder) {
    if (utils$1.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils$1.trim(rawValue);
      } catch (e2) {
        if (e2.name !== "SyntaxError") {
          throw e2;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  const defaults$1 = {
    transitional: transitionalDefaults,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils$1.isObject(data);
      if (isObjectPayload && utils$1.isHTMLForm(data)) {
        data = new FormData(data);
      }
      const isFormData2 = utils$1.isFormData(data);
      if (isFormData2) {
        return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
      }
      if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
        return data;
      }
      if (utils$1.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils$1.isURLSearchParams(data)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }
        if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData$1(
            isFileList2 ? { "files[]": data } : data,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      const transitional = this.transitional || defaults$1.transitional;
      const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
        return data;
      }
      if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional && transitional.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data, this.parseReviver);
        } catch (e2) {
          if (strictJSONParsing) {
            if (e2.name === "SyntaxError") {
              throw AxiosError$1.from(e2, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e2;
          }
        }
      }
      return data;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform$1.classes.FormData,
      Blob: platform$1.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
    defaults$1.headers[method] = {};
  });
  const ignoreDuplicateOf = utils$1.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  const parseHeaders = (rawHeaders) => {
    const parsed = {};
    let key2;
    let val;
    let i;
    rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
      i = line.indexOf(":");
      key2 = line.substring(0, i).trim().toLowerCase();
      val = line.substring(i + 1).trim();
      if (!key2 || parsed[key2] && ignoreDuplicateOf[key2]) {
        return;
      }
      if (key2 === "set-cookie") {
        if (parsed[key2]) {
          parsed[key2].push(val);
        } else {
          parsed[key2] = [val];
        }
      } else {
        parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
      }
    });
    return parsed;
  };
  const $internals = Symbol("internals");
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
  }
  function parseTokens(str) {
    const tokens2 = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while (match = tokensRE.exec(str)) {
      tokens2[match[1]] = match[2];
    }
    return tokens2;
  }
  const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
  function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
    if (utils$1.isFunction(filter2)) {
      return filter2.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils$1.isString(value)) return;
    if (utils$1.isString(filter2)) {
      return value.indexOf(filter2) !== -1;
    }
    if (utils$1.isRegExp(filter2)) {
      return filter2.test(value);
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
  }
  function buildAccessors(obj, header) {
    const accessorName = utils$1.toCamelCase(" " + header);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  let AxiosHeaders$1 = class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key2 = utils$1.findKey(self2, lHeader);
        if (!key2 || self2[key2] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key2] !== false) {
          self2[key2 || _header] = normalizeValue(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders(parseHeaders(header), valueOrRewrite);
      } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
        let obj = {}, dest, key2;
        for (const entry of header) {
          if (!utils$1.isArray(entry)) {
            throw TypeError("Object iterator must return a key-value pair");
          }
          obj[key2 = entry[0]] = (dest = obj[key2]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
        }
        setHeaders(obj, valueOrRewrite);
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
    get(header, parser) {
      header = normalizeHeader(header);
      if (header) {
        const key2 = utils$1.findKey(this, header);
        if (key2) {
          const value = this[key2];
          if (!parser) {
            return value;
          }
          if (parser === true) {
            return parseTokens(value);
          }
          if (utils$1.isFunction(parser)) {
            return parser.call(this, value, key2);
          }
          if (utils$1.isRegExp(parser)) {
            return parser.exec(value);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header, matcher) {
      header = normalizeHeader(header);
      if (header) {
        const key2 = utils$1.findKey(this, header);
        return !!(key2 && this[key2] !== void 0 && (!matcher || matchHeaderValue(this, this[key2], key2, matcher)));
      }
      return false;
    }
    delete(header, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          const key2 = utils$1.findKey(self2, _header);
          if (key2 && (!matcher || matchHeaderValue(self2, self2[key2], key2, matcher))) {
            delete self2[key2];
            deleted = true;
          }
        }
      }
      if (utils$1.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }
      return deleted;
    }
    clear(matcher) {
      const keys2 = Object.keys(this);
      let i = keys2.length;
      let deleted = false;
      while (i--) {
        const key2 = keys2[i];
        if (!matcher || matchHeaderValue(this, this[key2], key2, matcher, true)) {
          delete this[key2];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format2) {
      const self2 = this;
      const headers = {};
      utils$1.forEach(this, (value, header) => {
        const key2 = utils$1.findKey(headers, header);
        if (key2) {
          self2[key2] = normalizeValue(value);
          delete self2[header];
          return;
        }
        const normalized = format2 ? formatHeader(header) : String(header).trim();
        if (normalized !== header) {
          delete self2[header];
        }
        self2[normalized] = normalizeValue(value);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj = /* @__PURE__ */ Object.create(null);
      utils$1.forEach(this, (value, header) => {
        value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
      });
      return obj;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
    }
    getSetCookie() {
      return this.get("set-cookie") || [];
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
      const computed = new this(first);
      targets.forEach((target) => computed.set(target));
      return computed;
    }
    static accessor(header) {
      const internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype2 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype2, _header);
          accessors[lHeader] = true;
        }
      }
      utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  };
  AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key2) => {
    let mapped = key2[0].toUpperCase() + key2.slice(1);
    return {
      get: () => value,
      set(headerValue) {
        this[mapped] = headerValue;
      }
    };
  });
  utils$1.freezeMethods(AxiosHeaders$1);
  function transformData(fns, response) {
    const config = this || defaults$1;
    const context = response || config;
    const headers = AxiosHeaders$1.from(context.headers);
    let data = context.data;
    utils$1.forEach(fns, function transform(fn) {
      data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data;
  }
  function isCancel$1(value) {
    return !!(value && value.__CANCEL__);
  }
  let CanceledError$1 = class CanceledError extends AxiosError$1 {
    /**
     * A `CanceledError` is an object that is thrown when an operation is canceled.
     *
     * @param {string=} message The message.
     * @param {Object=} config The config.
     * @param {Object=} request The request.
     *
     * @returns {CanceledError} The created error.
     */
    constructor(message, config, request) {
      super(message == null ? "canceled" : message, AxiosError$1.ERR_CANCELED, config, request);
      this.name = "CanceledError";
      this.__CANCEL__ = true;
    }
  };
  function settle(resolve, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError$1(
        "Request failed with status code " + response.status,
        [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }
  function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
  }
  function speedometer(samplesCount, min3) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min3 = min3 !== void 0 ? min3 : 1e3;
    return function push(chunkLength) {
      const now = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now;
      let i = tail;
      let bytesCount = 0;
      while (i !== head) {
        bytesCount += bytes[i++];
        i = i % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now - firstSampleTS < min3) {
        return;
      }
      const passed = startedAt && now - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  function throttle$1(fn, freq) {
    let timestamp = 0;
    let threshold = 1e3 / freq;
    let lastArgs;
    let timer;
    const invoke = (args, now = Date.now()) => {
      timestamp = now;
      lastArgs = null;
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      fn(...args);
    };
    const throttled = (...args) => {
      const now = Date.now();
      const passed = now - timestamp;
      if (passed >= threshold) {
        invoke(args, now);
      } else {
        lastArgs = args;
        if (!timer) {
          timer = setTimeout(() => {
            timer = null;
            invoke(lastArgs);
          }, threshold - passed);
        }
      }
    };
    const flush = () => lastArgs && invoke(lastArgs);
    return [throttled, flush];
  }
  const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
    let bytesNotified = 0;
    const _speedometer = speedometer(50, 250);
    return throttle$1((e2) => {
      const loaded = e2.loaded;
      const total = e2.lengthComputable ? e2.total : void 0;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;
      bytesNotified = loaded;
      const data = {
        loaded,
        total,
        progress: total ? loaded / total : void 0,
        bytes: progressBytes,
        rate: rate ? rate : void 0,
        estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
        event: e2,
        lengthComputable: total != null,
        [isDownloadStream ? "download" : "upload"]: true
      };
      listener(data);
    }, freq);
  };
  const progressEventDecorator = (total, throttled) => {
    const lengthComputable = total != null;
    return [(loaded) => throttled[0]({
      lengthComputable,
      total,
      loaded
    }), throttled[1]];
  };
  const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
  const isURLSameOrigin = platform$1.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
    url = new URL(url, platform$1.origin);
    return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
  })(
    new URL(platform$1.origin),
    platform$1.navigator && /(msie|trident)/i.test(platform$1.navigator.userAgent)
  ) : () => true;
  const cookies = platform$1.hasStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    {
      write(name, value, expires, path, domain, secure, sameSite) {
        if (typeof document === "undefined") return;
        const cookie = [`${name}=${encodeURIComponent(value)}`];
        if (utils$1.isNumber(expires)) {
          cookie.push(`expires=${new Date(expires).toUTCString()}`);
        }
        if (utils$1.isString(path)) {
          cookie.push(`path=${path}`);
        }
        if (utils$1.isString(domain)) {
          cookie.push(`domain=${domain}`);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        if (utils$1.isString(sameSite)) {
          cookie.push(`SameSite=${sameSite}`);
        }
        document.cookie = cookie.join("; ");
      },
      read(name) {
        if (typeof document === "undefined") return null;
        const match = document.cookie.match(new RegExp("(?:^|; )" + name + "=([^;]*)"));
        return match ? decodeURIComponent(match[1]) : null;
      },
      remove(name) {
        this.write(name, "", Date.now() - 864e5, "/");
      }
    }
  ) : (
    // Non-standard browser env (web workers, react-native) lack needed support.
    {
      write() {
      },
      read() {
        return null;
      },
      remove() {
      }
    }
  );
  function isAbsoluteURL(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  }
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }
  function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
    let isRelativeUrl = !isAbsoluteURL(requestedURL);
    if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }
  const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
  function mergeConfig$1(config1, config2) {
    config2 = config2 || {};
    const config = {};
    function getMergedValue(target, source, prop, caseless) {
      if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
        return utils$1.merge.call({ caseless }, target, source);
      } else if (utils$1.isPlainObject(source)) {
        return utils$1.merge({}, source);
      } else if (utils$1.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a, b, prop, caseless) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(a, b, prop, caseless);
      } else if (!utils$1.isUndefined(a)) {
        return getMergedValue(void 0, a, prop, caseless);
      }
    }
    function valueFromConfig2(a, b) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(void 0, b);
      }
    }
    function defaultToConfig2(a, b) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(void 0, b);
      } else if (!utils$1.isUndefined(a)) {
        return getMergedValue(void 0, a);
      }
    }
    function mergeDirectKeys(a, b, prop) {
      if (prop in config2) {
        return getMergedValue(a, b);
      } else if (prop in config1) {
        return getMergedValue(void 0, a);
      }
    }
    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      withXSRFToken: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
    };
    utils$1.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
      const merge2 = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge2(config1[prop], config2[prop], prop);
      utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
  }
  const resolveConfig = (config) => {
    const newConfig = mergeConfig$1({}, config);
    let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
    newConfig.headers = headers = AxiosHeaders$1.from(headers);
    newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
    if (auth) {
      headers.set(
        "Authorization",
        "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
      );
    }
    if (utils$1.isFormData(data)) {
      if (platform$1.hasStandardBrowserEnv || platform$1.hasStandardBrowserWebWorkerEnv) {
        headers.setContentType(void 0);
      } else if (utils$1.isFunction(data.getHeaders)) {
        const formHeaders = data.getHeaders();
        const allowedHeaders = ["content-type", "content-length"];
        Object.entries(formHeaders).forEach(([key2, val]) => {
          if (allowedHeaders.includes(key2.toLowerCase())) {
            headers.set(key2, val);
          }
        });
      }
    }
    if (platform$1.hasStandardBrowserEnv) {
      withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
        const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
        if (xsrfValue) {
          headers.set(xsrfHeaderName, xsrfValue);
        }
      }
    }
    return newConfig;
  };
  const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
  const xhrAdapter = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      const _config = resolveConfig(config);
      let requestData = _config.data;
      const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
      let { responseType, onUploadProgress, onDownloadProgress } = _config;
      let onCanceled;
      let uploadThrottled, downloadThrottled;
      let flushUpload, flushDownload;
      function done() {
        flushUpload && flushUpload();
        flushDownload && flushDownload();
        _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
        _config.signal && _config.signal.removeEventListener("abort", onCanceled);
      }
      let request = new XMLHttpRequest();
      request.open(_config.method.toUpperCase(), _config.url, true);
      request.timeout = _config.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders$1.from(
          "getAllResponseHeaders" in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };
        settle(function _resolve(value) {
          resolve(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config, request));
        request = null;
      };
      request.onerror = function handleError(event) {
        const msg = event && event.message ? event.message : "Network Error";
        const err = new AxiosError$1(msg, AxiosError$1.ERR_NETWORK, config, request);
        err.event = event || null;
        reject(err);
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional = _config.transitional || transitionalDefaults;
        if (_config.timeoutErrorMessage) {
          timeoutErrorMessage = _config.timeoutErrorMessage;
        }
        reject(new AxiosError$1(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
          config,
          request
        ));
        request = null;
      };
      requestData === void 0 && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key2) {
          request.setRequestHeader(key2, val);
        });
      }
      if (!utils$1.isUndefined(_config.withCredentials)) {
        request.withCredentials = !!_config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = _config.responseType;
      }
      if (onDownloadProgress) {
        [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
        request.addEventListener("progress", downloadThrottled);
      }
      if (onUploadProgress && request.upload) {
        [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
        request.upload.addEventListener("progress", uploadThrottled);
        request.upload.addEventListener("loadend", flushUpload);
      }
      if (_config.cancelToken || _config.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError$1(null, config, request) : cancel);
          request.abort();
          request = null;
        };
        _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
        if (_config.signal) {
          _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol = parseProtocol(_config.url);
      if (protocol && platform$1.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config));
        return;
      }
      request.send(requestData || null);
    });
  };
  const composeSignals = (signals, timeout) => {
    const { length } = signals = signals ? signals.filter(Boolean) : [];
    if (timeout || length) {
      let controller = new AbortController();
      let aborted;
      const onabort = function(reason) {
        if (!aborted) {
          aborted = true;
          unsubscribe();
          const err = reason instanceof Error ? reason : this.reason;
          controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
        }
      };
      let timer = timeout && setTimeout(() => {
        timer = null;
        onabort(new AxiosError$1(`timeout of ${timeout}ms exceeded`, AxiosError$1.ETIMEDOUT));
      }, timeout);
      const unsubscribe = () => {
        if (signals) {
          timer && clearTimeout(timer);
          timer = null;
          signals.forEach((signal2) => {
            signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
          });
          signals = null;
        }
      };
      signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
      const { signal } = controller;
      signal.unsubscribe = () => utils$1.asap(unsubscribe);
      return signal;
    }
  };
  const streamChunk = function* (chunk, chunkSize) {
    let len2 = chunk.byteLength;
    if (len2 < chunkSize) {
      yield chunk;
      return;
    }
    let pos = 0;
    let end2;
    while (pos < len2) {
      end2 = pos + chunkSize;
      yield chunk.slice(pos, end2);
      pos = end2;
    }
  };
  const readBytes = async function* (iterable, chunkSize) {
    for await (const chunk of readStream(iterable)) {
      yield* streamChunk(chunk, chunkSize);
    }
  };
  const readStream = async function* (stream) {
    if (stream[Symbol.asyncIterator]) {
      yield* stream;
      return;
    }
    const reader = stream.getReader();
    try {
      for (; ; ) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        yield value;
      }
    } finally {
      await reader.cancel();
    }
  };
  const trackStream = (stream, chunkSize, onProgress, onFinish) => {
    const iterator2 = readBytes(stream, chunkSize);
    let bytes = 0;
    let done;
    let _onFinish = (e2) => {
      if (!done) {
        done = true;
        onFinish && onFinish(e2);
      }
    };
    return new ReadableStream({
      async pull(controller) {
        try {
          const { done: done2, value } = await iterator2.next();
          if (done2) {
            _onFinish();
            controller.close();
            return;
          }
          let len2 = value.byteLength;
          if (onProgress) {
            let loadedBytes = bytes += len2;
            onProgress(loadedBytes);
          }
          controller.enqueue(new Uint8Array(value));
        } catch (err) {
          _onFinish(err);
          throw err;
        }
      },
      cancel(reason) {
        _onFinish(reason);
        return iterator2.return();
      }
    }, {
      highWaterMark: 2
    });
  };
  const DEFAULT_CHUNK_SIZE = 64 * 1024;
  const { isFunction: isFunction$1 } = utils$1;
  const globalFetchAPI = (({ Request, Response }) => ({
    Request,
    Response
  }))(utils$1.global);
  const {
    ReadableStream: ReadableStream$1,
    TextEncoder
  } = utils$1.global;
  const test = (fn, ...args) => {
    try {
      return !!fn(...args);
    } catch (e2) {
      return false;
    }
  };
  const factory = (env2) => {
    env2 = utils$1.merge.call({
      skipUndefined: true
    }, globalFetchAPI, env2);
    const { fetch: envFetch, Request, Response } = env2;
    const isFetchSupported = envFetch ? isFunction$1(envFetch) : typeof fetch === "function";
    const isRequestSupported = isFunction$1(Request);
    const isResponseSupported = isFunction$1(Response);
    if (!isFetchSupported) {
      return false;
    }
    const isReadableStreamSupported = isFetchSupported && isFunction$1(ReadableStream$1);
    const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Request(str).arrayBuffer()));
    const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
      let duplexAccessed = false;
      const hasContentType = new Request(platform$1.origin, {
        body: new ReadableStream$1(),
        method: "POST",
        get duplex() {
          duplexAccessed = true;
          return "half";
        }
      }).headers.has("Content-Type");
      return duplexAccessed && !hasContentType;
    });
    const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
    const resolvers = {
      stream: supportsResponseStream && ((res) => res.body)
    };
    isFetchSupported && (() => {
      ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
        !resolvers[type] && (resolvers[type] = (res, config) => {
          let method = res && res[type];
          if (method) {
            return method.call(res);
          }
          throw new AxiosError$1(`Response type '${type}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config);
        });
      });
    })();
    const getBodyLength = async (body) => {
      if (body == null) {
        return 0;
      }
      if (utils$1.isBlob(body)) {
        return body.size;
      }
      if (utils$1.isSpecCompliantForm(body)) {
        const _request = new Request(platform$1.origin, {
          method: "POST",
          body
        });
        return (await _request.arrayBuffer()).byteLength;
      }
      if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
        return body.byteLength;
      }
      if (utils$1.isURLSearchParams(body)) {
        body = body + "";
      }
      if (utils$1.isString(body)) {
        return (await encodeText(body)).byteLength;
      }
    };
    const resolveBodyLength = async (headers, body) => {
      const length = utils$1.toFiniteNumber(headers.getContentLength());
      return length == null ? getBodyLength(body) : length;
    };
    return async (config) => {
      let {
        url,
        method,
        data,
        signal,
        cancelToken,
        timeout,
        onDownloadProgress,
        onUploadProgress,
        responseType,
        headers,
        withCredentials = "same-origin",
        fetchOptions
      } = resolveConfig(config);
      let _fetch = envFetch || fetch;
      responseType = responseType ? (responseType + "").toLowerCase() : "text";
      let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
      let request = null;
      const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
        composedSignal.unsubscribe();
      });
      let requestContentLength;
      try {
        if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
          let _request = new Request(url, {
            method: "POST",
            body: data,
            duplex: "half"
          });
          let contentTypeHeader;
          if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
            headers.setContentType(contentTypeHeader);
          }
          if (_request.body) {
            const [onProgress, flush] = progressEventDecorator(
              requestContentLength,
              progressEventReducer(asyncDecorator(onUploadProgress))
            );
            data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
          }
        }
        if (!utils$1.isString(withCredentials)) {
          withCredentials = withCredentials ? "include" : "omit";
        }
        const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
        const resolvedOptions = {
          ...fetchOptions,
          signal: composedSignal,
          method: method.toUpperCase(),
          headers: headers.normalize().toJSON(),
          body: data,
          duplex: "half",
          credentials: isCredentialsSupported ? withCredentials : void 0
        };
        request = isRequestSupported && new Request(url, resolvedOptions);
        let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));
        const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
        if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
          const options = {};
          ["status", "statusText", "headers"].forEach((prop) => {
            options[prop] = response[prop];
          });
          const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
          const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
            responseContentLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true)
          ) || [];
          response = new Response(
            trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
              flush && flush();
              unsubscribe && unsubscribe();
            }),
            options
          );
        }
        responseType = responseType || "text";
        let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config);
        !isStreamResponse && unsubscribe && unsubscribe();
        return await new Promise((resolve, reject) => {
          settle(resolve, reject, {
            data: responseData,
            headers: AxiosHeaders$1.from(response.headers),
            status: response.status,
            statusText: response.statusText,
            config,
            request
          });
        });
      } catch (err) {
        unsubscribe && unsubscribe();
        if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
          throw Object.assign(
            new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request),
            {
              cause: err.cause || err
            }
          );
        }
        throw AxiosError$1.from(err, err && err.code, config, request);
      }
    };
  };
  const seedCache = /* @__PURE__ */ new Map();
  const getFetch = (config) => {
    let env2 = config && config.env || {};
    const { fetch: fetch2, Request, Response } = env2;
    const seeds = [
      Request,
      Response,
      fetch2
    ];
    let len2 = seeds.length, i = len2, seed, target, map2 = seedCache;
    while (i--) {
      seed = seeds[i];
      target = map2.get(seed);
      target === void 0 && map2.set(seed, target = i ? /* @__PURE__ */ new Map() : factory(env2));
      map2 = target;
    }
    return target;
  };
  getFetch();
  const knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter,
    fetch: {
      get: getFetch
    }
  };
  utils$1.forEach(knownAdapters, (fn, value) => {
    if (fn) {
      try {
        Object.defineProperty(fn, "name", { value });
      } catch (e2) {
      }
      Object.defineProperty(fn, "adapterName", { value });
    }
  });
  const renderReason = (reason) => `- ${reason}`;
  const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
  function getAdapter$1(adapters2, config) {
    adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters2[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError$1(`Unknown adapter '${id}'`);
        }
      }
      if (adapter && (utils$1.isFunction(adapter) || (adapter = adapter.get(config)))) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError$1(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  }
  const adapters = {
    /**
     * Resolve an adapter from a list of adapter names or functions.
     * @type {Function}
     */
    getAdapter: getAdapter$1,
    /**
     * Exposes all known adapters
     * @type {Object<string, Function|Object>}
     */
    adapters: knownAdapters
  };
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
      throw new CanceledError$1(null, config);
    }
  }
  function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = AxiosHeaders$1.from(config.headers);
    config.data = transformData.call(
      config,
      config.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config.method) !== -1) {
      config.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter, config);
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData.call(
        config,
        config.transformResponse,
        response
      );
      response.headers = AxiosHeaders$1.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel$1(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config,
            config.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }
  const VERSION$1 = "1.13.4";
  const validators$1 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
    validators$1[type] = function validator2(thing) {
      return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
  });
  const deprecatedWarnings = {};
  validators$1.transitional = function transitional(validator2, version, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value, opt, opts) => {
      if (validator2 === false) {
        throw new AxiosError$1(
          formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
          AxiosError$1.ERR_DEPRECATED
        );
      }
      if (version && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version + " and will be removed in the near future"
          )
        );
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  validators$1.spelling = function spelling(correctSpelling) {
    return (value, opt) => {
      console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
      return true;
    };
  };
  function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
    }
    const keys2 = Object.keys(options);
    let i = keys2.length;
    while (i-- > 0) {
      const opt = keys2[i];
      const validator2 = schema[opt];
      if (validator2) {
        const value = options[opt];
        const result = value === void 0 || validator2(value, opt, options);
        if (result !== true) {
          throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
      }
    }
  }
  const validator = {
    assertOptions,
    validators: validators$1
  };
  const validators = validator.validators;
  let Axios$1 = class Axios {
    constructor(instanceConfig) {
      this.defaults = instanceConfig || {};
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    async request(configOrUrl, config) {
      try {
        return await this._request(configOrUrl, config);
      } catch (err) {
        if (err instanceof Error) {
          let dummy = {};
          Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
          const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
          try {
            if (!err.stack) {
              err.stack = stack;
            } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
              err.stack += "\n" + stack;
            }
          } catch (e2) {
          }
        }
        throw err;
      }
    }
    _request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig$1(this.defaults, config);
      const { transitional, paramsSerializer, headers } = config;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      if (paramsSerializer != null) {
        if (utils$1.isFunction(paramsSerializer)) {
          config.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
          }, true);
        }
      }
      if (config.allowAbsoluteUrls !== void 0) ;
      else if (this.defaults.allowAbsoluteUrls !== void 0) {
        config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
      } else {
        config.allowAbsoluteUrls = true;
      }
      validator.assertOptions(config, {
        baseUrl: validators.spelling("baseURL"),
        withXsrfToken: validators.spelling("withXSRFToken")
      }, true);
      config.method = (config.method || this.defaults.method || "get").toLowerCase();
      let contextHeaders = headers && utils$1.merge(
        headers.common,
        headers[config.method]
      );
      headers && utils$1.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (method) => {
          delete headers[method];
        }
      );
      config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      let i = 0;
      let len2;
      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), void 0];
        chain.unshift(...requestInterceptorChain);
        chain.push(...responseInterceptorChain);
        len2 = chain.length;
        promise = Promise.resolve(config);
        while (i < len2) {
          promise = promise.then(chain[i++], chain[i++]);
        }
        return promise;
      }
      len2 = requestInterceptorChain.length;
      let newConfig = config;
      while (i < len2) {
        const onFulfilled = requestInterceptorChain[i++];
        const onRejected = requestInterceptorChain[i++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error2) {
          onRejected.call(this, error2);
          break;
        }
      }
      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error2) {
        return Promise.reject(error2);
      }
      i = 0;
      len2 = responseInterceptorChain.length;
      while (i < len2) {
        promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
      }
      return promise;
    }
    getUri(config) {
      config = mergeConfig$1(this.defaults, config);
      const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    }
  };
  utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios$1.prototype[method] = function(url, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        url,
        data: (config || {}).data
      }));
    };
  });
  utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data, config) {
        return this.request(mergeConfig$1(config || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url,
          data
        }));
      };
    }
    Axios$1.prototype[method] = generateHTTPMethod();
    Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  let CancelToken$1 = class CancelToken2 {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      const token = this;
      this.promise.then((cancel) => {
        if (!token._listeners) return;
        let i = token._listeners.length;
        while (i-- > 0) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = (onfulfilled) => {
        let _resolve;
        const promise = new Promise((resolve) => {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config, request) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError$1(message, config, request);
        resolvePromise(token.reason);
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index2 = this._listeners.indexOf(listener);
      if (index2 !== -1) {
        this._listeners.splice(index2, 1);
      }
    }
    toAbortSignal() {
      const controller = new AbortController();
      const abort = (err) => {
        controller.abort(err);
      };
      this.subscribe(abort);
      controller.signal.unsubscribe = () => this.unsubscribe(abort);
      return controller.signal;
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token = new CancelToken2(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    }
  };
  function spread$1(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }
  function isAxiosError$1(payload) {
    return utils$1.isObject(payload) && payload.isAxiosError === true;
  }
  const HttpStatusCode$1 = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511,
    WebServerIsDown: 521,
    ConnectionTimedOut: 522,
    OriginIsUnreachable: 523,
    TimeoutOccurred: 524,
    SslHandshakeFailed: 525,
    InvalidSslCertificate: 526
  };
  Object.entries(HttpStatusCode$1).forEach(([key2, value]) => {
    HttpStatusCode$1[value] = key2;
  });
  function createInstance(defaultConfig2) {
    const context = new Axios$1(defaultConfig2);
    const instance = bind$2(Axios$1.prototype.request, context);
    utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
    utils$1.extend(instance, context, null, { allOwnKeys: true });
    instance.create = function create2(instanceConfig) {
      return createInstance(mergeConfig$1(defaultConfig2, instanceConfig));
    };
    return instance;
  }
  const axios = createInstance(defaults$1);
  axios.Axios = Axios$1;
  axios.CanceledError = CanceledError$1;
  axios.CancelToken = CancelToken$1;
  axios.isCancel = isCancel$1;
  axios.VERSION = VERSION$1;
  axios.toFormData = toFormData$1;
  axios.AxiosError = AxiosError$1;
  axios.Cancel = axios.CanceledError;
  axios.all = function all2(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread$1;
  axios.isAxiosError = isAxiosError$1;
  axios.mergeConfig = mergeConfig$1;
  axios.AxiosHeaders = AxiosHeaders$1;
  axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.getAdapter = adapters.getAdapter;
  axios.HttpStatusCode = HttpStatusCode$1;
  axios.default = axios;
  const {
    Axios,
    AxiosError,
    CanceledError,
    isCancel,
    CancelToken,
    VERSION,
    all,
    Cancel,
    isAxiosError,
    spread,
    toFormData,
    AxiosHeaders,
    HttpStatusCode,
    formToJSON,
    getAdapter,
    mergeConfig
  } = axios;
  const defaultHeaderConfig = (_config) => {
    const headers = {};
    const token = localStorage.getItem("token");
    if (token) {
      headers.Authorization = `Bearer ${token}`;
    }
    const namespace = localStorage.getItem("namespace") || "default";
    {
      headers["X-Namespace"] = namespace;
    }
    const clientId = localStorage.getItem("gress_sse_client_id");
    if (clientId) {
      headers["X-Client-Id"] = clientId;
    }
    return headers;
  };
  const defaultMessageHandler = {
    success: (msg) => console.log("[Success]", msg),
    error: (msg) => console.error("[Error]", msg),
    warning: (msg) => console.warn("[Warning]", msg),
    info: (msg) => console.info("[Info]", msg)
  };
  const defaultRouterHandler = {
    push: (path) => {
      if (typeof window !== "undefined") {
        window.location.href = path;
      }
    }
  };
  class RequestClient {
    constructor(options = {}) {
      const {
        headerConfig = defaultHeaderConfig,
        messageHandler = defaultMessageHandler,
        routerHandler = defaultRouterHandler,
        ...axiosConfig
      } = options;
      this.headerConfig = headerConfig;
      this.messageHandler = messageHandler;
      this.routerHandler = routerHandler;
      this.instance = axios.create({
        timeout: 3e4,
        ...axiosConfig
      });
      this.setupInterceptors();
    }
    /**
     * 设置 Header 配置函数
     */
    setHeaderConfig(headerConfig) {
      this.headerConfig = headerConfig;
    }
    /**
     * 设置消息处理器
     */
    setMessageHandler(messageHandler) {
      this.messageHandler = messageHandler;
    }
    /**
     * 设置路由处理器
     */
    setRouterHandler(routerHandler) {
      this.routerHandler = routerHandler;
    }
    setupInterceptors() {
      this.instance.interceptors.request.use(
        (config) => {
          if (this.headerConfig) {
            const dynamicHeaders = this.headerConfig(config);
            config.headers = config.headers || {};
            Object.assign(config.headers, dynamicHeaders);
          }
          return config;
        },
        (error2) => {
          return Promise.reject(error2);
        }
      );
      this.instance.interceptors.response.use(
        (response) => {
          return this.handleResponse(response);
        },
        (error2) => {
          return this.handleError(error2);
        }
      );
    }
    handleResponse(response) {
      const config = response.config;
      const { isReturnNativeResponse, isTransformResponse = true } = config;
      if (isReturnNativeResponse) {
        return response;
      }
      if (!isTransformResponse) {
        return response.data;
      }
      const responseData = response.data;
      if (!responseData) {
        console.error("响应数据为空:", response);
        throw new Error("请求失败，未返回数据");
      }
      if (typeof responseData !== "object") {
        console.error("响应数据类型错误:", typeof responseData, responseData);
        throw new Error("响应数据格式错误");
      }
      const { code, data, errorMessage: msg } = responseData;
      if (code === void 0 || code === null) {
        console.error("响应数据缺少 code 字段:", responseData);
        throw new Error("响应数据格式错误：缺少 code 字段");
      }
      const hasSuccess = code === 200;
      if (hasSuccess) {
        if (config.successMessageMode === "message" && msg) {
          this.messageHandler.success(msg);
        }
        return data;
      }
      return this.handleBusinessError(code, msg, config);
    }
    handleBusinessError(code, msg, config) {
      const errorMessageMode = config.errorMessageMode ?? "message";
      switch (code) {
        case 401: {
          localStorage.removeItem("token");
          this.messageHandler.error("登录已过期，请重新登录");
          this.routerHandler.push("/login");
          break;
        }
        case 403: {
          this.messageHandler.error("没有权限访问该资源");
          break;
        }
        case 404: {
          this.messageHandler.error("请求的资源不存在");
          break;
        }
        default: {
          if (errorMessageMode === "message" && msg) {
            this.messageHandler.error(msg);
          }
        }
      }
      throw new Error(msg || "请求失败");
    }
    handleError(error2) {
      const config = error2.config;
      const errorMessageMode = (config == null ? void 0 : config.errorMessageMode) ?? "message";
      let errorMessage = "请求失败";
      if (error2.response) {
        const { status, data } = error2.response;
        errorMessage = (data == null ? void 0 : data.message) || `请求失败 (${status})`;
      } else if (error2.request) {
        errorMessage = "网络错误，请检查网络连接";
      } else {
        errorMessage = error2.message || "请求配置错误";
      }
      if (errorMessageMode === "message") {
        this.messageHandler.error(errorMessage);
      }
      return Promise.reject(error2);
    }
    // GET 请求
    get(url, config) {
      return this.instance.get(url, config);
    }
    // POST 请求
    post(url, data, config) {
      return this.instance.post(url, data, config);
    }
    // PUT 请求
    put(url, data, config) {
      return this.instance.put(url, data, config);
    }
    // DELETE 请求
    delete(url, config) {
      return this.instance.delete(url, config);
    }
    // PATCH 请求
    patch(url, data, config) {
      return this.instance.patch(url, data, config);
    }
    // 获取原始 axios 实例
    getAxiosInstance() {
      return this.instance;
    }
  }
  function createRequestClient(options = {}) {
    return new RequestClient(options);
  }
  createRequestClient({
    baseURL: "/api",
    headers: {
      "Content-Type": "application/json"
    },
    headerConfig: defaultHeaderConfig
  });
  function getGressBridge() {
    if (typeof window !== "undefined" && window.GressBridge) {
      return window.GressBridge;
    }
    throw new Error("GressBridge未初始化");
  }
  const http = {
    /**
     * GET请求
     */
    async get(url, params) {
      const bridge = getGressBridge();
      let fullUrl = url;
      if (params) {
        const filteredParams = {};
        for (const [key2, value] of Object.entries(params)) {
          if (value !== void 0 && value !== null && value !== "") {
            filteredParams[key2] = String(value);
          }
        }
        if (Object.keys(filteredParams).length > 0) {
          const queryString = new URLSearchParams(filteredParams).toString();
          fullUrl = `${url}?${queryString}`;
        }
      }
      try {
        const response = await bridge.http.get(fullUrl);
        if (response && response.success === false) {
          const errorMessage = response.message || "请求失败";
          throw new Error(errorMessage);
        }
        return response;
      } catch (error2) {
        throw error2;
      }
    },
    /**
     * POST请求
     */
    async post(url, data) {
      const bridge = getGressBridge();
      try {
        const response = await bridge.http.post(url, data);
        if (response && response.success === false) {
          const errorMessage = response.message || "请求失败";
          throw new Error(errorMessage);
        }
        return response;
      } catch (error2) {
        throw error2;
      }
    },
    /**
     * PUT请求
     */
    async put(url, data) {
      const bridge = getGressBridge();
      try {
        const response = await bridge.http.put(url, data);
        if (response && response.success === false) {
          const errorMessage = response.message || "请求失败";
          throw new Error(errorMessage);
        }
        return response;
      } catch (error2) {
        throw error2;
      }
    },
    /**
     * DELETE请求
     */
    async delete(url) {
      const bridge = getGressBridge();
      try {
        const response = await bridge.http.delete(url);
        if (response && response.success === false) {
          const errorMessage = response.message || "请求失败";
          throw new Error(errorMessage);
        }
        return response;
      } catch (error2) {
        throw error2;
      }
    }
  };
  const API_BASE$3 = "/plugins/appstore";
  const applicationApi = {
    /**
     * 查询应用列表
     */
    getList(params) {
      return http.get(`${API_BASE$3}/applications`, params);
    },
    /**
     * 获取应用详情
     */
    getDetail(id) {
      return http.get(`${API_BASE$3}/applications/${id}`);
    },
    /**
     * 升级应用
     */
    upgrade(id, data) {
      return http.post(`${API_BASE$3}/applications/${id}/upgrade`, data);
    },
    /**
     * 卸载应用
     */
    uninstall(id, data) {
      return http.delete(`${API_BASE$3}/applications/${id}`, data);
    },
    /**
     * 启用应用
     */
    enable(id, operatorName) {
      return http.post(`${API_BASE$3}/applications/${id}/enable`, { operatorName });
    },
    /**
     * 禁用应用
     */
    disable(id, operatorName) {
      return http.post(`${API_BASE$3}/applications/${id}/disable`, { operatorName });
    },
    /**
     * 查询远程应用商店应用列表
     */
    getRemoteList(params) {
      return http.get(`${API_BASE$3}/applications/remote`, params);
    },
    /**
     * 上传并安装应用包
     * 注意：使用原生 fetch API，因为 GressBridge 不支持 FormData
     */
    async uploadAndInstall(formData) {
      const response = await fetch(`/api/${API_BASE$3}/applications/upload`, {
        method: "POST",
        body: formData,
        credentials: "include"
        // 包含 cookies
      });
      const result = await response.json().catch(() => ({
        success: false,
        errorMessage: "解析响应失败"
      }));
      if (result.success === false) {
        throw new Error(result.errorMessage || "上传失败");
      }
      if (!response.ok) {
        throw new Error(result.errorMessage || `HTTP ${response.status}`);
      }
      return result.data;
    },
    /**
     * 从远程应用商店安装应用
     */
    installRemote(pluginId, operatorName = "admin") {
      const params = {
        pluginId,
        operatorName
      };
      const queryString = new URLSearchParams(params).toString();
      return http.post(`${API_BASE$3}/applications/remote/install?${queryString}`);
    },
    /**
     * 查询应用升级日志
     */
    getUpgradeLogs(id) {
      return http.get(`${API_BASE$3}/applications/${id}/upgrade-logs`);
    },
    /**
     * 降级应用（按指定版本回滚）
     */
    rollback(id, data) {
      return http.post(`${API_BASE$3}/applications/${id}/rollback`, data);
    },
    /**
     * 重启应用
     */
    restart(id, operatorName = "admin") {
      return http.post(`${API_BASE$3}/applications/${id}/restart`, { operatorName });
    },
    /**
     * 获取应用配置元数据（用于动态表单渲染）
     */
    getConfigMetadata(id) {
      return http.get(`${API_BASE$3}/applications/${id}/config/metadata`);
    },
    /**
     * 获取应用配置
     */
    getConfig(id) {
      return http.get(`${API_BASE$3}/applications/${id}/config`);
    },
    /**
     * 更新应用配置
     */
    updateConfig(id, data) {
      return http.put(`${API_BASE$3}/applications/${id}/config`, data);
    },
    /**
     * 查询应用操作日志
     */
    getOperationLogs(id, page = 1, size = 20, operationType) {
      const params = { page, size };
      if (operationType) {
        params.operationType = operationType;
      }
      return http.get(`${API_BASE$3}/applications/${id}/operation-logs`, params);
    },
    /**
     * 查询所有应用操作日志（全局查询）
     */
    getAllOperationLogs(params) {
      return http.get(`${API_BASE$3}/applications/operation-logs`, params);
    }
  };
  const _hoisted_1$6 = { class: "application-management-page" };
  const _hoisted_2$6 = { class: "page-content" };
  const _hoisted_3$6 = {
    key: 0,
    class: "loading-state"
  };
  const _hoisted_4$4 = {
    key: 1,
    class: "empty-state"
  };
  const _hoisted_5$3 = { class: "empty-state__icon" };
  const _hoisted_6$3 = { class: "empty-state__text" };
  const _hoisted_7$2 = {
    key: 2,
    class: "app-list"
  };
  const _hoisted_8$2 = { class: "app-header" };
  const _hoisted_9$2 = { class: "app-info" };
  const _hoisted_10$2 = { class: "app-name" };
  const _hoisted_11$2 = { class: "app-code" };
  const _hoisted_12$1 = { class: "app-status" };
  const _hoisted_13$1 = { class: "app-body" };
  const _hoisted_14$1 = { class: "app-meta" };
  const _hoisted_15$1 = { class: "meta-item" };
  const _hoisted_16$1 = { class: "meta-value" };
  const _hoisted_17$1 = { class: "meta-item" };
  const _hoisted_18$1 = { class: "meta-value" };
  const _hoisted_19$1 = { class: "meta-item" };
  const _hoisted_20$1 = {
    key: 0,
    class: "meta-item"
  };
  const _hoisted_21$1 = {
    key: 0,
    class: "app-description"
  };
  const _hoisted_22$1 = { class: "app-footer" };
  const _hoisted_23$1 = { class: "app-time" };
  const _hoisted_24$1 = { class: "app-actions" };
  const _hoisted_25$1 = {
    key: 3,
    class: "pagination"
  };
  const _hoisted_26$1 = {
    key: 0,
    class: "loading-state"
  };
  const _hoisted_27$1 = {
    key: 1,
    class: "empty-state"
  };
  const _hoisted_28$1 = { class: "empty-state__icon" };
  const _hoisted_29$1 = { class: "empty-state__text" };
  const _hoisted_30$1 = {
    key: 2,
    class: "app-list"
  };
  const _hoisted_31$1 = { class: "app-header" };
  const _hoisted_32$1 = { class: "app-icon app-icon--plugin" };
  const _hoisted_33$1 = { class: "app-info" };
  const _hoisted_34$1 = { class: "app-name" };
  const _hoisted_35$1 = { class: "app-code" };
  const _hoisted_36$1 = { class: "app-status" };
  const _hoisted_37$1 = { class: "app-body" };
  const _hoisted_38 = { class: "app-meta" };
  const _hoisted_39 = { class: "meta-item" };
  const _hoisted_40 = { class: "meta-value" };
  const _hoisted_41 = { class: "meta-item" };
  const _hoisted_42 = { class: "meta-value" };
  const _hoisted_43 = {
    key: 0,
    class: "meta-item"
  };
  const _hoisted_44 = { class: "meta-value" };
  const _hoisted_45 = {
    key: 1,
    class: "meta-item"
  };
  const _hoisted_46 = { class: "meta-value" };
  const _hoisted_47 = {
    key: 0,
    class: "app-description"
  };
  const _hoisted_48 = { class: "app-footer" };
  const _hoisted_49 = { class: "app-time" };
  const _hoisted_50 = { class: "app-actions" };
  const _hoisted_51 = {
    key: 3,
    class: "pagination"
  };
  const _hoisted_52 = { class: "app-detail" };
  const _hoisted_53 = { key: 1 };
  const _hoisted_54 = ["href"];
  const _hoisted_55 = {
    key: 0,
    class: "loading-state"
  };
  const _hoisted_56 = {
    key: 1,
    class: "empty-state"
  };
  const _hoisted_57 = {
    key: 2,
    class: "operation-log-list"
  };
  const _hoisted_58 = { class: "log-header" };
  const _hoisted_59 = { style: { "margin-left": "8px", "color": "#666" } };
  const _hoisted_60 = { class: "log-content" };
  const _hoisted_61 = {
    key: 0,
    class: "log-row"
  };
  const _hoisted_62 = { class: "log-value" };
  const _hoisted_63 = {
    key: 1,
    class: "log-row"
  };
  const _hoisted_64 = { class: "log-value" };
  const _hoisted_65 = {
    key: 2,
    class: "log-row"
  };
  const _hoisted_66 = { class: "log-value" };
  const _hoisted_67 = {
    key: 3,
    class: "config-diff"
  };
  const _hoisted_68 = { class: "config-compare" };
  const _hoisted_69 = { class: "config-column" };
  const _hoisted_70 = { class: "config-content" };
  const _hoisted_71 = { class: "config-column" };
  const _hoisted_72 = { class: "config-content" };
  const _hoisted_73 = {
    key: 0,
    class: "pagination",
    style: { "margin-top": "16px" }
  };
  const _hoisted_74 = {
    key: 0,
    class: "upgrade-info"
  };
  const _hoisted_75 = { style: { "display": "flex", "align-items": "center", "gap": "8px" } };
  const _hoisted_76 = { style: { "font-weight": "600" } };
  const _hoisted_77 = {
    key: 0,
    class: "loading-state"
  };
  const _hoisted_78 = { key: 1 };
  const _hoisted_79 = {
    key: 0,
    class: "empty-state"
  };
  const _hoisted_80 = {
    key: 1,
    class: "upgrade-log-list"
  };
  const _hoisted_81 = { class: "upgrade-log-item" };
  const _hoisted_82 = { class: "upgrade-log-row" };
  const _hoisted_83 = { class: "meta-value" };
  const _hoisted_84 = {
    key: 0,
    class: "upgrade-log-row"
  };
  const _hoisted_85 = { class: "meta-value" };
  const _hoisted_86 = {
    key: 1,
    class: "upgrade-log-row"
  };
  const _hoisted_87 = { class: "meta-value" };
  const _hoisted_88 = {
    key: 2,
    class: "upgrade-log-row"
  };
  const _hoisted_89 = { class: "meta-value" };
  const _hoisted_90 = { class: "config-modal-content" };
  const _hoisted_91 = { class: "app-info-row" };
  const _hoisted_92 = { class: "app-info-item" };
  const _hoisted_93 = { class: "info-value" };
  const _hoisted_94 = { class: "app-info-item" };
  const _hoisted_95 = { class: "advanced-config-grid" };
  const _hoisted_96 = { style: { "margin-bottom": "12px" } };
  const _hoisted_97 = { style: { "margin-top": "8px" } };
  const _sfc_main$6 = /* @__PURE__ */ vue.defineComponent({
    __name: "ApplicationManagement",
    setup(__props) {
      const Refresh = useIcon("RefreshOutline");
      useIcon("EyeOutline");
      useIcon("PowerOutline");
      useIcon("PowerOffOutline");
      const CloudUploadOutline = useIcon("CloudUploadOutline");
      useIcon("TrashOutline");
      const AppsOutline = useIcon("AppsOutline");
      const CubeOutline = useIcon("CubeOutline");
      const ExtensionPuzzleOutline = useIcon("ExtensionPuzzleOutline");
      const TimeOutline = useIcon("TimeOutline");
      const RocketOutline = useIcon("RocketOutline");
      const EllipsisHorizontalOutline = useIcon("EllipsisHorizontalOutline");
      const message = useMessage();
      const dialog = naiveUi.useDialog();
      const showStartConfirm = vue.ref(false);
      const showStopConfirm = vue.ref(false);
      const confirmTarget = vue.ref(null);
      const refreshLoading = vue.ref(false);
      const startLoading = vue.ref(false);
      const stopLoading = vue.ref(false);
      const upgradeLoading = vue.ref(false);
      const uninstallLoading = vue.ref(false);
      const restartLoading = vue.ref(false);
      const installRemoteLoading = vue.ref({});
      const upgradeRemoteLoading = vue.ref({});
      const activeTab = vue.ref("local");
      const loading = vue.ref(false);
      const tableData = vue.ref([]);
      const showDetailDrawer = vue.ref(false);
      const currentApplication = vue.ref(null);
      const detailActiveTab = vue.ref("basic");
      const operationLogs = vue.ref([]);
      const operationLogsLoading = vue.ref(false);
      const operationLogsPagination = vue.reactive({
        page: 1,
        pageSize: 20,
        itemCount: 0
      });
      const remoteLoading = vue.ref(false);
      const remoteTableData = vue.ref([]);
      const showAdvanced = vue.ref(false);
      const filters = vue.ref({
        keyword: "",
        status: null,
        applicationType: null
      });
      const showRemoteAdvanced = vue.ref(false);
      const remoteFilters = vue.ref({
        keyword: ""
      });
      const pagination = vue.reactive({
        page: 1,
        pageSize: 20,
        itemCount: 0,
        showSizePicker: true,
        pageSizes: [10, 20, 50, 100]
      });
      const remotePagination = vue.reactive({
        page: 1,
        pageSize: 20,
        itemCount: 0,
        showSizePicker: true,
        pageSizes: [10, 20, 50, 100]
      });
      const showUpgradeModal = vue.ref(false);
      const upgradeFormRef = vue.ref(null);
      const upgradeForm = vue.reactive({
        targetVersion: ""
      });
      const upgradeRules = {
        targetVersion: [
          { required: true, message: "请输入目标版本号", trigger: "blur" }
        ]
      };
      const showUninstallModal = vue.ref(false);
      const uninstallFormRef = vue.ref(null);
      const uninstallForm = vue.reactive({
        reason: ""
      });
      const uninstallRules = {
        reason: [
          { required: true, message: "请输入卸载原因", trigger: "blur" }
        ]
      };
      const showUpgradeInfoModal = vue.ref(false);
      const upgradeInfoApp = vue.ref(null);
      const showUploadModal = vue.ref(false);
      const uploadFormRef = vue.ref(null);
      const uploadRef = vue.ref(null);
      const uploadForm = vue.reactive({});
      const uploadFile = vue.ref(null);
      const uploading = vue.ref(false);
      const showUpgradeLogModal = vue.ref(false);
      const upgradeLogsLoading = vue.ref(false);
      const upgradeLogs = vue.ref([]);
      const showRollbackModal = vue.ref(false);
      const rollbackLoading = vue.ref(false);
      const rollbackVersionsLoading = vue.ref(false);
      const rollbackFormRef = vue.ref(null);
      const rollbackForm = vue.reactive({
        targetVersion: ""
      });
      const rollbackVersionOptions = vue.ref([]);
      const selectedRollbackLog = vue.ref(null);
      const rollbackTargetApp = vue.ref(null);
      const showConfigModal = vue.ref(false);
      const configLoading = vue.ref(false);
      const configFormRef = vue.ref(null);
      const configTargetApp = vue.ref(null);
      const configForm = vue.reactive({
        autoLoad: false,
        loadOnStartup: false,
        startPriority: 50,
        startDelay: 0,
        description: "",
        extensionConfig: {}
      });
      const configMetadata = vue.ref([]);
      const configMetadataLoading = vue.ref(false);
      const basicFields = [
        {
          key: "keyword",
          label: "关键词",
          type: "input",
          placeholder: "搜索应用名称、代码、插件ID"
        },
        {
          key: "status",
          label: "运行状态",
          type: "select",
          placeholder: "请选择状态",
          options: [
            { label: "全部", value: null },
            { label: "运行中", value: 1 },
            { label: "已停止", value: 0 }
          ]
        },
        {
          key: "applicationType",
          label: "应用类型",
          type: "select",
          placeholder: "请选择类型",
          options: [
            { label: "全部", value: null },
            { label: "集成应用", value: "integrated" },
            { label: "插件应用", value: "plugin" }
          ]
        }
      ];
      const remoteBasicFields = [
        {
          key: "keyword",
          label: "关键词",
          type: "input",
          placeholder: "搜索应用名称、代码、插件ID"
        }
      ];
      const loadData = async () => {
        refreshLoading.value = true;
        try {
          if (activeTab.value === "local") {
            await loadLocalData();
          } else {
            await loadRemoteData();
          }
        } finally {
          refreshLoading.value = false;
        }
      };
      const loadLocalData = async () => {
        loading.value = true;
        try {
          const params = {
            page: pagination.page,
            size: pagination.pageSize
          };
          if (filters.value.keyword && filters.value.keyword.trim()) {
            params.keyword = filters.value.keyword.trim();
          }
          if (filters.value.status !== null) {
            params.status = filters.value.status;
          }
          if (filters.value.applicationType) {
            params.applicationType = filters.value.applicationType;
          }
          const data = await applicationApi.getList(params);
          tableData.value = data.items;
          pagination.itemCount = data.total;
        } catch (error2) {
          console.error("加载应用列表失败:", error2);
        } finally {
          loading.value = false;
        }
      };
      const loadRemoteData = async () => {
        remoteLoading.value = true;
        try {
          const params = {
            page: remotePagination.page,
            size: remotePagination.pageSize
          };
          if (remoteFilters.value.keyword && remoteFilters.value.keyword.trim()) {
            params.keyword = remoteFilters.value.keyword.trim();
          }
          const data = await applicationApi.getRemoteList(params);
          remoteTableData.value = data.items;
          remotePagination.itemCount = data.total;
        } catch (error2) {
          console.error("加载远程应用列表失败:", error2);
        } finally {
          remoteLoading.value = false;
        }
      };
      const handleSearch = () => {
        pagination.page = 1;
        loadLocalData();
      };
      const handleReset = () => {
        filters.value.keyword = "";
        filters.value.status = null;
        filters.value.applicationType = null;
        pagination.page = 1;
        loadLocalData();
      };
      const handleRemoteSearch = () => {
        remotePagination.page = 1;
        loadRemoteData();
      };
      const handleRemoteReset = () => {
        remoteFilters.value.keyword = "";
        remotePagination.page = 1;
        loadRemoteData();
      };
      const handleTabChange = (value) => {
        activeTab.value = value;
        loadData();
      };
      const handlePageChange = (page) => {
        pagination.page = page;
        loadLocalData();
      };
      const handlePageSizeChange = (pageSize) => {
        pagination.pageSize = pageSize;
        pagination.page = 1;
        loadLocalData();
      };
      const handleRemotePageChange = (page) => {
        remotePagination.page = page;
        loadRemoteData();
      };
      const handleRemotePageSizeChange = (pageSize) => {
        remotePagination.pageSize = pageSize;
        remotePagination.page = 1;
        loadRemoteData();
      };
      const handleViewDetail = async (app) => {
        try {
          const data = await applicationApi.getDetail(app.id);
          currentApplication.value = data;
          showDetailDrawer.value = true;
          detailActiveTab.value = "basic";
          loadOperationLogs(app.id);
        } catch (error2) {
          console.error("加载应用详情失败:", error2);
        }
      };
      const loadOperationLogs = async (appId) => {
        operationLogsLoading.value = true;
        try {
          const data = await applicationApi.getOperationLogs(
            appId,
            operationLogsPagination.page,
            operationLogsPagination.pageSize
          );
          operationLogs.value = data.items;
          operationLogsPagination.itemCount = data.total;
        } catch (error2) {
        } finally {
          operationLogsLoading.value = false;
        }
      };
      const handleOperationLogsPageChange = (page) => {
        operationLogsPagination.page = page;
        if (currentApplication.value) {
          loadOperationLogs(currentApplication.value.id);
        }
      };
      const handleOperationLogsPageSizeChange = (pageSize) => {
        operationLogsPagination.pageSize = pageSize;
        operationLogsPagination.page = 1;
        if (currentApplication.value) {
          loadOperationLogs(currentApplication.value.id);
        }
      };
      const handleViewRemoteDetail = async (app) => {
        currentApplication.value = app;
        showDetailDrawer.value = true;
      };
      const handleStart = (app) => {
        confirmTarget.value = app;
        showStartConfirm.value = true;
      };
      const confirmStart = async () => {
        if (!confirmTarget.value) return false;
        startLoading.value = true;
        try {
          await applicationApi.enable(confirmTarget.value.id, "admin");
          message.success("应用已启动，页面即将刷新...");
          showStartConfirm.value = false;
          setTimeout(() => {
            window.location.reload();
          }, 1500);
          return true;
        } catch (error2) {
          console.error("启动应用失败:", error2);
          return false;
        } finally {
          startLoading.value = false;
        }
      };
      const handleStop = (app) => {
        confirmTarget.value = app;
        showStopConfirm.value = true;
      };
      const confirmStop = async () => {
        if (!confirmTarget.value) return false;
        stopLoading.value = true;
        try {
          await applicationApi.disable(confirmTarget.value.id, "admin");
          message.success("应用已停止，页面即将刷新...");
          showStopConfirm.value = false;
          setTimeout(() => {
            window.location.reload();
          }, 1500);
          return true;
        } catch (error2) {
          console.error("停止应用失败:", error2);
          return false;
        } finally {
          stopLoading.value = false;
        }
      };
      const handleUpgrade = (app) => {
        currentApplication.value = app;
        upgradeForm.targetVersion = app.remoteVersion || "";
        showUpgradeModal.value = true;
      };
      const confirmUpgrade = async () => {
        var _a2;
        try {
          await ((_a2 = upgradeFormRef.value) == null ? void 0 : _a2.validate());
        } catch {
          return false;
        }
        if (!currentApplication.value) return false;
        upgradeLoading.value = true;
        try {
          await applicationApi.upgrade(currentApplication.value.id, {
            targetVersion: upgradeForm.targetVersion,
            operatorId: "admin",
            operatorName: "admin"
          });
          message.success("应用升级成功，页面即将刷新...");
          showUpgradeModal.value = false;
          setTimeout(() => {
            window.location.reload();
          }, 1500);
          return true;
        } catch (error2) {
          console.error("升级应用失败:", error2);
          return false;
        } finally {
          upgradeLoading.value = false;
        }
      };
      const handleUninstall = (app) => {
        currentApplication.value = app;
        uninstallForm.reason = "";
        showUninstallModal.value = true;
      };
      const confirmUninstall = async () => {
        var _a2;
        try {
          await ((_a2 = uninstallFormRef.value) == null ? void 0 : _a2.validate());
        } catch {
          return false;
        }
        if (!currentApplication.value) return false;
        uninstallLoading.value = true;
        try {
          await applicationApi.uninstall(currentApplication.value.id, {
            operatorId: "admin",
            operatorName: "admin",
            reason: uninstallForm.reason
          });
          message.success("应用卸载成功，页面即将刷新...");
          showUninstallModal.value = false;
          setTimeout(() => {
            window.location.reload();
          }, 1500);
          return true;
        } catch (error2) {
          console.error("卸载应用失败:", error2);
          return false;
        } finally {
          uninstallLoading.value = false;
        }
      };
      const handleInstallRemote = (app) => {
        if (!app.pluginId) {
          message.error("插件ID不能为空");
          return;
        }
        dialog.warning({
          title: "安装应用",
          content: `确定要安装应用 "${app.applicationName}" 吗？`,
          positiveText: "安装",
          negativeText: "取消",
          onPositiveClick: async () => {
            installRemoteLoading.value[app.pluginId] = true;
            message.info(`正在安装应用: ${app.applicationName}...`);
            try {
              await applicationApi.installRemote(app.pluginId, "admin");
              message.success("应用安装成功，页面即将刷新...");
              setTimeout(() => window.location.reload(), 1500);
            } catch (error2) {
            } finally {
              installRemoteLoading.value[app.pluginId] = false;
            }
          }
        });
      };
      const handleUpgradeRemote = (app) => {
        if (!app.pluginId) {
          message.error("插件ID不能为空");
          return;
        }
        const targetVersion = app.pluginVersion || app.remoteVersion || "-";
        dialog.warning({
          title: "升级应用",
          content: `确定要将应用 "${app.applicationName}" 升级到版本 ${targetVersion} 吗？`,
          positiveText: "升级",
          negativeText: "取消",
          onPositiveClick: async () => {
            upgradeRemoteLoading.value[app.pluginId] = true;
            message.info(`正在升级应用: ${app.applicationName}...`);
            try {
              await applicationApi.installRemote(app.pluginId, "admin");
              message.success("应用升级成功，页面即将刷新...");
              setTimeout(() => {
                window.location.reload();
              }, 1500);
            } catch (error2) {
            } finally {
              upgradeRemoteLoading.value[app.pluginId] = false;
            }
          }
        });
      };
      const handleShowUpgradeInfo = (app) => {
        upgradeInfoApp.value = app;
        showUpgradeInfoModal.value = true;
      };
      const handleUpgradeFromInfo = () => {
        if (!upgradeInfoApp.value) return;
        currentApplication.value = upgradeInfoApp.value;
        upgradeForm.targetVersion = upgradeInfoApp.value.remoteVersion || "";
        showUpgradeInfoModal.value = false;
        showUpgradeModal.value = true;
      };
      const handleShowUpgradeLogs = async (app) => {
        showUpgradeLogModal.value = true;
        upgradeLogsLoading.value = true;
        upgradeLogs.value = [];
        try {
          const logs = await applicationApi.getUpgradeLogs(app.id);
          upgradeLogs.value = logs;
        } catch (error2) {
        } finally {
          upgradeLogsLoading.value = false;
        }
      };
      const handleRollback = async (app) => {
        rollbackTargetApp.value = app;
        rollbackForm.targetVersion = "";
        selectedRollbackLog.value = null;
        rollbackVersionOptions.value = [];
        showRollbackModal.value = true;
        rollbackVersionsLoading.value = true;
        try {
          const logs = await applicationApi.getUpgradeLogs(app.id);
          const successLogs = logs.filter((log2) => log2.status === "SUCCESS" && log2.newVersion);
          const versionMap = /* @__PURE__ */ new Map();
          successLogs.forEach((log2) => {
            if (log2.newVersion && !versionMap.has(log2.newVersion)) {
              versionMap.set(log2.newVersion, log2);
            }
          });
          rollbackVersionOptions.value = Array.from(versionMap.entries()).map(([version, log2]) => ({
            label: `${version} (${formatDateTime(log2.createTime)})`,
            value: version
          }));
          upgradeLogs.value = logs;
        } catch (error2) {
        } finally {
          rollbackVersionsLoading.value = false;
        }
      };
      const handleRollbackVersionChange = (version) => {
        const log2 = upgradeLogs.value.find((l) => l.newVersion === version && l.status === "SUCCESS");
        selectedRollbackLog.value = log2 || null;
      };
      const confirmRollback = async () => {
        if (!rollbackForm.targetVersion) {
          message.warning("请选择要降级到的版本");
          return false;
        }
        if (!rollbackTargetApp.value) return false;
        rollbackLoading.value = true;
        try {
          await applicationApi.rollback(rollbackTargetApp.value.id, {
            targetVersion: rollbackForm.targetVersion,
            operatorId: "admin",
            operatorName: "admin"
          });
          message.success("应用降级成功，页面即将刷新...");
          showRollbackModal.value = false;
          setTimeout(() => {
            window.location.reload();
          }, 1500);
          return true;
        } catch (error2) {
          console.error("降级应用失败:", error2);
          return false;
        } finally {
          rollbackLoading.value = false;
        }
      };
      const handleRestart = (app) => {
        dialog.warning({
          title: "重启应用",
          content: `确定要重启应用 "${app.applicationName}" 吗？重启过程中应用将暂时不可用。`,
          positiveText: "确定",
          negativeText: "取消",
          onPositiveClick: async () => {
            restartLoading.value = true;
            try {
              await applicationApi.restart(app.id, "admin");
              message.success("应用重启成功");
              await loadData();
            } catch (error2) {
            } finally {
              restartLoading.value = false;
            }
          }
        });
      };
      const handleUploadClick = () => {
        uploadFile.value = null;
        showUploadModal.value = true;
      };
      const handleFileChange = (options) => {
        if (options.fileList.length > 0) {
          uploadFile.value = options.fileList[0];
        } else {
          uploadFile.value = null;
        }
      };
      const confirmUpload = async () => {
        var _a2;
        if (!uploadFile.value || !uploadFile.value.file) {
          message.warning("请选择要上传的应用包文件");
          return false;
        }
        if (!uploadFile.value.name.endsWith(".jar")) {
          message.error("只支持 .jar 格式的应用包文件");
          return false;
        }
        uploading.value = true;
        try {
          const formData = new FormData();
          formData.append("file", uploadFile.value.file);
          formData.append("operatorId", "admin");
          formData.append("operatorName", "admin");
          console.log("准备上传文件:", {
            fileName: uploadFile.value.name,
            fileSize: (_a2 = uploadFile.value.file) == null ? void 0 : _a2.size
          });
          await applicationApi.uploadAndInstall(formData);
          message.success("应用包上传并安装成功，页面即将刷新...");
          showUploadModal.value = false;
          uploadFile.value = null;
          setTimeout(() => {
            window.location.reload();
          }, 1500);
          return true;
        } catch (error2) {
          return false;
        } finally {
          uploading.value = false;
        }
      };
      const formatFileSize = (bytes) => {
        if (bytes === 0) return "0 B";
        const k = 1024;
        const sizes = ["B", "KB", "MB", "GB"];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return Math.round(bytes / Math.pow(k, i) * 100) / 100 + " " + sizes[i];
      };
      const handleShowConfig = async (app) => {
        configTargetApp.value = app;
        configMetadata.value = [];
        configMetadataLoading.value = true;
        try {
          const metadata = await applicationApi.getConfigMetadata(app.id);
          configMetadata.value = metadata || [];
          console.log("[ApplicationManagement] 加载配置元数据:", {
            appId: app.id,
            appName: app.applicationName,
            metadataCount: configMetadata.value.length
          });
        } catch (error2) {
          configMetadata.value = [];
        } finally {
          configMetadataLoading.value = false;
        }
        configLoading.value = true;
        try {
          const config = await applicationApi.getConfig(app.id);
          configForm.autoLoad = config.autoLoad || false;
          configForm.loadOnStartup = config.loadOnStartup || false;
          configForm.startPriority = config.startPriority || 50;
          configForm.startDelay = config.startDelay || 0;
          configForm.description = config.description || "";
          configForm.extensionConfig = config.extensionConfig || {};
          console.log("[ApplicationManagement] 加载应用配置:", {
            appId: app.id,
            appName: app.applicationName,
            extensionConfig: configForm.extensionConfig,
            extensionConfigKeys: Object.keys(configForm.extensionConfig)
          });
        } catch (error2) {
          console.error("加载应用配置失败:", error2);
          configForm.autoLoad = false;
          configForm.loadOnStartup = false;
          configForm.startPriority = 50;
          configForm.startDelay = 0;
          configForm.description = "";
          configForm.extensionConfig = {};
        } finally {
          configLoading.value = false;
        }
        showConfigModal.value = true;
      };
      const confirmConfig = async () => {
        if (!configTargetApp.value) return false;
        configLoading.value = true;
        try {
          const extensionConfigToSave = { ...configForm.extensionConfig };
          console.log("[ApplicationManagement] 保存配置:", {
            appId: configTargetApp.value.id,
            appName: configTargetApp.value.applicationName,
            extensionConfig: extensionConfigToSave,
            extensionConfigKeys: Object.keys(extensionConfigToSave)
          });
          await applicationApi.updateConfig(configTargetApp.value.id, {
            autoLoad: configForm.autoLoad,
            loadOnStartup: configForm.loadOnStartup,
            startPriority: configForm.startPriority,
            startDelay: configForm.startDelay,
            description: configForm.description,
            extensionConfig: extensionConfigToSave
          });
          message.success("应用配置已保存");
          showConfigModal.value = false;
          return true;
        } catch (error2) {
          console.error("保存应用配置失败:", error2);
          return false;
        } finally {
          configLoading.value = false;
        }
      };
      const getMoreActions = (app) => {
        const actions2 = [];
        actions2.push({
          label: "升级日志",
          key: "upgrade-logs"
        });
        actions2.push({
          label: "降级",
          key: "rollback",
          disabled: app.applicationType === "integrated"
        });
        actions2.push({
          label: "详情",
          key: "detail"
        });
        if (app.status === 1) {
          actions2.push({
            label: "停止",
            key: "stop"
          });
        } else {
          actions2.push({
            label: "启动",
            key: "start"
          });
        }
        actions2.push({
          label: "卸载",
          key: "uninstall",
          disabled: app.isDefault === 1 || app.applicationType === "integrated"
        });
        return actions2;
      };
      const handleMoreAction = (key2, app) => {
        switch (key2) {
          case "upgrade-logs":
            handleShowUpgradeLogs(app);
            break;
          case "rollback":
            handleRollback(app);
            break;
          case "detail":
            handleViewDetail(app);
            break;
          case "start":
            handleStart(app);
            break;
          case "stop":
            handleStop(app);
            break;
          case "uninstall":
            handleUninstall(app);
            break;
        }
      };
      const getApplicationTypeColor = (type) => {
        if (type === "integrated") {
          return "info";
        } else if (type === "plugin") {
          return "success";
        }
        return "default";
      };
      const getPluginTypes = (pluginType) => {
        if (!pluginType) return [];
        return pluginType.split(",").map((t) => t.trim()).filter((t) => t);
      };
      const getPluginTypeText = (type) => {
        const typeMap = {
          "TRIGGER": "触发器",
          "TASK": "任务",
          "APPLICATION": "应用",
          "EXECUTOR": "执行器",
          "DATASOURCE": "数据源"
        };
        return typeMap[type.toUpperCase()] || type;
      };
      const getPluginTypeColor = (type) => {
        const colorMap = {
          "TRIGGER": "warning",
          "TASK": "success",
          "APPLICATION": "info",
          "EXECUTOR": "error",
          "DATASOURCE": "default"
        };
        return colorMap[type.toUpperCase()] || "default";
      };
      const formatDateTime = (dateTime) => {
        if (!dateTime) return "-";
        const date = new Date(dateTime);
        return date.toLocaleString("zh-CN", {
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit"
        });
      };
      const getOperationTypeColor = (type) => {
        const colorMap = {
          "START": "success",
          "STOP": "warning",
          "RESTART": "info",
          "INSTALL": "success",
          "UNINSTALL": "error",
          "UPGRADE": "warning",
          "ROLLBACK": "warning",
          "CONFIG_UPDATE": "info"
        };
        return colorMap[type] || "default";
      };
      const formatJson = (jsonStr) => {
        if (!jsonStr) return "{}";
        try {
          const obj = typeof jsonStr === "string" ? JSON.parse(jsonStr) : jsonStr;
          return JSON.stringify(obj, null, 2);
        } catch (e2) {
          return jsonStr;
        }
      };
      vue.onMounted(() => {
        loadData();
      });
      return (_ctx, _cache) => {
        const _component_PageHeader = vue.resolveComponent("PageHeader");
        const _component_FilterPanel = vue.resolveComponent("FilterPanel");
        const _component_DynamicFormRenderer = vue.resolveComponent("DynamicFormRenderer");
        const _directive_copy = vue.resolveDirective("copy");
        return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$6, [
          vue.createVNode(_component_PageHeader, {
            title: "应用管理",
            subtitle: "管理已安装的应用插件"
          }, {
            actions: vue.withCtx(() => [
              activeTab.value === "local" ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NButton), {
                key: 0,
                type: "primary",
                onClick: handleUploadClick
              }, {
                icon: vue.withCtx(() => [
                  vue.createVNode(vue.unref(naiveUi.NIcon), null, {
                    default: vue.withCtx(() => [
                      (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(CloudUploadOutline))))
                    ]),
                    _: 1
                  })
                ]),
                default: vue.withCtx(() => [
                  _cache[33] || (_cache[33] = vue.createTextVNode(" 上传应用包 ", -1))
                ]),
                _: 1
              })) : vue.createCommentVNode("", true),
              vue.createVNode(vue.unref(naiveUi.NButton), {
                loading: refreshLoading.value,
                onClick: loadData
              }, {
                icon: vue.withCtx(() => [
                  vue.createVNode(vue.unref(naiveUi.NIcon), null, {
                    default: vue.withCtx(() => [
                      (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(Refresh))))
                    ]),
                    _: 1
                  })
                ]),
                default: vue.withCtx(() => [
                  _cache[34] || (_cache[34] = vue.createTextVNode(" 刷新 ", -1))
                ]),
                _: 1
              }, 8, ["loading"])
            ]),
            _: 1
          }),
          vue.createElementVNode("div", _hoisted_2$6, [
            vue.createVNode(vue.unref(naiveUi.NTabs), {
              value: activeTab.value,
              "onUpdate:value": [
                _cache[9] || (_cache[9] = ($event) => activeTab.value = $event),
                handleTabChange
              ],
              type: "line"
            }, {
              default: vue.withCtx(() => [
                vue.createVNode(vue.unref(naiveUi.NTabPane), {
                  name: "local",
                  tab: "我的应用"
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(_component_FilterPanel, {
                      filters: filters.value,
                      "onUpdate:filters": _cache[0] || (_cache[0] = ($event) => filters.value = $event),
                      "show-advanced": showAdvanced.value,
                      "onUpdate:showAdvanced": _cache[1] || (_cache[1] = ($event) => showAdvanced.value = $event),
                      "basic-fields": basicFields,
                      onSearch: handleSearch,
                      onReset: handleReset
                    }, null, 8, ["filters", "show-advanced"]),
                    loading.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_3$6, [
                      vue.createVNode(vue.unref(naiveUi.NSpin), { size: "large" })
                    ])) : tableData.value.length === 0 ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_4$4, [
                      vue.createElementVNode("div", _hoisted_5$3, [
                        vue.createVNode(vue.unref(naiveUi.NIcon), { size: "48" }, {
                          default: vue.withCtx(() => [
                            (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(AppsOutline))))
                          ]),
                          _: 1
                        })
                      ]),
                      vue.createElementVNode("div", _hoisted_6$3, vue.toDisplayString(filters.value.keyword ? "未找到匹配的应用" : "暂无应用信息"), 1)
                    ])) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_7$2, [
                      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(tableData.value, (app) => {
                        return vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NCard), {
                          key: app.id,
                          class: "app-card",
                          hoverable: "",
                          onClick: ($event) => handleViewDetail(app)
                        }, {
                          default: vue.withCtx(() => [
                            vue.createElementVNode("div", _hoisted_8$2, [
                              vue.createElementVNode("div", {
                                class: vue.normalizeClass(["app-icon", `app-icon--${app.applicationType}`])
                              }, [
                                vue.createVNode(vue.unref(naiveUi.NIcon), { size: "24" }, {
                                  default: vue.withCtx(() => [
                                    (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(app.applicationType === "integrated" ? vue.unref(CubeOutline) : vue.unref(ExtensionPuzzleOutline))))
                                  ]),
                                  _: 2
                                }, 1024)
                              ], 2),
                              vue.createElementVNode("div", _hoisted_9$2, [
                                vue.createElementVNode("div", _hoisted_10$2, [
                                  vue.createTextVNode(vue.toDisplayString(app.applicationName) + " ", 1),
                                  app.isDefault === 1 ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NTag), {
                                    key: 0,
                                    type: "warning",
                                    size: "small",
                                    style: { "margin-left": "8px" }
                                  }, {
                                    default: vue.withCtx(() => [..._cache[35] || (_cache[35] = [
                                      vue.createTextVNode(" 默认 ", -1)
                                    ])]),
                                    _: 1
                                  })) : vue.createCommentVNode("", true)
                                ]),
                                vue.createElementVNode("div", _hoisted_11$2, vue.toDisplayString(app.applicationCode), 1)
                              ]),
                              vue.createElementVNode("div", _hoisted_12$1, [
                                vue.createVNode(vue.unref(naiveUi.NTag), {
                                  type: app.status === 1 ? "success" : "error",
                                  size: "small"
                                }, {
                                  default: vue.withCtx(() => [
                                    vue.createTextVNode(vue.toDisplayString(app.statusText), 1)
                                  ]),
                                  _: 2
                                }, 1032, ["type"])
                              ])
                            ]),
                            vue.createElementVNode("div", _hoisted_13$1, [
                              vue.createElementVNode("div", _hoisted_14$1, [
                                vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", _hoisted_15$1, [
                                  _cache[36] || (_cache[36] = vue.createElementVNode("span", { class: "meta-label" }, "插件ID：", -1)),
                                  vue.createElementVNode("span", _hoisted_16$1, vue.toDisplayString(app.pluginId), 1)
                                ])), [
                                  [_directive_copy, app.pluginId]
                                ]),
                                vue.createElementVNode("div", _hoisted_17$1, [
                                  _cache[37] || (_cache[37] = vue.createElementVNode("span", { class: "meta-label" }, "版本：", -1)),
                                  vue.createElementVNode("span", _hoisted_18$1, vue.toDisplayString(app.pluginVersion || "-"), 1),
                                  app.hasNewVersion ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NTooltip), {
                                    key: 0,
                                    placement: "top"
                                  }, {
                                    trigger: vue.withCtx(() => [
                                      vue.createVNode(vue.unref(naiveUi.NIcon), {
                                        size: "16",
                                        color: "#f59e0b",
                                        style: { "margin-left": "6px", "cursor": "pointer", "vertical-align": "middle" },
                                        onClick: vue.withModifiers(($event) => handleShowUpgradeInfo(app), ["stop"])
                                      }, {
                                        default: vue.withCtx(() => [
                                          (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(RocketOutline))))
                                        ]),
                                        _: 1
                                      }, 8, ["onClick"])
                                    ]),
                                    default: vue.withCtx(() => [
                                      vue.createElementVNode("span", null, "有新版本 " + vue.toDisplayString(app.remoteVersion) + " 可升级", 1)
                                    ]),
                                    _: 2
                                  }, 1024)) : vue.createCommentVNode("", true)
                                ]),
                                vue.createElementVNode("div", _hoisted_19$1, [
                                  _cache[38] || (_cache[38] = vue.createElementVNode("span", { class: "meta-label" }, "类型：", -1)),
                                  vue.createVNode(vue.unref(naiveUi.NTag), {
                                    size: "small",
                                    type: getApplicationTypeColor(app.applicationType)
                                  }, {
                                    default: vue.withCtx(() => [
                                      vue.createTextVNode(vue.toDisplayString(app.applicationTypeText), 1)
                                    ]),
                                    _: 2
                                  }, 1032, ["type"])
                                ]),
                                app.pluginType ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_20$1, [
                                  _cache[39] || (_cache[39] = vue.createElementVNode("span", { class: "meta-label" }, "插件类型：", -1)),
                                  vue.createVNode(vue.unref(naiveUi.NSpace), { size: 4 }, {
                                    default: vue.withCtx(() => [
                                      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(getPluginTypes(app.pluginType), (type) => {
                                        return vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NTag), {
                                          key: type,
                                          size: "small",
                                          type: getPluginTypeColor(type)
                                        }, {
                                          default: vue.withCtx(() => [
                                            vue.createTextVNode(vue.toDisplayString(getPluginTypeText(type)), 1)
                                          ]),
                                          _: 2
                                        }, 1032, ["type"]);
                                      }), 128))
                                    ]),
                                    _: 2
                                  }, 1024)
                                ])) : vue.createCommentVNode("", true)
                              ]),
                              app.description ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_21$1, vue.toDisplayString(app.description), 1)) : vue.createCommentVNode("", true)
                            ]),
                            vue.createElementVNode("div", _hoisted_22$1, [
                              vue.createElementVNode("div", _hoisted_23$1, [
                                vue.createVNode(vue.unref(naiveUi.NIcon), { size: "14" }, {
                                  default: vue.withCtx(() => [
                                    (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(TimeOutline))))
                                  ]),
                                  _: 1
                                }),
                                vue.createTextVNode(" 安装：" + vue.toDisplayString(formatDateTime(app.installTime)), 1)
                              ]),
                              vue.createElementVNode("div", _hoisted_24$1, [
                                vue.createVNode(vue.unref(naiveUi.NButton), {
                                  text: "",
                                  type: "primary",
                                  size: "small",
                                  onClick: vue.withModifiers(($event) => handleShowConfig(app), ["stop"])
                                }, {
                                  default: vue.withCtx(() => [..._cache[40] || (_cache[40] = [
                                    vue.createTextVNode(" 配置 ", -1)
                                  ])]),
                                  _: 1
                                }, 8, ["onClick"]),
                                app.hasNewVersion ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NButton), {
                                  key: 0,
                                  text: "",
                                  type: "warning",
                                  size: "small",
                                  disabled: app.applicationType === "integrated",
                                  onClick: vue.withModifiers(($event) => handleUpgrade(app), ["stop"])
                                }, {
                                  default: vue.withCtx(() => [..._cache[41] || (_cache[41] = [
                                    vue.createTextVNode(" 升级 ", -1)
                                  ])]),
                                  _: 1
                                }, 8, ["disabled", "onClick"])) : vue.createCommentVNode("", true),
                                vue.createVNode(vue.unref(naiveUi.NButton), {
                                  text: "",
                                  type: "info",
                                  size: "small",
                                  disabled: app.status !== 1,
                                  onClick: vue.withModifiers(($event) => handleRestart(app), ["stop"])
                                }, {
                                  default: vue.withCtx(() => [..._cache[42] || (_cache[42] = [
                                    vue.createTextVNode(" 重启 ", -1)
                                  ])]),
                                  _: 1
                                }, 8, ["disabled", "onClick"]),
                                vue.createVNode(vue.unref(naiveUi.NDropdown), {
                                  options: getMoreActions(app),
                                  onSelect: (key2) => handleMoreAction(key2, app),
                                  trigger: "click"
                                }, {
                                  default: vue.withCtx(() => [
                                    vue.createVNode(vue.unref(naiveUi.NButton), {
                                      text: "",
                                      size: "small",
                                      onClick: _cache[2] || (_cache[2] = vue.withModifiers(() => {
                                      }, ["stop"]))
                                    }, {
                                      icon: vue.withCtx(() => [
                                        vue.createVNode(vue.unref(naiveUi.NIcon), null, {
                                          default: vue.withCtx(() => [
                                            (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(EllipsisHorizontalOutline))))
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 1
                                }, 8, ["options", "onSelect"])
                              ])
                            ])
                          ]),
                          _: 2
                        }, 1032, ["onClick"]);
                      }), 128))
                    ])),
                    pagination.itemCount > 0 ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_25$1, [
                      vue.createVNode(vue.unref(naiveUi.NPagination), {
                        page: pagination.page,
                        "onUpdate:page": [
                          _cache[3] || (_cache[3] = ($event) => pagination.page = $event),
                          handlePageChange
                        ],
                        "page-size": pagination.pageSize,
                        "onUpdate:pageSize": [
                          _cache[4] || (_cache[4] = ($event) => pagination.pageSize = $event),
                          handlePageSizeChange
                        ],
                        "page-count": Math.ceil(pagination.itemCount / pagination.pageSize),
                        "page-sizes": pagination.pageSizes,
                        "show-size-picker": ""
                      }, null, 8, ["page", "page-size", "page-count", "page-sizes"])
                    ])) : vue.createCommentVNode("", true)
                  ]),
                  _: 1
                }),
                vue.createVNode(vue.unref(naiveUi.NTabPane), {
                  name: "remote",
                  tab: "应用商店"
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(_component_FilterPanel, {
                      filters: remoteFilters.value,
                      "onUpdate:filters": _cache[5] || (_cache[5] = ($event) => remoteFilters.value = $event),
                      "show-advanced": showRemoteAdvanced.value,
                      "onUpdate:showAdvanced": _cache[6] || (_cache[6] = ($event) => showRemoteAdvanced.value = $event),
                      "basic-fields": remoteBasicFields,
                      onSearch: handleRemoteSearch,
                      onReset: handleRemoteReset
                    }, null, 8, ["filters", "show-advanced"]),
                    remoteLoading.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_26$1, [
                      vue.createVNode(vue.unref(naiveUi.NSpin), { size: "large" })
                    ])) : remoteTableData.value.length === 0 ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_27$1, [
                      vue.createElementVNode("div", _hoisted_28$1, [
                        vue.createVNode(vue.unref(naiveUi.NIcon), { size: "48" }, {
                          default: vue.withCtx(() => [
                            (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(AppsOutline))))
                          ]),
                          _: 1
                        })
                      ]),
                      vue.createElementVNode("div", _hoisted_29$1, vue.toDisplayString(remoteFilters.value.keyword ? "未找到匹配的应用" : "暂无远程应用"), 1)
                    ])) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_30$1, [
                      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(remoteTableData.value, (app) => {
                        return vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NCard), {
                          key: app.id,
                          class: "app-card",
                          hoverable: "",
                          onClick: ($event) => handleViewRemoteDetail(app)
                        }, {
                          default: vue.withCtx(() => [
                            vue.createElementVNode("div", _hoisted_31$1, [
                              vue.createElementVNode("div", _hoisted_32$1, [
                                vue.createVNode(vue.unref(naiveUi.NIcon), { size: "24" }, {
                                  default: vue.withCtx(() => [
                                    (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(ExtensionPuzzleOutline))))
                                  ]),
                                  _: 1
                                })
                              ]),
                              vue.createElementVNode("div", _hoisted_33$1, [
                                vue.createElementVNode("div", _hoisted_34$1, vue.toDisplayString(app.applicationName), 1),
                                vue.createElementVNode("div", _hoisted_35$1, vue.toDisplayString(app.applicationCode), 1)
                              ]),
                              vue.createElementVNode("div", _hoisted_36$1, [
                                app.installStatus === "INSTALLED" ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NTag), {
                                  key: 0,
                                  type: "success",
                                  size: "small"
                                }, {
                                  default: vue.withCtx(() => [..._cache[43] || (_cache[43] = [
                                    vue.createTextVNode(" 已安装 ", -1)
                                  ])]),
                                  _: 1
                                })) : app.installStatus === "UPGRADABLE" ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NTag), {
                                  key: 1,
                                  type: "warning",
                                  size: "small"
                                }, {
                                  default: vue.withCtx(() => [..._cache[44] || (_cache[44] = [
                                    vue.createTextVNode(" 可升级 ", -1)
                                  ])]),
                                  _: 1
                                })) : (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NTag), {
                                  key: 2,
                                  type: "info",
                                  size: "small"
                                }, {
                                  default: vue.withCtx(() => [..._cache[45] || (_cache[45] = [
                                    vue.createTextVNode(" 未安装 ", -1)
                                  ])]),
                                  _: 1
                                }))
                              ])
                            ]),
                            vue.createElementVNode("div", _hoisted_37$1, [
                              vue.createElementVNode("div", _hoisted_38, [
                                vue.createElementVNode("div", _hoisted_39, [
                                  _cache[46] || (_cache[46] = vue.createElementVNode("span", { class: "meta-label" }, "插件ID：", -1)),
                                  vue.createElementVNode("span", _hoisted_40, vue.toDisplayString(app.pluginId), 1)
                                ]),
                                vue.createElementVNode("div", _hoisted_41, [
                                  _cache[47] || (_cache[47] = vue.createElementVNode("span", { class: "meta-label" }, "远程版本：", -1)),
                                  vue.createElementVNode("span", _hoisted_42, vue.toDisplayString(app.pluginVersion || "-"), 1)
                                ]),
                                app.localVersion ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_43, [
                                  _cache[48] || (_cache[48] = vue.createElementVNode("span", { class: "meta-label" }, "本地版本：", -1)),
                                  vue.createElementVNode("span", _hoisted_44, vue.toDisplayString(app.localVersion), 1)
                                ])) : vue.createCommentVNode("", true),
                                app.author ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_45, [
                                  _cache[49] || (_cache[49] = vue.createElementVNode("span", { class: "meta-label" }, "作者：", -1)),
                                  vue.createElementVNode("span", _hoisted_46, vue.toDisplayString(app.author), 1)
                                ])) : vue.createCommentVNode("", true)
                              ]),
                              app.description ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_47, vue.toDisplayString(app.description), 1)) : vue.createCommentVNode("", true)
                            ]),
                            vue.createElementVNode("div", _hoisted_48, [
                              vue.createElementVNode("div", _hoisted_49, [
                                vue.createVNode(vue.unref(naiveUi.NIcon), { size: "14" }, {
                                  default: vue.withCtx(() => [
                                    (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(TimeOutline))))
                                  ]),
                                  _: 1
                                }),
                                vue.createTextVNode(" 更新：" + vue.toDisplayString(formatDateTime(app.updateTime)), 1)
                              ]),
                              vue.createElementVNode("div", _hoisted_50, [
                                vue.createVNode(vue.unref(naiveUi.NButton), {
                                  text: "",
                                  type: "info",
                                  size: "small",
                                  onClick: vue.withModifiers(($event) => handleViewRemoteDetail(app), ["stop"])
                                }, {
                                  default: vue.withCtx(() => [..._cache[50] || (_cache[50] = [
                                    vue.createTextVNode(" 详情 ", -1)
                                  ])]),
                                  _: 1
                                }, 8, ["onClick"]),
                                app.installStatus === "NOT_INSTALLED" ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NButton), {
                                  key: 0,
                                  text: "",
                                  type: "success",
                                  size: "small",
                                  loading: installRemoteLoading.value[app.pluginId],
                                  onClick: vue.withModifiers(($event) => handleInstallRemote(app), ["stop"])
                                }, {
                                  default: vue.withCtx(() => [..._cache[51] || (_cache[51] = [
                                    vue.createTextVNode(" 安装 ", -1)
                                  ])]),
                                  _: 1
                                }, 8, ["loading", "onClick"])) : app.installStatus === "UPGRADABLE" ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NButton), {
                                  key: 1,
                                  text: "",
                                  type: "warning",
                                  size: "small",
                                  loading: upgradeRemoteLoading.value[app.pluginId],
                                  onClick: vue.withModifiers(($event) => handleUpgradeRemote(app), ["stop"])
                                }, {
                                  default: vue.withCtx(() => [..._cache[52] || (_cache[52] = [
                                    vue.createTextVNode(" 升级 ", -1)
                                  ])]),
                                  _: 1
                                }, 8, ["loading", "onClick"])) : (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NButton), {
                                  key: 2,
                                  text: "",
                                  type: "default",
                                  size: "small",
                                  disabled: ""
                                }, {
                                  default: vue.withCtx(() => [..._cache[53] || (_cache[53] = [
                                    vue.createTextVNode(" 已安装 ", -1)
                                  ])]),
                                  _: 1
                                }))
                              ])
                            ])
                          ]),
                          _: 2
                        }, 1032, ["onClick"]);
                      }), 128))
                    ])),
                    remotePagination.itemCount > 0 ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_51, [
                      vue.createVNode(vue.unref(naiveUi.NPagination), {
                        page: remotePagination.page,
                        "onUpdate:page": [
                          _cache[7] || (_cache[7] = ($event) => remotePagination.page = $event),
                          handleRemotePageChange
                        ],
                        "page-size": remotePagination.pageSize,
                        "onUpdate:pageSize": [
                          _cache[8] || (_cache[8] = ($event) => remotePagination.pageSize = $event),
                          handleRemotePageSizeChange
                        ],
                        "page-count": Math.ceil(remotePagination.itemCount / remotePagination.pageSize),
                        "page-sizes": remotePagination.pageSizes,
                        "show-size-picker": ""
                      }, null, 8, ["page", "page-size", "page-count", "page-sizes"])
                    ])) : vue.createCommentVNode("", true)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["value"])
          ]),
          vue.createVNode(vue.unref(naiveUi.NDrawer), {
            show: showDetailDrawer.value,
            "onUpdate:show": _cache[14] || (_cache[14] = ($event) => showDetailDrawer.value = $event),
            width: 720,
            placement: "right"
          }, {
            default: vue.withCtx(() => [
              vue.createVNode(vue.unref(naiveUi.NDrawerContent), {
                title: "应用详情",
                closable: ""
              }, {
                footer: vue.withCtx(() => [
                  vue.createVNode(vue.unref(naiveUi.NSpace), { justify: "end" }, {
                    default: vue.withCtx(() => [
                      vue.createVNode(vue.unref(naiveUi.NButton), {
                        onClick: _cache[13] || (_cache[13] = ($event) => showDetailDrawer.value = false)
                      }, {
                        default: vue.withCtx(() => [..._cache[61] || (_cache[61] = [
                          vue.createTextVNode("关闭", -1)
                        ])]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                default: vue.withCtx(() => [
                  currentApplication.value ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NTabs), {
                    key: 0,
                    value: detailActiveTab.value,
                    "onUpdate:value": _cache[12] || (_cache[12] = ($event) => detailActiveTab.value = $event),
                    type: "line"
                  }, {
                    default: vue.withCtx(() => [
                      vue.createVNode(vue.unref(naiveUi.NTabPane), {
                        name: "basic",
                        tab: "基本信息"
                      }, {
                        default: vue.withCtx(() => [
                          vue.createElementVNode("div", _hoisted_52, [
                            vue.createVNode(vue.unref(naiveUi.NCard), {
                              title: "基本信息",
                              bordered: false,
                              class: "detail-section"
                            }, {
                              default: vue.withCtx(() => [
                                vue.createVNode(vue.unref(naiveUi.NDescriptions), {
                                  column: 2,
                                  "label-placement": "left"
                                }, {
                                  default: vue.withCtx(() => [
                                    vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "应用ID" }, {
                                      default: vue.withCtx(() => [
                                        vue.createTextVNode(vue.toDisplayString(currentApplication.value.id), 1)
                                      ]),
                                      _: 1
                                    }),
                                    vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "应用代码" }, {
                                      default: vue.withCtx(() => [
                                        vue.createTextVNode(vue.toDisplayString(currentApplication.value.applicationCode), 1)
                                      ]),
                                      _: 1
                                    }),
                                    vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "应用名称" }, {
                                      default: vue.withCtx(() => [
                                        vue.createTextVNode(vue.toDisplayString(currentApplication.value.applicationName), 1)
                                      ]),
                                      _: 1
                                    }),
                                    vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "插件ID" }, {
                                      default: vue.withCtx(() => [
                                        vue.createTextVNode(vue.toDisplayString(currentApplication.value.pluginId), 1)
                                      ]),
                                      _: 1
                                    }),
                                    vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "插件版本" }, {
                                      default: vue.withCtx(() => [
                                        vue.createTextVNode(vue.toDisplayString(currentApplication.value.pluginVersion || "-"), 1)
                                      ]),
                                      _: 1
                                    }),
                                    vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "应用类型" }, {
                                      default: vue.withCtx(() => [
                                        vue.createVNode(vue.unref(naiveUi.NTag), {
                                          type: getApplicationTypeColor(currentApplication.value.applicationType),
                                          size: "small"
                                        }, {
                                          default: vue.withCtx(() => [
                                            vue.createTextVNode(vue.toDisplayString(currentApplication.value.applicationTypeText), 1)
                                          ]),
                                          _: 1
                                        }, 8, ["type"])
                                      ]),
                                      _: 1
                                    }),
                                    currentApplication.value.pluginType ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NDescriptionsItem), {
                                      key: 0,
                                      label: "插件类型",
                                      span: 2
                                    }, {
                                      default: vue.withCtx(() => [
                                        vue.createVNode(vue.unref(naiveUi.NSpace), { size: 8 }, {
                                          default: vue.withCtx(() => [
                                            (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(getPluginTypes(currentApplication.value.pluginType), (type) => {
                                              return vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NTag), {
                                                key: type,
                                                size: "small",
                                                type: getPluginTypeColor(type)
                                              }, {
                                                default: vue.withCtx(() => [
                                                  vue.createTextVNode(vue.toDisplayString(getPluginTypeText(type)), 1)
                                                ]),
                                                _: 2
                                              }, 1032, ["type"]);
                                            }), 128))
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    })) : vue.createCommentVNode("", true),
                                    vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "运行状态" }, {
                                      default: vue.withCtx(() => [
                                        vue.createVNode(vue.unref(naiveUi.NTag), {
                                          type: currentApplication.value.status === 1 ? "success" : "error",
                                          size: "small"
                                        }, {
                                          default: vue.withCtx(() => [
                                            vue.createTextVNode(vue.toDisplayString(currentApplication.value.status === 1 ? "运行中" : "已停止"), 1)
                                          ]),
                                          _: 1
                                        }, 8, ["type"])
                                      ]),
                                      _: 1
                                    }),
                                    vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "默认应用" }, {
                                      default: vue.withCtx(() => [
                                        currentApplication.value.isDefault === 1 ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NTag), {
                                          key: 0,
                                          type: "warning",
                                          size: "small"
                                        }, {
                                          default: vue.withCtx(() => [..._cache[54] || (_cache[54] = [
                                            vue.createTextVNode("是", -1)
                                          ])]),
                                          _: 1
                                        })) : (vue.openBlock(), vue.createElementBlock("span", _hoisted_53, "否"))
                                      ]),
                                      _: 1
                                    }),
                                    currentApplication.value.namespaceCode ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NDescriptionsItem), {
                                      key: 1,
                                      label: "命名空间"
                                    }, {
                                      default: vue.withCtx(() => [
                                        vue.createTextVNode(vue.toDisplayString(currentApplication.value.namespaceCode), 1)
                                      ]),
                                      _: 1
                                    })) : vue.createCommentVNode("", true)
                                  ]),
                                  _: 1
                                }),
                                currentApplication.value.description ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
                                  vue.createVNode(vue.unref(naiveUi.NDivider)),
                                  vue.createVNode(vue.unref(naiveUi.NDescriptions), {
                                    column: 1,
                                    "label-placement": "left"
                                  }, {
                                    default: vue.withCtx(() => [
                                      vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "描述" }, {
                                        default: vue.withCtx(() => [
                                          vue.createTextVNode(vue.toDisplayString(currentApplication.value.description), 1)
                                        ]),
                                        _: 1
                                      })
                                    ]),
                                    _: 1
                                  })
                                ], 64)) : vue.createCommentVNode("", true)
                              ]),
                              _: 1
                            }),
                            currentApplication.value.author || currentApplication.value.homepage ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NCard), {
                              key: 0,
                              title: "作者信息",
                              bordered: false,
                              class: "detail-section"
                            }, {
                              default: vue.withCtx(() => [
                                vue.createVNode(vue.unref(naiveUi.NDescriptions), {
                                  column: 2,
                                  "label-placement": "left"
                                }, {
                                  default: vue.withCtx(() => [
                                    currentApplication.value.author ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NDescriptionsItem), {
                                      key: 0,
                                      label: "作者"
                                    }, {
                                      default: vue.withCtx(() => [
                                        vue.createTextVNode(vue.toDisplayString(currentApplication.value.author), 1)
                                      ]),
                                      _: 1
                                    })) : vue.createCommentVNode("", true),
                                    currentApplication.value.homepage ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NDescriptionsItem), {
                                      key: 1,
                                      label: "主页",
                                      span: 2
                                    }, {
                                      default: vue.withCtx(() => [
                                        vue.createElementVNode("a", {
                                          href: currentApplication.value.homepage,
                                          target: "_blank",
                                          rel: "noopener noreferrer"
                                        }, vue.toDisplayString(currentApplication.value.homepage), 9, _hoisted_54)
                                      ]),
                                      _: 1
                                    })) : vue.createCommentVNode("", true)
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            })) : vue.createCommentVNode("", true),
                            vue.createVNode(vue.unref(naiveUi.NCard), {
                              title: "时间信息",
                              bordered: false,
                              class: "detail-section"
                            }, {
                              default: vue.withCtx(() => [
                                vue.createVNode(vue.unref(naiveUi.NDescriptions), {
                                  column: 2,
                                  "label-placement": "left"
                                }, {
                                  default: vue.withCtx(() => [
                                    vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "安装时间" }, {
                                      default: vue.withCtx(() => [
                                        vue.createTextVNode(vue.toDisplayString(formatDateTime(currentApplication.value.installTime)), 1)
                                      ]),
                                      _: 1
                                    }),
                                    vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "更新时间" }, {
                                      default: vue.withCtx(() => [
                                        vue.createTextVNode(vue.toDisplayString(formatDateTime(currentApplication.value.updateTime)), 1)
                                      ]),
                                      _: 1
                                    }),
                                    currentApplication.value.createBy ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NDescriptionsItem), {
                                      key: 0,
                                      label: "创建人"
                                    }, {
                                      default: vue.withCtx(() => [
                                        vue.createTextVNode(vue.toDisplayString(currentApplication.value.createBy), 1)
                                      ]),
                                      _: 1
                                    })) : vue.createCommentVNode("", true),
                                    currentApplication.value.updateBy ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NDescriptionsItem), {
                                      key: 1,
                                      label: "更新人"
                                    }, {
                                      default: vue.withCtx(() => [
                                        vue.createTextVNode(vue.toDisplayString(currentApplication.value.updateBy), 1)
                                      ]),
                                      _: 1
                                    })) : vue.createCommentVNode("", true)
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            })
                          ])
                        ]),
                        _: 1
                      }),
                      vue.createVNode(vue.unref(naiveUi.NTabPane), {
                        name: "logs",
                        tab: "操作日志"
                      }, {
                        default: vue.withCtx(() => [
                          operationLogsLoading.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_55, [
                            vue.createVNode(vue.unref(naiveUi.NSpin), { size: "large" })
                          ])) : operationLogs.value.length === 0 ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_56, [..._cache[55] || (_cache[55] = [
                            vue.createElementVNode("div", { class: "empty-state__text" }, "暂无操作日志", -1)
                          ])])) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_57, [
                            vue.createVNode(vue.unref(naiveUi.NTimeline), null, {
                              default: vue.withCtx(() => [
                                (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(operationLogs.value, (log2) => {
                                  return vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NTimelineItem), {
                                    key: log2.id,
                                    type: log2.status === "SUCCESS" ? "success" : "error",
                                    time: formatDateTime(log2.createTime)
                                  }, {
                                    header: vue.withCtx(() => [
                                      vue.createElementVNode("div", _hoisted_58, [
                                        vue.createVNode(vue.unref(naiveUi.NTag), {
                                          size: "small",
                                          type: getOperationTypeColor(log2.operationType)
                                        }, {
                                          default: vue.withCtx(() => [
                                            vue.createTextVNode(vue.toDisplayString(log2.operationTypeText), 1)
                                          ]),
                                          _: 2
                                        }, 1032, ["type"]),
                                        vue.createVNode(vue.unref(naiveUi.NTag), {
                                          size: "small",
                                          type: log2.status === "SUCCESS" ? "success" : "error",
                                          style: { "margin-left": "8px" }
                                        }, {
                                          default: vue.withCtx(() => [
                                            vue.createTextVNode(vue.toDisplayString(log2.statusText), 1)
                                          ]),
                                          _: 2
                                        }, 1032, ["type"]),
                                        vue.createElementVNode("span", _hoisted_59, vue.toDisplayString(log2.operationDesc), 1)
                                      ])
                                    ]),
                                    default: vue.withCtx(() => [
                                      vue.createElementVNode("div", _hoisted_60, [
                                        log2.operatorName ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_61, [
                                          _cache[56] || (_cache[56] = vue.createElementVNode("span", { class: "log-label" }, "操作人：", -1)),
                                          vue.createElementVNode("span", _hoisted_62, vue.toDisplayString(log2.operatorName), 1)
                                        ])) : vue.createCommentVNode("", true),
                                        log2.duration ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_63, [
                                          _cache[57] || (_cache[57] = vue.createElementVNode("span", { class: "log-label" }, "耗时：", -1)),
                                          vue.createElementVNode("span", _hoisted_64, vue.toDisplayString(log2.duration) + "ms", 1)
                                        ])) : vue.createCommentVNode("", true),
                                        log2.message ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_65, [
                                          _cache[58] || (_cache[58] = vue.createElementVNode("span", { class: "log-label" }, "说明：", -1)),
                                          vue.createElementVNode("span", _hoisted_66, vue.toDisplayString(log2.message), 1)
                                        ])) : vue.createCommentVNode("", true),
                                        log2.operationType === "CONFIG_UPDATE" && (log2.beforeData || log2.afterData) ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_67, [
                                          vue.createVNode(vue.unref(naiveUi.NCollapse), null, {
                                            default: vue.withCtx(() => [
                                              vue.createVNode(vue.unref(naiveUi.NCollapseItem), {
                                                title: "查看配置变更",
                                                name: "config"
                                              }, {
                                                default: vue.withCtx(() => [
                                                  vue.createElementVNode("div", _hoisted_68, [
                                                    vue.createElementVNode("div", _hoisted_69, [
                                                      _cache[59] || (_cache[59] = vue.createElementVNode("div", { class: "config-title" }, "原配置", -1)),
                                                      vue.createElementVNode("pre", _hoisted_70, vue.toDisplayString(formatJson(log2.beforeData)), 1)
                                                    ]),
                                                    vue.createElementVNode("div", _hoisted_71, [
                                                      _cache[60] || (_cache[60] = vue.createElementVNode("div", { class: "config-title" }, "新配置", -1)),
                                                      vue.createElementVNode("pre", _hoisted_72, vue.toDisplayString(formatJson(log2.afterData)), 1)
                                                    ])
                                                  ])
                                                ]),
                                                _: 2
                                              }, 1024)
                                            ]),
                                            _: 2
                                          }, 1024)
                                        ])) : vue.createCommentVNode("", true)
                                      ])
                                    ]),
                                    _: 2
                                  }, 1032, ["type", "time"]);
                                }), 128))
                              ]),
                              _: 1
                            }),
                            operationLogsPagination.itemCount > 0 ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_73, [
                              vue.createVNode(vue.unref(naiveUi.NPagination), {
                                page: operationLogsPagination.page,
                                "onUpdate:page": [
                                  _cache[10] || (_cache[10] = ($event) => operationLogsPagination.page = $event),
                                  handleOperationLogsPageChange
                                ],
                                "page-size": operationLogsPagination.pageSize,
                                "onUpdate:pageSize": [
                                  _cache[11] || (_cache[11] = ($event) => operationLogsPagination.pageSize = $event),
                                  handleOperationLogsPageSizeChange
                                ],
                                "page-count": Math.ceil(operationLogsPagination.itemCount / operationLogsPagination.pageSize),
                                "page-sizes": [10, 20, 50],
                                "show-size-picker": ""
                              }, null, 8, ["page", "page-size", "page-count"])
                            ])) : vue.createCommentVNode("", true)
                          ]))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["value"])) : vue.createCommentVNode("", true)
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["show"]),
          vue.createVNode(vue.unref(naiveUi.NModal), {
            show: showStartConfirm.value,
            "onUpdate:show": _cache[15] || (_cache[15] = ($event) => showStartConfirm.value = $event),
            preset: "dialog",
            title: "启动应用",
            "positive-text": "确定",
            "negative-text": "取消",
            "positive-button-props": { loading: startLoading.value },
            loading: startLoading.value,
            onPositiveClick: confirmStart
          }, {
            default: vue.withCtx(() => [
              vue.createVNode(vue.unref(naiveUi.NAlert), {
                type: "info",
                "show-icon": true
              }, {
                default: vue.withCtx(() => {
                  var _a2;
                  return [
                    vue.createTextVNode(' 确定要启动应用"' + vue.toDisplayString((_a2 = confirmTarget.value) == null ? void 0 : _a2.applicationName) + '"吗？ ', 1)
                  ];
                }),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["show", "positive-button-props", "loading"]),
          vue.createVNode(vue.unref(naiveUi.NModal), {
            show: showStopConfirm.value,
            "onUpdate:show": _cache[16] || (_cache[16] = ($event) => showStopConfirm.value = $event),
            preset: "dialog",
            title: "停止应用",
            "positive-text": "确定",
            "negative-text": "取消",
            "positive-button-props": { type: "warning", loading: stopLoading.value },
            loading: stopLoading.value,
            onPositiveClick: confirmStop
          }, {
            default: vue.withCtx(() => [
              vue.createVNode(vue.unref(naiveUi.NAlert), {
                type: "warning",
                "show-icon": true
              }, {
                default: vue.withCtx(() => {
                  var _a2;
                  return [
                    vue.createTextVNode(' 确定要停止应用"' + vue.toDisplayString((_a2 = confirmTarget.value) == null ? void 0 : _a2.applicationName) + '"吗？停止后该应用将无法使用。 ', 1)
                  ];
                }),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["show", "positive-button-props", "loading"]),
          vue.createVNode(vue.unref(naiveUi.NModal), {
            show: showUpgradeModal.value,
            "onUpdate:show": _cache[18] || (_cache[18] = ($event) => showUpgradeModal.value = $event),
            preset: "dialog",
            title: "升级应用",
            "positive-text": "确认升级",
            "negative-text": "取消",
            "positive-button-props": { loading: upgradeLoading.value },
            loading: upgradeLoading.value,
            onPositiveClick: confirmUpgrade
          }, {
            default: vue.withCtx(() => [
              vue.createVNode(vue.unref(naiveUi.NForm), {
                ref_key: "upgradeFormRef",
                ref: upgradeFormRef,
                model: upgradeForm,
                rules: upgradeRules
              }, {
                default: vue.withCtx(() => [
                  vue.createVNode(vue.unref(naiveUi.NFormItem), {
                    label: "目标版本",
                    path: "targetVersion"
                  }, {
                    default: vue.withCtx(() => [
                      vue.createVNode(vue.unref(naiveUi.NInput), {
                        value: upgradeForm.targetVersion,
                        "onUpdate:value": _cache[17] || (_cache[17] = ($event) => upgradeForm.targetVersion = $event),
                        placeholder: "请输入目标版本号，如：1.0.1",
                        disabled: upgradeLoading.value
                      }, null, 8, ["value", "disabled"])
                    ]),
                    _: 1
                  }),
                  vue.createVNode(vue.unref(naiveUi.NAlert), {
                    type: "info",
                    "show-icon": false,
                    style: { "margin-top": "16px" }
                  }, {
                    default: vue.withCtx(() => [..._cache[62] || (_cache[62] = [
                      vue.createTextVNode(" 升级后将使用新版本的插件包 ", -1)
                    ])]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["model"])
            ]),
            _: 1
          }, 8, ["show", "positive-button-props", "loading"]),
          vue.createVNode(vue.unref(naiveUi.NModal), {
            show: showUninstallModal.value,
            "onUpdate:show": _cache[20] || (_cache[20] = ($event) => showUninstallModal.value = $event),
            preset: "dialog",
            title: "卸载应用",
            "positive-text": "确认卸载",
            "negative-text": "取消",
            "positive-button-props": { type: "error", loading: uninstallLoading.value },
            loading: uninstallLoading.value,
            onPositiveClick: confirmUninstall
          }, {
            default: vue.withCtx(() => [
              vue.createVNode(vue.unref(naiveUi.NForm), {
                ref_key: "uninstallFormRef",
                ref: uninstallFormRef,
                model: uninstallForm,
                rules: uninstallRules
              }, {
                default: vue.withCtx(() => [
                  vue.createVNode(vue.unref(naiveUi.NFormItem), {
                    label: "卸载原因",
                    path: "reason"
                  }, {
                    default: vue.withCtx(() => [
                      vue.createVNode(vue.unref(naiveUi.NInput), {
                        value: uninstallForm.reason,
                        "onUpdate:value": _cache[19] || (_cache[19] = ($event) => uninstallForm.reason = $event),
                        type: "textarea",
                        placeholder: "请输入卸载原因（必填）",
                        rows: 4,
                        disabled: uninstallLoading.value
                      }, null, 8, ["value", "disabled"])
                    ]),
                    _: 1
                  }),
                  vue.createVNode(vue.unref(naiveUi.NAlert), {
                    type: "warning",
                    "show-icon": false,
                    style: { "margin-top": "16px" }
                  }, {
                    default: vue.withCtx(() => [..._cache[63] || (_cache[63] = [
                      vue.createTextVNode(" 卸载后应用数据将被删除，此操作不可恢复！ ", -1)
                    ])]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["model"])
            ]),
            _: 1
          }, 8, ["show", "positive-button-props", "loading"]),
          vue.createVNode(vue.unref(naiveUi.NModal), {
            show: showUpgradeInfoModal.value,
            "onUpdate:show": _cache[21] || (_cache[21] = ($event) => showUpgradeInfoModal.value = $event),
            preset: "dialog",
            title: "发现新版本",
            "positive-text": "立即升级",
            "negative-text": "稍后再说",
            "positive-button-props": { loading: upgradeLoading.value },
            onPositiveClick: handleUpgradeFromInfo
          }, {
            default: vue.withCtx(() => [
              upgradeInfoApp.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_74, [
                vue.createVNode(vue.unref(naiveUi.NAlert), {
                  type: "info",
                  "show-icon": false,
                  style: { "margin-bottom": "16px" }
                }, {
                  header: vue.withCtx(() => [
                    vue.createElementVNode("div", _hoisted_75, [
                      vue.createVNode(vue.unref(naiveUi.NIcon), {
                        size: "20",
                        color: "#f59e0b"
                      }, {
                        default: vue.withCtx(() => [
                          (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(RocketOutline))))
                        ]),
                        _: 1
                      }),
                      vue.createElementVNode("span", _hoisted_76, vue.toDisplayString(upgradeInfoApp.value.applicationName) + " 有新版本可用", 1)
                    ])
                  ]),
                  _: 1
                }),
                vue.createVNode(vue.unref(naiveUi.NDescriptions), {
                  column: 1,
                  "label-placement": "left",
                  bordered: ""
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "应用名称" }, {
                      default: vue.withCtx(() => [
                        vue.createTextVNode(vue.toDisplayString(upgradeInfoApp.value.applicationName), 1)
                      ]),
                      _: 1
                    }),
                    vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "当前版本" }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(naiveUi.NTag), {
                          type: "default",
                          size: "small"
                        }, {
                          default: vue.withCtx(() => [
                            vue.createTextVNode(vue.toDisplayString(upgradeInfoApp.value.pluginVersion), 1)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "最新版本" }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(naiveUi.NTag), {
                          type: "success",
                          size: "small"
                        }, {
                          default: vue.withCtx(() => [
                            vue.createTextVNode(vue.toDisplayString(upgradeInfoApp.value.remoteVersion), 1)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "插件ID" }, {
                      default: vue.withCtx(() => [
                        vue.createTextVNode(vue.toDisplayString(upgradeInfoApp.value.pluginId), 1)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                vue.createVNode(vue.unref(naiveUi.NAlert), {
                  type: "warning",
                  "show-icon": false,
                  style: { "margin-top": "16px" }
                }, {
                  default: vue.withCtx(() => [..._cache[64] || (_cache[64] = [
                    vue.createTextVNode(" 升级前请确保已备份重要数据，升级过程中应用将暂时不可用 ", -1)
                  ])]),
                  _: 1
                })
              ])) : vue.createCommentVNode("", true)
            ]),
            _: 1
          }, 8, ["show", "positive-button-props"]),
          vue.createVNode(vue.unref(naiveUi.NModal), {
            show: showUpgradeLogModal.value,
            "onUpdate:show": _cache[22] || (_cache[22] = ($event) => showUpgradeLogModal.value = $event),
            preset: "dialog",
            title: "升级日志",
            style: { width: "720px" },
            "negative-text": "关闭"
          }, {
            default: vue.withCtx(() => [
              upgradeLogsLoading.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_77, [
                vue.createVNode(vue.unref(naiveUi.NSpin), { size: "large" })
              ])) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_78, [
                upgradeLogs.value.length === 0 ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_79, [..._cache[65] || (_cache[65] = [
                  vue.createElementVNode("div", { class: "empty-state__text" }, "暂未查询到升级日志", -1)
                ])])) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_80, [
                  vue.createVNode(vue.unref(naiveUi.NTimeline), null, {
                    default: vue.withCtx(() => [
                      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(upgradeLogs.value, (log2) => {
                        return vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NTimelineItem), {
                          key: log2.id,
                          type: log2.status === "SUCCESS" ? "success" : "error",
                          time: formatDateTime(log2.createTime)
                        }, {
                          header: vue.withCtx(() => [
                            vue.createElementVNode("span", null, [
                              vue.createTextVNode(" 版本 " + vue.toDisplayString(log2.oldVersion || "-") + " → " + vue.toDisplayString(log2.newVersion || "-") + " ", 1),
                              vue.createVNode(vue.unref(naiveUi.NTag), {
                                size: "small",
                                type: log2.status === "SUCCESS" ? "success" : "error",
                                style: { "margin-left": "8px" }
                              }, {
                                default: vue.withCtx(() => [
                                  vue.createTextVNode(vue.toDisplayString(log2.status === "SUCCESS" ? "成功" : "失败"), 1)
                                ]),
                                _: 2
                              }, 1032, ["type"])
                            ])
                          ]),
                          default: vue.withCtx(() => [
                            vue.createElementVNode("div", _hoisted_81, [
                              vue.createElementVNode("div", _hoisted_82, [
                                _cache[66] || (_cache[66] = vue.createElementVNode("span", { class: "meta-label" }, "目标版本：", -1)),
                                vue.createElementVNode("span", _hoisted_83, vue.toDisplayString(log2.targetVersion || "-"), 1)
                              ]),
                              log2.pluginType ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_84, [
                                _cache[67] || (_cache[67] = vue.createElementVNode("span", { class: "meta-label" }, "插件类型：", -1)),
                                vue.createElementVNode("span", _hoisted_85, vue.toDisplayString(log2.pluginType), 1)
                              ])) : vue.createCommentVNode("", true),
                              log2.operatorName ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_86, [
                                _cache[68] || (_cache[68] = vue.createElementVNode("span", { class: "meta-label" }, "操作人：", -1)),
                                vue.createElementVNode("span", _hoisted_87, vue.toDisplayString(log2.operatorName), 1)
                              ])) : vue.createCommentVNode("", true),
                              log2.message ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_88, [
                                _cache[69] || (_cache[69] = vue.createElementVNode("span", { class: "meta-label" }, "说明：", -1)),
                                vue.createElementVNode("span", _hoisted_89, vue.toDisplayString(log2.message), 1)
                              ])) : vue.createCommentVNode("", true)
                            ])
                          ]),
                          _: 2
                        }, 1032, ["type", "time"]);
                      }), 128))
                    ]),
                    _: 1
                  })
                ]))
              ]))
            ]),
            _: 1
          }, 8, ["show"]),
          vue.createVNode(vue.unref(naiveUi.NModal), {
            show: showRollbackModal.value,
            "onUpdate:show": _cache[24] || (_cache[24] = ($event) => showRollbackModal.value = $event),
            preset: "dialog",
            title: "降级应用",
            "positive-text": "确认降级",
            "negative-text": "取消",
            "positive-button-props": { type: "warning", loading: rollbackLoading.value },
            loading: rollbackLoading.value,
            onPositiveClick: confirmRollback
          }, {
            default: vue.withCtx(() => [
              vue.createVNode(vue.unref(naiveUi.NForm), {
                ref_key: "rollbackFormRef",
                ref: rollbackFormRef,
                model: rollbackForm
              }, {
                default: vue.withCtx(() => [
                  vue.createVNode(vue.unref(naiveUi.NFormItem), {
                    label: "选择版本",
                    path: "targetVersion"
                  }, {
                    default: vue.withCtx(() => [
                      vue.createVNode(vue.unref(naiveUi.NSelect), {
                        value: rollbackForm.targetVersion,
                        "onUpdate:value": [
                          _cache[23] || (_cache[23] = ($event) => rollbackForm.targetVersion = $event),
                          handleRollbackVersionChange
                        ],
                        options: rollbackVersionOptions.value,
                        placeholder: "请选择要降级到的版本",
                        loading: rollbackVersionsLoading.value,
                        disabled: rollbackLoading.value
                      }, null, 8, ["value", "options", "loading", "disabled"])
                    ]),
                    _: 1
                  }),
                  rollbackForm.targetVersion && selectedRollbackLog.value ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NFormItem), {
                    key: 0,
                    label: "版本信息"
                  }, {
                    default: vue.withCtx(() => [
                      vue.createVNode(vue.unref(naiveUi.NCard), {
                        size: "small",
                        bordered: true
                      }, {
                        default: vue.withCtx(() => [
                          vue.createVNode(vue.unref(naiveUi.NDescriptions), {
                            column: 1,
                            "label-placement": "left",
                            size: "small"
                          }, {
                            default: vue.withCtx(() => [
                              vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "版本号" }, {
                                default: vue.withCtx(() => [
                                  vue.createTextVNode(vue.toDisplayString(selectedRollbackLog.value.newVersion || "-"), 1)
                                ]),
                                _: 1
                              }),
                              vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "升级时间" }, {
                                default: vue.withCtx(() => [
                                  vue.createTextVNode(vue.toDisplayString(formatDateTime(selectedRollbackLog.value.createTime)), 1)
                                ]),
                                _: 1
                              }),
                              selectedRollbackLog.value.operatorName ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NDescriptionsItem), {
                                key: 0,
                                label: "操作人"
                              }, {
                                default: vue.withCtx(() => [
                                  vue.createTextVNode(vue.toDisplayString(selectedRollbackLog.value.operatorName), 1)
                                ]),
                                _: 1
                              })) : vue.createCommentVNode("", true),
                              selectedRollbackLog.value.message ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NDescriptionsItem), {
                                key: 1,
                                label: "升级说明"
                              }, {
                                default: vue.withCtx(() => [
                                  vue.createTextVNode(vue.toDisplayString(selectedRollbackLog.value.message), 1)
                                ]),
                                _: 1
                              })) : vue.createCommentVNode("", true)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })) : vue.createCommentVNode("", true),
                  vue.createVNode(vue.unref(naiveUi.NAlert), {
                    type: "warning",
                    "show-icon": false,
                    style: { "margin-top": "16px" }
                  }, {
                    header: vue.withCtx(() => [..._cache[70] || (_cache[70] = [
                      vue.createElementVNode("div", { style: { "font-weight": "600" } }, "注意事项", -1)
                    ])]),
                    default: vue.withCtx(() => [
                      _cache[71] || (_cache[71] = vue.createElementVNode("ul", { style: { "margin": "8px 0 0 0", "padding-left": "20px" } }, [
                        vue.createElementVNode("li", null, "降级操作会将应用回滚到指定版本"),
                        vue.createElementVNode("li", null, "降级过程中应用将暂时不可用"),
                        vue.createElementVNode("li", null, "请确保已备份重要数据")
                      ], -1))
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["model"])
            ]),
            _: 1
          }, 8, ["show", "positive-button-props", "loading"]),
          vue.createVNode(vue.unref(naiveUi.NModal), {
            show: showConfigModal.value,
            "onUpdate:show": _cache[31] || (_cache[31] = ($event) => showConfigModal.value = $event),
            preset: "dialog",
            title: "应用配置",
            "positive-text": "保存",
            "negative-text": "取消",
            "positive-button-props": { loading: configLoading.value },
            loading: configLoading.value,
            style: { width: "900px" },
            onPositiveClick: confirmConfig
          }, {
            default: vue.withCtx(() => [
              vue.createVNode(vue.unref(naiveUi.NScrollbar), { style: { "max-height": "70vh" } }, {
                default: vue.withCtx(() => [
                  vue.createVNode(vue.unref(naiveUi.NSpin), { show: configMetadataLoading.value }, {
                    default: vue.withCtx(() => [
                      vue.createElementVNode("div", _hoisted_90, [
                        vue.createVNode(vue.unref(naiveUi.NCard), {
                          size: "small",
                          bordered: false,
                          class: "app-info-card"
                        }, {
                          default: vue.withCtx(() => {
                            var _a2;
                            return [
                              vue.createElementVNode("div", _hoisted_91, [
                                vue.createElementVNode("div", _hoisted_92, [
                                  _cache[72] || (_cache[72] = vue.createElementVNode("span", { class: "info-label" }, "应用名称：", -1)),
                                  vue.createElementVNode("span", _hoisted_93, vue.toDisplayString((_a2 = configTargetApp.value) == null ? void 0 : _a2.applicationName), 1)
                                ]),
                                vue.createElementVNode("div", _hoisted_94, [
                                  _cache[73] || (_cache[73] = vue.createElementVNode("span", { class: "info-label" }, "应用代码：", -1)),
                                  vue.createVNode(vue.unref(naiveUi.NText), {
                                    type: "info",
                                    class: "info-value"
                                  }, {
                                    default: vue.withCtx(() => {
                                      var _a3;
                                      return [
                                        vue.createTextVNode(vue.toDisplayString((_a3 = configTargetApp.value) == null ? void 0 : _a3.applicationCode), 1)
                                      ];
                                    }),
                                    _: 1
                                  })
                                ])
                              ])
                            ];
                          }),
                          _: 1
                        }),
                        configMetadata.value.length > 0 ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NCard), {
                          key: 0,
                          size: "small",
                          title: "扩展配置",
                          bordered: false,
                          class: "config-section"
                        }, {
                          default: vue.withCtx(() => [
                            vue.createVNode(_component_DynamicFormRenderer, {
                              modelValue: configForm.extensionConfig,
                              "onUpdate:modelValue": _cache[25] || (_cache[25] = ($event) => configForm.extensionConfig = $event),
                              metadata: { fields: configMetadata.value }
                            }, null, 8, ["modelValue", "metadata"])
                          ]),
                          _: 1
                        })) : vue.createCommentVNode("", true),
                        vue.createVNode(vue.unref(naiveUi.NCollapse), {
                          "default-expanded-names": configMetadata.value.length === 0 ? ["advanced"] : [],
                          class: "config-section"
                        }, {
                          default: vue.withCtx(() => [
                            vue.createVNode(vue.unref(naiveUi.NCollapseItem), {
                              title: "高级配置",
                              name: "advanced"
                            }, {
                              default: vue.withCtx(() => [
                                vue.createVNode(vue.unref(naiveUi.NForm), {
                                  ref_key: "configFormRef",
                                  ref: configFormRef,
                                  model: configForm,
                                  "label-placement": "left",
                                  "label-width": "100",
                                  size: "small"
                                }, {
                                  default: vue.withCtx(() => [
                                    vue.createElementVNode("div", _hoisted_95, [
                                      vue.createVNode(vue.unref(naiveUi.NFormItem), {
                                        label: "自动加载",
                                        path: "autoLoad"
                                      }, {
                                        default: vue.withCtx(() => [
                                          vue.createVNode(vue.unref(naiveUi.NSwitch), {
                                            value: configForm.autoLoad,
                                            "onUpdate:value": _cache[26] || (_cache[26] = ($event) => configForm.autoLoad = $event),
                                            disabled: configLoading.value,
                                            size: "small"
                                          }, {
                                            checked: vue.withCtx(() => [..._cache[74] || (_cache[74] = [
                                              vue.createTextVNode("开启", -1)
                                            ])]),
                                            unchecked: vue.withCtx(() => [..._cache[75] || (_cache[75] = [
                                              vue.createTextVNode("关闭", -1)
                                            ])]),
                                            _: 1
                                          }, 8, ["value", "disabled"])
                                        ]),
                                        _: 1
                                      }),
                                      vue.createVNode(vue.unref(naiveUi.NFormItem), {
                                        label: "启动时加载",
                                        path: "loadOnStartup"
                                      }, {
                                        default: vue.withCtx(() => [
                                          vue.createVNode(vue.unref(naiveUi.NSwitch), {
                                            value: configForm.loadOnStartup,
                                            "onUpdate:value": _cache[27] || (_cache[27] = ($event) => configForm.loadOnStartup = $event),
                                            disabled: configLoading.value || !configForm.autoLoad,
                                            size: "small"
                                          }, {
                                            checked: vue.withCtx(() => [..._cache[76] || (_cache[76] = [
                                              vue.createTextVNode("开启", -1)
                                            ])]),
                                            unchecked: vue.withCtx(() => [..._cache[77] || (_cache[77] = [
                                              vue.createTextVNode("关闭", -1)
                                            ])]),
                                            _: 1
                                          }, 8, ["value", "disabled"])
                                        ]),
                                        _: 1
                                      }),
                                      vue.createVNode(vue.unref(naiveUi.NFormItem), {
                                        label: "启动优先级",
                                        path: "startPriority"
                                      }, {
                                        default: vue.withCtx(() => [
                                          vue.createVNode(vue.unref(naiveUi.NInputNumber), {
                                            value: configForm.startPriority,
                                            "onUpdate:value": _cache[28] || (_cache[28] = ($event) => configForm.startPriority = $event),
                                            min: 0,
                                            max: 100,
                                            disabled: configLoading.value || !configForm.autoLoad,
                                            size: "small",
                                            style: { "width": "120px" }
                                          }, null, 8, ["value", "disabled"])
                                        ]),
                                        _: 1
                                      }),
                                      vue.createVNode(vue.unref(naiveUi.NFormItem), {
                                        label: "启动延迟(ms)",
                                        path: "startDelay"
                                      }, {
                                        default: vue.withCtx(() => [
                                          vue.createVNode(vue.unref(naiveUi.NInputNumber), {
                                            value: configForm.startDelay,
                                            "onUpdate:value": _cache[29] || (_cache[29] = ($event) => configForm.startDelay = $event),
                                            min: 0,
                                            max: 6e4,
                                            step: 1e3,
                                            disabled: configLoading.value || !configForm.autoLoad,
                                            size: "small",
                                            style: { "width": "120px" }
                                          }, null, 8, ["value", "disabled"])
                                        ]),
                                        _: 1
                                      })
                                    ]),
                                    vue.createVNode(vue.unref(naiveUi.NFormItem), {
                                      label: "配置描述",
                                      path: "description"
                                    }, {
                                      default: vue.withCtx(() => [
                                        vue.createVNode(vue.unref(naiveUi.NInput), {
                                          value: configForm.description,
                                          "onUpdate:value": _cache[30] || (_cache[30] = ($event) => configForm.description = $event),
                                          type: "textarea",
                                          placeholder: "可选，描述此配置的用途",
                                          rows: 2,
                                          disabled: configLoading.value,
                                          size: "small"
                                        }, null, 8, ["value", "disabled"])
                                      ]),
                                      _: 1
                                    }),
                                    vue.createVNode(vue.unref(naiveUi.NAlert), {
                                      type: "info",
                                      "show-icon": false,
                                      size: "small",
                                      style: { "margin-top": "12px" }
                                    }, {
                                      default: vue.withCtx(() => [..._cache[78] || (_cache[78] = [
                                        vue.createElementVNode("ul", { style: { "margin": "0", "padding-left": "20px", "font-size": "12px", "line-height": "1.6" } }, [
                                          vue.createElementVNode("li", null, "自动加载：系统启动时是否自动加载该插件"),
                                          vue.createElementVNode("li", null, "启动时加载：插件加载后是否立即启动"),
                                          vue.createElementVNode("li", null, "启动优先级：数值越大越先启动（0-100）"),
                                          vue.createElementVNode("li", null, "启动延迟：应用启动前的等待时间")
                                        ], -1)
                                      ])]),
                                      _: 1
                                    })
                                  ]),
                                  _: 1
                                }, 8, ["model"])
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        }, 8, ["default-expanded-names"])
                      ])
                    ]),
                    _: 1
                  }, 8, ["show"])
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["show", "positive-button-props", "loading"]),
          vue.createVNode(vue.unref(naiveUi.NModal), {
            show: showUploadModal.value,
            "onUpdate:show": _cache[32] || (_cache[32] = ($event) => showUploadModal.value = $event),
            preset: "dialog",
            title: "上传应用包",
            "positive-text": "确认安装",
            "negative-text": "取消",
            "positive-button-props": { disabled: !uploadFile.value, loading: uploading.value },
            loading: uploading.value,
            onPositiveClick: confirmUpload
          }, {
            default: vue.withCtx(() => [
              vue.createVNode(vue.unref(naiveUi.NForm), {
                ref_key: "uploadFormRef",
                ref: uploadFormRef,
                model: uploadForm
              }, {
                default: vue.withCtx(() => [
                  vue.createVNode(vue.unref(naiveUi.NFormItem), { label: "应用包文件" }, {
                    default: vue.withCtx(() => [
                      vue.createVNode(vue.unref(naiveUi.NUpload), {
                        ref_key: "uploadRef",
                        ref: uploadRef,
                        max: 1,
                        "default-upload": false,
                        accept: ".jar",
                        disabled: uploading.value,
                        onChange: handleFileChange
                      }, {
                        default: vue.withCtx(() => [
                          vue.createVNode(vue.unref(naiveUi.NUploadDragger), null, {
                            default: vue.withCtx(() => [
                              vue.createElementVNode("div", _hoisted_96, [
                                vue.createVNode(vue.unref(naiveUi.NIcon), {
                                  size: "48",
                                  depth: 3
                                }, {
                                  default: vue.withCtx(() => [
                                    (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(CloudUploadOutline))))
                                  ]),
                                  _: 1
                                })
                              ]),
                              vue.createVNode(vue.unref(naiveUi.NText), { style: { "font-size": "16px" } }, {
                                default: vue.withCtx(() => [..._cache[79] || (_cache[79] = [
                                  vue.createTextVNode(" 点击或拖拽文件到此区域上传 ", -1)
                                ])]),
                                _: 1
                              }),
                              vue.createVNode(vue.unref(naiveUi.NP), {
                                depth: "3",
                                style: { "margin": "8px 0 0 0" }
                              }, {
                                default: vue.withCtx(() => [..._cache[80] || (_cache[80] = [
                                  vue.createTextVNode(" 仅支持 .jar 格式的应用包文件 ", -1)
                                ])]),
                                _: 1
                              })
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }, 8, ["disabled"])
                    ]),
                    _: 1
                  }),
                  uploadFile.value ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NAlert), {
                    key: 0,
                    type: "info",
                    "show-icon": false,
                    style: { "margin-top": "16px" }
                  }, {
                    header: vue.withCtx(() => [..._cache[81] || (_cache[81] = [
                      vue.createElementVNode("div", { style: { "font-weight": "600" } }, "已选择文件", -1)
                    ])]),
                    default: vue.withCtx(() => {
                      var _a2;
                      return [
                        vue.createElementVNode("div", _hoisted_97, [
                          vue.createElementVNode("div", null, [
                            _cache[82] || (_cache[82] = vue.createElementVNode("strong", null, "文件名：", -1)),
                            vue.createTextVNode(vue.toDisplayString(uploadFile.value.name), 1)
                          ]),
                          vue.createElementVNode("div", null, [
                            _cache[83] || (_cache[83] = vue.createElementVNode("strong", null, "大小：", -1)),
                            vue.createTextVNode(vue.toDisplayString(formatFileSize(((_a2 = uploadFile.value.file) == null ? void 0 : _a2.size) || 0)), 1)
                          ])
                        ])
                      ];
                    }),
                    _: 1
                  })) : vue.createCommentVNode("", true),
                  vue.createVNode(vue.unref(naiveUi.NAlert), {
                    type: "warning",
                    "show-icon": false,
                    style: { "margin-top": "16px" }
                  }, {
                    header: vue.withCtx(() => [..._cache[84] || (_cache[84] = [
                      vue.createElementVNode("div", { style: { "font-weight": "600" } }, "注意事项", -1)
                    ])]),
                    default: vue.withCtx(() => [
                      _cache[85] || (_cache[85] = vue.createElementVNode("ul", { style: { "margin": "8px 0 0 0", "padding-left": "20px" } }, [
                        vue.createElementVNode("li", null, "请确保上传的是有效的应用包文件"),
                        vue.createElementVNode("li", null, "安装过程中请勿关闭页面"),
                        vue.createElementVNode("li", null, "安装完成后应用将自动启用")
                      ], -1))
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["model"])
            ]),
            _: 1
          }, 8, ["show", "positive-button-props", "loading"])
        ]);
      };
    }
  });
  const _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key2, val] of props) {
      target[key2] = val;
    }
    return target;
  };
  const ApplicationManagement = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-6096b87c"]]);
  const _hoisted_1$5 = { class: "operation-log-page" };
  const _hoisted_2$5 = { class: "page-header-wrapper" };
  const _hoisted_3$5 = { class: "page-content" };
  const _hoisted_4$3 = { class: "table-container" };
  const _hoisted_5$2 = { class: "pagination-container" };
  const _hoisted_6$2 = {
    key: 0,
    class: "log-detail"
  };
  const _hoisted_7$1 = { class: "config-diff" };
  const _hoisted_8$1 = { class: "config-column" };
  const _hoisted_9$1 = {
    key: 1,
    class: "empty-config"
  };
  const _hoisted_10$1 = { class: "config-column" };
  const _hoisted_11$1 = {
    key: 1,
    class: "empty-config"
  };
  const _sfc_main$5 = /* @__PURE__ */ vue.defineComponent({
    __name: "OperationLog",
    setup(__props) {
      const Refresh = useIcon("RefreshOutline");
      const Eye = useIcon("EyeOutline");
      const CheckmarkCircle = useIcon("CheckmarkCircleOutline");
      const CloseCircle = useIcon("CloseCircleOutline");
      const message = useMessage();
      const loading = vue.ref(false);
      const refreshLoading = vue.ref(false);
      const tableData = vue.ref([]);
      const showDetailDrawer = vue.ref(false);
      const currentLog = vue.ref(null);
      const showAdvanced = vue.ref(false);
      const filters = vue.ref({
        operationType: null,
        status: null,
        applicationName: "",
        operatorName: ""
      });
      const pagination = vue.reactive({
        page: 1,
        pageSize: 10,
        itemCount: 0,
        pageSizes: [10, 20, 50, 100]
      });
      const handlePageChange = (page) => {
        pagination.page = page;
        loadData();
      };
      const handlePageSizeChange = (pageSize) => {
        pagination.pageSize = pageSize;
        pagination.page = 1;
        loadData();
      };
      const basicFields = [
        {
          key: "applicationName",
          label: "应用名称",
          type: "input",
          placeholder: "搜索应用名称"
        },
        {
          key: "operationType",
          label: "操作类型",
          type: "select",
          placeholder: "请选择操作类型",
          options: [
            { label: "全部", value: null },
            { label: "启动", value: "START" },
            { label: "停止", value: "STOP" },
            { label: "重启", value: "RESTART" },
            { label: "安装", value: "INSTALL" },
            { label: "卸载", value: "UNINSTALL" },
            { label: "升级", value: "UPGRADE" },
            { label: "降级", value: "ROLLBACK" },
            { label: "配置更新", value: "CONFIG_UPDATE" }
          ]
        },
        {
          key: "status",
          label: "操作结果",
          type: "select",
          placeholder: "请选择操作结果",
          options: [
            { label: "全部", value: null },
            { label: "成功", value: "SUCCESS" },
            { label: "失败", value: "FAIL" }
          ]
        },
        {
          key: "operatorName",
          label: "操作人",
          type: "input",
          placeholder: "搜索操作人"
        }
      ];
      const advancedFields = [];
      const columns = [
        {
          title: "ID",
          key: "id",
          width: 80
        },
        {
          title: "应用名称",
          key: "applicationName",
          width: 150,
          ellipsis: {
            tooltip: true
          }
        },
        {
          title: "操作类型",
          key: "operationType",
          width: 120,
          render: (row) => vue.h(
            naiveUi.NTag,
            {
              type: getOperationTypeColor(row.operationType),
              size: "small"
            },
            { default: () => row.operationTypeText }
          )
        },
        {
          title: "操作描述",
          key: "operationDesc",
          width: 200,
          ellipsis: {
            tooltip: true
          }
        },
        {
          title: "操作人",
          key: "operatorName",
          width: 120,
          ellipsis: {
            tooltip: true
          },
          render: (row) => row.operatorName || row.operatorId
        },
        {
          title: "结果",
          key: "status",
          width: 80,
          render: (row) => vue.h(
            naiveUi.NTag,
            {
              type: row.status === "SUCCESS" ? "success" : "error",
              size: "small"
            },
            {
              default: () => row.statusText,
              icon: () => vue.h(naiveUi.NIcon, {
                component: row.status === "SUCCESS" ? CheckmarkCircle : CloseCircle
              })
            }
          )
        },
        {
          title: "耗时",
          key: "duration",
          width: 100,
          render: (row) => row.duration ? `${row.duration} ms` : "-"
        },
        {
          title: "操作时间",
          key: "createTime",
          width: 180,
          render: (row) => formatDateTime(row.createTime)
        },
        {
          title: "操作",
          key: "actions",
          width: 100,
          fixed: "right",
          render: (row) => vue.h(
            naiveUi.NButton,
            {
              size: "small",
              onClick: () => handleViewDetail(row)
            },
            {
              default: () => "查看详情",
              icon: () => vue.h(naiveUi.NIcon, { component: Eye })
            }
          )
        }
      ];
      const loadData = async () => {
        loading.value = true;
        refreshLoading.value = true;
        try {
          const params = {
            page: pagination.page,
            size: pagination.pageSize
          };
          if (filters.value.operationType) {
            params.operationType = filters.value.operationType;
          }
          if (filters.value.status) {
            params.status = filters.value.status;
          }
          if (filters.value.applicationName && filters.value.applicationName.trim()) {
            params.applicationName = filters.value.applicationName.trim();
          }
          if (filters.value.operatorName && filters.value.operatorName.trim()) {
            params.operatorName = filters.value.operatorName.trim();
          }
          const response = await applicationApi.getAllOperationLogs(params);
          if (response) {
            tableData.value = response.items;
            pagination.itemCount = response.total;
          } else {
            message.error("加载操作日志失败");
          }
        } finally {
          loading.value = false;
          refreshLoading.value = false;
        }
      };
      const handleSearch = () => {
        pagination.page = 1;
        loadData();
      };
      const handleReset = () => {
        filters.value.operationType = null;
        filters.value.status = null;
        filters.value.applicationName = "";
        filters.value.operatorName = "";
        pagination.page = 1;
        loadData();
      };
      const handleViewDetail = (log2) => {
        currentLog.value = log2;
        showDetailDrawer.value = true;
      };
      const getOperationTypeColor = (type) => {
        if (type === "START" || type === "INSTALL" || type === "UPGRADE") {
          return "success";
        }
        if (type === "STOP" || type === "UNINSTALL" || type === "ROLLBACK") {
          return "error";
        }
        if (type === "RESTART" || type === "CONFIG_UPDATE") {
          return "info";
        }
        return "default";
      };
      const formatDateTime = (dateTime) => {
        if (!dateTime) return "-";
        const date = new Date(dateTime);
        return date.toLocaleString("zh-CN", {
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit"
        });
      };
      const formatJson = (jsonStr) => {
        try {
          const obj = typeof jsonStr === "string" ? JSON.parse(jsonStr) : jsonStr;
          return JSON.stringify(obj, null, 2);
        } catch (e2) {
          return jsonStr;
        }
      };
      vue.onMounted(() => {
        loadData();
      });
      return (_ctx, _cache) => {
        const _component_PageHeader = vue.resolveComponent("PageHeader");
        const _component_FilterPanel = vue.resolveComponent("FilterPanel");
        return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$5, [
          vue.createElementVNode("div", _hoisted_2$5, [
            vue.createVNode(_component_PageHeader, {
              title: "操作日志",
              subtitle: "查看所有应用操作记录，追踪应用变更"
            }, {
              actions: vue.withCtx(() => [
                vue.createVNode(vue.unref(naiveUi.NButton), {
                  onClick: loadData,
                  loading: refreshLoading.value
                }, {
                  icon: vue.withCtx(() => [
                    vue.createVNode(vue.unref(naiveUi.NIcon), null, {
                      default: vue.withCtx(() => [
                        (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(Refresh))))
                      ]),
                      _: 1
                    })
                  ]),
                  default: vue.withCtx(() => [
                    _cache[6] || (_cache[6] = vue.createTextVNode(" 刷新 ", -1))
                  ]),
                  _: 1
                }, 8, ["loading"])
              ]),
              _: 1
            })
          ]),
          vue.createElementVNode("div", _hoisted_3$5, [
            vue.createVNode(_component_FilterPanel, {
              filters: filters.value,
              "onUpdate:filters": _cache[0] || (_cache[0] = ($event) => filters.value = $event),
              "show-advanced": showAdvanced.value,
              "onUpdate:showAdvanced": _cache[1] || (_cache[1] = ($event) => showAdvanced.value = $event),
              "basic-fields": basicFields,
              "advanced-fields": advancedFields,
              onSearch: handleSearch,
              onReset: handleReset
            }, null, 8, ["filters", "show-advanced"]),
            vue.createElementVNode("div", _hoisted_4$3, [
              vue.createVNode(vue.unref(naiveUi.NDataTable), {
                columns,
                data: tableData.value,
                loading: loading.value,
                pagination: false,
                "row-key": (row) => row.id,
                striped: ""
              }, null, 8, ["data", "loading", "row-key"]),
              vue.createElementVNode("div", _hoisted_5$2, [
                vue.createVNode(vue.unref(naiveUi.NPagination), {
                  page: pagination.page,
                  "onUpdate:page": [
                    _cache[2] || (_cache[2] = ($event) => pagination.page = $event),
                    handlePageChange
                  ],
                  "page-size": pagination.pageSize,
                  "onUpdate:pageSize": [
                    _cache[3] || (_cache[3] = ($event) => pagination.pageSize = $event),
                    handlePageSizeChange
                  ],
                  "item-count": pagination.itemCount,
                  "page-sizes": pagination.pageSizes,
                  "show-size-picker": "",
                  "show-quick-jumper": ""
                }, {
                  prefix: vue.withCtx(({ itemCount }) => [
                    vue.createTextVNode(" 共 " + vue.toDisplayString(itemCount) + " 条 ", 1)
                  ]),
                  _: 1
                }, 8, ["page", "page-size", "item-count", "page-sizes"])
              ])
            ])
          ]),
          vue.createVNode(vue.unref(naiveUi.NDrawer), {
            show: showDetailDrawer.value,
            "onUpdate:show": _cache[5] || (_cache[5] = ($event) => showDetailDrawer.value = $event),
            width: 720,
            placement: "right"
          }, {
            default: vue.withCtx(() => [
              vue.createVNode(vue.unref(naiveUi.NDrawerContent), {
                title: "操作日志详情",
                closable: ""
              }, {
                footer: vue.withCtx(() => [
                  vue.createVNode(vue.unref(naiveUi.NSpace), { justify: "end" }, {
                    default: vue.withCtx(() => [
                      vue.createVNode(vue.unref(naiveUi.NButton), {
                        onClick: _cache[4] || (_cache[4] = ($event) => showDetailDrawer.value = false)
                      }, {
                        default: vue.withCtx(() => [..._cache[9] || (_cache[9] = [
                          vue.createTextVNode("关闭", -1)
                        ])]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                default: vue.withCtx(() => [
                  currentLog.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_6$2, [
                    vue.createVNode(vue.unref(naiveUi.NCard), {
                      title: "基本信息",
                      bordered: false,
                      class: "detail-section"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(naiveUi.NDescriptions), {
                          column: 2,
                          "label-placement": "left"
                        }, {
                          default: vue.withCtx(() => [
                            vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "日志ID" }, {
                              default: vue.withCtx(() => [
                                vue.createTextVNode(vue.toDisplayString(currentLog.value.id), 1)
                              ]),
                              _: 1
                            }),
                            vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "操作时间" }, {
                              default: vue.withCtx(() => [
                                vue.createTextVNode(vue.toDisplayString(formatDateTime(currentLog.value.createTime)), 1)
                              ]),
                              _: 1
                            }),
                            vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "应用名称" }, {
                              default: vue.withCtx(() => [
                                vue.createTextVNode(vue.toDisplayString(currentLog.value.applicationName), 1)
                              ]),
                              _: 1
                            }),
                            vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "操作类型" }, {
                              default: vue.withCtx(() => [
                                vue.createVNode(vue.unref(naiveUi.NTag), {
                                  type: getOperationTypeColor(currentLog.value.operationType),
                                  size: "small"
                                }, {
                                  default: vue.withCtx(() => [
                                    vue.createTextVNode(vue.toDisplayString(currentLog.value.operationTypeText), 1)
                                  ]),
                                  _: 1
                                }, 8, ["type"])
                              ]),
                              _: 1
                            }),
                            vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), {
                              label: "操作结果",
                              span: 2
                            }, {
                              default: vue.withCtx(() => [
                                vue.createVNode(vue.unref(naiveUi.NTag), {
                                  type: currentLog.value.status === "SUCCESS" ? "success" : "error",
                                  size: "small"
                                }, {
                                  default: vue.withCtx(() => [
                                    vue.createTextVNode(vue.toDisplayString(currentLog.value.statusText), 1)
                                  ]),
                                  _: 1
                                }, 8, ["type"])
                              ]),
                              _: 1
                            }),
                            currentLog.value.duration ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NDescriptionsItem), {
                              key: 0,
                              label: "耗时",
                              span: 2
                            }, {
                              default: vue.withCtx(() => [
                                vue.createTextVNode(vue.toDisplayString(currentLog.value.duration) + " ms ", 1)
                              ]),
                              _: 1
                            })) : vue.createCommentVNode("", true)
                          ]),
                          _: 1
                        }),
                        currentLog.value.operationDesc ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
                          vue.createVNode(vue.unref(naiveUi.NDivider)),
                          vue.createVNode(vue.unref(naiveUi.NDescriptions), {
                            column: 1,
                            "label-placement": "left"
                          }, {
                            default: vue.withCtx(() => [
                              vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "操作描述" }, {
                                default: vue.withCtx(() => [
                                  vue.createTextVNode(vue.toDisplayString(currentLog.value.operationDesc), 1)
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          })
                        ], 64)) : vue.createCommentVNode("", true)
                      ]),
                      _: 1
                    }),
                    vue.createVNode(vue.unref(naiveUi.NCard), {
                      title: "操作人信息",
                      bordered: false,
                      class: "detail-section"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(naiveUi.NDescriptions), {
                          column: 2,
                          "label-placement": "left"
                        }, {
                          default: vue.withCtx(() => [
                            vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "操作人ID" }, {
                              default: vue.withCtx(() => [
                                vue.createTextVNode(vue.toDisplayString(currentLog.value.operatorId), 1)
                              ]),
                              _: 1
                            }),
                            vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "操作人名称" }, {
                              default: vue.withCtx(() => [
                                vue.createTextVNode(vue.toDisplayString(currentLog.value.operatorName || "-"), 1)
                              ]),
                              _: 1
                            }),
                            vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), {
                              label: "操作IP",
                              span: 2
                            }, {
                              default: vue.withCtx(() => [
                                vue.createTextVNode(vue.toDisplayString(currentLog.value.clientIp || "-"), 1)
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    currentLog.value.status === "FAIL" && currentLog.value.message ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NCard), {
                      key: 0,
                      title: "错误信息",
                      bordered: false,
                      class: "detail-section"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(naiveUi.NAlert), {
                          type: "error",
                          "show-icon": false
                        }, {
                          default: vue.withCtx(() => [
                            vue.createTextVNode(vue.toDisplayString(currentLog.value.message), 1)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })) : vue.createCommentVNode("", true),
                    currentLog.value.operationType === "CONFIG_UPDATE" && (currentLog.value.beforeData || currentLog.value.afterData) ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NCard), {
                      key: 1,
                      title: "配置变更",
                      bordered: false,
                      class: "detail-section"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createElementVNode("div", _hoisted_7$1, [
                          vue.createElementVNode("div", _hoisted_8$1, [
                            _cache[7] || (_cache[7] = vue.createElementVNode("div", { class: "config-header" }, "变更前", -1)),
                            currentLog.value.beforeData ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NCode), {
                              key: 0,
                              code: formatJson(currentLog.value.beforeData),
                              language: "json",
                              "word-wrap": true
                            }, null, 8, ["code"])) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_9$1, "无数据"))
                          ]),
                          vue.createElementVNode("div", _hoisted_10$1, [
                            _cache[8] || (_cache[8] = vue.createElementVNode("div", { class: "config-header" }, "变更后", -1)),
                            currentLog.value.afterData ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NCode), {
                              key: 0,
                              code: formatJson(currentLog.value.afterData),
                              language: "json",
                              "word-wrap": true
                            }, null, 8, ["code"])) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_11$1, "无数据"))
                          ])
                        ])
                      ]),
                      _: 1
                    })) : vue.createCommentVNode("", true)
                  ])) : vue.createCommentVNode("", true)
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["show"])
        ]);
      };
    }
  });
  const OperationLog = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-1f12c0f3"]]);
  const API_BASE$2 = "/plugins/appstore";
  const middlewareApi = {
    list() {
      return http.get(`${API_BASE$2}/middlewares`);
    },
    health(middlewareId) {
      return http.get(`${API_BASE$2}/middlewares/${middlewareId}/health`);
    },
    uninstall(middlewareId, operatorName = "admin") {
      return http.post(`${API_BASE$2}/middlewares/${middlewareId}/uninstall`, { operatorName });
    },
    /**
     * 获取远程中间件列表（分页）
     */
    getRemoteList(params) {
      return http.get(`${API_BASE$2}/middlewares/remote`, params);
    },
    /**
     * 从远程应用商店安装中间件
     */
    installRemote(pluginId, operatorName = "admin", opts) {
      const params = new URLSearchParams({ pluginId, operatorName });
      if (opts == null ? void 0 : opts.targetNodeId) params.set("targetNodeId", opts.targetNodeId);
      if (opts == null ? void 0 : opts.executionType) params.set("executionType", opts.executionType);
      return http.post(`${API_BASE$2}/middlewares/remote/install?${params.toString()}`);
    },
    /**
     * 从远程应用商店安装中间件（配合 SSE 显示日志）
     * 注意：主应用会自动在请求中注入 X-Client-Id / X-Namespace，无需前端手动传递
     */
    async installRemoteStream(pluginId, opts) {
      const params = new URLSearchParams({ pluginId, operatorName: "admin" });
      if (opts == null ? void 0 : opts.targetNodeId) params.set("targetNodeId", opts.targetNodeId);
      if (opts == null ? void 0 : opts.executionType) params.set("executionType", opts.executionType);
      await http.post(
        `${API_BASE$2}/middlewares/remote/install?${params.toString()}`,
        (opts == null ? void 0 : opts.config) || {}
      );
    },
    /**
     * 上传并安装中间件插件包
     * 注意：使用原生 fetch API，因为 GressBridge 不支持 FormData
     */
    async uploadAndInstall(formData) {
      const response = await fetch(`/api/${API_BASE$2}/middlewares/upload`, {
        method: "POST",
        body: formData,
        credentials: "include"
      });
      const result = await response.json().catch(() => ({
        success: false,
        errorMessage: "解析响应失败"
      }));
      if (result.success === false) {
        throw new Error(result.errorMessage || "上传失败");
      }
      if (!response.ok) {
        throw new Error(result.errorMessage || `HTTP ${response.status}`);
      }
      return result.data;
    },
    /**
     * 获取中间件连接信息
     */
    getConnectionInfo(middlewareId) {
      return http.get(`${API_BASE$2}/middlewares/${middlewareId}/connection-info`);
    },
    /**
     * 获取中间件连接信息（文本格式）
     */
    getConnectionInfoText(middlewareId) {
      return http.get(`${API_BASE$2}/middlewares/${middlewareId}/connection-info/text`);
    },
    /**
     * 获取中间件插件配置元数据（用于动态表单渲染）
     */
    getConfigMetadata(pluginId) {
      return http.get(`${API_BASE$2}/middlewares/remote/${pluginId}/config/metadata`);
    },
    /**
     * 列出所有中间件服务
     */
    listServices() {
      return http.get(`${API_BASE$2}/middlewares/services`);
    },
    /**
     * 获取单个服务信息
     */
    getService(serviceId) {
      return http.get(`${API_BASE$2}/middlewares/services/${serviceId}`);
    },
    /**
     * 手动注册中间件服务
     */
    registerService(serviceInfo) {
      return http.post(`${API_BASE$2}/middlewares/services`, serviceInfo);
    },
    /**
     * 更新中间件服务信息
     */
    updateService(serviceId, serviceInfo) {
      return http.put(`${API_BASE$2}/middlewares/services/${serviceId}`, serviceInfo);
    },
    /**
     * 删除中间件服务
     */
    deleteService(serviceId) {
      return http.delete(`${API_BASE$2}/middlewares/services/${serviceId}`);
    }
  };
  const API_BASE$1 = "/plugins/appstore";
  const nodesApi = {
    list() {
      return http.get(`${API_BASE$1}/nodes`);
    },
    get(nodeId) {
      return http.get(`${API_BASE$1}/nodes/${nodeId}`);
    },
    save(node) {
      return http.post(`${API_BASE$1}/nodes`, node);
    },
    delete(nodeId) {
      return http.delete(`${API_BASE$1}/nodes/${nodeId}`);
    },
    test(nodeId) {
      return http.post(`${API_BASE$1}/nodes/${nodeId}/test`);
    }
  };
  const _hoisted_1$4 = { class: "middleware-management-page" };
  const _hoisted_2$4 = { class: "page-content" };
  const _hoisted_3$4 = {
    key: 0,
    class: "loading-state"
  };
  const _hoisted_4$2 = {
    key: 1,
    class: "empty-state"
  };
  const _hoisted_5$1 = { class: "empty-state__icon" };
  const _hoisted_6$1 = { class: "empty-state__text" };
  const _hoisted_7 = {
    key: 2,
    class: "middleware-list"
  };
  const _hoisted_8 = { class: "middleware-header" };
  const _hoisted_9 = { class: "middleware-icon" };
  const _hoisted_10 = { class: "middleware-info" };
  const _hoisted_11 = { class: "middleware-name" };
  const _hoisted_12 = { class: "middleware-id" };
  const _hoisted_13 = { class: "middleware-status" };
  const _hoisted_14 = { class: "middleware-body" };
  const _hoisted_15 = { class: "middleware-meta" };
  const _hoisted_16 = { class: "meta-item" };
  const _hoisted_17 = { class: "meta-value" };
  const _hoisted_18 = {
    key: 0,
    class: "meta-item"
  };
  const _hoisted_19 = { class: "meta-value" };
  const _hoisted_20 = {
    key: 1,
    class: "meta-item"
  };
  const _hoisted_21 = { class: "meta-value" };
  const _hoisted_22 = {
    key: 0,
    class: "middleware-description"
  };
  const _hoisted_23 = { class: "middleware-footer" };
  const _hoisted_24 = { class: "middleware-actions" };
  const _hoisted_25 = {
    key: 3,
    class: "pagination"
  };
  const _hoisted_26 = { style: { "display": "flex", "justify-content": "space-between", "align-items": "center" } };
  const _hoisted_27 = { class: "install-drawer__body" };
  const _hoisted_28 = { style: { "display": "flex", "justify-content": "space-between", "align-items": "center" } };
  const _hoisted_29 = { class: "install-drawer__logs" };
  const _hoisted_30 = { key: 1 };
  const _hoisted_31 = { class: "config-modal-content" };
  const _hoisted_32 = { class: "app-info-row" };
  const _hoisted_33 = { class: "app-info-item" };
  const _hoisted_34 = { class: "info-value" };
  const _hoisted_35 = { class: "app-info-item" };
  const _hoisted_36 = { style: { "display": "flex", "justify-content": "space-between", "align-items": "center" } };
  const _hoisted_37 = {
    key: 0,
    style: { "text-align": "center", "color": "#999", "padding": "20px" }
  };
  const _sfc_main$4 = /* @__PURE__ */ vue.defineComponent({
    __name: "MiddlewareManagement",
    setup(__props) {
      const message = naiveUi.useMessage();
      const dialog = naiveUi.useDialog();
      const Refresh = useIcon("RefreshOutline");
      const CloudUploadOutline = useIcon("CloudUploadOutline");
      const PulseOutline = useIcon("PulseOutline");
      const TrashOutline = useIcon("TrashOutline");
      const ServerOutline = useIcon("ServerOutline");
      const SearchOutline = useIcon("SearchOutline");
      const CopyOutline = useIcon("CopyOutline");
      const AddOutline = useIcon("AddOutline");
      const EditOutline = useIcon("CreateOutline");
      const activeTab = vue.ref("local");
      const localLoading = vue.ref(false);
      const refreshLoading = vue.ref(false);
      const uploadLoading = vue.ref(false);
      const localTableData = vue.ref([]);
      const remoteLoading = vue.ref(false);
      const remoteTableData = vue.ref([]);
      const remoteFilters = vue.ref({
        keyword: ""
      });
      const installRemoteLoading = vue.ref({});
      const upgradeRemoteLoading = vue.ref({});
      const showInstallDrawer = vue.ref(false);
      const installLogs = vue.ref([]);
      const currentInstallPluginId = vue.ref(null);
      let installSseUnsubscribe = null;
      const installStepProgress = vue.ref({
        currentStep: 0,
        totalSteps: 0,
        stepName: "",
        percentage: 0,
        status: "info"
      });
      const nodesLoading = vue.ref(false);
      const nodes = vue.ref([]);
      const selectedNodeId = vue.ref("__local__");
      const showConfigDialog = vue.ref(false);
      vue.ref(null);
      const configFormData = vue.ref({});
      const configMetadata = vue.ref([]);
      const configMetadataLoading = vue.ref(false);
      const configLoading = vue.ref(false);
      const pendingInstall = vue.ref(null);
      const serviceLoading = vue.ref(false);
      const serviceTableData = vue.ref([]);
      const showServiceDialog = vue.ref(false);
      const serviceFormRef = vue.ref(null);
      const serviceFormData = vue.ref({
        serviceId: "",
        serviceType: "",
        serviceName: "",
        containerName: "",
        serviceHost: "localhost",
        servicePort: void 0,
        healthCheckUrl: "",
        config: {},
        installedBy: "manual",
        status: "RUNNING"
      });
      const editingServiceId = vue.ref(null);
      const configItems = vue.ref([]);
      const nodeOptions = () => {
        const opts = [
          { label: "本地 (local)", value: "__local__" }
        ];
        for (const n of nodes.value) {
          const label = `${n.nodeId}${n.name ? `（${n.name}）` : ""} - ${n.type}${n.enabled ? "" : " [禁用]"}`;
          opts.push({ label, value: n.nodeId });
        }
        return opts;
      };
      async function loadNodes() {
        nodesLoading.value = true;
        try {
          nodes.value = await nodesApi.list();
        } catch (e2) {
          console.warn("加载节点失败:", e2);
          nodes.value = [];
        } finally {
          nodesLoading.value = false;
        }
      }
      const remotePagination = vue.reactive({
        page: 1,
        pageSize: 20,
        itemCount: 0,
        pageSizes: [10, 20, 50, 100]
      });
      const fileInputRef = vue.ref(null);
      function appendInstallLog(line) {
        if (!line) return;
        installLogs.value.push(line);
      }
      function subscribeInstallLogs(pluginId) {
        const sseClient = window.__GRESS_SSE_CLIENT__;
        if (!sseClient) {
          console.warn("[Middleware] 全局 SSE 客户端未初始化");
          return;
        }
        if (installSseUnsubscribe) {
          installSseUnsubscribe();
          installSseUnsubscribe = null;
        }
        currentInstallPluginId.value = pluginId;
        installLogs.value = [];
        const businessType = "MIDDLEWARE_INSTALL";
        installSseUnsubscribe = sseClient.on(businessType, (message2) => {
          try {
            const { businessId, type, status, data, message: msg, error: error2, progress } = message2 || {};
            if (businessId && businessId !== pluginId) return;
            switch (type) {
              case "DATA":
                appendInstallLog(data && (data.line || data.message) || msg || "");
                break;
              case "PROGRESS":
                if (progress) {
                  installStepProgress.value = {
                    currentStep: progress.current || 0,
                    totalSteps: progress.total || 0,
                    stepName: progress.message || "",
                    percentage: progress.percentage || 0,
                    status: "info"
                  };
                  if (progress.message) {
                    appendInstallLog(`[步骤 ${progress.current}/${progress.total}] ${progress.message}`);
                  }
                }
                break;
              case "STATUS":
                if (status === "START") {
                  appendInstallLog("开始安装中间件...");
                  installStepProgress.value = {
                    currentStep: 0,
                    totalSteps: 0,
                    stepName: "",
                    percentage: 0,
                    status: "info"
                  };
                } else if (status === "SUCCESS") {
                  appendInstallLog("中间件安装成功");
                  if (installStepProgress.value.totalSteps > 0) {
                    installStepProgress.value.currentStep = installStepProgress.value.totalSteps;
                    installStepProgress.value.percentage = 100;
                    installStepProgress.value.status = "success";
                  }
                  loadLocalData();
                } else if (msg) {
                  appendInstallLog(String(msg));
                }
                break;
              case "ERROR":
                appendInstallLog(`安装出错: ${error2 || msg || ""}`);
                installStepProgress.value.status = "error";
                break;
              case "COMPLETE":
                appendInstallLog("安装完成");
                if (installStepProgress.value.totalSteps > 0) {
                  installStepProgress.value.currentStep = installStepProgress.value.totalSteps;
                  installStepProgress.value.percentage = 100;
                  installStepProgress.value.status = "success";
                }
                break;
              default:
                if (msg) {
                  appendInstallLog(String(msg));
                }
            }
          } catch (e2) {
            console.error("[Middleware] 处理安装日志消息失败:", e2, message2);
          }
        });
      }
      function closeInstallDrawer() {
        if (installSseUnsubscribe) {
          installSseUnsubscribe();
          installSseUnsubscribe = null;
        }
        showInstallDrawer.value = false;
        installLogs.value = [];
        currentInstallPluginId.value = null;
        installStepProgress.value = {
          currentStep: 0,
          totalSteps: 0,
          stepName: "",
          percentage: 0,
          status: "info"
        };
      }
      const localColumns = [
        {
          title: "ID",
          key: "id",
          width: 220
        },
        {
          title: "版本",
          key: "version",
          width: 120
        },
        {
          title: "状态",
          key: "status",
          width: 120,
          render(row) {
            return row.status || "UNKNOWN";
          }
        },
        {
          title: "工作目录",
          key: "workDir",
          render(row) {
            return row.workDir || "-";
          }
        },
        {
          title: "操作",
          key: "actions",
          width: 320,
          render(row) {
            return vue.h("div", { style: "display:flex; gap:8px;" }, [
              vue.h(
                naiveUi.NButton,
                {
                  size: "small",
                  onClick: () => handleCopyConnectionInfo(row)
                },
                {
                  icon: () => vue.h(naiveUi.NIcon, null, { default: () => vue.h(CopyOutline) }),
                  default: () => "复制连接信息"
                }
              ),
              vue.h(
                naiveUi.NButton,
                {
                  size: "small",
                  onClick: () => handleHealth(row)
                },
                {
                  icon: () => vue.h(naiveUi.NIcon, null, { default: () => vue.h(PulseOutline) }),
                  default: () => "健康"
                }
              ),
              vue.h(
                naiveUi.NButton,
                {
                  size: "small",
                  type: "error",
                  onClick: () => handleUninstall(row)
                },
                {
                  icon: () => vue.h(naiveUi.NIcon, null, { default: () => vue.h(TrashOutline) }),
                  default: () => "卸载"
                }
              )
            ]);
          }
        }
      ];
      const serviceColumns = [
        {
          title: "服务ID",
          key: "serviceId",
          width: 180
        },
        {
          title: "服务名称",
          key: "serviceName",
          width: 150
        },
        {
          title: "服务类型",
          key: "serviceType",
          width: 120
        },
        {
          title: "主机",
          key: "serviceHost",
          width: 150
        },
        {
          title: "端口",
          key: "servicePort",
          width: 100
        },
        {
          title: "状态",
          key: "status",
          width: 100,
          render(row) {
            const status = row.status || "RUNNING";
            const type = status === "RUNNING" ? "success" : status === "STOPPED" ? "default" : "error";
            return vue.h(naiveUi.NTag, { type, size: "small" }, { default: () => status });
          }
        },
        {
          title: "引用计数",
          key: "referenceCount",
          width: 100,
          render(row) {
            return row.referenceCount || 0;
          }
        },
        {
          title: "安装者",
          key: "installedBy",
          width: 120,
          render(row) {
            return row.installedBy || "-";
          }
        },
        {
          title: "操作",
          key: "actions",
          width: 200,
          render(row) {
            return vue.h("div", { style: "display:flex; gap:8px;" }, [
              vue.h(
                naiveUi.NButton,
                {
                  size: "small",
                  onClick: () => handleEditService(row)
                },
                {
                  icon: () => vue.h(naiveUi.NIcon, null, { default: () => vue.h(EditOutline) }),
                  default: () => "编辑"
                }
              ),
              vue.h(
                naiveUi.NButton,
                {
                  size: "small",
                  type: "error",
                  onClick: () => handleDeleteService(row)
                },
                {
                  icon: () => vue.h(naiveUi.NIcon, null, { default: () => vue.h(TrashOutline) }),
                  default: () => "删除"
                }
              )
            ]);
          }
        }
      ];
      const loadData = async () => {
        refreshLoading.value = true;
        try {
          if (activeTab.value === "local") {
            await loadLocalData();
          } else if (activeTab.value === "remote") {
            await loadRemoteData();
          } else if (activeTab.value === "services") {
            await loadServices();
          }
        } finally {
          refreshLoading.value = false;
        }
      };
      const loadLocalData = async () => {
        localLoading.value = true;
        try {
          localTableData.value = await middlewareApi.list();
        } catch (e2) {
        } finally {
          localLoading.value = false;
        }
      };
      const loadRemoteData = async () => {
        remoteLoading.value = true;
        try {
          const params = {
            page: remotePagination.page,
            size: remotePagination.pageSize
          };
          if (remoteFilters.value.keyword && remoteFilters.value.keyword.trim()) {
            params.keyword = remoteFilters.value.keyword.trim();
          }
          const data = await middlewareApi.getRemoteList(params);
          remoteTableData.value = data.items;
          remotePagination.itemCount = data.total;
        } catch (e2) {
        } finally {
          remoteLoading.value = false;
        }
      };
      const handleTabChange = (value) => {
        activeTab.value = value;
        loadData();
      };
      const handleRemoteSearch = () => {
        remotePagination.page = 1;
        loadRemoteData();
      };
      const handleRemoteReset = () => {
        remoteFilters.value.keyword = "";
        remotePagination.page = 1;
        loadRemoteData();
      };
      const handleRemotePageChange = (page) => {
        remotePagination.page = page;
        loadRemoteData();
      };
      const handleRemotePageSizeChange = (pageSize) => {
        remotePagination.pageSize = pageSize;
        remotePagination.page = 1;
        loadRemoteData();
      };
      const loadServices = async () => {
        serviceLoading.value = true;
        try {
          serviceTableData.value = await middlewareApi.listServices();
        } catch (e2) {
        } finally {
          serviceLoading.value = false;
        }
      };
      const handleAddServiceClick = () => {
        editingServiceId.value = null;
        serviceFormData.value = {
          serviceId: "",
          serviceType: "",
          serviceName: "",
          containerName: "",
          serviceHost: "localhost",
          servicePort: void 0,
          healthCheckUrl: "",
          config: {},
          installedBy: "manual",
          status: "RUNNING"
        };
        configItems.value = [];
        showServiceDialog.value = true;
      };
      const handleEditService = (service) => {
        editingServiceId.value = service.serviceId;
        serviceFormData.value = {
          ...service,
          config: service.config || {}
        };
        let configObj = {};
        if (service.config) {
          if (typeof service.config === "string") {
            try {
              configObj = JSON.parse(service.config);
            } catch (e2) {
              console.warn("解析 config JSON 失败:", e2);
              configObj = {};
            }
          } else if (typeof service.config === "object") {
            configObj = service.config;
          }
        }
        configItems.value = Object.entries(configObj).map(([key2, value]) => ({
          key: key2,
          value: String(value != null ? value : "")
        }));
        showServiceDialog.value = true;
      };
      const handleDeleteService = (service) => {
        dialog.warning({
          title: "删除服务",
          content: `确定要删除服务 "${service.serviceId}" 吗？${service.referenceCount && service.referenceCount > 0 ? `该服务正在被 ${service.referenceCount} 个中间件使用。` : ""}`,
          positiveText: "删除",
          negativeText: "取消",
          onPositiveClick: async () => {
            try {
              await middlewareApi.deleteService(service.serviceId);
              message.success("删除成功");
              await loadServices();
            } catch (e2) {
            }
          }
        });
      };
      const handleAddConfigItem = () => {
        configItems.value.push({ key: "", value: "" });
      };
      const handleRemoveConfigItem = (index2) => {
        configItems.value.splice(index2, 1);
        updateConfigFromItems();
      };
      const updateConfigFromItems = () => {
        const config = {};
        configItems.value.forEach((item) => {
          if (item.key && item.key.trim()) {
            config[item.key.trim()] = item.value || "";
          }
        });
        serviceFormData.value.config = config;
      };
      const handleSaveService = async () => {
        var _a2;
        try {
          updateConfigFromItems();
          await ((_a2 = serviceFormRef.value) == null ? void 0 : _a2.validate());
          if (editingServiceId.value) {
            await middlewareApi.updateService(editingServiceId.value, serviceFormData.value);
            message.success("更新成功");
          } else {
            await middlewareApi.registerService(serviceFormData.value);
            message.success("添加成功");
          }
          showServiceDialog.value = false;
          await loadServices();
        } catch (e2) {
          if ((e2 == null ? void 0 : e2.message) && !e2.message.includes("validation")) {
            message.error(e2.message);
          }
        }
      };
      const serviceFormRules = {
        serviceId: {
          required: true,
          message: "请输入服务ID",
          trigger: "blur"
        },
        serviceHost: {
          required: true,
          message: "请输入服务主机",
          trigger: "blur"
        },
        servicePort: {
          required: true,
          type: "number",
          message: "请输入服务端口",
          trigger: "blur"
        }
      };
      function handleUploadClick() {
        var _a2;
        (_a2 = fileInputRef.value) == null ? void 0 : _a2.click();
      }
      async function handleFileSelected() {
        const input = fileInputRef.value;
        if (!input || !input.files || input.files.length === 0) return;
        const file = input.files[0];
        input.value = "";
        uploadLoading.value = true;
        try {
          const fd = new FormData();
          fd.append("file", file);
          fd.append("operatorName", "admin");
          const r = await middlewareApi.uploadAndInstall(fd);
          message.success(`安装成功: ${r.middlewareId}`);
          await loadLocalData();
        } catch (e2) {
        } finally {
          uploadLoading.value = false;
        }
      }
      async function handleHealth(row) {
        const r = await middlewareApi.health(row.id);
        if (r.healthy) {
          message.success(`健康: ${row.id}`);
        } else {
          message.warning(`不健康: ${r.message || row.id}`);
        }
      }
      function handleUninstall(row) {
        dialog.warning({
          title: "确认卸载",
          content: `确定要卸载中间件 ${row.id} 吗？`,
          positiveText: "卸载",
          negativeText: "取消",
          onPositiveClick: async () => {
            await middlewareApi.uninstall(row.id, "admin");
            message.success("卸载成功");
            await loadLocalData();
          }
        });
      }
      async function handleCopyConnectionInfo(row) {
        const result = await middlewareApi.getConnectionInfoText(row.id);
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(result.text);
          message.success("连接信息已复制到剪贴板");
        } else {
          const textArea = document.createElement("textarea");
          textArea.value = result.text;
          textArea.style.position = "fixed";
          textArea.style.left = "-999999px";
          document.body.appendChild(textArea);
          textArea.select();
          try {
            document.execCommand("copy");
            message.success("连接信息已复制到剪贴板");
          } finally {
            document.body.removeChild(textArea);
          }
        }
      }
      const handleInstallRemote = (middleware) => {
        if (!middleware.pluginId) {
          message.error("插件ID不能为空");
          return;
        }
        loadNodes();
        selectedNodeId.value = "__local__";
        dialog.warning({
          title: "安装中间件",
          content: () => vue.h("div", { style: "display:flex; flex-direction:column; gap:12px;" }, [
            vue.h("div", null, `确定要安装中间件 "${middleware.applicationName || middleware.pluginId}" 吗？`),
            vue.h("div", { style: "display:flex; align-items:center; gap:10px;" }, [
              vue.h("div", { style: "width:96px; color:#666;" }, "目标节点"),
              vue.h(naiveUi.NSelect, {
                value: selectedNodeId.value,
                options: nodeOptions(),
                loading: nodesLoading.value,
                style: "flex:1;",
                onUpdateValue: (v) => selectedNodeId.value = v
              })
            ])
          ]),
          positiveText: "下一步",
          negativeText: "取消",
          onPositiveClick: async () => {
            const targetNodeId = selectedNodeId.value === "__local__" ? void 0 : selectedNodeId.value;
            const node = targetNodeId ? nodes.value.find((n) => n.nodeId === targetNodeId) : void 0;
            configMetadataLoading.value = true;
            try {
              const metadata = await middlewareApi.getConfigMetadata(middleware.pluginId);
              configMetadata.value = metadata || [];
              if (configMetadata.value.length > 0) {
                configFormData.value = {};
                configMetadata.value.forEach((field) => {
                  if (field.defaultValue) {
                    configFormData.value[field.code] = field.defaultValue;
                  }
                });
                pendingInstall.value = {
                  middleware,
                  targetNodeId,
                  executionType: node == null ? void 0 : node.type
                };
                showConfigDialog.value = true;
              } else {
                await doInstall(middleware, targetNodeId, node == null ? void 0 : node.type, {});
              }
            } catch (error2) {
              console.error("获取配置元数据失败:", error2);
              message.warning("获取配置元数据失败，将使用默认配置安装");
              await doInstall(middleware, targetNodeId, node == null ? void 0 : node.type, {});
            } finally {
              configMetadataLoading.value = false;
            }
          }
        });
      };
      async function doInstall(middleware, targetNodeId, executionType, config) {
        installRemoteLoading.value[middleware.pluginId] = true;
        showInstallDrawer.value = true;
        subscribeInstallLogs(middleware.pluginId);
        message.info(`正在安装中间件（可在右侧抽屉查看实时日志）: ${middleware.applicationName || middleware.pluginId}...`);
        try {
          await middlewareApi.installRemoteStream(middleware.pluginId, {
            targetNodeId,
            executionType,
            config
          });
        } finally {
          installRemoteLoading.value[middleware.pluginId] = false;
        }
      }
      function handleConfirmConfig() {
        if (!pendingInstall.value) return false;
        configLoading.value = true;
        try {
          showConfigDialog.value = false;
          const { middleware, targetNodeId, executionType } = pendingInstall.value;
          doInstall(middleware, targetNodeId, executionType, configFormData.value);
          pendingInstall.value = null;
          return true;
        } catch (error2) {
          return false;
        } finally {
          configLoading.value = false;
        }
      }
      const handleUpgradeRemote = (middleware) => {
        if (!middleware.pluginId) {
          message.error("插件ID不能为空");
          return;
        }
        const targetVersion = middleware.pluginVersion || "-";
        loadNodes();
        selectedNodeId.value = "__local__";
        dialog.warning({
          title: "升级中间件",
          content: () => vue.h("div", { style: "display:flex; flex-direction:column; gap:12px;" }, [
            vue.h("div", null, `确定要将中间件 "${middleware.applicationName || middleware.pluginId}" 升级到版本 ${targetVersion} 吗？`),
            vue.h("div", { style: "display:flex; align-items:center; gap:10px;" }, [
              vue.h("div", { style: "width:96px; color:#666;" }, "目标节点"),
              vue.h(naiveUi.NSelect, {
                value: selectedNodeId.value,
                options: nodeOptions(),
                loading: nodesLoading.value,
                style: "flex:1;",
                onUpdateValue: (v) => selectedNodeId.value = v
              })
            ])
          ]),
          positiveText: "升级",
          negativeText: "取消",
          onPositiveClick: async () => {
            upgradeRemoteLoading.value[middleware.pluginId] = true;
            showInstallDrawer.value = true;
            subscribeInstallLogs(middleware.pluginId);
            message.info(`正在升级中间件（可在右侧抽屉查看实时日志）: ${middleware.applicationName || middleware.pluginId}...`);
            try {
              const targetNodeId = selectedNodeId.value === "__local__" ? void 0 : selectedNodeId.value;
              const node = targetNodeId ? nodes.value.find((n) => n.nodeId === targetNodeId) : void 0;
              await middlewareApi.installRemoteStream(middleware.pluginId, {
                targetNodeId,
                executionType: node == null ? void 0 : node.type
              });
            } finally {
              upgradeRemoteLoading.value[middleware.pluginId] = false;
            }
          }
        });
      };
      vue.onMounted(() => {
        loadData();
      });
      vue.onUnmounted(() => {
        if (installSseUnsubscribe) {
          installSseUnsubscribe();
          installSseUnsubscribe = null;
        }
      });
      return (_ctx, _cache) => {
        const _component_PageHeader = vue.resolveComponent("PageHeader");
        const _component_n_data_table = vue.resolveComponent("n-data-table");
        const _component_n_drawer_content = vue.resolveComponent("n-drawer-content");
        const _component_n_drawer = vue.resolveComponent("n-drawer");
        const _component_DynamicFormRenderer = vue.resolveComponent("DynamicFormRenderer");
        return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$4, [
          vue.createVNode(_component_PageHeader, {
            title: "中间件管理",
            subtitle: "安装与管理基础设施中间件插件（如 Milvus/Redis 等）"
          }, {
            actions: vue.withCtx(() => [
              activeTab.value === "local" ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NButton), {
                key: 0,
                type: "primary",
                onClick: handleUploadClick,
                loading: uploadLoading.value
              }, {
                icon: vue.withCtx(() => [
                  vue.createVNode(vue.unref(naiveUi.NIcon), null, {
                    default: vue.withCtx(() => [
                      (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(CloudUploadOutline))))
                    ]),
                    _: 1
                  })
                ]),
                default: vue.withCtx(() => [
                  _cache[17] || (_cache[17] = vue.createTextVNode(" 上传中间件插件包 ", -1))
                ]),
                _: 1
              }, 8, ["loading"])) : vue.createCommentVNode("", true),
              vue.createVNode(vue.unref(naiveUi.NButton), {
                loading: refreshLoading.value,
                onClick: loadData
              }, {
                icon: vue.withCtx(() => [
                  vue.createVNode(vue.unref(naiveUi.NIcon), null, {
                    default: vue.withCtx(() => [
                      (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(Refresh))))
                    ]),
                    _: 1
                  })
                ]),
                default: vue.withCtx(() => [
                  _cache[18] || (_cache[18] = vue.createTextVNode(" 刷新 ", -1))
                ]),
                _: 1
              }, 8, ["loading"])
            ]),
            _: 1
          }),
          vue.createElementVNode("div", _hoisted_2$4, [
            vue.createVNode(vue.unref(naiveUi.NTabs), {
              value: activeTab.value,
              "onUpdate:value": [
                _cache[3] || (_cache[3] = ($event) => activeTab.value = $event),
                handleTabChange
              ],
              type: "line"
            }, {
              default: vue.withCtx(() => [
                vue.createVNode(vue.unref(naiveUi.NTabPane), {
                  name: "local",
                  tab: "我的中间件"
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(vue.unref(naiveUi.NCard), null, {
                      default: vue.withCtx(() => [
                        vue.createVNode(_component_n_data_table, {
                          columns: localColumns,
                          data: localTableData.value,
                          loading: localLoading.value,
                          pagination: false,
                          "row-key": (row) => row.id,
                          striped: ""
                        }, null, 8, ["data", "loading", "row-key"])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                vue.createVNode(vue.unref(naiveUi.NTabPane), {
                  name: "remote",
                  tab: "中间件商店"
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(vue.unref(naiveUi.NCard), { style: { "margin-bottom": "16px" } }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(naiveUi.NSpace), null, {
                          default: vue.withCtx(() => [
                            vue.createVNode(vue.unref(naiveUi.NInput), {
                              value: remoteFilters.value.keyword,
                              "onUpdate:value": _cache[0] || (_cache[0] = ($event) => remoteFilters.value.keyword = $event),
                              placeholder: "搜索中间件名称、插件ID",
                              clearable: "",
                              style: { "width": "300px" },
                              onKeyup: vue.withKeys(handleRemoteSearch, ["enter"])
                            }, {
                              prefix: vue.withCtx(() => [
                                vue.createVNode(vue.unref(naiveUi.NIcon), null, {
                                  default: vue.withCtx(() => [
                                    (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(SearchOutline))))
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            }, 8, ["value"]),
                            vue.createVNode(vue.unref(naiveUi.NButton), {
                              type: "primary",
                              onClick: handleRemoteSearch
                            }, {
                              default: vue.withCtx(() => [..._cache[19] || (_cache[19] = [
                                vue.createTextVNode("搜索", -1)
                              ])]),
                              _: 1
                            }),
                            vue.createVNode(vue.unref(naiveUi.NButton), { onClick: handleRemoteReset }, {
                              default: vue.withCtx(() => [..._cache[20] || (_cache[20] = [
                                vue.createTextVNode("重置", -1)
                              ])]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    remoteLoading.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_3$4, [
                      vue.createVNode(vue.unref(naiveUi.NSpin), { size: "large" })
                    ])) : remoteTableData.value.length === 0 ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_4$2, [
                      vue.createElementVNode("div", _hoisted_5$1, [
                        vue.createVNode(vue.unref(naiveUi.NIcon), { size: "48" }, {
                          default: vue.withCtx(() => [
                            (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(ServerOutline))))
                          ]),
                          _: 1
                        })
                      ]),
                      vue.createElementVNode("div", _hoisted_6$1, vue.toDisplayString(remoteFilters.value.keyword ? "未找到匹配的中间件" : "暂无远程中间件"), 1)
                    ])) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_7, [
                      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(remoteTableData.value, (middleware) => {
                        return vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NCard), {
                          key: middleware.pluginId,
                          class: "middleware-card",
                          hoverable: ""
                        }, {
                          default: vue.withCtx(() => [
                            vue.createElementVNode("div", _hoisted_8, [
                              vue.createElementVNode("div", _hoisted_9, [
                                vue.createVNode(vue.unref(naiveUi.NIcon), { size: "24" }, {
                                  default: vue.withCtx(() => [
                                    (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(ServerOutline))))
                                  ]),
                                  _: 1
                                })
                              ]),
                              vue.createElementVNode("div", _hoisted_10, [
                                vue.createElementVNode("div", _hoisted_11, vue.toDisplayString(middleware.applicationName || middleware.pluginId), 1),
                                vue.createElementVNode("div", _hoisted_12, vue.toDisplayString(middleware.pluginId), 1)
                              ]),
                              vue.createElementVNode("div", _hoisted_13, [
                                middleware.installStatus === "INSTALLED" ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NTag), {
                                  key: 0,
                                  type: "success",
                                  size: "small"
                                }, {
                                  default: vue.withCtx(() => [..._cache[21] || (_cache[21] = [
                                    vue.createTextVNode(" 已安装 ", -1)
                                  ])]),
                                  _: 1
                                })) : middleware.installStatus === "UPGRADABLE" ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NTag), {
                                  key: 1,
                                  type: "warning",
                                  size: "small"
                                }, {
                                  default: vue.withCtx(() => [..._cache[22] || (_cache[22] = [
                                    vue.createTextVNode(" 可升级 ", -1)
                                  ])]),
                                  _: 1
                                })) : (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NTag), {
                                  key: 2,
                                  type: "info",
                                  size: "small"
                                }, {
                                  default: vue.withCtx(() => [..._cache[23] || (_cache[23] = [
                                    vue.createTextVNode(" 未安装 ", -1)
                                  ])]),
                                  _: 1
                                }))
                              ])
                            ]),
                            vue.createElementVNode("div", _hoisted_14, [
                              vue.createElementVNode("div", _hoisted_15, [
                                vue.createElementVNode("div", _hoisted_16, [
                                  _cache[24] || (_cache[24] = vue.createElementVNode("span", { class: "meta-label" }, "远程版本：", -1)),
                                  vue.createElementVNode("span", _hoisted_17, vue.toDisplayString(middleware.pluginVersion || "-"), 1)
                                ]),
                                middleware.localVersion ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_18, [
                                  _cache[25] || (_cache[25] = vue.createElementVNode("span", { class: "meta-label" }, "本地版本：", -1)),
                                  vue.createElementVNode("span", _hoisted_19, vue.toDisplayString(middleware.localVersion), 1)
                                ])) : vue.createCommentVNode("", true),
                                middleware.author ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_20, [
                                  _cache[26] || (_cache[26] = vue.createElementVNode("span", { class: "meta-label" }, "作者：", -1)),
                                  vue.createElementVNode("span", _hoisted_21, vue.toDisplayString(middleware.author), 1)
                                ])) : vue.createCommentVNode("", true)
                              ]),
                              middleware.description ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_22, vue.toDisplayString(middleware.description), 1)) : vue.createCommentVNode("", true)
                            ]),
                            vue.createElementVNode("div", _hoisted_23, [
                              vue.createElementVNode("div", _hoisted_24, [
                                middleware.installStatus === "NOT_INSTALLED" ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NButton), {
                                  key: 0,
                                  text: "",
                                  type: "success",
                                  size: "small",
                                  loading: installRemoteLoading.value[middleware.pluginId],
                                  onClick: ($event) => handleInstallRemote(middleware)
                                }, {
                                  default: vue.withCtx(() => [..._cache[27] || (_cache[27] = [
                                    vue.createTextVNode(" 安装 ", -1)
                                  ])]),
                                  _: 1
                                }, 8, ["loading", "onClick"])) : middleware.installStatus === "UPGRADABLE" ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NButton), {
                                  key: 1,
                                  text: "",
                                  type: "warning",
                                  size: "small",
                                  loading: upgradeRemoteLoading.value[middleware.pluginId],
                                  onClick: ($event) => handleUpgradeRemote(middleware)
                                }, {
                                  default: vue.withCtx(() => [..._cache[28] || (_cache[28] = [
                                    vue.createTextVNode(" 升级 ", -1)
                                  ])]),
                                  _: 1
                                }, 8, ["loading", "onClick"])) : (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NButton), {
                                  key: 2,
                                  text: "",
                                  type: "default",
                                  size: "small",
                                  disabled: ""
                                }, {
                                  default: vue.withCtx(() => [..._cache[29] || (_cache[29] = [
                                    vue.createTextVNode(" 已安装 ", -1)
                                  ])]),
                                  _: 1
                                }))
                              ])
                            ])
                          ]),
                          _: 2
                        }, 1024);
                      }), 128))
                    ])),
                    remotePagination.itemCount > 0 ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_25, [
                      vue.createVNode(vue.unref(naiveUi.NPagination), {
                        page: remotePagination.page,
                        "onUpdate:page": [
                          _cache[1] || (_cache[1] = ($event) => remotePagination.page = $event),
                          handleRemotePageChange
                        ],
                        "page-size": remotePagination.pageSize,
                        "onUpdate:pageSize": [
                          _cache[2] || (_cache[2] = ($event) => remotePagination.pageSize = $event),
                          handleRemotePageSizeChange
                        ],
                        "page-count": Math.ceil(remotePagination.itemCount / remotePagination.pageSize),
                        "page-sizes": remotePagination.pageSizes,
                        "show-size-picker": ""
                      }, null, 8, ["page", "page-size", "page-count", "page-sizes"])
                    ])) : vue.createCommentVNode("", true)
                  ]),
                  _: 1
                }),
                vue.createVNode(vue.unref(naiveUi.NTabPane), {
                  name: "services",
                  tab: "服务管理"
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(vue.unref(naiveUi.NCard), null, {
                      header: vue.withCtx(() => [
                        vue.createElementVNode("div", _hoisted_26, [
                          _cache[31] || (_cache[31] = vue.createElementVNode("span", null, "中间件服务管理", -1)),
                          vue.createVNode(vue.unref(naiveUi.NButton), {
                            type: "primary",
                            onClick: handleAddServiceClick
                          }, {
                            icon: vue.withCtx(() => [
                              vue.createVNode(vue.unref(naiveUi.NIcon), null, {
                                default: vue.withCtx(() => [
                                  (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(AddOutline))))
                                ]),
                                _: 1
                              })
                            ]),
                            default: vue.withCtx(() => [
                              _cache[30] || (_cache[30] = vue.createTextVNode(" 添加服务 ", -1))
                            ]),
                            _: 1
                          })
                        ])
                      ]),
                      default: vue.withCtx(() => [
                        vue.createVNode(_component_n_data_table, {
                          columns: serviceColumns,
                          data: serviceTableData.value,
                          loading: serviceLoading.value,
                          pagination: false,
                          "row-key": (row) => row.serviceId,
                          striped: ""
                        }, null, 8, ["data", "loading", "row-key"])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["value"]),
            vue.createElementVNode("input", {
              ref_key: "fileInputRef",
              ref: fileInputRef,
              type: "file",
              accept: ".jar",
              style: { "display": "none" },
              onChange: handleFileSelected
            }, null, 544),
            vue.createVNode(_component_n_drawer, {
              show: showInstallDrawer.value,
              "onUpdate:show": _cache[4] || (_cache[4] = ($event) => showInstallDrawer.value = $event),
              placement: "right",
              width: "520"
            }, {
              default: vue.withCtx(() => [
                vue.createVNode(_component_n_drawer_content, {
                  title: currentInstallPluginId.value ? `安装详情 - ${currentInstallPluginId.value}` : "安装详情"
                }, {
                  footer: vue.withCtx(() => [
                    vue.createVNode(vue.unref(naiveUi.NSpace), { justify: "end" }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(naiveUi.NButton), { onClick: closeInstallDrawer }, {
                          default: vue.withCtx(() => [..._cache[33] || (_cache[33] = [
                            vue.createTextVNode("关闭", -1)
                          ])]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  default: vue.withCtx(() => [
                    vue.createElementVNode("div", _hoisted_27, [
                      installStepProgress.value.currentStep > 0 ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NCard), {
                        key: 0,
                        size: "small",
                        style: { "margin-bottom": "16px" }
                      }, {
                        default: vue.withCtx(() => [
                          vue.createVNode(vue.unref(naiveUi.NSpace), {
                            vertical: "",
                            size: 8
                          }, {
                            default: vue.withCtx(() => [
                              vue.createElementVNode("div", _hoisted_28, [
                                _cache[32] || (_cache[32] = vue.createElementVNode("span", { style: { "font-weight": "500" } }, "执行进度", -1)),
                                vue.createVNode(vue.unref(naiveUi.NText), { type: "info" }, {
                                  default: vue.withCtx(() => [
                                    vue.createTextVNode(vue.toDisplayString(installStepProgress.value.currentStep) + " / " + vue.toDisplayString(installStepProgress.value.totalSteps), 1)
                                  ]),
                                  _: 1
                                })
                              ]),
                              vue.createVNode(vue.unref(naiveUi.NProgress), {
                                percentage: installStepProgress.value.percentage,
                                status: installStepProgress.value.status,
                                "show-indicator": true
                              }, null, 8, ["percentage", "status"]),
                              installStepProgress.value.stepName ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NText), {
                                key: 0,
                                depth: "3",
                                style: { "font-size": "12px" }
                              }, {
                                default: vue.withCtx(() => [
                                  vue.createTextVNode(" 当前步骤: " + vue.toDisplayString(installStepProgress.value.stepName), 1)
                                ]),
                                _: 1
                              })) : vue.createCommentVNode("", true)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })) : vue.createCommentVNode("", true),
                      vue.createElementVNode("div", _hoisted_29, [
                        installLogs.value.length > 0 ? (vue.openBlock(true), vue.createElementBlock(vue.Fragment, { key: 0 }, vue.renderList(installLogs.value, (line, idx) => {
                          return vue.openBlock(), vue.createElementBlock("div", { key: idx }, vue.toDisplayString(line), 1);
                        }), 128)) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_30, "等待安装日志输出..."))
                      ])
                    ])
                  ]),
                  _: 1
                }, 8, ["title"])
              ]),
              _: 1
            }, 8, ["show"]),
            vue.createVNode(vue.unref(naiveUi.NModal), {
              show: showConfigDialog.value,
              "onUpdate:show": _cache[6] || (_cache[6] = ($event) => showConfigDialog.value = $event),
              preset: "dialog",
              title: "配置安装参数",
              "positive-text": "确定安装",
              "negative-text": "取消",
              "positive-button-props": { loading: configLoading.value },
              loading: configLoading.value,
              style: { width: "900px" },
              onPositiveClick: handleConfirmConfig
            }, {
              default: vue.withCtx(() => [
                vue.createVNode(vue.unref(naiveUi.NScrollbar), { style: { "max-height": "70vh" } }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(vue.unref(naiveUi.NSpin), { show: configMetadataLoading.value }, {
                      default: vue.withCtx(() => [
                        vue.createElementVNode("div", _hoisted_31, [
                          pendingInstall.value ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NCard), {
                            key: 0,
                            size: "small",
                            bordered: false,
                            class: "app-info-card"
                          }, {
                            default: vue.withCtx(() => [
                              vue.createElementVNode("div", _hoisted_32, [
                                vue.createElementVNode("div", _hoisted_33, [
                                  _cache[34] || (_cache[34] = vue.createElementVNode("span", { class: "info-label" }, "中间件名称：", -1)),
                                  vue.createElementVNode("span", _hoisted_34, vue.toDisplayString(pendingInstall.value.middleware.applicationName || pendingInstall.value.middleware.pluginId), 1)
                                ]),
                                vue.createElementVNode("div", _hoisted_35, [
                                  _cache[35] || (_cache[35] = vue.createElementVNode("span", { class: "info-label" }, "插件ID：", -1)),
                                  vue.createVNode(vue.unref(naiveUi.NText), {
                                    type: "info",
                                    class: "info-value"
                                  }, {
                                    default: vue.withCtx(() => [
                                      vue.createTextVNode(vue.toDisplayString(pendingInstall.value.middleware.pluginId), 1)
                                    ]),
                                    _: 1
                                  })
                                ])
                              ])
                            ]),
                            _: 1
                          })) : vue.createCommentVNode("", true),
                          configMetadata.value.length > 0 ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NCard), {
                            key: 1,
                            size: "small",
                            title: "安装配置",
                            bordered: false,
                            class: "config-section"
                          }, {
                            default: vue.withCtx(() => [
                              vue.createVNode(_component_DynamicFormRenderer, {
                                modelValue: configFormData.value,
                                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => configFormData.value = $event),
                                metadata: { fields: configMetadata.value }
                              }, null, 8, ["modelValue", "metadata"])
                            ]),
                            _: 1
                          })) : vue.createCommentVNode("", true)
                        ])
                      ]),
                      _: 1
                    }, 8, ["show"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["show", "positive-button-props", "loading"]),
            vue.createVNode(vue.unref(naiveUi.NModal), {
              show: showServiceDialog.value,
              "onUpdate:show": _cache[16] || (_cache[16] = ($event) => showServiceDialog.value = $event),
              preset: "dialog",
              title: editingServiceId.value ? "编辑服务" : "添加服务",
              "positive-text": "确定",
              "negative-text": "取消",
              style: { width: "800px" },
              onPositiveClick: handleSaveService
            }, {
              default: vue.withCtx(() => [
                vue.createVNode(vue.unref(naiveUi.NForm), {
                  ref_key: "serviceFormRef",
                  ref: serviceFormRef,
                  model: serviceFormData.value,
                  rules: serviceFormRules,
                  "label-placement": "left",
                  "label-width": "120px",
                  "require-mark-placement": "right-hanging"
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(vue.unref(naiveUi.NFormItem), {
                      label: "服务ID",
                      path: "serviceId"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(naiveUi.NInput), {
                          value: serviceFormData.value.serviceId,
                          "onUpdate:value": _cache[7] || (_cache[7] = ($event) => serviceFormData.value.serviceId = $event),
                          placeholder: "例如: etcd-installer, minio-installer",
                          disabled: !!editingServiceId.value
                        }, null, 8, ["value", "disabled"])
                      ]),
                      _: 1
                    }),
                    vue.createVNode(vue.unref(naiveUi.NFormItem), {
                      label: "服务名称",
                      path: "serviceName"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(naiveUi.NInput), {
                          value: serviceFormData.value.serviceName,
                          "onUpdate:value": _cache[8] || (_cache[8] = ($event) => serviceFormData.value.serviceName = $event),
                          placeholder: "服务显示名称"
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    vue.createVNode(vue.unref(naiveUi.NFormItem), {
                      label: "服务类型",
                      path: "serviceType"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(naiveUi.NInput), {
                          value: serviceFormData.value.serviceType,
                          "onUpdate:value": _cache[9] || (_cache[9] = ($event) => serviceFormData.value.serviceType = $event),
                          placeholder: "例如: etcd, minio, redis"
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    vue.createVNode(vue.unref(naiveUi.NFormItem), {
                      label: "容器名称",
                      path: "containerName"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(naiveUi.NInput), {
                          value: serviceFormData.value.containerName,
                          "onUpdate:value": _cache[10] || (_cache[10] = ($event) => serviceFormData.value.containerName = $event),
                          placeholder: "Docker 容器名称（可选）"
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    vue.createVNode(vue.unref(naiveUi.NFormItem), {
                      label: "服务主机",
                      path: "serviceHost"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(naiveUi.NInput), {
                          value: serviceFormData.value.serviceHost,
                          "onUpdate:value": _cache[11] || (_cache[11] = ($event) => serviceFormData.value.serviceHost = $event),
                          placeholder: "localhost 或 IP 地址"
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    vue.createVNode(vue.unref(naiveUi.NFormItem), {
                      label: "服务端口",
                      path: "servicePort"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(naiveUi.NInputNumber), {
                          value: serviceFormData.value.servicePort,
                          "onUpdate:value": _cache[12] || (_cache[12] = ($event) => serviceFormData.value.servicePort = $event),
                          placeholder: "端口号",
                          min: 1,
                          max: 65535,
                          style: { "width": "100%" }
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    vue.createVNode(vue.unref(naiveUi.NFormItem), {
                      label: "健康检查URL",
                      path: "healthCheckUrl"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(naiveUi.NInput), {
                          value: serviceFormData.value.healthCheckUrl,
                          "onUpdate:value": _cache[13] || (_cache[13] = ($event) => serviceFormData.value.healthCheckUrl = $event),
                          placeholder: "例如: http://localhost:9000/health"
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    vue.createVNode(vue.unref(naiveUi.NFormItem), {
                      label: "服务状态",
                      path: "status"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(naiveUi.NSelect), {
                          value: serviceFormData.value.status,
                          "onUpdate:value": _cache[14] || (_cache[14] = ($event) => serviceFormData.value.status = $event),
                          options: [
                            { label: "运行中", value: "RUNNING" },
                            { label: "已停止", value: "STOPPED" },
                            { label: "错误", value: "ERROR" }
                          ]
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    vue.createVNode(vue.unref(naiveUi.NFormItem), {
                      label: "安装者",
                      path: "installedBy"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(naiveUi.NInput), {
                          value: serviceFormData.value.installedBy,
                          "onUpdate:value": _cache[15] || (_cache[15] = ($event) => serviceFormData.value.installedBy = $event),
                          placeholder: "manual"
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    vue.createVNode(vue.unref(naiveUi.NFormItem), {
                      label: "自定义配置",
                      path: "config"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(naiveUi.NCard), {
                          size: "small",
                          bordered: true,
                          style: { "width": "100%" }
                        }, {
                          header: vue.withCtx(() => [
                            vue.createElementVNode("div", _hoisted_36, [
                              _cache[37] || (_cache[37] = vue.createElementVNode("span", null, "配置项（如账号、密码等）", -1)),
                              vue.createVNode(vue.unref(naiveUi.NButton), {
                                size: "small",
                                type: "primary",
                                onClick: handleAddConfigItem
                              }, {
                                icon: vue.withCtx(() => [
                                  vue.createVNode(vue.unref(naiveUi.NIcon), null, {
                                    default: vue.withCtx(() => [
                                      (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(AddOutline))))
                                    ]),
                                    _: 1
                                  })
                                ]),
                                default: vue.withCtx(() => [
                                  _cache[36] || (_cache[36] = vue.createTextVNode(" 添加 ", -1))
                                ]),
                                _: 1
                              })
                            ])
                          ]),
                          default: vue.withCtx(() => [
                            configItems.value.length === 0 ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_37, ' 暂无配置项，点击"添加"按钮添加配置 ')) : (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NSpace), {
                              key: 1,
                              vertical: "",
                              size: 12
                            }, {
                              default: vue.withCtx(() => [
                                (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(configItems.value, (item, index2) => {
                                  return vue.openBlock(), vue.createElementBlock("div", {
                                    key: index2,
                                    style: { "display": "flex", "gap": "8px", "align-items": "center", "padding": "8px", "background": "#f5f5f5", "border-radius": "4px" }
                                  }, [
                                    vue.createVNode(vue.unref(naiveUi.NInput), {
                                      value: item.key,
                                      "onUpdate:value": [($event) => item.key = $event, updateConfigFromItems],
                                      placeholder: "配置键（如: username）",
                                      style: { "flex": "1" }
                                    }, null, 8, ["value", "onUpdate:value"]),
                                    vue.createVNode(vue.unref(naiveUi.NInput), {
                                      value: item.value,
                                      "onUpdate:value": [($event) => item.value = $event, updateConfigFromItems],
                                      placeholder: "配置值（如: admin）",
                                      style: { "flex": "1" },
                                      type: item.key && (item.key.toLowerCase().includes("password") || item.key.toLowerCase().includes("pwd") || item.key.toLowerCase().includes("secret")) ? "password" : "text"
                                    }, null, 8, ["value", "onUpdate:value", "type"]),
                                    vue.createVNode(vue.unref(naiveUi.NButton), {
                                      size: "small",
                                      type: "error",
                                      onClick: ($event) => handleRemoveConfigItem(index2)
                                    }, {
                                      icon: vue.withCtx(() => [
                                        vue.createVNode(vue.unref(naiveUi.NIcon), null, {
                                          default: vue.withCtx(() => [
                                            (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(TrashOutline))))
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    }, 8, ["onClick"])
                                  ]);
                                }), 128))
                              ]),
                              _: 1
                            }))
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["model"])
              ]),
              _: 1
            }, 8, ["show", "title"])
          ])
        ]);
      };
    }
  });
  const MiddlewareManagement = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-de190af1"]]);
  const _hoisted_1$3 = { class: "node-management-page" };
  const _hoisted_2$3 = { class: "page-content" };
  const _hoisted_3$3 = { style: { "display": "flex", "justify-content": "flex-end", "gap": "8px" } };
  const _sfc_main$3 = /* @__PURE__ */ vue.defineComponent({
    __name: "NodeManagement",
    setup(__props) {
      const message = naiveUi.useMessage();
      const dialog = naiveUi.useDialog();
      const nodes = vue.ref([]);
      const loading = vue.ref(false);
      const saving = vue.ref(false);
      const showModal = vue.ref(false);
      const isEdit = vue.ref(false);
      const modalTitle = vue.ref("新增节点");
      const formRef = vue.ref(null);
      const emptyForm = () => ({
        nodeId: "",
        name: "",
        type: "local",
        description: "",
        enabled: true,
        config: { type: "local" }
      });
      const form = vue.ref(emptyForm());
      const typeOptions = [
        { label: "本地 (local)", value: "local" },
        { label: "SSH (ssh)", value: "ssh" },
        { label: "Docker API (docker-api)", value: "docker-api" }
      ];
      const enabledOptions = [
        { label: "启用", value: true },
        { label: "禁用", value: false }
      ];
      const sshAuthOptions = [
        { label: "密码 (PASSWORD)", value: "PASSWORD" },
        { label: "密钥 (KEY)", value: "KEY" }
      ];
      const dockerTlsOptions = [
        { label: "否", value: false },
        { label: "是", value: true }
      ];
      const rules = {
        nodeId: { required: true, message: "nodeId 不能为空", trigger: ["blur", "input"] },
        type: { required: true, message: "请选择类型", trigger: ["change"] }
      };
      const columns = [
        { title: "节点ID", key: "nodeId", width: 180 },
        { title: "名称", key: "name", width: 160, render: (row) => row.name || "-" },
        { title: "类型", key: "type", width: 140 },
        { title: "启用", key: "enabled", width: 100, render: (row) => row.enabled ? "是" : "否" },
        {
          title: "操作",
          key: "actions",
          width: 260,
          render(row) {
            return vue.h("div", { style: "display:flex; gap:8px;" }, [
              vue.h(
                naiveUi.NButton,
                { size: "small", onClick: () => handleTest(row) },
                { default: () => "测试" }
              ),
              vue.h(
                naiveUi.NButton,
                { size: "small", onClick: () => openEdit(row) },
                { default: () => "编辑" }
              ),
              vue.h(
                naiveUi.NButton,
                { size: "small", type: "error", onClick: () => handleDelete(row) },
                { default: () => "删除" }
              )
            ]);
          }
        }
      ];
      async function loadNodes() {
        loading.value = true;
        try {
          nodes.value = await nodesApi.list();
        } finally {
          loading.value = false;
        }
      }
      function openCreate() {
        isEdit.value = false;
        modalTitle.value = "新增节点";
        form.value = emptyForm();
        showModal.value = true;
      }
      function openEdit(row) {
        isEdit.value = true;
        modalTitle.value = "编辑节点";
        form.value = JSON.parse(JSON.stringify(row));
        showModal.value = true;
      }
      async function handleSave() {
        var _a2, _b2, _c2, _d2;
        saving.value = true;
        try {
          const t = form.value.type;
          if (!form.value.config) form.value.config = {};
          form.value.config.type = t;
          if (t === "local") {
            form.value.config = { type: "local" };
          } else if (t === "ssh") {
            (_a2 = form.value.config).port ?? (_a2.port = 22);
            (_b2 = form.value.config).authType ?? (_b2.authType = "PASSWORD");
            (_c2 = form.value.config).timeoutSeconds ?? (_c2.timeoutSeconds = 30);
          } else if (t === "docker-api") {
            (_d2 = form.value.config).dockerTlsVerify ?? (_d2.dockerTlsVerify = false);
          }
          await nodesApi.save(form.value);
          message.success("保存成功");
          showModal.value = false;
          await loadNodes();
        } finally {
          saving.value = false;
        }
      }
      async function handleDelete(row) {
        dialog.warning({
          title: "确认删除",
          content: `确定删除节点 ${row.nodeId} 吗？`,
          positiveText: "删除",
          negativeText: "取消",
          onPositiveClick: async () => {
            await nodesApi.delete(row.nodeId);
            message.success("删除成功");
            await loadNodes();
          }
        });
      }
      async function handleTest(row) {
        const ok = await nodesApi.test(row.nodeId);
        if (ok) message.success("连接成功");
        else message.warning("连接失败");
      }
      vue.onMounted(() => {
        loadNodes();
      });
      return (_ctx, _cache) => {
        const _component_PageHeader = vue.resolveComponent("PageHeader");
        const _component_n_data_table = vue.resolveComponent("n-data-table");
        const _component_n_card = vue.resolveComponent("n-card");
        const _component_n_input = vue.resolveComponent("n-input");
        const _component_n_form_item = vue.resolveComponent("n-form-item");
        const _component_n_select = vue.resolveComponent("n-select");
        const _component_n_input_number = vue.resolveComponent("n-input-number");
        const _component_n_form = vue.resolveComponent("n-form");
        const _component_n_modal = vue.resolveComponent("n-modal");
        return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$3, [
          vue.createVNode(_component_PageHeader, {
            title: "节点管理",
            subtitle: "管理用于远程部署的节点（local/ssh/docker-api）"
          }, {
            actions: vue.withCtx(() => [
              vue.createVNode(vue.unref(naiveUi.NButton), {
                type: "primary",
                onClick: openCreate
              }, {
                default: vue.withCtx(() => [..._cache[18] || (_cache[18] = [
                  vue.createTextVNode(" 新增节点 ", -1)
                ])]),
                _: 1
              }),
              vue.createVNode(vue.unref(naiveUi.NButton), {
                loading: loading.value,
                onClick: loadNodes
              }, {
                default: vue.withCtx(() => [..._cache[19] || (_cache[19] = [
                  vue.createTextVNode("刷新", -1)
                ])]),
                _: 1
              }, 8, ["loading"])
            ]),
            _: 1
          }),
          vue.createElementVNode("div", _hoisted_2$3, [
            vue.createVNode(_component_n_card, null, {
              default: vue.withCtx(() => [
                vue.createVNode(_component_n_data_table, {
                  columns,
                  data: nodes.value,
                  loading: loading.value,
                  pagination: false,
                  "row-key": (row) => row.nodeId,
                  striped: ""
                }, null, 8, ["data", "loading", "row-key"])
              ]),
              _: 1
            })
          ]),
          vue.createVNode(_component_n_modal, {
            show: showModal.value,
            "onUpdate:show": _cache[17] || (_cache[17] = ($event) => showModal.value = $event),
            preset: "card",
            title: modalTitle.value,
            style: { "width": "720px" }
          }, {
            footer: vue.withCtx(() => [
              vue.createElementVNode("div", _hoisted_3$3, [
                vue.createVNode(vue.unref(naiveUi.NButton), {
                  onClick: _cache[16] || (_cache[16] = ($event) => showModal.value = false)
                }, {
                  default: vue.withCtx(() => [..._cache[20] || (_cache[20] = [
                    vue.createTextVNode("取消", -1)
                  ])]),
                  _: 1
                }),
                vue.createVNode(vue.unref(naiveUi.NButton), {
                  type: "primary",
                  loading: saving.value,
                  onClick: handleSave
                }, {
                  default: vue.withCtx(() => [..._cache[21] || (_cache[21] = [
                    vue.createTextVNode("保存", -1)
                  ])]),
                  _: 1
                }, 8, ["loading"])
              ])
            ]),
            default: vue.withCtx(() => [
              vue.createVNode(_component_n_form, {
                ref_key: "formRef",
                ref: formRef,
                model: form.value,
                rules,
                "label-placement": "left",
                "label-width": "120"
              }, {
                default: vue.withCtx(() => [
                  vue.createVNode(_component_n_form_item, {
                    label: "节点ID",
                    path: "nodeId"
                  }, {
                    default: vue.withCtx(() => [
                      vue.createVNode(_component_n_input, {
                        value: form.value.nodeId,
                        "onUpdate:value": _cache[0] || (_cache[0] = ($event) => form.value.nodeId = $event),
                        placeholder: "如 node-001",
                        disabled: isEdit.value
                      }, null, 8, ["value", "disabled"])
                    ]),
                    _: 1
                  }),
                  vue.createVNode(_component_n_form_item, {
                    label: "节点名称",
                    path: "name"
                  }, {
                    default: vue.withCtx(() => [
                      vue.createVNode(_component_n_input, {
                        value: form.value.name,
                        "onUpdate:value": _cache[1] || (_cache[1] = ($event) => form.value.name = $event),
                        placeholder: "可选"
                      }, null, 8, ["value"])
                    ]),
                    _: 1
                  }),
                  vue.createVNode(_component_n_form_item, {
                    label: "类型",
                    path: "type"
                  }, {
                    default: vue.withCtx(() => [
                      vue.createVNode(_component_n_select, {
                        value: form.value.type,
                        "onUpdate:value": _cache[2] || (_cache[2] = ($event) => form.value.type = $event),
                        options: typeOptions
                      }, null, 8, ["value"])
                    ]),
                    _: 1
                  }),
                  vue.createVNode(_component_n_form_item, {
                    label: "启用",
                    path: "enabled"
                  }, {
                    default: vue.withCtx(() => [
                      vue.createVNode(_component_n_select, {
                        value: form.value.enabled,
                        "onUpdate:value": _cache[3] || (_cache[3] = ($event) => form.value.enabled = $event),
                        options: enabledOptions
                      }, null, 8, ["value"])
                    ]),
                    _: 1
                  }),
                  vue.createVNode(_component_n_form_item, {
                    label: "描述",
                    path: "description"
                  }, {
                    default: vue.withCtx(() => [
                      vue.createVNode(_component_n_input, {
                        value: form.value.description,
                        "onUpdate:value": _cache[4] || (_cache[4] = ($event) => form.value.description = $event),
                        type: "textarea",
                        placeholder: "可选"
                      }, null, 8, ["value"])
                    ]),
                    _: 1
                  }),
                  form.value.type === "ssh" ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
                    vue.createVNode(_component_n_form_item, {
                      label: "Host",
                      path: "config.host"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(_component_n_input, {
                          value: form.value.config.host,
                          "onUpdate:value": _cache[5] || (_cache[5] = ($event) => form.value.config.host = $event),
                          placeholder: "192.168.1.100"
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    vue.createVNode(_component_n_form_item, {
                      label: "Port",
                      path: "config.port"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(_component_n_input_number, {
                          value: form.value.config.port,
                          "onUpdate:value": _cache[6] || (_cache[6] = ($event) => form.value.config.port = $event),
                          min: 1,
                          max: 65535
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    vue.createVNode(_component_n_form_item, {
                      label: "用户名",
                      path: "config.username"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(_component_n_input, {
                          value: form.value.config.username,
                          "onUpdate:value": _cache[7] || (_cache[7] = ($event) => form.value.config.username = $event),
                          placeholder: "root"
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    vue.createVNode(_component_n_form_item, {
                      label: "认证方式",
                      path: "config.authType"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(_component_n_select, {
                          value: form.value.config.authType,
                          "onUpdate:value": _cache[8] || (_cache[8] = ($event) => form.value.config.authType = $event),
                          options: sshAuthOptions
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    form.value.config.authType === "PASSWORD" ? (vue.openBlock(), vue.createBlock(_component_n_form_item, {
                      key: 0,
                      label: "密码",
                      path: "config.password"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(_component_n_input, {
                          value: form.value.config.password,
                          "onUpdate:value": _cache[9] || (_cache[9] = ($event) => form.value.config.password = $event),
                          type: "password"
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    })) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
                      vue.createVNode(_component_n_form_item, {
                        label: "私钥",
                        path: "config.privateKey"
                      }, {
                        default: vue.withCtx(() => [
                          vue.createVNode(_component_n_input, {
                            value: form.value.config.privateKey,
                            "onUpdate:value": _cache[10] || (_cache[10] = ($event) => form.value.config.privateKey = $event),
                            type: "textarea",
                            placeholder: "-----BEGIN ...-----"
                          }, null, 8, ["value"])
                        ]),
                        _: 1
                      }),
                      vue.createVNode(_component_n_form_item, {
                        label: "私钥密码",
                        path: "config.passphrase"
                      }, {
                        default: vue.withCtx(() => [
                          vue.createVNode(_component_n_input, {
                            value: form.value.config.passphrase,
                            "onUpdate:value": _cache[11] || (_cache[11] = ($event) => form.value.config.passphrase = $event),
                            type: "password",
                            placeholder: "可选"
                          }, null, 8, ["value"])
                        ]),
                        _: 1
                      })
                    ], 64)),
                    vue.createVNode(_component_n_form_item, {
                      label: "超时(秒)",
                      path: "config.timeoutSeconds"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(_component_n_input_number, {
                          value: form.value.config.timeoutSeconds,
                          "onUpdate:value": _cache[12] || (_cache[12] = ($event) => form.value.config.timeoutSeconds = $event),
                          min: 10,
                          max: 3600
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    })
                  ], 64)) : form.value.type === "docker-api" ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
                    vue.createVNode(_component_n_form_item, {
                      label: "DOCKER_HOST",
                      path: "config.dockerHost"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(_component_n_input, {
                          value: form.value.config.dockerHost,
                          "onUpdate:value": _cache[13] || (_cache[13] = ($event) => form.value.config.dockerHost = $event),
                          placeholder: "tcp://192.168.1.100:2376"
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    vue.createVNode(_component_n_form_item, {
                      label: "TLS Verify",
                      path: "config.dockerTlsVerify"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(_component_n_select, {
                          value: form.value.config.dockerTlsVerify,
                          "onUpdate:value": _cache[14] || (_cache[14] = ($event) => form.value.config.dockerTlsVerify = $event),
                          options: dockerTlsOptions
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    vue.createVNode(_component_n_form_item, {
                      label: "CERT_PATH",
                      path: "config.dockerCertPath"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(_component_n_input, {
                          value: form.value.config.dockerCertPath,
                          "onUpdate:value": _cache[15] || (_cache[15] = ($event) => form.value.config.dockerCertPath = $event),
                          placeholder: "可选，如 /etc/docker/certs"
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    })
                  ], 64)) : vue.createCommentVNode("", true)
                ]),
                _: 1
              }, 8, ["model"])
            ]),
            _: 1
          }, 8, ["show", "title"])
        ]);
      };
    }
  });
  const NodeManagement = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-f5a8cbe7"]]);
  const API_BASE = "/plugins/appstore/monitor";
  const pluginMonitorApi = {
    /**
     * 获取所有插件的监控状态
     */
    getAllStatus() {
      return http.get(`${API_BASE}/status`);
    },
    /**
     * 获取单个插件的详细监控信息
     */
    getDetail(pluginId) {
      return http.get(`${API_BASE}/status/${pluginId}`);
    },
    /**
     * 获取插件历史监控数据
     * @param pluginId 插件ID
     * @param timeRange 时间范围，如 "1h", "24h", "7d"，默认 "1h"
     */
    getHistory(pluginId, timeRange = "1h") {
      return http.get(`${API_BASE}/history/${pluginId}`, { timeRange });
    },
    /**
     * 获取系统监控概览
     */
    getOverview() {
      return http.get(`${API_BASE}/overview`);
    }
  };
  /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
  
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
  
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var Browser = /* @__PURE__ */ function() {
    function Browser2() {
      this.firefox = false;
      this.ie = false;
      this.edge = false;
      this.newEdge = false;
      this.weChat = false;
    }
    return Browser2;
  }();
  var Env = /* @__PURE__ */ function() {
    function Env2() {
      this.browser = new Browser();
      this.node = false;
      this.wxa = false;
      this.worker = false;
      this.svgSupported = false;
      this.touchEventsSupported = false;
      this.pointerEventsSupported = false;
      this.domSupported = false;
      this.transformSupported = false;
      this.transform3dSupported = false;
      this.hasGlobalWindow = typeof window !== "undefined";
    }
    return Env2;
  }();
  var env = new Env();
  if (typeof wx === "object" && typeof wx.getSystemInfoSync === "function") {
    env.wxa = true;
    env.touchEventsSupported = true;
  } else if (typeof document === "undefined" && typeof self !== "undefined") {
    env.worker = true;
  } else if (!env.hasGlobalWindow || "Deno" in window || typeof navigator !== "undefined" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Node.js") > -1) {
    env.node = true;
    env.svgSupported = true;
  } else {
    detect(navigator.userAgent, env);
  }
  function detect(ua, env2) {
    var browser = env2.browser;
    var firefox = ua.match(/Firefox\/([\d.]+)/);
    var ie = ua.match(/MSIE\s([\d.]+)/) || ua.match(/Trident\/.+?rv:(([\d.]+))/);
    var edge = ua.match(/Edge?\/([\d.]+)/);
    var weChat = /micromessenger/i.test(ua);
    if (firefox) {
      browser.firefox = true;
      browser.version = firefox[1];
    }
    if (ie) {
      browser.ie = true;
      browser.version = ie[1];
    }
    if (edge) {
      browser.edge = true;
      browser.version = edge[1];
      browser.newEdge = +edge[1].split(".")[0] > 18;
    }
    if (weChat) {
      browser.weChat = true;
    }
    env2.svgSupported = typeof SVGRect !== "undefined";
    env2.touchEventsSupported = "ontouchstart" in window && !browser.ie && !browser.edge;
    env2.pointerEventsSupported = "onpointerdown" in window && (browser.edge || browser.ie && +browser.version >= 11);
    var domSupported = env2.domSupported = typeof document !== "undefined";
    if (domSupported) {
      var style = document.documentElement.style;
      env2.transform3dSupported = (browser.ie && "transition" in style || browser.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in style) && !("OTransition" in style);
      env2.transformSupported = env2.transform3dSupported || browser.ie && +browser.version >= 9;
    }
  }
  var DEFAULT_FONT_SIZE = 12;
  var DEFAULT_FONT_FAMILY = "sans-serif";
  var DEFAULT_FONT = DEFAULT_FONT_SIZE + "px " + DEFAULT_FONT_FAMILY;
  var OFFSET = 20;
  var SCALE = 100;
  var defaultWidthMapStr = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
  function getTextWidthMap(mapStr) {
    var map2 = {};
    if (typeof JSON === "undefined") {
      return map2;
    }
    for (var i = 0; i < mapStr.length; i++) {
      var char = String.fromCharCode(i + 32);
      var size = (mapStr.charCodeAt(i) - OFFSET) / SCALE;
      map2[char] = size;
    }
    return map2;
  }
  var DEFAULT_TEXT_WIDTH_MAP = getTextWidthMap(defaultWidthMapStr);
  var platformApi = {
    createCanvas: function() {
      return typeof document !== "undefined" && document.createElement("canvas");
    },
    measureText: /* @__PURE__ */ function() {
      var _ctx;
      var _cachedFont;
      return function(text, font) {
        if (!_ctx) {
          var canvas = platformApi.createCanvas();
          _ctx = canvas && canvas.getContext("2d");
        }
        if (_ctx) {
          if (_cachedFont !== font) {
            _cachedFont = _ctx.font = font || DEFAULT_FONT;
          }
          return _ctx.measureText(text);
        } else {
          text = text || "";
          font = font || DEFAULT_FONT;
          var res = /((?:\d+)?\.?\d*)px/.exec(font);
          var fontSize = res && +res[1] || DEFAULT_FONT_SIZE;
          var width = 0;
          if (font.indexOf("mono") >= 0) {
            width = fontSize * text.length;
          } else {
            for (var i = 0; i < text.length; i++) {
              var preCalcWidth = DEFAULT_TEXT_WIDTH_MAP[text[i]];
              width += preCalcWidth == null ? fontSize : preCalcWidth * fontSize;
            }
          }
          return { width };
        }
      };
    }(),
    loadImage: function(src, onload, onerror) {
      var image = new Image();
      image.onload = onload;
      image.onerror = onerror;
      image.src = src;
      return image;
    }
  };
  var BUILTIN_OBJECT = reduce([
    "Function",
    "RegExp",
    "Date",
    "Error",
    "CanvasGradient",
    "CanvasPattern",
    "Image",
    "Canvas"
  ], function(obj, val) {
    obj["[object " + val + "]"] = true;
    return obj;
  }, {});
  var TYPED_ARRAY = reduce([
    "Int8",
    "Uint8",
    "Uint8Clamped",
    "Int16",
    "Uint16",
    "Int32",
    "Uint32",
    "Float32",
    "Float64"
  ], function(obj, val) {
    obj["[object " + val + "Array]"] = true;
    return obj;
  }, {});
  var objToString = Object.prototype.toString;
  var arrayProto = Array.prototype;
  var nativeForEach = arrayProto.forEach;
  var nativeFilter = arrayProto.filter;
  var nativeSlice = arrayProto.slice;
  var nativeMap = arrayProto.map;
  var ctorFunction = (function() {
  }).constructor;
  var protoFunction = ctorFunction ? ctorFunction.prototype : null;
  var protoKey = "__proto__";
  var idStart = 2311;
  function guid() {
    return idStart++;
  }
  function logError() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (typeof console !== "undefined") {
      console.error.apply(console, args);
    }
  }
  function clone$2(source) {
    if (source == null || typeof source !== "object") {
      return source;
    }
    var result = source;
    var typeStr = objToString.call(source);
    if (typeStr === "[object Array]") {
      if (!isPrimitive(source)) {
        result = [];
        for (var i = 0, len2 = source.length; i < len2; i++) {
          result[i] = clone$2(source[i]);
        }
      }
    } else if (TYPED_ARRAY[typeStr]) {
      if (!isPrimitive(source)) {
        var Ctor = source.constructor;
        if (Ctor.from) {
          result = Ctor.from(source);
        } else {
          result = new Ctor(source.length);
          for (var i = 0, len2 = source.length; i < len2; i++) {
            result[i] = source[i];
          }
        }
      }
    } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
      result = {};
      for (var key2 in source) {
        if (source.hasOwnProperty(key2) && key2 !== protoKey) {
          result[key2] = clone$2(source[key2]);
        }
      }
    }
    return result;
  }
  function merge(target, source, overwrite) {
    if (!isObject$2(source) || !isObject$2(target)) {
      return overwrite ? clone$2(source) : target;
    }
    for (var key2 in source) {
      if (source.hasOwnProperty(key2) && key2 !== protoKey) {
        var targetProp = target[key2];
        var sourceProp = source[key2];
        if (isObject$2(sourceProp) && isObject$2(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
          merge(targetProp, sourceProp, overwrite);
        } else if (overwrite || !(key2 in target)) {
          target[key2] = clone$2(source[key2]);
        }
      }
    }
    return target;
  }
  function extend(target, source) {
    if (Object.assign) {
      Object.assign(target, source);
    } else {
      for (var key2 in source) {
        if (source.hasOwnProperty(key2) && key2 !== protoKey) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  }
  function defaults(target, source, overlay) {
    var keysArr = keys(source);
    for (var i = 0, len2 = keysArr.length; i < len2; i++) {
      var key2 = keysArr[i];
      if (target[key2] == null) {
        target[key2] = source[key2];
      }
    }
    return target;
  }
  function indexOf(array, value) {
    if (array) {
      if (array.indexOf) {
        return array.indexOf(value);
      }
      for (var i = 0, len2 = array.length; i < len2; i++) {
        if (array[i] === value) {
          return i;
        }
      }
    }
    return -1;
  }
  function inherits(clazz, baseClazz) {
    var clazzPrototype = clazz.prototype;
    function F() {
    }
    F.prototype = baseClazz.prototype;
    clazz.prototype = new F();
    for (var prop in clazzPrototype) {
      if (clazzPrototype.hasOwnProperty(prop)) {
        clazz.prototype[prop] = clazzPrototype[prop];
      }
    }
    clazz.prototype.constructor = clazz;
    clazz.superClass = baseClazz;
  }
  function mixin(target, source, override) {
    target = "prototype" in target ? target.prototype : target;
    source = "prototype" in source ? source.prototype : source;
    if (Object.getOwnPropertyNames) {
      var keyList = Object.getOwnPropertyNames(source);
      for (var i = 0; i < keyList.length; i++) {
        var key2 = keyList[i];
        if (key2 !== "constructor") {
          if (target[key2] == null) {
            target[key2] = source[key2];
          }
        }
      }
    } else {
      defaults(target, source);
    }
  }
  function isArrayLike(data) {
    if (!data) {
      return false;
    }
    if (typeof data === "string") {
      return false;
    }
    return typeof data.length === "number";
  }
  function each$5(arr, cb, context) {
    if (!(arr && cb)) {
      return;
    }
    if (arr.forEach && arr.forEach === nativeForEach) {
      arr.forEach(cb, context);
    } else if (arr.length === +arr.length) {
      for (var i = 0, len2 = arr.length; i < len2; i++) {
        cb.call(context, arr[i], i, arr);
      }
    } else {
      for (var key2 in arr) {
        if (arr.hasOwnProperty(key2)) {
          cb.call(context, arr[key2], key2, arr);
        }
      }
    }
  }
  function map$1(arr, cb, context) {
    if (!arr) {
      return [];
    }
    if (!cb) {
      return slice(arr);
    }
    if (arr.map && arr.map === nativeMap) {
      return arr.map(cb, context);
    } else {
      var result = [];
      for (var i = 0, len2 = arr.length; i < len2; i++) {
        result.push(cb.call(context, arr[i], i, arr));
      }
      return result;
    }
  }
  function reduce(arr, cb, memo, context) {
    if (!(arr && cb)) {
      return;
    }
    for (var i = 0, len2 = arr.length; i < len2; i++) {
      memo = cb.call(context, memo, arr[i], i, arr);
    }
    return memo;
  }
  function filter(arr, cb, context) {
    if (!arr) {
      return [];
    }
    if (!cb) {
      return slice(arr);
    }
    if (arr.filter && arr.filter === nativeFilter) {
      return arr.filter(cb, context);
    } else {
      var result = [];
      for (var i = 0, len2 = arr.length; i < len2; i++) {
        if (cb.call(context, arr[i], i, arr)) {
          result.push(arr[i]);
        }
      }
      return result;
    }
  }
  function find(arr, cb, context) {
    if (!(arr && cb)) {
      return;
    }
    for (var i = 0, len2 = arr.length; i < len2; i++) {
      if (cb.call(context, arr[i], i, arr)) {
        return arr[i];
      }
    }
  }
  function keys(obj) {
    if (!obj) {
      return [];
    }
    if (Object.keys) {
      return Object.keys(obj);
    }
    var keyList = [];
    for (var key2 in obj) {
      if (obj.hasOwnProperty(key2)) {
        keyList.push(key2);
      }
    }
    return keyList;
  }
  function bindPolyfill(func, context) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    return function() {
      return func.apply(context, args.concat(nativeSlice.call(arguments)));
    };
  }
  var bind$1 = protoFunction && isFunction(protoFunction.bind) ? protoFunction.call.bind(protoFunction.bind) : bindPolyfill;
  function curry$1(func) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    return function() {
      return func.apply(this, args.concat(nativeSlice.call(arguments)));
    };
  }
  function isArray(value) {
    if (Array.isArray) {
      return Array.isArray(value);
    }
    return objToString.call(value) === "[object Array]";
  }
  function isFunction(value) {
    return typeof value === "function";
  }
  function isString(value) {
    return typeof value === "string";
  }
  function isStringSafe(value) {
    return objToString.call(value) === "[object String]";
  }
  function isNumber(value) {
    return typeof value === "number";
  }
  function isObject$2(value) {
    var type = typeof value;
    return type === "function" || !!value && type === "object";
  }
  function isBuiltInObject(value) {
    return !!BUILTIN_OBJECT[objToString.call(value)];
  }
  function isTypedArray(value) {
    return !!TYPED_ARRAY[objToString.call(value)];
  }
  function isDom(value) {
    return typeof value === "object" && typeof value.nodeType === "number" && typeof value.ownerDocument === "object";
  }
  function isGradientObject(value) {
    return value.colorStops != null;
  }
  function isImagePatternObject(value) {
    return value.image != null;
  }
  function isRegExp(value) {
    return objToString.call(value) === "[object RegExp]";
  }
  function eqNaN(value) {
    return value !== value;
  }
  function retrieve() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    for (var i = 0, len2 = args.length; i < len2; i++) {
      if (args[i] != null) {
        return args[i];
      }
    }
  }
  function retrieve2(value0, value1) {
    return value0 != null ? value0 : value1;
  }
  function retrieve3(value0, value1, value2) {
    return value0 != null ? value0 : value1 != null ? value1 : value2;
  }
  function slice(arr) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    return nativeSlice.apply(arr, args);
  }
  function normalizeCssArray$1(val) {
    if (typeof val === "number") {
      return [val, val, val, val];
    }
    var len2 = val.length;
    if (len2 === 2) {
      return [val[0], val[1], val[0], val[1]];
    } else if (len2 === 3) {
      return [val[0], val[1], val[2], val[1]];
    }
    return val;
  }
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  }
  function trim(str) {
    if (str == null) {
      return null;
    } else if (typeof str.trim === "function") {
      return str.trim();
    } else {
      return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    }
  }
  var primitiveKey = "__ec_primitive__";
  function setAsPrimitive(obj) {
    obj[primitiveKey] = true;
  }
  function isPrimitive(obj) {
    return obj[primitiveKey];
  }
  var MapPolyfill = function() {
    function MapPolyfill2() {
      this.data = {};
    }
    MapPolyfill2.prototype["delete"] = function(key2) {
      var existed = this.has(key2);
      if (existed) {
        delete this.data[key2];
      }
      return existed;
    };
    MapPolyfill2.prototype.has = function(key2) {
      return this.data.hasOwnProperty(key2);
    };
    MapPolyfill2.prototype.get = function(key2) {
      return this.data[key2];
    };
    MapPolyfill2.prototype.set = function(key2, value) {
      this.data[key2] = value;
      return this;
    };
    MapPolyfill2.prototype.keys = function() {
      return keys(this.data);
    };
    MapPolyfill2.prototype.forEach = function(callback) {
      var data = this.data;
      for (var key2 in data) {
        if (data.hasOwnProperty(key2)) {
          callback(data[key2], key2);
        }
      }
    };
    return MapPolyfill2;
  }();
  var isNativeMapSupported = typeof Map === "function";
  function maybeNativeMap() {
    return isNativeMapSupported ? /* @__PURE__ */ new Map() : new MapPolyfill();
  }
  var HashMap = function() {
    function HashMap2(obj) {
      var isArr = isArray(obj);
      this.data = maybeNativeMap();
      var thisMap = this;
      obj instanceof HashMap2 ? obj.each(visit) : obj && each$5(obj, visit);
      function visit(value, key2) {
        isArr ? thisMap.set(value, key2) : thisMap.set(key2, value);
      }
    }
    HashMap2.prototype.hasKey = function(key2) {
      return this.data.has(key2);
    };
    HashMap2.prototype.get = function(key2) {
      return this.data.get(key2);
    };
    HashMap2.prototype.set = function(key2, value) {
      this.data.set(key2, value);
      return value;
    };
    HashMap2.prototype.each = function(cb, context) {
      this.data.forEach(function(value, key2) {
        cb.call(context, value, key2);
      });
    };
    HashMap2.prototype.keys = function() {
      var keys2 = this.data.keys();
      return isNativeMapSupported ? Array.from(keys2) : keys2;
    };
    HashMap2.prototype.removeKey = function(key2) {
      this.data["delete"](key2);
    };
    return HashMap2;
  }();
  function createHashMap(obj) {
    return new HashMap(obj);
  }
  function concatArray(a, b) {
    var newArray = new a.constructor(a.length + b.length);
    for (var i = 0; i < a.length; i++) {
      newArray[i] = a[i];
    }
    var offset = a.length;
    for (var i = 0; i < b.length; i++) {
      newArray[i + offset] = b[i];
    }
    return newArray;
  }
  function createObject(proto, properties) {
    var obj;
    if (Object.create) {
      obj = Object.create(proto);
    } else {
      var StyleCtor = function() {
      };
      StyleCtor.prototype = proto;
      obj = new StyleCtor();
    }
    if (properties) {
      extend(obj, properties);
    }
    return obj;
  }
  function disableUserSelect(dom) {
    var domStyle = dom.style;
    domStyle.webkitUserSelect = "none";
    domStyle.userSelect = "none";
    domStyle.webkitTapHighlightColor = "rgba(0,0,0,0)";
    domStyle["-webkit-touch-callout"] = "none";
  }
  function hasOwn(own, prop) {
    return own.hasOwnProperty(prop);
  }
  function noop() {
  }
  var RADIAN_TO_DEGREE = 180 / Math.PI;
  function create$1(x, y) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    return [x, y];
  }
  function clone$1(v) {
    return [v[0], v[1]];
  }
  function add(out2, v1, v2) {
    out2[0] = v1[0] + v2[0];
    out2[1] = v1[1] + v2[1];
    return out2;
  }
  function sub(out2, v1, v2) {
    out2[0] = v1[0] - v2[0];
    out2[1] = v1[1] - v2[1];
    return out2;
  }
  function len(v) {
    return Math.sqrt(lenSquare(v));
  }
  function lenSquare(v) {
    return v[0] * v[0] + v[1] * v[1];
  }
  function scale$2(out2, v, s) {
    out2[0] = v[0] * s;
    out2[1] = v[1] * s;
    return out2;
  }
  function normalize$1(out2, v) {
    var d = len(v);
    if (d === 0) {
      out2[0] = 0;
      out2[1] = 0;
    } else {
      out2[0] = v[0] / d;
      out2[1] = v[1] / d;
    }
    return out2;
  }
  function distance(v1, v2) {
    return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
  }
  var dist$1 = distance;
  function distanceSquare(v1, v2) {
    return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
  }
  var distSquare = distanceSquare;
  function applyTransform$1(out2, v, m2) {
    var x = v[0];
    var y = v[1];
    out2[0] = m2[0] * x + m2[2] * y + m2[4];
    out2[1] = m2[1] * x + m2[3] * y + m2[5];
    return out2;
  }
  function min$1(out2, v1, v2) {
    out2[0] = Math.min(v1[0], v2[0]);
    out2[1] = Math.min(v1[1], v2[1]);
    return out2;
  }
  function max$1(out2, v1, v2) {
    out2[0] = Math.max(v1[0], v2[0]);
    out2[1] = Math.max(v1[1], v2[1]);
    return out2;
  }
  var Param = /* @__PURE__ */ function() {
    function Param2(target, e2) {
      this.target = target;
      this.topTarget = e2 && e2.topTarget;
    }
    return Param2;
  }();
  var Draggable = function() {
    function Draggable2(handler) {
      this.handler = handler;
      handler.on("mousedown", this._dragStart, this);
      handler.on("mousemove", this._drag, this);
      handler.on("mouseup", this._dragEnd, this);
    }
    Draggable2.prototype._dragStart = function(e2) {
      var draggingTarget = e2.target;
      while (draggingTarget && !draggingTarget.draggable) {
        draggingTarget = draggingTarget.parent || draggingTarget.__hostTarget;
      }
      if (draggingTarget) {
        this._draggingTarget = draggingTarget;
        draggingTarget.dragging = true;
        this._x = e2.offsetX;
        this._y = e2.offsetY;
        this.handler.dispatchToElement(new Param(draggingTarget, e2), "dragstart", e2.event);
      }
    };
    Draggable2.prototype._drag = function(e2) {
      var draggingTarget = this._draggingTarget;
      if (draggingTarget) {
        var x = e2.offsetX;
        var y = e2.offsetY;
        var dx = x - this._x;
        var dy = y - this._y;
        this._x = x;
        this._y = y;
        draggingTarget.drift(dx, dy, e2);
        this.handler.dispatchToElement(new Param(draggingTarget, e2), "drag", e2.event);
        var dropTarget = this.handler.findHover(x, y, draggingTarget).target;
        var lastDropTarget = this._dropTarget;
        this._dropTarget = dropTarget;
        if (draggingTarget !== dropTarget) {
          if (lastDropTarget && dropTarget !== lastDropTarget) {
            this.handler.dispatchToElement(new Param(lastDropTarget, e2), "dragleave", e2.event);
          }
          if (dropTarget && dropTarget !== lastDropTarget) {
            this.handler.dispatchToElement(new Param(dropTarget, e2), "dragenter", e2.event);
          }
        }
      }
    };
    Draggable2.prototype._dragEnd = function(e2) {
      var draggingTarget = this._draggingTarget;
      if (draggingTarget) {
        draggingTarget.dragging = false;
      }
      this.handler.dispatchToElement(new Param(draggingTarget, e2), "dragend", e2.event);
      if (this._dropTarget) {
        this.handler.dispatchToElement(new Param(this._dropTarget, e2), "drop", e2.event);
      }
      this._draggingTarget = null;
      this._dropTarget = null;
    };
    return Draggable2;
  }();
  var Eventful = function() {
    function Eventful2(eventProcessors) {
      if (eventProcessors) {
        this._$eventProcessor = eventProcessors;
      }
    }
    Eventful2.prototype.on = function(event, query, handler, context) {
      if (!this._$handlers) {
        this._$handlers = {};
      }
      var _h = this._$handlers;
      if (typeof query === "function") {
        context = handler;
        handler = query;
        query = null;
      }
      if (!handler || !event) {
        return this;
      }
      var eventProcessor = this._$eventProcessor;
      if (query != null && eventProcessor && eventProcessor.normalizeQuery) {
        query = eventProcessor.normalizeQuery(query);
      }
      if (!_h[event]) {
        _h[event] = [];
      }
      for (var i = 0; i < _h[event].length; i++) {
        if (_h[event][i].h === handler) {
          return this;
        }
      }
      var wrap = {
        h: handler,
        query,
        ctx: context || this,
        callAtLast: handler.zrEventfulCallAtLast
      };
      var lastIndex = _h[event].length - 1;
      var lastWrap = _h[event][lastIndex];
      lastWrap && lastWrap.callAtLast ? _h[event].splice(lastIndex, 0, wrap) : _h[event].push(wrap);
      return this;
    };
    Eventful2.prototype.isSilent = function(eventName) {
      var _h = this._$handlers;
      return !_h || !_h[eventName] || !_h[eventName].length;
    };
    Eventful2.prototype.off = function(eventType, handler) {
      var _h = this._$handlers;
      if (!_h) {
        return this;
      }
      if (!eventType) {
        this._$handlers = {};
        return this;
      }
      if (handler) {
        if (_h[eventType]) {
          var newList = [];
          for (var i = 0, l = _h[eventType].length; i < l; i++) {
            if (_h[eventType][i].h !== handler) {
              newList.push(_h[eventType][i]);
            }
          }
          _h[eventType] = newList;
        }
        if (_h[eventType] && _h[eventType].length === 0) {
          delete _h[eventType];
        }
      } else {
        delete _h[eventType];
      }
      return this;
    };
    Eventful2.prototype.trigger = function(eventType) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      if (!this._$handlers) {
        return this;
      }
      var _h = this._$handlers[eventType];
      var eventProcessor = this._$eventProcessor;
      if (_h) {
        var argLen = args.length;
        var len2 = _h.length;
        for (var i = 0; i < len2; i++) {
          var hItem = _h[i];
          if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(eventType, hItem.query)) {
            continue;
          }
          switch (argLen) {
            case 0:
              hItem.h.call(hItem.ctx);
              break;
            case 1:
              hItem.h.call(hItem.ctx, args[0]);
              break;
            case 2:
              hItem.h.call(hItem.ctx, args[0], args[1]);
              break;
            default:
              hItem.h.apply(hItem.ctx, args);
              break;
          }
        }
      }
      eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(eventType);
      return this;
    };
    Eventful2.prototype.triggerWithContext = function(type) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      if (!this._$handlers) {
        return this;
      }
      var _h = this._$handlers[type];
      var eventProcessor = this._$eventProcessor;
      if (_h) {
        var argLen = args.length;
        var ctx = args[argLen - 1];
        var len2 = _h.length;
        for (var i = 0; i < len2; i++) {
          var hItem = _h[i];
          if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
            continue;
          }
          switch (argLen) {
            case 0:
              hItem.h.call(ctx);
              break;
            case 1:
              hItem.h.call(ctx, args[0]);
              break;
            case 2:
              hItem.h.call(ctx, args[0], args[1]);
              break;
            default:
              hItem.h.apply(ctx, args.slice(1, argLen - 1));
              break;
          }
        }
      }
      eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
      return this;
    };
    return Eventful2;
  }();
  var LN2 = Math.log(2);
  function determinant(rows, rank, rowStart, rowMask, colMask, detCache) {
    var cacheKey = rowMask + "-" + colMask;
    var fullRank = rows.length;
    if (detCache.hasOwnProperty(cacheKey)) {
      return detCache[cacheKey];
    }
    if (rank === 1) {
      var colStart = Math.round(Math.log((1 << fullRank) - 1 & ~colMask) / LN2);
      return rows[rowStart][colStart];
    }
    var subRowMask = rowMask | 1 << rowStart;
    var subRowStart = rowStart + 1;
    while (rowMask & 1 << subRowStart) {
      subRowStart++;
    }
    var sum = 0;
    for (var j = 0, colLocalIdx = 0; j < fullRank; j++) {
      var colTag = 1 << j;
      if (!(colTag & colMask)) {
        sum += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j] * determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache);
        colLocalIdx++;
      }
    }
    detCache[cacheKey] = sum;
    return sum;
  }
  function buildTransformer(src, dest) {
    var mA = [
      [src[0], src[1], 1, 0, 0, 0, -dest[0] * src[0], -dest[0] * src[1]],
      [0, 0, 0, src[0], src[1], 1, -dest[1] * src[0], -dest[1] * src[1]],
      [src[2], src[3], 1, 0, 0, 0, -dest[2] * src[2], -dest[2] * src[3]],
      [0, 0, 0, src[2], src[3], 1, -dest[3] * src[2], -dest[3] * src[3]],
      [src[4], src[5], 1, 0, 0, 0, -dest[4] * src[4], -dest[4] * src[5]],
      [0, 0, 0, src[4], src[5], 1, -dest[5] * src[4], -dest[5] * src[5]],
      [src[6], src[7], 1, 0, 0, 0, -dest[6] * src[6], -dest[6] * src[7]],
      [0, 0, 0, src[6], src[7], 1, -dest[7] * src[6], -dest[7] * src[7]]
    ];
    var detCache = {};
    var det = determinant(mA, 8, 0, 0, 0, detCache);
    if (det === 0) {
      return;
    }
    var vh = [];
    for (var i = 0; i < 8; i++) {
      for (var j = 0; j < 8; j++) {
        vh[j] == null && (vh[j] = 0);
        vh[j] += ((i + j) % 2 ? -1 : 1) * determinant(mA, 7, i === 0 ? 1 : 0, 1 << i, 1 << j, detCache) / det * dest[i];
      }
    }
    return function(out2, srcPointX, srcPointY) {
      var pk = srcPointX * vh[6] + srcPointY * vh[7] + 1;
      out2[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk;
      out2[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk;
    };
  }
  var EVENT_SAVED_PROP = "___zrEVENTSAVED";
  var _calcOut$1 = [];
  function transformLocalCoord(out2, elFrom, elTarget, inX, inY) {
    return transformCoordWithViewport(_calcOut$1, elFrom, inX, inY, true) && transformCoordWithViewport(out2, elTarget, _calcOut$1[0], _calcOut$1[1]);
  }
  function transformLocalCoordClear(elFrom, elTarget) {
    elFrom && dealClear(elFrom);
    elTarget && dealClear(elTarget);
    function dealClear(el) {
      var saved = el[EVENT_SAVED_PROP];
      if (saved) {
        saved.clearMarkers && saved.clearMarkers();
        delete el[EVENT_SAVED_PROP];
      }
    }
  }
  function transformCoordWithViewport(out2, el, inX, inY, inverse) {
    if (el.getBoundingClientRect && env.domSupported && !isCanvasEl(el)) {
      var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});
      var markers = prepareCoordMarkers(el, saved);
      var transformer = preparePointerTransformer(markers, saved, inverse);
      if (transformer) {
        transformer(out2, inX, inY);
        return true;
      }
    }
    return false;
  }
  function prepareCoordMarkers(el, saved) {
    var markers = saved.markers;
    if (markers) {
      return markers;
    }
    markers = saved.markers = [];
    var propLR = ["left", "right"];
    var propTB = ["top", "bottom"];
    for (var i = 0; i < 4; i++) {
      var marker = document.createElement("div");
      var stl = marker.style;
      var idxLR = i % 2;
      var idxTB = (i >> 1) % 2;
      stl.cssText = [
        "position: absolute",
        "visibility: hidden",
        "padding: 0",
        "margin: 0",
        "border-width: 0",
        "user-select: none",
        "width:0",
        "height:0",
        propLR[idxLR] + ":0",
        propTB[idxTB] + ":0",
        propLR[1 - idxLR] + ":auto",
        propTB[1 - idxTB] + ":auto",
        ""
      ].join("!important;");
      el.appendChild(marker);
      markers.push(marker);
    }
    saved.clearMarkers = function() {
      each$5(markers, function(marker2) {
        marker2.parentNode && marker2.parentNode.removeChild(marker2);
      });
    };
    return markers;
  }
  function preparePointerTransformer(markers, saved, inverse) {
    var transformerName = inverse ? "invTrans" : "trans";
    var transformer = saved[transformerName];
    var oldSrcCoords = saved.srcCoords;
    var srcCoords = [];
    var destCoords = [];
    var oldCoordTheSame = true;
    for (var i = 0; i < 4; i++) {
      var rect = markers[i].getBoundingClientRect();
      var ii = 2 * i;
      var x = rect.left;
      var y = rect.top;
      srcCoords.push(x, y);
      oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1];
      destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);
    }
    return oldCoordTheSame && transformer ? transformer : (saved.srcCoords = srcCoords, saved[transformerName] = inverse ? buildTransformer(destCoords, srcCoords) : buildTransformer(srcCoords, destCoords));
  }
  function isCanvasEl(el) {
    return el.nodeName.toUpperCase() === "CANVAS";
  }
  var replaceReg = /([&<>"'])/g;
  var replaceMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  function encodeHTML(source) {
    return source == null ? "" : (source + "").replace(replaceReg, function(str, c) {
      return replaceMap[c];
    });
  }
  var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
  var _calcOut = [];
  var firefoxNotSupportOffsetXY = env.browser.firefox && +env.browser.version.split(".")[0] < 39;
  function clientToLocal(el, e2, out2, calculate) {
    out2 = out2 || {};
    if (calculate) {
      calculateZrXY(el, e2, out2);
    } else if (firefoxNotSupportOffsetXY && e2.layerX != null && e2.layerX !== e2.offsetX) {
      out2.zrX = e2.layerX;
      out2.zrY = e2.layerY;
    } else if (e2.offsetX != null) {
      out2.zrX = e2.offsetX;
      out2.zrY = e2.offsetY;
    } else {
      calculateZrXY(el, e2, out2);
    }
    return out2;
  }
  function calculateZrXY(el, e2, out2) {
    if (env.domSupported && el.getBoundingClientRect) {
      var ex = e2.clientX;
      var ey = e2.clientY;
      if (isCanvasEl(el)) {
        var box2 = el.getBoundingClientRect();
        out2.zrX = ex - box2.left;
        out2.zrY = ey - box2.top;
        return;
      } else {
        if (transformCoordWithViewport(_calcOut, el, ex, ey)) {
          out2.zrX = _calcOut[0];
          out2.zrY = _calcOut[1];
          return;
        }
      }
    }
    out2.zrX = out2.zrY = 0;
  }
  function getNativeEvent(e2) {
    return e2 || window.event;
  }
  function normalizeEvent(el, e2, calculate) {
    e2 = getNativeEvent(e2);
    if (e2.zrX != null) {
      return e2;
    }
    var eventType = e2.type;
    var isTouch = eventType && eventType.indexOf("touch") >= 0;
    if (!isTouch) {
      clientToLocal(el, e2, e2, calculate);
      var wheelDelta = getWheelDeltaMayPolyfill(e2);
      e2.zrDelta = wheelDelta ? wheelDelta / 120 : -(e2.detail || 0) / 3;
    } else {
      var touch = eventType !== "touchend" ? e2.targetTouches[0] : e2.changedTouches[0];
      touch && clientToLocal(el, touch, e2, calculate);
    }
    var button = e2.button;
    if (e2.which == null && button !== void 0 && MOUSE_EVENT_REG.test(e2.type)) {
      e2.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
    }
    return e2;
  }
  function getWheelDeltaMayPolyfill(e2) {
    var rawWheelDelta = e2.wheelDelta;
    if (rawWheelDelta) {
      return rawWheelDelta;
    }
    var deltaX = e2.deltaX;
    var deltaY = e2.deltaY;
    if (deltaX == null || deltaY == null) {
      return rawWheelDelta;
    }
    var delta = deltaY !== 0 ? Math.abs(deltaY) : Math.abs(deltaX);
    var sign = deltaY > 0 ? -1 : deltaY < 0 ? 1 : deltaX > 0 ? -1 : 1;
    return 3 * delta * sign;
  }
  function addEventListener(el, name, handler, opt) {
    el.addEventListener(name, handler, opt);
  }
  function removeEventListener(el, name, handler, opt) {
    el.removeEventListener(name, handler, opt);
  }
  var stop = function(e2) {
    e2.preventDefault();
    e2.stopPropagation();
    e2.cancelBubble = true;
  };
  function isMiddleOrRightButtonOnMouseUpDown(e2) {
    return e2.which === 2 || e2.which === 3;
  }
  var GestureMgr = function() {
    function GestureMgr2() {
      this._track = [];
    }
    GestureMgr2.prototype.recognize = function(event, target, root) {
      this._doTrack(event, target, root);
      return this._recognize(event);
    };
    GestureMgr2.prototype.clear = function() {
      this._track.length = 0;
      return this;
    };
    GestureMgr2.prototype._doTrack = function(event, target, root) {
      var touches = event.touches;
      if (!touches) {
        return;
      }
      var trackItem = {
        points: [],
        touches: [],
        target,
        event
      };
      for (var i = 0, len2 = touches.length; i < len2; i++) {
        var touch = touches[i];
        var pos = clientToLocal(root, touch, {});
        trackItem.points.push([pos.zrX, pos.zrY]);
        trackItem.touches.push(touch);
      }
      this._track.push(trackItem);
    };
    GestureMgr2.prototype._recognize = function(event) {
      for (var eventName in recognizers) {
        if (recognizers.hasOwnProperty(eventName)) {
          var gestureInfo = recognizers[eventName](this._track, event);
          if (gestureInfo) {
            return gestureInfo;
          }
        }
      }
    };
    return GestureMgr2;
  }();
  function dist(pointPair) {
    var dx = pointPair[1][0] - pointPair[0][0];
    var dy = pointPair[1][1] - pointPair[0][1];
    return Math.sqrt(dx * dx + dy * dy);
  }
  function center(pointPair) {
    return [
      (pointPair[0][0] + pointPair[1][0]) / 2,
      (pointPair[0][1] + pointPair[1][1]) / 2
    ];
  }
  var recognizers = {
    pinch: function(tracks, event) {
      var trackLen = tracks.length;
      if (!trackLen) {
        return;
      }
      var pinchEnd = (tracks[trackLen - 1] || {}).points;
      var pinchPre = (tracks[trackLen - 2] || {}).points || pinchEnd;
      if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
        var pinchScale = dist(pinchEnd) / dist(pinchPre);
        !isFinite(pinchScale) && (pinchScale = 1);
        event.pinchScale = pinchScale;
        var pinchCenter = center(pinchEnd);
        event.pinchX = pinchCenter[0];
        event.pinchY = pinchCenter[1];
        return {
          type: "pinch",
          target: tracks[0].target,
          event
        };
      }
    }
  };
  function create() {
    return [1, 0, 0, 1, 0, 0];
  }
  function identity(out2) {
    out2[0] = 1;
    out2[1] = 0;
    out2[2] = 0;
    out2[3] = 1;
    out2[4] = 0;
    out2[5] = 0;
    return out2;
  }
  function copy(out2, m2) {
    out2[0] = m2[0];
    out2[1] = m2[1];
    out2[2] = m2[2];
    out2[3] = m2[3];
    out2[4] = m2[4];
    out2[5] = m2[5];
    return out2;
  }
  function mul(out2, m1, m2) {
    var out0 = m1[0] * m2[0] + m1[2] * m2[1];
    var out1 = m1[1] * m2[0] + m1[3] * m2[1];
    var out22 = m1[0] * m2[2] + m1[2] * m2[3];
    var out3 = m1[1] * m2[2] + m1[3] * m2[3];
    var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
    var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
    out2[0] = out0;
    out2[1] = out1;
    out2[2] = out22;
    out2[3] = out3;
    out2[4] = out4;
    out2[5] = out5;
    return out2;
  }
  function translate(out2, a, v) {
    out2[0] = a[0];
    out2[1] = a[1];
    out2[2] = a[2];
    out2[3] = a[3];
    out2[4] = a[4] + v[0];
    out2[5] = a[5] + v[1];
    return out2;
  }
  function rotate(out2, a, rad, pivot) {
    if (pivot === void 0) {
      pivot = [0, 0];
    }
    var aa = a[0];
    var ac = a[2];
    var atx = a[4];
    var ab = a[1];
    var ad = a[3];
    var aty = a[5];
    var st = Math.sin(rad);
    var ct = Math.cos(rad);
    out2[0] = aa * ct + ab * st;
    out2[1] = -aa * st + ab * ct;
    out2[2] = ac * ct + ad * st;
    out2[3] = -ac * st + ct * ad;
    out2[4] = ct * (atx - pivot[0]) + st * (aty - pivot[1]) + pivot[0];
    out2[5] = ct * (aty - pivot[1]) - st * (atx - pivot[0]) + pivot[1];
    return out2;
  }
  function scale$1(out2, a, v) {
    var vx = v[0];
    var vy = v[1];
    out2[0] = a[0] * vx;
    out2[1] = a[1] * vy;
    out2[2] = a[2] * vx;
    out2[3] = a[3] * vy;
    out2[4] = a[4] * vx;
    out2[5] = a[5] * vy;
    return out2;
  }
  function invert(out2, a) {
    var aa = a[0];
    var ac = a[2];
    var atx = a[4];
    var ab = a[1];
    var ad = a[3];
    var aty = a[5];
    var det = aa * ad - ab * ac;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out2[0] = ad * det;
    out2[1] = -ab * det;
    out2[2] = -ac * det;
    out2[3] = aa * det;
    out2[4] = (ac * aty - ad * atx) * det;
    out2[5] = (ab * atx - aa * aty) * det;
    return out2;
  }
  var Point = function() {
    function Point2(x, y) {
      this.x = x || 0;
      this.y = y || 0;
    }
    Point2.prototype.copy = function(other) {
      this.x = other.x;
      this.y = other.y;
      return this;
    };
    Point2.prototype.clone = function() {
      return new Point2(this.x, this.y);
    };
    Point2.prototype.set = function(x, y) {
      this.x = x;
      this.y = y;
      return this;
    };
    Point2.prototype.equal = function(other) {
      return other.x === this.x && other.y === this.y;
    };
    Point2.prototype.add = function(other) {
      this.x += other.x;
      this.y += other.y;
      return this;
    };
    Point2.prototype.scale = function(scalar) {
      this.x *= scalar;
      this.y *= scalar;
    };
    Point2.prototype.scaleAndAdd = function(other, scalar) {
      this.x += other.x * scalar;
      this.y += other.y * scalar;
    };
    Point2.prototype.sub = function(other) {
      this.x -= other.x;
      this.y -= other.y;
      return this;
    };
    Point2.prototype.dot = function(other) {
      return this.x * other.x + this.y * other.y;
    };
    Point2.prototype.len = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    };
    Point2.prototype.lenSquare = function() {
      return this.x * this.x + this.y * this.y;
    };
    Point2.prototype.normalize = function() {
      var len2 = this.len();
      this.x /= len2;
      this.y /= len2;
      return this;
    };
    Point2.prototype.distance = function(other) {
      var dx = this.x - other.x;
      var dy = this.y - other.y;
      return Math.sqrt(dx * dx + dy * dy);
    };
    Point2.prototype.distanceSquare = function(other) {
      var dx = this.x - other.x;
      var dy = this.y - other.y;
      return dx * dx + dy * dy;
    };
    Point2.prototype.negate = function() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    };
    Point2.prototype.transform = function(m2) {
      if (!m2) {
        return;
      }
      var x = this.x;
      var y = this.y;
      this.x = m2[0] * x + m2[2] * y + m2[4];
      this.y = m2[1] * x + m2[3] * y + m2[5];
      return this;
    };
    Point2.prototype.toArray = function(out2) {
      out2[0] = this.x;
      out2[1] = this.y;
      return out2;
    };
    Point2.prototype.fromArray = function(input) {
      this.x = input[0];
      this.y = input[1];
    };
    Point2.set = function(p, x, y) {
      p.x = x;
      p.y = y;
    };
    Point2.copy = function(p, p2) {
      p.x = p2.x;
      p.y = p2.y;
    };
    Point2.len = function(p) {
      return Math.sqrt(p.x * p.x + p.y * p.y);
    };
    Point2.lenSquare = function(p) {
      return p.x * p.x + p.y * p.y;
    };
    Point2.dot = function(p0, p1) {
      return p0.x * p1.x + p0.y * p1.y;
    };
    Point2.add = function(out2, p0, p1) {
      out2.x = p0.x + p1.x;
      out2.y = p0.y + p1.y;
    };
    Point2.sub = function(out2, p0, p1) {
      out2.x = p0.x - p1.x;
      out2.y = p0.y - p1.y;
    };
    Point2.scale = function(out2, p0, scalar) {
      out2.x = p0.x * scalar;
      out2.y = p0.y * scalar;
    };
    Point2.scaleAndAdd = function(out2, p0, p1, scalar) {
      out2.x = p0.x + p1.x * scalar;
      out2.y = p0.y + p1.y * scalar;
    };
    Point2.lerp = function(out2, p0, p1, t) {
      var onet = 1 - t;
      out2.x = onet * p0.x + t * p1.x;
      out2.y = onet * p0.y + t * p1.y;
    };
    return Point2;
  }();
  var mathMin$6 = Math.min;
  var mathMax$6 = Math.max;
  var mathAbs$4 = Math.abs;
  var XY$2 = ["x", "y"];
  var WH$2 = ["width", "height"];
  var lt = new Point();
  var rb = new Point();
  var lb = new Point();
  var rt = new Point();
  var _intersectCtx$1 = createIntersectContext();
  var _minTv$1 = _intersectCtx$1.minTv;
  var _maxTv$1 = _intersectCtx$1.maxTv;
  var _lenMinMax = [0, 0];
  var BoundingRect = function() {
    function BoundingRect2(x, y, width, height) {
      BoundingRect2.set(this, x, y, width, height);
    }
    BoundingRect2.set = function(target, x, y, width, height) {
      if (width < 0) {
        x = x + width;
        width = -width;
      }
      if (height < 0) {
        y = y + height;
        height = -height;
      }
      target.x = x;
      target.y = y;
      target.width = width;
      target.height = height;
      return target;
    };
    BoundingRect2.prototype.union = function(other) {
      var x = mathMin$6(other.x, this.x);
      var y = mathMin$6(other.y, this.y);
      if (isFinite(this.x) && isFinite(this.width)) {
        this.width = mathMax$6(other.x + other.width, this.x + this.width) - x;
      } else {
        this.width = other.width;
      }
      if (isFinite(this.y) && isFinite(this.height)) {
        this.height = mathMax$6(other.y + other.height, this.y + this.height) - y;
      } else {
        this.height = other.height;
      }
      this.x = x;
      this.y = y;
    };
    BoundingRect2.prototype.applyTransform = function(m2) {
      BoundingRect2.applyTransform(this, this, m2);
    };
    BoundingRect2.prototype.calculateTransform = function(b) {
      var a = this;
      var sx = b.width / a.width;
      var sy = b.height / a.height;
      var m2 = create();
      translate(m2, m2, [-a.x, -a.y]);
      scale$1(m2, m2, [sx, sy]);
      translate(m2, m2, [b.x, b.y]);
      return m2;
    };
    BoundingRect2.prototype.intersect = function(b, mtv, opt) {
      return BoundingRect2.intersect(this, b, mtv, opt);
    };
    BoundingRect2.intersect = function(a, b, mtv, opt) {
      if (mtv) {
        Point.set(mtv, 0, 0);
      }
      var outIntersectRect = opt && opt.outIntersectRect || null;
      var clamp2 = opt && opt.clamp;
      if (outIntersectRect) {
        outIntersectRect.x = outIntersectRect.y = outIntersectRect.width = outIntersectRect.height = NaN;
      }
      if (!a || !b) {
        return false;
      }
      if (!(a instanceof BoundingRect2)) {
        a = BoundingRect2.set(_tmpIntersectA, a.x, a.y, a.width, a.height);
      }
      if (!(b instanceof BoundingRect2)) {
        b = BoundingRect2.set(_tmpIntersectB, b.x, b.y, b.width, b.height);
      }
      var useMTV = !!mtv;
      _intersectCtx$1.reset(opt, useMTV);
      var touchThreshold = _intersectCtx$1.touchThreshold;
      var ax0 = a.x + touchThreshold;
      var ax1 = a.x + a.width - touchThreshold;
      var ay0 = a.y + touchThreshold;
      var ay1 = a.y + a.height - touchThreshold;
      var bx0 = b.x + touchThreshold;
      var bx1 = b.x + b.width - touchThreshold;
      var by0 = b.y + touchThreshold;
      var by1 = b.y + b.height - touchThreshold;
      if (ax0 > ax1 || ay0 > ay1 || bx0 > bx1 || by0 > by1) {
        return false;
      }
      var overlap = !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
      if (useMTV || outIntersectRect) {
        _lenMinMax[0] = Infinity;
        _lenMinMax[1] = 0;
        intersectOneDim(ax0, ax1, bx0, bx1, 0, useMTV, outIntersectRect, clamp2);
        intersectOneDim(ay0, ay1, by0, by1, 1, useMTV, outIntersectRect, clamp2);
        if (useMTV) {
          Point.copy(mtv, overlap ? _intersectCtx$1.useDir ? _intersectCtx$1.dirMinTv : _minTv$1 : _maxTv$1);
        }
      }
      return overlap;
    };
    BoundingRect2.contain = function(rect, x, y) {
      return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
    };
    BoundingRect2.prototype.contain = function(x, y) {
      return BoundingRect2.contain(this, x, y);
    };
    BoundingRect2.prototype.clone = function() {
      return new BoundingRect2(this.x, this.y, this.width, this.height);
    };
    BoundingRect2.prototype.copy = function(other) {
      BoundingRect2.copy(this, other);
    };
    BoundingRect2.prototype.plain = function() {
      return {
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height
      };
    };
    BoundingRect2.prototype.isFinite = function() {
      return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
    };
    BoundingRect2.prototype.isZero = function() {
      return this.width === 0 || this.height === 0;
    };
    BoundingRect2.create = function(rect) {
      return new BoundingRect2(rect.x, rect.y, rect.width, rect.height);
    };
    BoundingRect2.copy = function(target, source) {
      target.x = source.x;
      target.y = source.y;
      target.width = source.width;
      target.height = source.height;
      return target;
    };
    BoundingRect2.applyTransform = function(target, source, m2) {
      if (!m2) {
        if (target !== source) {
          BoundingRect2.copy(target, source);
        }
        return;
      }
      if (m2[1] < 1e-5 && m2[1] > -1e-5 && m2[2] < 1e-5 && m2[2] > -1e-5) {
        var sx = m2[0];
        var sy = m2[3];
        var tx = m2[4];
        var ty = m2[5];
        target.x = source.x * sx + tx;
        target.y = source.y * sy + ty;
        target.width = source.width * sx;
        target.height = source.height * sy;
        if (target.width < 0) {
          target.x += target.width;
          target.width = -target.width;
        }
        if (target.height < 0) {
          target.y += target.height;
          target.height = -target.height;
        }
        return;
      }
      lt.x = lb.x = source.x;
      lt.y = rt.y = source.y;
      rb.x = rt.x = source.x + source.width;
      rb.y = lb.y = source.y + source.height;
      lt.transform(m2);
      rt.transform(m2);
      rb.transform(m2);
      lb.transform(m2);
      target.x = mathMin$6(lt.x, rb.x, lb.x, rt.x);
      target.y = mathMin$6(lt.y, rb.y, lb.y, rt.y);
      var maxX = mathMax$6(lt.x, rb.x, lb.x, rt.x);
      var maxY = mathMax$6(lt.y, rb.y, lb.y, rt.y);
      target.width = maxX - target.x;
      target.height = maxY - target.y;
    };
    return BoundingRect2;
  }();
  var _tmpIntersectA = new BoundingRect(0, 0, 0, 0);
  var _tmpIntersectB = new BoundingRect(0, 0, 0, 0);
  function intersectOneDim(a0, a1, b0, b1, updateDimIdx, useMTV, outIntersectRect, clamp2) {
    var d0 = mathAbs$4(a1 - b0);
    var d1 = mathAbs$4(b1 - a0);
    var d01min = mathMin$6(d0, d1);
    var updateDim = XY$2[updateDimIdx];
    var zeroDim = XY$2[1 - updateDimIdx];
    var wh = WH$2[updateDimIdx];
    if (a1 < b0 || b1 < a0) {
      if (d0 < d1) {
        if (useMTV) {
          _maxTv$1[updateDim] = -d0;
        }
        if (clamp2) {
          outIntersectRect[updateDim] = a1;
          outIntersectRect[wh] = 0;
        }
      } else {
        if (useMTV) {
          _maxTv$1[updateDim] = d1;
        }
        if (clamp2) {
          outIntersectRect[updateDim] = a0;
          outIntersectRect[wh] = 0;
        }
      }
    } else {
      if (outIntersectRect) {
        outIntersectRect[updateDim] = mathMax$6(a0, b0);
        outIntersectRect[wh] = mathMin$6(a1, b1) - outIntersectRect[updateDim];
      }
      if (useMTV) {
        if (d01min < _lenMinMax[0] || _intersectCtx$1.useDir) {
          _lenMinMax[0] = mathMin$6(d01min, _lenMinMax[0]);
          if (d0 < d1 || !_intersectCtx$1.bidirectional) {
            _minTv$1[updateDim] = d0;
            _minTv$1[zeroDim] = 0;
            if (_intersectCtx$1.useDir) {
              _intersectCtx$1.calcDirMTV();
            }
          }
          if (d0 >= d1 || !_intersectCtx$1.bidirectional) {
            _minTv$1[updateDim] = -d1;
            _minTv$1[zeroDim] = 0;
            if (_intersectCtx$1.useDir) {
              _intersectCtx$1.calcDirMTV();
            }
          }
        }
      }
    }
  }
  function createIntersectContext() {
    var _direction = 0;
    var _dirCheckVec = new Point();
    var _dirTmp = new Point();
    var _ctx = {
      minTv: new Point(),
      maxTv: new Point(),
      useDir: false,
      dirMinTv: new Point(),
      touchThreshold: 0,
      bidirectional: true,
      negativeSize: false,
      reset: function(opt, useMTV) {
        _ctx.touchThreshold = 0;
        if (opt && opt.touchThreshold != null) {
          _ctx.touchThreshold = mathMax$6(0, opt.touchThreshold);
        }
        _ctx.negativeSize = false;
        if (!useMTV) {
          return;
        }
        _ctx.minTv.set(Infinity, Infinity);
        _ctx.maxTv.set(0, 0);
        _ctx.useDir = false;
        if (opt && opt.direction != null) {
          _ctx.useDir = true;
          _ctx.dirMinTv.copy(_ctx.minTv);
          _dirTmp.copy(_ctx.minTv);
          _direction = opt.direction;
          _ctx.bidirectional = opt.bidirectional == null || !!opt.bidirectional;
          if (!_ctx.bidirectional) {
            _dirCheckVec.set(Math.cos(_direction), Math.sin(_direction));
          }
        }
      },
      calcDirMTV: function() {
        var minTv = _ctx.minTv;
        var dirMinTv = _ctx.dirMinTv;
        var squareMag = minTv.y * minTv.y + minTv.x * minTv.x;
        var dirSin = Math.sin(_direction);
        var dirCos = Math.cos(_direction);
        var dotProd = dirSin * minTv.y + dirCos * minTv.x;
        if (nearZero2(dotProd)) {
          if (nearZero2(minTv.x) && nearZero2(minTv.y)) {
            dirMinTv.set(0, 0);
          }
          return;
        }
        _dirTmp.x = squareMag * dirCos / dotProd;
        _dirTmp.y = squareMag * dirSin / dotProd;
        if (nearZero2(_dirTmp.x) && nearZero2(_dirTmp.y)) {
          dirMinTv.set(0, 0);
          return;
        }
        if ((_ctx.bidirectional || _dirCheckVec.dot(_dirTmp) > 0) && _dirTmp.len() < dirMinTv.len()) {
          dirMinTv.copy(_dirTmp);
        }
      }
    };
    function nearZero2(val) {
      return mathAbs$4(val) < 1e-10;
    }
    return _ctx;
  }
  var SILENT = "silent";
  function makeEventPacket(eveType, targetInfo, event) {
    return {
      type: eveType,
      event,
      target: targetInfo.target,
      topTarget: targetInfo.topTarget,
      cancelBubble: false,
      offsetX: event.zrX,
      offsetY: event.zrY,
      gestureEvent: event.gestureEvent,
      pinchX: event.pinchX,
      pinchY: event.pinchY,
      pinchScale: event.pinchScale,
      wheelDelta: event.zrDelta,
      zrByTouch: event.zrByTouch,
      which: event.which,
      stop: stopEvent
    };
  }
  function stopEvent() {
    stop(this.event);
  }
  var EmptyProxy = function(_super) {
    __extends(EmptyProxy2, _super);
    function EmptyProxy2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.handler = null;
      return _this;
    }
    EmptyProxy2.prototype.dispose = function() {
    };
    EmptyProxy2.prototype.setCursor = function() {
    };
    return EmptyProxy2;
  }(Eventful);
  var HoveredResult = /* @__PURE__ */ function() {
    function HoveredResult2(x, y) {
      this.x = x;
      this.y = y;
    }
    return HoveredResult2;
  }();
  var handlerNames = [
    "click",
    "dblclick",
    "mousewheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ];
  var tmpRect$1 = new BoundingRect(0, 0, 0, 0);
  var Handler = function(_super) {
    __extends(Handler2, _super);
    function Handler2(storage, painter, proxy, painterRoot, pointerSize) {
      var _this = _super.call(this) || this;
      _this._hovered = new HoveredResult(0, 0);
      _this.storage = storage;
      _this.painter = painter;
      _this.painterRoot = painterRoot;
      _this._pointerSize = pointerSize;
      proxy = proxy || new EmptyProxy();
      _this.proxy = null;
      _this.setHandlerProxy(proxy);
      _this._draggingMgr = new Draggable(_this);
      return _this;
    }
    Handler2.prototype.setHandlerProxy = function(proxy) {
      if (this.proxy) {
        this.proxy.dispose();
      }
      if (proxy) {
        each$5(handlerNames, function(name) {
          proxy.on && proxy.on(name, this[name], this);
        }, this);
        proxy.handler = this;
      }
      this.proxy = proxy;
    };
    Handler2.prototype.mousemove = function(event) {
      var x = event.zrX;
      var y = event.zrY;
      var isOutside = isOutsideBoundary(this, x, y);
      var lastHovered = this._hovered;
      var lastHoveredTarget = lastHovered.target;
      if (lastHoveredTarget && !lastHoveredTarget.__zr) {
        lastHovered = this.findHover(lastHovered.x, lastHovered.y);
        lastHoveredTarget = lastHovered.target;
      }
      var hovered = this._hovered = isOutside ? new HoveredResult(x, y) : this.findHover(x, y);
      var hoveredTarget = hovered.target;
      var proxy = this.proxy;
      proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : "default");
      if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
        this.dispatchToElement(lastHovered, "mouseout", event);
      }
      this.dispatchToElement(hovered, "mousemove", event);
      if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
        this.dispatchToElement(hovered, "mouseover", event);
      }
    };
    Handler2.prototype.mouseout = function(event) {
      var eventControl = event.zrEventControl;
      if (eventControl !== "only_globalout") {
        this.dispatchToElement(this._hovered, "mouseout", event);
      }
      if (eventControl !== "no_globalout") {
        this.trigger("globalout", { type: "globalout", event });
      }
    };
    Handler2.prototype.resize = function() {
      this._hovered = new HoveredResult(0, 0);
    };
    Handler2.prototype.dispatch = function(eventName, eventArgs) {
      var handler = this[eventName];
      handler && handler.call(this, eventArgs);
    };
    Handler2.prototype.dispose = function() {
      this.proxy.dispose();
      this.storage = null;
      this.proxy = null;
      this.painter = null;
    };
    Handler2.prototype.setCursorStyle = function(cursorStyle) {
      var proxy = this.proxy;
      proxy.setCursor && proxy.setCursor(cursorStyle);
    };
    Handler2.prototype.dispatchToElement = function(targetInfo, eventName, event) {
      targetInfo = targetInfo || {};
      var el = targetInfo.target;
      if (el && el.silent) {
        return;
      }
      var eventKey = "on" + eventName;
      var eventPacket = makeEventPacket(eventName, targetInfo, event);
      while (el) {
        el[eventKey] && (eventPacket.cancelBubble = !!el[eventKey].call(el, eventPacket));
        el.trigger(eventName, eventPacket);
        el = el.__hostTarget ? el.__hostTarget : el.parent;
        if (eventPacket.cancelBubble) {
          break;
        }
      }
      if (!eventPacket.cancelBubble) {
        this.trigger(eventName, eventPacket);
        if (this.painter && this.painter.eachOtherLayer) {
          this.painter.eachOtherLayer(function(layer) {
            if (typeof layer[eventKey] === "function") {
              layer[eventKey].call(layer, eventPacket);
            }
            if (layer.trigger) {
              layer.trigger(eventName, eventPacket);
            }
          });
        }
      }
    };
    Handler2.prototype.findHover = function(x, y, exclude) {
      var list = this.storage.getDisplayList();
      var out2 = new HoveredResult(x, y);
      setHoverTarget(list, out2, x, y, exclude);
      if (this._pointerSize && !out2.target) {
        var candidates = [];
        var pointerSize = this._pointerSize;
        var targetSizeHalf = pointerSize / 2;
        var pointerRect = new BoundingRect(x - targetSizeHalf, y - targetSizeHalf, pointerSize, pointerSize);
        for (var i = list.length - 1; i >= 0; i--) {
          var el = list[i];
          if (el !== exclude && !el.ignore && !el.ignoreCoarsePointer && (!el.parent || !el.parent.ignoreCoarsePointer)) {
            tmpRect$1.copy(el.getBoundingRect());
            if (el.transform) {
              tmpRect$1.applyTransform(el.transform);
            }
            if (tmpRect$1.intersect(pointerRect)) {
              candidates.push(el);
            }
          }
        }
        if (candidates.length) {
          var rStep = 4;
          var thetaStep = Math.PI / 12;
          var PI22 = Math.PI * 2;
          for (var r = 0; r < targetSizeHalf; r += rStep) {
            for (var theta = 0; theta < PI22; theta += thetaStep) {
              var x1 = x + r * Math.cos(theta);
              var y1 = y + r * Math.sin(theta);
              setHoverTarget(candidates, out2, x1, y1, exclude);
              if (out2.target) {
                return out2;
              }
            }
          }
        }
      }
      return out2;
    };
    Handler2.prototype.processGesture = function(event, stage) {
      if (!this._gestureMgr) {
        this._gestureMgr = new GestureMgr();
      }
      var gestureMgr = this._gestureMgr;
      stage === "start" && gestureMgr.clear();
      var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);
      stage === "end" && gestureMgr.clear();
      if (gestureInfo) {
        var type = gestureInfo.type;
        event.gestureEvent = type;
        var res = new HoveredResult();
        res.target = gestureInfo.target;
        this.dispatchToElement(res, type, gestureInfo.event);
      }
    };
    return Handler2;
  }(Eventful);
  each$5(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(name) {
    Handler.prototype[name] = function(event) {
      var x = event.zrX;
      var y = event.zrY;
      var isOutside = isOutsideBoundary(this, x, y);
      var hovered;
      var hoveredTarget;
      if (name !== "mouseup" || !isOutside) {
        hovered = this.findHover(x, y);
        hoveredTarget = hovered.target;
      }
      if (name === "mousedown") {
        this._downEl = hoveredTarget;
        this._downPoint = [event.zrX, event.zrY];
        this._upEl = hoveredTarget;
      } else if (name === "mouseup") {
        this._upEl = hoveredTarget;
      } else if (name === "click") {
        if (this._downEl !== this._upEl || !this._downPoint || dist$1(this._downPoint, [event.zrX, event.zrY]) > 4) {
          return;
        }
        this._downPoint = null;
      }
      this.dispatchToElement(hovered, name, event);
    };
  });
  function isHover(displayable, x, y) {
    if (displayable[displayable.rectHover ? "rectContain" : "contain"](x, y)) {
      var el = displayable;
      var isSilent = void 0;
      var ignoreClip = false;
      while (el) {
        if (el.ignoreClip) {
          ignoreClip = true;
        }
        if (!ignoreClip) {
          var clipPath = el.getClipPath();
          if (clipPath && !clipPath.contain(x, y)) {
            return false;
          }
        }
        if (el.silent) {
          isSilent = true;
        }
        var hostEl = el.__hostTarget;
        el = hostEl ? el.ignoreHostSilent ? null : hostEl : el.parent;
      }
      return isSilent ? SILENT : true;
    }
    return false;
  }
  function setHoverTarget(list, out2, x, y, exclude) {
    for (var i = list.length - 1; i >= 0; i--) {
      var el = list[i];
      var hoverCheckResult = void 0;
      if (el !== exclude && !el.ignore && (hoverCheckResult = isHover(el, x, y))) {
        !out2.topTarget && (out2.topTarget = el);
        if (hoverCheckResult !== SILENT) {
          out2.target = el;
          break;
        }
      }
    }
  }
  function isOutsideBoundary(handlerInstance, x, y) {
    var painter = handlerInstance.painter;
    return x < 0 || x > painter.getWidth() || y < 0 || y > painter.getHeight();
  }
  var DEFAULT_MIN_MERGE = 32;
  var DEFAULT_MIN_GALLOPING = 7;
  function minRunLength(n) {
    var r = 0;
    while (n >= DEFAULT_MIN_MERGE) {
      r |= n & 1;
      n >>= 1;
    }
    return n + r;
  }
  function makeAscendingRun(array, lo, hi, compare2) {
    var runHi = lo + 1;
    if (runHi === hi) {
      return 1;
    }
    if (compare2(array[runHi++], array[lo]) < 0) {
      while (runHi < hi && compare2(array[runHi], array[runHi - 1]) < 0) {
        runHi++;
      }
      reverseRun(array, lo, runHi);
    } else {
      while (runHi < hi && compare2(array[runHi], array[runHi - 1]) >= 0) {
        runHi++;
      }
    }
    return runHi - lo;
  }
  function reverseRun(array, lo, hi) {
    hi--;
    while (lo < hi) {
      var t = array[lo];
      array[lo++] = array[hi];
      array[hi--] = t;
    }
  }
  function binaryInsertionSort(array, lo, hi, start2, compare2) {
    if (start2 === lo) {
      start2++;
    }
    for (; start2 < hi; start2++) {
      var pivot = array[start2];
      var left = lo;
      var right = start2;
      var mid;
      while (left < right) {
        mid = left + right >>> 1;
        if (compare2(pivot, array[mid]) < 0) {
          right = mid;
        } else {
          left = mid + 1;
        }
      }
      var n = start2 - left;
      switch (n) {
        case 3:
          array[left + 3] = array[left + 2];
        case 2:
          array[left + 2] = array[left + 1];
        case 1:
          array[left + 1] = array[left];
          break;
        default:
          while (n > 0) {
            array[left + n] = array[left + n - 1];
            n--;
          }
      }
      array[left] = pivot;
    }
  }
  function gallopLeft(value, array, start2, length, hint, compare2) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset = 1;
    if (compare2(value, array[start2 + hint]) > 0) {
      maxOffset = length - hint;
      while (offset < maxOffset && compare2(value, array[start2 + hint + offset]) > 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;
        if (offset <= 0) {
          offset = maxOffset;
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset;
      }
      lastOffset += hint;
      offset += hint;
    } else {
      maxOffset = hint + 1;
      while (offset < maxOffset && compare2(value, array[start2 + hint - offset]) <= 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;
        if (offset <= 0) {
          offset = maxOffset;
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset;
      }
      var tmp = lastOffset;
      lastOffset = hint - offset;
      offset = hint - tmp;
    }
    lastOffset++;
    while (lastOffset < offset) {
      var m2 = lastOffset + (offset - lastOffset >>> 1);
      if (compare2(value, array[start2 + m2]) > 0) {
        lastOffset = m2 + 1;
      } else {
        offset = m2;
      }
    }
    return offset;
  }
  function gallopRight(value, array, start2, length, hint, compare2) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset = 1;
    if (compare2(value, array[start2 + hint]) < 0) {
      maxOffset = hint + 1;
      while (offset < maxOffset && compare2(value, array[start2 + hint - offset]) < 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;
        if (offset <= 0) {
          offset = maxOffset;
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset;
      }
      var tmp = lastOffset;
      lastOffset = hint - offset;
      offset = hint - tmp;
    } else {
      maxOffset = length - hint;
      while (offset < maxOffset && compare2(value, array[start2 + hint + offset]) >= 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;
        if (offset <= 0) {
          offset = maxOffset;
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset;
      }
      lastOffset += hint;
      offset += hint;
    }
    lastOffset++;
    while (lastOffset < offset) {
      var m2 = lastOffset + (offset - lastOffset >>> 1);
      if (compare2(value, array[start2 + m2]) < 0) {
        offset = m2;
      } else {
        lastOffset = m2 + 1;
      }
    }
    return offset;
  }
  function TimSort(array, compare2) {
    var minGallop = DEFAULT_MIN_GALLOPING;
    var runStart;
    var runLength;
    var stackSize = 0;
    var tmp = [];
    runStart = [];
    runLength = [];
    function pushRun(_runStart, _runLength) {
      runStart[stackSize] = _runStart;
      runLength[stackSize] = _runLength;
      stackSize += 1;
    }
    function mergeRuns() {
      while (stackSize > 1) {
        var n = stackSize - 2;
        if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
          if (runLength[n - 1] < runLength[n + 1]) {
            n--;
          }
        } else if (runLength[n] > runLength[n + 1]) {
          break;
        }
        mergeAt(n);
      }
    }
    function forceMergeRuns() {
      while (stackSize > 1) {
        var n = stackSize - 2;
        if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
          n--;
        }
        mergeAt(n);
      }
    }
    function mergeAt(i) {
      var start1 = runStart[i];
      var length1 = runLength[i];
      var start2 = runStart[i + 1];
      var length2 = runLength[i + 1];
      runLength[i] = length1 + length2;
      if (i === stackSize - 3) {
        runStart[i + 1] = runStart[i + 2];
        runLength[i + 1] = runLength[i + 2];
      }
      stackSize--;
      var k = gallopRight(array[start2], array, start1, length1, 0, compare2);
      start1 += k;
      length1 -= k;
      if (length1 === 0) {
        return;
      }
      length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare2);
      if (length2 === 0) {
        return;
      }
      if (length1 <= length2) {
        mergeLow(start1, length1, start2, length2);
      } else {
        mergeHigh(start1, length1, start2, length2);
      }
    }
    function mergeLow(start1, length1, start2, length2) {
      var i = 0;
      for (i = 0; i < length1; i++) {
        tmp[i] = array[start1 + i];
      }
      var cursor1 = 0;
      var cursor2 = start2;
      var dest = start1;
      array[dest++] = array[cursor2++];
      if (--length2 === 0) {
        for (i = 0; i < length1; i++) {
          array[dest + i] = tmp[cursor1 + i];
        }
        return;
      }
      if (length1 === 1) {
        for (i = 0; i < length2; i++) {
          array[dest + i] = array[cursor2 + i];
        }
        array[dest + length2] = tmp[cursor1];
        return;
      }
      var _minGallop = minGallop;
      var count1;
      var count2;
      var exit;
      while (1) {
        count1 = 0;
        count2 = 0;
        exit = false;
        do {
          if (compare2(array[cursor2], tmp[cursor1]) < 0) {
            array[dest++] = array[cursor2++];
            count2++;
            count1 = 0;
            if (--length2 === 0) {
              exit = true;
              break;
            }
          } else {
            array[dest++] = tmp[cursor1++];
            count1++;
            count2 = 0;
            if (--length1 === 1) {
              exit = true;
              break;
            }
          }
        } while ((count1 | count2) < _minGallop);
        if (exit) {
          break;
        }
        do {
          count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare2);
          if (count1 !== 0) {
            for (i = 0; i < count1; i++) {
              array[dest + i] = tmp[cursor1 + i];
            }
            dest += count1;
            cursor1 += count1;
            length1 -= count1;
            if (length1 <= 1) {
              exit = true;
              break;
            }
          }
          array[dest++] = array[cursor2++];
          if (--length2 === 0) {
            exit = true;
            break;
          }
          count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare2);
          if (count2 !== 0) {
            for (i = 0; i < count2; i++) {
              array[dest + i] = array[cursor2 + i];
            }
            dest += count2;
            cursor2 += count2;
            length2 -= count2;
            if (length2 === 0) {
              exit = true;
              break;
            }
          }
          array[dest++] = tmp[cursor1++];
          if (--length1 === 1) {
            exit = true;
            break;
          }
          _minGallop--;
        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
        if (exit) {
          break;
        }
        if (_minGallop < 0) {
          _minGallop = 0;
        }
        _minGallop += 2;
      }
      minGallop = _minGallop;
      minGallop < 1 && (minGallop = 1);
      if (length1 === 1) {
        for (i = 0; i < length2; i++) {
          array[dest + i] = array[cursor2 + i];
        }
        array[dest + length2] = tmp[cursor1];
      } else if (length1 === 0) {
        throw new Error();
      } else {
        for (i = 0; i < length1; i++) {
          array[dest + i] = tmp[cursor1 + i];
        }
      }
    }
    function mergeHigh(start1, length1, start2, length2) {
      var i = 0;
      for (i = 0; i < length2; i++) {
        tmp[i] = array[start2 + i];
      }
      var cursor1 = start1 + length1 - 1;
      var cursor2 = length2 - 1;
      var dest = start2 + length2 - 1;
      var customCursor = 0;
      var customDest = 0;
      array[dest--] = array[cursor1--];
      if (--length1 === 0) {
        customCursor = dest - (length2 - 1);
        for (i = 0; i < length2; i++) {
          array[customCursor + i] = tmp[i];
        }
        return;
      }
      if (length2 === 1) {
        dest -= length1;
        cursor1 -= length1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;
        for (i = length1 - 1; i >= 0; i--) {
          array[customDest + i] = array[customCursor + i];
        }
        array[dest] = tmp[cursor2];
        return;
      }
      var _minGallop = minGallop;
      while (true) {
        var count1 = 0;
        var count2 = 0;
        var exit = false;
        do {
          if (compare2(tmp[cursor2], array[cursor1]) < 0) {
            array[dest--] = array[cursor1--];
            count1++;
            count2 = 0;
            if (--length1 === 0) {
              exit = true;
              break;
            }
          } else {
            array[dest--] = tmp[cursor2--];
            count2++;
            count1 = 0;
            if (--length2 === 1) {
              exit = true;
              break;
            }
          }
        } while ((count1 | count2) < _minGallop);
        if (exit) {
          break;
        }
        do {
          count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare2);
          if (count1 !== 0) {
            dest -= count1;
            cursor1 -= count1;
            length1 -= count1;
            customDest = dest + 1;
            customCursor = cursor1 + 1;
            for (i = count1 - 1; i >= 0; i--) {
              array[customDest + i] = array[customCursor + i];
            }
            if (length1 === 0) {
              exit = true;
              break;
            }
          }
          array[dest--] = tmp[cursor2--];
          if (--length2 === 1) {
            exit = true;
            break;
          }
          count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare2);
          if (count2 !== 0) {
            dest -= count2;
            cursor2 -= count2;
            length2 -= count2;
            customDest = dest + 1;
            customCursor = cursor2 + 1;
            for (i = 0; i < count2; i++) {
              array[customDest + i] = tmp[customCursor + i];
            }
            if (length2 <= 1) {
              exit = true;
              break;
            }
          }
          array[dest--] = array[cursor1--];
          if (--length1 === 0) {
            exit = true;
            break;
          }
          _minGallop--;
        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
        if (exit) {
          break;
        }
        if (_minGallop < 0) {
          _minGallop = 0;
        }
        _minGallop += 2;
      }
      minGallop = _minGallop;
      if (minGallop < 1) {
        minGallop = 1;
      }
      if (length2 === 1) {
        dest -= length1;
        cursor1 -= length1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;
        for (i = length1 - 1; i >= 0; i--) {
          array[customDest + i] = array[customCursor + i];
        }
        array[dest] = tmp[cursor2];
      } else if (length2 === 0) {
        throw new Error();
      } else {
        customCursor = dest - (length2 - 1);
        for (i = 0; i < length2; i++) {
          array[customCursor + i] = tmp[i];
        }
      }
    }
    return {
      mergeRuns,
      forceMergeRuns,
      pushRun
    };
  }
  function sort(array, compare2, lo, hi) {
    if (!lo) {
      lo = 0;
    }
    if (!hi) {
      hi = array.length;
    }
    var remaining = hi - lo;
    if (remaining < 2) {
      return;
    }
    var runLength = 0;
    if (remaining < DEFAULT_MIN_MERGE) {
      runLength = makeAscendingRun(array, lo, hi, compare2);
      binaryInsertionSort(array, lo, hi, lo + runLength, compare2);
      return;
    }
    var ts = TimSort(array, compare2);
    var minRun = minRunLength(remaining);
    do {
      runLength = makeAscendingRun(array, lo, hi, compare2);
      if (runLength < minRun) {
        var force = remaining;
        if (force > minRun) {
          force = minRun;
        }
        binaryInsertionSort(array, lo, lo + force, lo + runLength, compare2);
        runLength = force;
      }
      ts.pushRun(lo, runLength);
      ts.mergeRuns();
      remaining -= runLength;
      lo += runLength;
    } while (remaining !== 0);
    ts.forceMergeRuns();
  }
  var REDRAW_BIT = 1;
  var STYLE_CHANGED_BIT = 2;
  var SHAPE_CHANGED_BIT = 4;
  var invalidZErrorLogged = false;
  function logInvalidZError() {
    if (invalidZErrorLogged) {
      return;
    }
    invalidZErrorLogged = true;
    console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors");
  }
  function shapeCompareFunc(a, b) {
    if (a.zlevel === b.zlevel) {
      if (a.z === b.z) {
        return a.z2 - b.z2;
      }
      return a.z - b.z;
    }
    return a.zlevel - b.zlevel;
  }
  var Storage = function() {
    function Storage2() {
      this._roots = [];
      this._displayList = [];
      this._displayListLen = 0;
      this.displayableSortFunc = shapeCompareFunc;
    }
    Storage2.prototype.traverse = function(cb, context) {
      for (var i = 0; i < this._roots.length; i++) {
        this._roots[i].traverse(cb, context);
      }
    };
    Storage2.prototype.getDisplayList = function(update, includeIgnore) {
      includeIgnore = includeIgnore || false;
      var displayList = this._displayList;
      if (update || !displayList.length) {
        this.updateDisplayList(includeIgnore);
      }
      return displayList;
    };
    Storage2.prototype.updateDisplayList = function(includeIgnore) {
      this._displayListLen = 0;
      var roots2 = this._roots;
      var displayList = this._displayList;
      for (var i = 0, len2 = roots2.length; i < len2; i++) {
        this._updateAndAddDisplayable(roots2[i], null, includeIgnore);
      }
      displayList.length = this._displayListLen;
      sort(displayList, shapeCompareFunc);
    };
    Storage2.prototype._updateAndAddDisplayable = function(el, parentClipPaths, includeIgnore) {
      if (el.ignore && !includeIgnore) {
        return;
      }
      el.beforeUpdate();
      el.update();
      el.afterUpdate();
      var userSetClipPath = el.getClipPath();
      var parentHasClipPaths = parentClipPaths && parentClipPaths.length;
      var clipPathIdx = 0;
      var thisClipPaths = el.__clipPaths;
      if (!el.ignoreClip && (parentHasClipPaths || userSetClipPath)) {
        if (!thisClipPaths) {
          thisClipPaths = el.__clipPaths = [];
        }
        if (parentHasClipPaths) {
          for (var idx = 0; idx < parentClipPaths.length; idx++) {
            thisClipPaths[clipPathIdx++] = parentClipPaths[idx];
          }
        }
        var currentClipPath = userSetClipPath;
        var parentClipPath = el;
        while (currentClipPath) {
          currentClipPath.parent = parentClipPath;
          currentClipPath.updateTransform();
          thisClipPaths[clipPathIdx++] = currentClipPath;
          parentClipPath = currentClipPath;
          currentClipPath = currentClipPath.getClipPath();
        }
      }
      if (thisClipPaths) {
        thisClipPaths.length = clipPathIdx;
      }
      if (el.childrenRef) {
        var children = el.childrenRef();
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          if (el.__dirty) {
            child.__dirty |= REDRAW_BIT;
          }
          this._updateAndAddDisplayable(child, thisClipPaths, includeIgnore);
        }
        el.__dirty = 0;
      } else {
        var disp = el;
        if (isNaN(disp.z)) {
          logInvalidZError();
          disp.z = 0;
        }
        if (isNaN(disp.z2)) {
          logInvalidZError();
          disp.z2 = 0;
        }
        if (isNaN(disp.zlevel)) {
          logInvalidZError();
          disp.zlevel = 0;
        }
        this._displayList[this._displayListLen++] = disp;
      }
      var decalEl = el.getDecalElement && el.getDecalElement();
      if (decalEl) {
        this._updateAndAddDisplayable(decalEl, thisClipPaths, includeIgnore);
      }
      var textGuide = el.getTextGuideLine();
      if (textGuide) {
        this._updateAndAddDisplayable(textGuide, thisClipPaths, includeIgnore);
      }
      var textEl = el.getTextContent();
      if (textEl) {
        this._updateAndAddDisplayable(textEl, thisClipPaths, includeIgnore);
      }
    };
    Storage2.prototype.addRoot = function(el) {
      if (el.__zr && el.__zr.storage === this) {
        return;
      }
      this._roots.push(el);
    };
    Storage2.prototype.delRoot = function(el) {
      if (el instanceof Array) {
        for (var i = 0, l = el.length; i < l; i++) {
          this.delRoot(el[i]);
        }
        return;
      }
      var idx = indexOf(this._roots, el);
      if (idx >= 0) {
        this._roots.splice(idx, 1);
      }
    };
    Storage2.prototype.delAllRoots = function() {
      this._roots = [];
      this._displayList = [];
      this._displayListLen = 0;
      return;
    };
    Storage2.prototype.getRoots = function() {
      return this._roots;
    };
    Storage2.prototype.dispose = function() {
      this._displayList = null;
      this._roots = null;
    };
    return Storage2;
  }();
  var requestAnimationFrame;
  requestAnimationFrame = env.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(func) {
    return setTimeout(func, 16);
  };
  var easingFuncs = {
    linear: function(k) {
      return k;
    },
    quadraticIn: function(k) {
      return k * k;
    },
    quadraticOut: function(k) {
      return k * (2 - k);
    },
    quadraticInOut: function(k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k;
      }
      return -0.5 * (--k * (k - 2) - 1);
    },
    cubicIn: function(k) {
      return k * k * k;
    },
    cubicOut: function(k) {
      return --k * k * k + 1;
    },
    cubicInOut: function(k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k * k;
      }
      return 0.5 * ((k -= 2) * k * k + 2);
    },
    quarticIn: function(k) {
      return k * k * k * k;
    },
    quarticOut: function(k) {
      return 1 - --k * k * k * k;
    },
    quarticInOut: function(k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k * k * k;
      }
      return -0.5 * ((k -= 2) * k * k * k - 2);
    },
    quinticIn: function(k) {
      return k * k * k * k * k;
    },
    quinticOut: function(k) {
      return --k * k * k * k * k + 1;
    },
    quinticInOut: function(k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k * k * k * k;
      }
      return 0.5 * ((k -= 2) * k * k * k * k + 2);
    },
    sinusoidalIn: function(k) {
      return 1 - Math.cos(k * Math.PI / 2);
    },
    sinusoidalOut: function(k) {
      return Math.sin(k * Math.PI / 2);
    },
    sinusoidalInOut: function(k) {
      return 0.5 * (1 - Math.cos(Math.PI * k));
    },
    exponentialIn: function(k) {
      return k === 0 ? 0 : Math.pow(1024, k - 1);
    },
    exponentialOut: function(k) {
      return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
    },
    exponentialInOut: function(k) {
      if (k === 0) {
        return 0;
      }
      if (k === 1) {
        return 1;
      }
      if ((k *= 2) < 1) {
        return 0.5 * Math.pow(1024, k - 1);
      }
      return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
    },
    circularIn: function(k) {
      return 1 - Math.sqrt(1 - k * k);
    },
    circularOut: function(k) {
      return Math.sqrt(1 - --k * k);
    },
    circularInOut: function(k) {
      if ((k *= 2) < 1) {
        return -0.5 * (Math.sqrt(1 - k * k) - 1);
      }
      return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
    },
    elasticIn: function(k) {
      var s;
      var a = 0.1;
      var p = 0.4;
      if (k === 0) {
        return 0;
      }
      if (k === 1) {
        return 1;
      }
      if (!a || a < 1) {
        a = 1;
        s = p / 4;
      } else {
        s = p * Math.asin(1 / a) / (2 * Math.PI);
      }
      return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
    },
    elasticOut: function(k) {
      var s;
      var a = 0.1;
      var p = 0.4;
      if (k === 0) {
        return 0;
      }
      if (k === 1) {
        return 1;
      }
      if (!a || a < 1) {
        a = 1;
        s = p / 4;
      } else {
        s = p * Math.asin(1 / a) / (2 * Math.PI);
      }
      return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
    },
    elasticInOut: function(k) {
      var s;
      var a = 0.1;
      var p = 0.4;
      if (k === 0) {
        return 0;
      }
      if (k === 1) {
        return 1;
      }
      if (!a || a < 1) {
        a = 1;
        s = p / 4;
      } else {
        s = p * Math.asin(1 / a) / (2 * Math.PI);
      }
      if ((k *= 2) < 1) {
        return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
      }
      return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
    },
    backIn: function(k) {
      var s = 1.70158;
      return k * k * ((s + 1) * k - s);
    },
    backOut: function(k) {
      var s = 1.70158;
      return --k * k * ((s + 1) * k + s) + 1;
    },
    backInOut: function(k) {
      var s = 1.70158 * 1.525;
      if ((k *= 2) < 1) {
        return 0.5 * (k * k * ((s + 1) * k - s));
      }
      return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
    },
    bounceIn: function(k) {
      return 1 - easingFuncs.bounceOut(1 - k);
    },
    bounceOut: function(k) {
      if (k < 1 / 2.75) {
        return 7.5625 * k * k;
      } else if (k < 2 / 2.75) {
        return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
      } else if (k < 2.5 / 2.75) {
        return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
      } else {
        return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
      }
    },
    bounceInOut: function(k) {
      if (k < 0.5) {
        return easingFuncs.bounceIn(k * 2) * 0.5;
      }
      return easingFuncs.bounceOut(k * 2 - 1) * 0.5 + 0.5;
    }
  };
  var mathPow$1 = Math.pow;
  var mathSqrt$3 = Math.sqrt;
  var EPSILON$2 = 1e-8;
  var EPSILON_NUMERIC = 1e-4;
  var THREE_SQRT = mathSqrt$3(3);
  var ONE_THIRD = 1 / 3;
  var _v0 = create$1();
  var _v1 = create$1();
  var _v2 = create$1();
  function isAroundZero(val) {
    return val > -EPSILON$2 && val < EPSILON$2;
  }
  function isNotAroundZero$1(val) {
    return val > EPSILON$2 || val < -EPSILON$2;
  }
  function cubicAt(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
  }
  function cubicDerivativeAt(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
  }
  function cubicRootAt(p0, p1, p2, p3, val, roots2) {
    var a = p3 + 3 * (p1 - p2) - p0;
    var b = 3 * (p2 - p1 * 2 + p0);
    var c = 3 * (p1 - p0);
    var d = p0 - val;
    var A = b * b - 3 * a * c;
    var B = b * c - 9 * a * d;
    var C = c * c - 3 * b * d;
    var n = 0;
    if (isAroundZero(A) && isAroundZero(B)) {
      if (isAroundZero(b)) {
        roots2[0] = 0;
      } else {
        var t1 = -c / b;
        if (t1 >= 0 && t1 <= 1) {
          roots2[n++] = t1;
        }
      }
    } else {
      var disc = B * B - 4 * A * C;
      if (isAroundZero(disc)) {
        var K = B / A;
        var t1 = -b / a + K;
        var t2 = -K / 2;
        if (t1 >= 0 && t1 <= 1) {
          roots2[n++] = t1;
        }
        if (t2 >= 0 && t2 <= 1) {
          roots2[n++] = t2;
        }
      } else if (disc > 0) {
        var discSqrt = mathSqrt$3(disc);
        var Y1 = A * b + 1.5 * a * (-B + discSqrt);
        var Y2 = A * b + 1.5 * a * (-B - discSqrt);
        if (Y1 < 0) {
          Y1 = -mathPow$1(-Y1, ONE_THIRD);
        } else {
          Y1 = mathPow$1(Y1, ONE_THIRD);
        }
        if (Y2 < 0) {
          Y2 = -mathPow$1(-Y2, ONE_THIRD);
        } else {
          Y2 = mathPow$1(Y2, ONE_THIRD);
        }
        var t1 = (-b - (Y1 + Y2)) / (3 * a);
        if (t1 >= 0 && t1 <= 1) {
          roots2[n++] = t1;
        }
      } else {
        var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt$3(A * A * A));
        var theta = Math.acos(T) / 3;
        var ASqrt = mathSqrt$3(A);
        var tmp = Math.cos(theta);
        var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
        var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
        var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
        if (t1 >= 0 && t1 <= 1) {
          roots2[n++] = t1;
        }
        if (t2 >= 0 && t2 <= 1) {
          roots2[n++] = t2;
        }
        if (t3 >= 0 && t3 <= 1) {
          roots2[n++] = t3;
        }
      }
    }
    return n;
  }
  function cubicExtrema(p0, p1, p2, p3, extrema2) {
    var b = 6 * p2 - 12 * p1 + 6 * p0;
    var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
    var c = 3 * p1 - 3 * p0;
    var n = 0;
    if (isAroundZero(a)) {
      if (isNotAroundZero$1(b)) {
        var t1 = -c / b;
        if (t1 >= 0 && t1 <= 1) {
          extrema2[n++] = t1;
        }
      }
    } else {
      var disc = b * b - 4 * a * c;
      if (isAroundZero(disc)) {
        extrema2[0] = -b / (2 * a);
      } else if (disc > 0) {
        var discSqrt = mathSqrt$3(disc);
        var t1 = (-b + discSqrt) / (2 * a);
        var t2 = (-b - discSqrt) / (2 * a);
        if (t1 >= 0 && t1 <= 1) {
          extrema2[n++] = t1;
        }
        if (t2 >= 0 && t2 <= 1) {
          extrema2[n++] = t2;
        }
      }
    }
    return n;
  }
  function cubicSubdivide(p0, p1, p2, p3, t, out2) {
    var p01 = (p1 - p0) * t + p0;
    var p12 = (p2 - p1) * t + p1;
    var p23 = (p3 - p2) * t + p2;
    var p012 = (p12 - p01) * t + p01;
    var p123 = (p23 - p12) * t + p12;
    var p0123 = (p123 - p012) * t + p012;
    out2[0] = p0;
    out2[1] = p01;
    out2[2] = p012;
    out2[3] = p0123;
    out2[4] = p0123;
    out2[5] = p123;
    out2[6] = p23;
    out2[7] = p3;
  }
  function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out2) {
    var t;
    var interval = 5e-3;
    var d = Infinity;
    var prev;
    var next;
    var d1;
    var d2;
    _v0[0] = x;
    _v0[1] = y;
    for (var _t = 0; _t < 1; _t += 0.05) {
      _v1[0] = cubicAt(x0, x1, x2, x3, _t);
      _v1[1] = cubicAt(y0, y1, y2, y3, _t);
      d1 = distSquare(_v0, _v1);
      if (d1 < d) {
        t = _t;
        d = d1;
      }
    }
    d = Infinity;
    for (var i = 0; i < 32; i++) {
      if (interval < EPSILON_NUMERIC) {
        break;
      }
      prev = t - interval;
      next = t + interval;
      _v1[0] = cubicAt(x0, x1, x2, x3, prev);
      _v1[1] = cubicAt(y0, y1, y2, y3, prev);
      d1 = distSquare(_v1, _v0);
      if (prev >= 0 && d1 < d) {
        t = prev;
        d = d1;
      } else {
        _v2[0] = cubicAt(x0, x1, x2, x3, next);
        _v2[1] = cubicAt(y0, y1, y2, y3, next);
        d2 = distSquare(_v2, _v0);
        if (next <= 1 && d2 < d) {
          t = next;
          d = d2;
        } else {
          interval *= 0.5;
        }
      }
    }
    return mathSqrt$3(d);
  }
  function cubicLength(x0, y0, x1, y1, x2, y2, x3, y3, iteration) {
    var px = x0;
    var py = y0;
    var d = 0;
    var step = 1 / iteration;
    for (var i = 1; i <= iteration; i++) {
      var t = i * step;
      var x = cubicAt(x0, x1, x2, x3, t);
      var y = cubicAt(y0, y1, y2, y3, t);
      var dx = x - px;
      var dy = y - py;
      d += Math.sqrt(dx * dx + dy * dy);
      px = x;
      py = y;
    }
    return d;
  }
  function quadraticAt(p0, p1, p2, t) {
    var onet = 1 - t;
    return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
  }
  function quadraticDerivativeAt(p0, p1, p2, t) {
    return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
  }
  function quadraticRootAt(p0, p1, p2, val, roots2) {
    var a = p0 - 2 * p1 + p2;
    var b = 2 * (p1 - p0);
    var c = p0 - val;
    var n = 0;
    if (isAroundZero(a)) {
      if (isNotAroundZero$1(b)) {
        var t1 = -c / b;
        if (t1 >= 0 && t1 <= 1) {
          roots2[n++] = t1;
        }
      }
    } else {
      var disc = b * b - 4 * a * c;
      if (isAroundZero(disc)) {
        var t1 = -b / (2 * a);
        if (t1 >= 0 && t1 <= 1) {
          roots2[n++] = t1;
        }
      } else if (disc > 0) {
        var discSqrt = mathSqrt$3(disc);
        var t1 = (-b + discSqrt) / (2 * a);
        var t2 = (-b - discSqrt) / (2 * a);
        if (t1 >= 0 && t1 <= 1) {
          roots2[n++] = t1;
        }
        if (t2 >= 0 && t2 <= 1) {
          roots2[n++] = t2;
        }
      }
    }
    return n;
  }
  function quadraticExtremum(p0, p1, p2) {
    var divider = p0 + p2 - 2 * p1;
    if (divider === 0) {
      return 0.5;
    } else {
      return (p0 - p1) / divider;
    }
  }
  function quadraticSubdivide(p0, p1, p2, t, out2) {
    var p01 = (p1 - p0) * t + p0;
    var p12 = (p2 - p1) * t + p1;
    var p012 = (p12 - p01) * t + p01;
    out2[0] = p0;
    out2[1] = p01;
    out2[2] = p012;
    out2[3] = p012;
    out2[4] = p12;
    out2[5] = p2;
  }
  function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out2) {
    var t;
    var interval = 5e-3;
    var d = Infinity;
    _v0[0] = x;
    _v0[1] = y;
    for (var _t = 0; _t < 1; _t += 0.05) {
      _v1[0] = quadraticAt(x0, x1, x2, _t);
      _v1[1] = quadraticAt(y0, y1, y2, _t);
      var d1 = distSquare(_v0, _v1);
      if (d1 < d) {
        t = _t;
        d = d1;
      }
    }
    d = Infinity;
    for (var i = 0; i < 32; i++) {
      if (interval < EPSILON_NUMERIC) {
        break;
      }
      var prev = t - interval;
      var next = t + interval;
      _v1[0] = quadraticAt(x0, x1, x2, prev);
      _v1[1] = quadraticAt(y0, y1, y2, prev);
      var d1 = distSquare(_v1, _v0);
      if (prev >= 0 && d1 < d) {
        t = prev;
        d = d1;
      } else {
        _v2[0] = quadraticAt(x0, x1, x2, next);
        _v2[1] = quadraticAt(y0, y1, y2, next);
        var d2 = distSquare(_v2, _v0);
        if (next <= 1 && d2 < d) {
          t = next;
          d = d2;
        } else {
          interval *= 0.5;
        }
      }
    }
    return mathSqrt$3(d);
  }
  function quadraticLength(x0, y0, x1, y1, x2, y2, iteration) {
    var px = x0;
    var py = y0;
    var d = 0;
    var step = 1 / iteration;
    for (var i = 1; i <= iteration; i++) {
      var t = i * step;
      var x = quadraticAt(x0, x1, x2, t);
      var y = quadraticAt(y0, y1, y2, t);
      var dx = x - px;
      var dy = y - py;
      d += Math.sqrt(dx * dx + dy * dy);
      px = x;
      py = y;
    }
    return d;
  }
  var regexp = /cubic-bezier\(([0-9,\.e ]+)\)/;
  function createCubicEasingFunc(cubicEasingStr) {
    var cubic = cubicEasingStr && regexp.exec(cubicEasingStr);
    if (cubic) {
      var points2 = cubic[1].split(",");
      var a_1 = +trim(points2[0]);
      var b_1 = +trim(points2[1]);
      var c_1 = +trim(points2[2]);
      var d_1 = +trim(points2[3]);
      if (isNaN(a_1 + b_1 + c_1 + d_1)) {
        return;
      }
      var roots_1 = [];
      return function(p) {
        return p <= 0 ? 0 : p >= 1 ? 1 : cubicRootAt(0, a_1, c_1, 1, p, roots_1) && cubicAt(0, b_1, d_1, 1, roots_1[0]);
      };
    }
  }
  var Clip = function() {
    function Clip2(opts) {
      this._inited = false;
      this._startTime = 0;
      this._pausedTime = 0;
      this._paused = false;
      this._life = opts.life || 1e3;
      this._delay = opts.delay || 0;
      this.loop = opts.loop || false;
      this.onframe = opts.onframe || noop;
      this.ondestroy = opts.ondestroy || noop;
      this.onrestart = opts.onrestart || noop;
      opts.easing && this.setEasing(opts.easing);
    }
    Clip2.prototype.step = function(globalTime, deltaTime) {
      if (!this._inited) {
        this._startTime = globalTime + this._delay;
        this._inited = true;
      }
      if (this._paused) {
        this._pausedTime += deltaTime;
        return;
      }
      var life = this._life;
      var elapsedTime = globalTime - this._startTime - this._pausedTime;
      var percent = elapsedTime / life;
      if (percent < 0) {
        percent = 0;
      }
      percent = Math.min(percent, 1);
      var easingFunc = this.easingFunc;
      var schedule = easingFunc ? easingFunc(percent) : percent;
      this.onframe(schedule);
      if (percent === 1) {
        if (this.loop) {
          var remainder = elapsedTime % life;
          this._startTime = globalTime - remainder;
          this._pausedTime = 0;
          this.onrestart();
        } else {
          return true;
        }
      }
      return false;
    };
    Clip2.prototype.pause = function() {
      this._paused = true;
    };
    Clip2.prototype.resume = function() {
      this._paused = false;
    };
    Clip2.prototype.setEasing = function(easing) {
      this.easing = easing;
      this.easingFunc = isFunction(easing) ? easing : easingFuncs[easing] || createCubicEasingFunc(easing);
    };
    return Clip2;
  }();
  var Entry = /* @__PURE__ */ function() {
    function Entry2(val) {
      this.value = val;
    }
    return Entry2;
  }();
  var LinkedList = function() {
    function LinkedList2() {
      this._len = 0;
    }
    LinkedList2.prototype.insert = function(val) {
      var entry = new Entry(val);
      this.insertEntry(entry);
      return entry;
    };
    LinkedList2.prototype.insertEntry = function(entry) {
      if (!this.head) {
        this.head = this.tail = entry;
      } else {
        this.tail.next = entry;
        entry.prev = this.tail;
        entry.next = null;
        this.tail = entry;
      }
      this._len++;
    };
    LinkedList2.prototype.remove = function(entry) {
      var prev = entry.prev;
      var next = entry.next;
      if (prev) {
        prev.next = next;
      } else {
        this.head = next;
      }
      if (next) {
        next.prev = prev;
      } else {
        this.tail = prev;
      }
      entry.next = entry.prev = null;
      this._len--;
    };
    LinkedList2.prototype.len = function() {
      return this._len;
    };
    LinkedList2.prototype.clear = function() {
      this.head = this.tail = null;
      this._len = 0;
    };
    return LinkedList2;
  }();
  var LRU = function() {
    function LRU2(maxSize) {
      this._list = new LinkedList();
      this._maxSize = 10;
      this._map = {};
      this._maxSize = maxSize;
    }
    LRU2.prototype.put = function(key2, value) {
      var list = this._list;
      var map2 = this._map;
      var removed = null;
      if (map2[key2] == null) {
        var len2 = list.len();
        var entry = this._lastRemovedEntry;
        if (len2 >= this._maxSize && len2 > 0) {
          var leastUsedEntry = list.head;
          list.remove(leastUsedEntry);
          delete map2[leastUsedEntry.key];
          removed = leastUsedEntry.value;
          this._lastRemovedEntry = leastUsedEntry;
        }
        if (entry) {
          entry.value = value;
        } else {
          entry = new Entry(value);
        }
        entry.key = key2;
        list.insertEntry(entry);
        map2[key2] = entry;
      }
      return removed;
    };
    LRU2.prototype.get = function(key2) {
      var entry = this._map[key2];
      var list = this._list;
      if (entry != null) {
        if (entry !== list.tail) {
          list.remove(entry);
          list.insertEntry(entry);
        }
        return entry.value;
      }
    };
    LRU2.prototype.clear = function() {
      this._list.clear();
      this._map = {};
    };
    LRU2.prototype.len = function() {
      return this._list.len();
    };
    return LRU2;
  }();
  var kCSSColorTable = {
    "transparent": [0, 0, 0, 0],
    "aliceblue": [240, 248, 255, 1],
    "antiquewhite": [250, 235, 215, 1],
    "aqua": [0, 255, 255, 1],
    "aquamarine": [127, 255, 212, 1],
    "azure": [240, 255, 255, 1],
    "beige": [245, 245, 220, 1],
    "bisque": [255, 228, 196, 1],
    "black": [0, 0, 0, 1],
    "blanchedalmond": [255, 235, 205, 1],
    "blue": [0, 0, 255, 1],
    "blueviolet": [138, 43, 226, 1],
    "brown": [165, 42, 42, 1],
    "burlywood": [222, 184, 135, 1],
    "cadetblue": [95, 158, 160, 1],
    "chartreuse": [127, 255, 0, 1],
    "chocolate": [210, 105, 30, 1],
    "coral": [255, 127, 80, 1],
    "cornflowerblue": [100, 149, 237, 1],
    "cornsilk": [255, 248, 220, 1],
    "crimson": [220, 20, 60, 1],
    "cyan": [0, 255, 255, 1],
    "darkblue": [0, 0, 139, 1],
    "darkcyan": [0, 139, 139, 1],
    "darkgoldenrod": [184, 134, 11, 1],
    "darkgray": [169, 169, 169, 1],
    "darkgreen": [0, 100, 0, 1],
    "darkgrey": [169, 169, 169, 1],
    "darkkhaki": [189, 183, 107, 1],
    "darkmagenta": [139, 0, 139, 1],
    "darkolivegreen": [85, 107, 47, 1],
    "darkorange": [255, 140, 0, 1],
    "darkorchid": [153, 50, 204, 1],
    "darkred": [139, 0, 0, 1],
    "darksalmon": [233, 150, 122, 1],
    "darkseagreen": [143, 188, 143, 1],
    "darkslateblue": [72, 61, 139, 1],
    "darkslategray": [47, 79, 79, 1],
    "darkslategrey": [47, 79, 79, 1],
    "darkturquoise": [0, 206, 209, 1],
    "darkviolet": [148, 0, 211, 1],
    "deeppink": [255, 20, 147, 1],
    "deepskyblue": [0, 191, 255, 1],
    "dimgray": [105, 105, 105, 1],
    "dimgrey": [105, 105, 105, 1],
    "dodgerblue": [30, 144, 255, 1],
    "firebrick": [178, 34, 34, 1],
    "floralwhite": [255, 250, 240, 1],
    "forestgreen": [34, 139, 34, 1],
    "fuchsia": [255, 0, 255, 1],
    "gainsboro": [220, 220, 220, 1],
    "ghostwhite": [248, 248, 255, 1],
    "gold": [255, 215, 0, 1],
    "goldenrod": [218, 165, 32, 1],
    "gray": [128, 128, 128, 1],
    "green": [0, 128, 0, 1],
    "greenyellow": [173, 255, 47, 1],
    "grey": [128, 128, 128, 1],
    "honeydew": [240, 255, 240, 1],
    "hotpink": [255, 105, 180, 1],
    "indianred": [205, 92, 92, 1],
    "indigo": [75, 0, 130, 1],
    "ivory": [255, 255, 240, 1],
    "khaki": [240, 230, 140, 1],
    "lavender": [230, 230, 250, 1],
    "lavenderblush": [255, 240, 245, 1],
    "lawngreen": [124, 252, 0, 1],
    "lemonchiffon": [255, 250, 205, 1],
    "lightblue": [173, 216, 230, 1],
    "lightcoral": [240, 128, 128, 1],
    "lightcyan": [224, 255, 255, 1],
    "lightgoldenrodyellow": [250, 250, 210, 1],
    "lightgray": [211, 211, 211, 1],
    "lightgreen": [144, 238, 144, 1],
    "lightgrey": [211, 211, 211, 1],
    "lightpink": [255, 182, 193, 1],
    "lightsalmon": [255, 160, 122, 1],
    "lightseagreen": [32, 178, 170, 1],
    "lightskyblue": [135, 206, 250, 1],
    "lightslategray": [119, 136, 153, 1],
    "lightslategrey": [119, 136, 153, 1],
    "lightsteelblue": [176, 196, 222, 1],
    "lightyellow": [255, 255, 224, 1],
    "lime": [0, 255, 0, 1],
    "limegreen": [50, 205, 50, 1],
    "linen": [250, 240, 230, 1],
    "magenta": [255, 0, 255, 1],
    "maroon": [128, 0, 0, 1],
    "mediumaquamarine": [102, 205, 170, 1],
    "mediumblue": [0, 0, 205, 1],
    "mediumorchid": [186, 85, 211, 1],
    "mediumpurple": [147, 112, 219, 1],
    "mediumseagreen": [60, 179, 113, 1],
    "mediumslateblue": [123, 104, 238, 1],
    "mediumspringgreen": [0, 250, 154, 1],
    "mediumturquoise": [72, 209, 204, 1],
    "mediumvioletred": [199, 21, 133, 1],
    "midnightblue": [25, 25, 112, 1],
    "mintcream": [245, 255, 250, 1],
    "mistyrose": [255, 228, 225, 1],
    "moccasin": [255, 228, 181, 1],
    "navajowhite": [255, 222, 173, 1],
    "navy": [0, 0, 128, 1],
    "oldlace": [253, 245, 230, 1],
    "olive": [128, 128, 0, 1],
    "olivedrab": [107, 142, 35, 1],
    "orange": [255, 165, 0, 1],
    "orangered": [255, 69, 0, 1],
    "orchid": [218, 112, 214, 1],
    "palegoldenrod": [238, 232, 170, 1],
    "palegreen": [152, 251, 152, 1],
    "paleturquoise": [175, 238, 238, 1],
    "palevioletred": [219, 112, 147, 1],
    "papayawhip": [255, 239, 213, 1],
    "peachpuff": [255, 218, 185, 1],
    "peru": [205, 133, 63, 1],
    "pink": [255, 192, 203, 1],
    "plum": [221, 160, 221, 1],
    "powderblue": [176, 224, 230, 1],
    "purple": [128, 0, 128, 1],
    "red": [255, 0, 0, 1],
    "rosybrown": [188, 143, 143, 1],
    "royalblue": [65, 105, 225, 1],
    "saddlebrown": [139, 69, 19, 1],
    "salmon": [250, 128, 114, 1],
    "sandybrown": [244, 164, 96, 1],
    "seagreen": [46, 139, 87, 1],
    "seashell": [255, 245, 238, 1],
    "sienna": [160, 82, 45, 1],
    "silver": [192, 192, 192, 1],
    "skyblue": [135, 206, 235, 1],
    "slateblue": [106, 90, 205, 1],
    "slategray": [112, 128, 144, 1],
    "slategrey": [112, 128, 144, 1],
    "snow": [255, 250, 250, 1],
    "springgreen": [0, 255, 127, 1],
    "steelblue": [70, 130, 180, 1],
    "tan": [210, 180, 140, 1],
    "teal": [0, 128, 128, 1],
    "thistle": [216, 191, 216, 1],
    "tomato": [255, 99, 71, 1],
    "turquoise": [64, 224, 208, 1],
    "violet": [238, 130, 238, 1],
    "wheat": [245, 222, 179, 1],
    "white": [255, 255, 255, 1],
    "whitesmoke": [245, 245, 245, 1],
    "yellow": [255, 255, 0, 1],
    "yellowgreen": [154, 205, 50, 1]
  };
  function clampCssByte(i) {
    i = Math.round(i);
    return i < 0 ? 0 : i > 255 ? 255 : i;
  }
  function clampCssFloat(f) {
    return f < 0 ? 0 : f > 1 ? 1 : f;
  }
  function parseCssInt(val) {
    var str = val;
    if (str.length && str.charAt(str.length - 1) === "%") {
      return clampCssByte(parseFloat(str) / 100 * 255);
    }
    return clampCssByte(parseInt(str, 10));
  }
  function parseCssFloat(val) {
    var str = val;
    if (str.length && str.charAt(str.length - 1) === "%") {
      return clampCssFloat(parseFloat(str) / 100);
    }
    return clampCssFloat(parseFloat(str));
  }
  function cssHueToRgb(m1, m2, h) {
    if (h < 0) {
      h += 1;
    } else if (h > 1) {
      h -= 1;
    }
    if (h * 6 < 1) {
      return m1 + (m2 - m1) * h * 6;
    }
    if (h * 2 < 1) {
      return m2;
    }
    if (h * 3 < 2) {
      return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    }
    return m1;
  }
  function lerpNumber(a, b, p) {
    return a + (b - a) * p;
  }
  function setRgba(out2, r, g, b, a) {
    out2[0] = r;
    out2[1] = g;
    out2[2] = b;
    out2[3] = a;
    return out2;
  }
  function copyRgba(out2, a) {
    out2[0] = a[0];
    out2[1] = a[1];
    out2[2] = a[2];
    out2[3] = a[3];
    return out2;
  }
  var colorCache = new LRU(20);
  var lastRemovedArr = null;
  function putToCache(colorStr, rgbaArr) {
    if (lastRemovedArr) {
      copyRgba(lastRemovedArr, rgbaArr);
    }
    lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
  }
  function parse(colorStr, rgbaArr) {
    if (!colorStr) {
      return;
    }
    rgbaArr = rgbaArr || [];
    var cached = colorCache.get(colorStr);
    if (cached) {
      return copyRgba(rgbaArr, cached);
    }
    colorStr = colorStr + "";
    var str = colorStr.replace(/ /g, "").toLowerCase();
    if (str in kCSSColorTable) {
      copyRgba(rgbaArr, kCSSColorTable[str]);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    }
    var strLen = str.length;
    if (str.charAt(0) === "#") {
      if (strLen === 4 || strLen === 5) {
        var iv = parseInt(str.slice(1, 4), 16);
        if (!(iv >= 0 && iv <= 4095)) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        setRgba(rgbaArr, (iv & 3840) >> 4 | (iv & 3840) >> 8, iv & 240 | (iv & 240) >> 4, iv & 15 | (iv & 15) << 4, strLen === 5 ? parseInt(str.slice(4), 16) / 15 : 1);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      } else if (strLen === 7 || strLen === 9) {
        var iv = parseInt(str.slice(1, 7), 16);
        if (!(iv >= 0 && iv <= 16777215)) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        setRgba(rgbaArr, (iv & 16711680) >> 16, (iv & 65280) >> 8, iv & 255, strLen === 9 ? parseInt(str.slice(7), 16) / 255 : 1);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      }
      return;
    }
    var op = str.indexOf("(");
    var ep = str.indexOf(")");
    if (op !== -1 && ep + 1 === strLen) {
      var fname = str.substr(0, op);
      var params = str.substr(op + 1, ep - (op + 1)).split(",");
      var alpha = 1;
      switch (fname) {
        case "rgba":
          if (params.length !== 4) {
            return params.length === 3 ? setRgba(rgbaArr, +params[0], +params[1], +params[2], 1) : setRgba(rgbaArr, 0, 0, 0, 1);
          }
          alpha = parseCssFloat(params.pop());
        case "rgb":
          if (params.length >= 3) {
            setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), params.length === 3 ? alpha : parseCssFloat(params[3]));
            putToCache(colorStr, rgbaArr);
            return rgbaArr;
          } else {
            setRgba(rgbaArr, 0, 0, 0, 1);
            return;
          }
        case "hsla":
          if (params.length !== 4) {
            setRgba(rgbaArr, 0, 0, 0, 1);
            return;
          }
          params[3] = parseCssFloat(params[3]);
          hsla2rgba(params, rgbaArr);
          putToCache(colorStr, rgbaArr);
          return rgbaArr;
        case "hsl":
          if (params.length !== 3) {
            setRgba(rgbaArr, 0, 0, 0, 1);
            return;
          }
          hsla2rgba(params, rgbaArr);
          putToCache(colorStr, rgbaArr);
          return rgbaArr;
        default:
          return;
      }
    }
    setRgba(rgbaArr, 0, 0, 0, 1);
    return;
  }
  function hsla2rgba(hsla, rgba) {
    var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;
    var s = parseCssFloat(hsla[1]);
    var l = parseCssFloat(hsla[2]);
    var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
    var m1 = l * 2 - m2;
    rgba = rgba || [];
    setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);
    if (hsla.length === 4) {
      rgba[3] = hsla[3];
    }
    return rgba;
  }
  function rgba2hsla(rgba) {
    if (!rgba) {
      return;
    }
    var R = rgba[0] / 255;
    var G = rgba[1] / 255;
    var B = rgba[2] / 255;
    var vMin = Math.min(R, G, B);
    var vMax = Math.max(R, G, B);
    var delta = vMax - vMin;
    var L = (vMax + vMin) / 2;
    var H;
    var S;
    if (delta === 0) {
      H = 0;
      S = 0;
    } else {
      if (L < 0.5) {
        S = delta / (vMax + vMin);
      } else {
        S = delta / (2 - vMax - vMin);
      }
      var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
      var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
      var deltaB = ((vMax - B) / 6 + delta / 2) / delta;
      if (R === vMax) {
        H = deltaB - deltaG;
      } else if (G === vMax) {
        H = 1 / 3 + deltaR - deltaB;
      } else if (B === vMax) {
        H = 2 / 3 + deltaG - deltaR;
      }
      if (H < 0) {
        H += 1;
      }
      if (H > 1) {
        H -= 1;
      }
    }
    var hsla = [H * 360, S, L];
    if (rgba[3] != null) {
      hsla.push(rgba[3]);
    }
    return hsla;
  }
  function lift(color2, level) {
    var colorArr = parse(color2);
    if (colorArr) {
      for (var i = 0; i < 3; i++) {
        {
          colorArr[i] = colorArr[i] * (1 - level) | 0;
        }
        if (colorArr[i] > 255) {
          colorArr[i] = 255;
        } else if (colorArr[i] < 0) {
          colorArr[i] = 0;
        }
      }
      return stringify(colorArr, colorArr.length === 4 ? "rgba" : "rgb");
    }
  }
  function lerp(normalizedValue, colors, fullOutput) {
    if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
      return;
    }
    var value = normalizedValue * (colors.length - 1);
    var leftIndex = Math.floor(value);
    var rightIndex = Math.ceil(value);
    var leftColor = parse(colors[leftIndex]);
    var rightColor = parse(colors[rightIndex]);
    var dv = value - leftIndex;
    var color2 = stringify([
      clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),
      clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),
      clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),
      clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))
    ], "rgba");
    return fullOutput ? {
      color: color2,
      leftIndex,
      rightIndex,
      value
    } : color2;
  }
  function modifyHSL(color2, h, s, l) {
    var colorArr = parse(color2);
    if (color2) {
      colorArr = rgba2hsla(colorArr);
      s != null && (colorArr[1] = parseCssFloat(isFunction(s) ? s(colorArr[1]) : s));
      l != null && (colorArr[2] = parseCssFloat(isFunction(l) ? l(colorArr[2]) : l));
      return stringify(hsla2rgba(colorArr), "rgba");
    }
  }
  function stringify(arrColor, type) {
    if (!arrColor || !arrColor.length) {
      return;
    }
    var colorStr = arrColor[0] + "," + arrColor[1] + "," + arrColor[2];
    if (type === "rgba" || type === "hsva" || type === "hsla") {
      colorStr += "," + arrColor[3];
    }
    return type + "(" + colorStr + ")";
  }
  function lum(color2, backgroundLum) {
    var arr = parse(color2);
    return arr ? (0.299 * arr[0] + 0.587 * arr[1] + 0.114 * arr[2]) * arr[3] / 255 + (1 - arr[3]) * backgroundLum : 0;
  }
  var liftedColorCache = new LRU(100);
  function liftColor(color2) {
    if (isString(color2)) {
      var liftedColor = liftedColorCache.get(color2);
      if (!liftedColor) {
        liftedColor = lift(color2, -0.1);
        liftedColorCache.put(color2, liftedColor);
      }
      return liftedColor;
    } else if (isGradientObject(color2)) {
      var ret = extend({}, color2);
      ret.colorStops = map$1(color2.colorStops, function(stop2) {
        return {
          offset: stop2.offset,
          color: lift(stop2.color, -0.1)
        };
      });
      return ret;
    }
    return color2;
  }
  var define_process_env_default$R = {};
  function isLinearGradient(val) {
    return val.type === "linear";
  }
  function isRadialGradient(val) {
    return val.type === "radial";
  }
  (function() {
    if (env.hasGlobalWindow && isFunction(window.btoa)) {
      return function(str) {
        return window.btoa(unescape(encodeURIComponent(str)));
      };
    }
    if (typeof Buffer !== "undefined") {
      return function(str) {
        return Buffer.from(str).toString("base64");
      };
    }
    return function(str) {
      if (define_process_env_default$R.NODE_ENV !== "production") {
        logError("Base64 isn't natively supported in the current environment.");
      }
      return null;
    };
  })();
  var arraySlice = Array.prototype.slice;
  function interpolateNumber$1(p0, p1, percent) {
    return (p1 - p0) * percent + p0;
  }
  function interpolate1DArray(out2, p0, p1, percent) {
    var len2 = p0.length;
    for (var i = 0; i < len2; i++) {
      out2[i] = interpolateNumber$1(p0[i], p1[i], percent);
    }
    return out2;
  }
  function interpolate2DArray(out2, p0, p1, percent) {
    var len2 = p0.length;
    var len22 = len2 && p0[0].length;
    for (var i = 0; i < len2; i++) {
      if (!out2[i]) {
        out2[i] = [];
      }
      for (var j = 0; j < len22; j++) {
        out2[i][j] = interpolateNumber$1(p0[i][j], p1[i][j], percent);
      }
    }
    return out2;
  }
  function add1DArray(out2, p0, p1, sign) {
    var len2 = p0.length;
    for (var i = 0; i < len2; i++) {
      out2[i] = p0[i] + p1[i] * sign;
    }
    return out2;
  }
  function add2DArray(out2, p0, p1, sign) {
    var len2 = p0.length;
    var len22 = len2 && p0[0].length;
    for (var i = 0; i < len2; i++) {
      if (!out2[i]) {
        out2[i] = [];
      }
      for (var j = 0; j < len22; j++) {
        out2[i][j] = p0[i][j] + p1[i][j] * sign;
      }
    }
    return out2;
  }
  function fillColorStops(val0, val1) {
    var len0 = val0.length;
    var len1 = val1.length;
    var shorterArr = len0 > len1 ? val1 : val0;
    var shorterLen = Math.min(len0, len1);
    var last = shorterArr[shorterLen - 1] || { color: [0, 0, 0, 0], offset: 0 };
    for (var i = shorterLen; i < Math.max(len0, len1); i++) {
      shorterArr.push({
        offset: last.offset,
        color: last.color.slice()
      });
    }
  }
  function fillArray(val0, val1, arrDim) {
    var arr0 = val0;
    var arr1 = val1;
    if (!arr0.push || !arr1.push) {
      return;
    }
    var arr0Len = arr0.length;
    var arr1Len = arr1.length;
    if (arr0Len !== arr1Len) {
      var isPreviousLarger = arr0Len > arr1Len;
      if (isPreviousLarger) {
        arr0.length = arr1Len;
      } else {
        for (var i = arr0Len; i < arr1Len; i++) {
          arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
        }
      }
    }
    var len2 = arr0[0] && arr0[0].length;
    for (var i = 0; i < arr0.length; i++) {
      if (arrDim === 1) {
        if (isNaN(arr0[i])) {
          arr0[i] = arr1[i];
        }
      } else {
        for (var j = 0; j < len2; j++) {
          if (isNaN(arr0[i][j])) {
            arr0[i][j] = arr1[i][j];
          }
        }
      }
    }
  }
  function cloneValue(value) {
    if (isArrayLike(value)) {
      var len2 = value.length;
      if (isArrayLike(value[0])) {
        var ret = [];
        for (var i = 0; i < len2; i++) {
          ret.push(arraySlice.call(value[i]));
        }
        return ret;
      }
      return arraySlice.call(value);
    }
    return value;
  }
  function rgba2String(rgba) {
    rgba[0] = Math.floor(rgba[0]) || 0;
    rgba[1] = Math.floor(rgba[1]) || 0;
    rgba[2] = Math.floor(rgba[2]) || 0;
    rgba[3] = rgba[3] == null ? 1 : rgba[3];
    return "rgba(" + rgba.join(",") + ")";
  }
  function guessArrayDim(value) {
    return isArrayLike(value && value[0]) ? 2 : 1;
  }
  var VALUE_TYPE_NUMBER = 0;
  var VALUE_TYPE_1D_ARRAY = 1;
  var VALUE_TYPE_2D_ARRAY = 2;
  var VALUE_TYPE_COLOR = 3;
  var VALUE_TYPE_LINEAR_GRADIENT = 4;
  var VALUE_TYPE_RADIAL_GRADIENT = 5;
  var VALUE_TYPE_UNKOWN = 6;
  function isGradientValueType(valType) {
    return valType === VALUE_TYPE_LINEAR_GRADIENT || valType === VALUE_TYPE_RADIAL_GRADIENT;
  }
  function isArrayValueType(valType) {
    return valType === VALUE_TYPE_1D_ARRAY || valType === VALUE_TYPE_2D_ARRAY;
  }
  var tmpRgba = [0, 0, 0, 0];
  var Track = function() {
    function Track2(propName) {
      this.keyframes = [];
      this.discrete = false;
      this._invalid = false;
      this._needsSort = false;
      this._lastFr = 0;
      this._lastFrP = 0;
      this.propName = propName;
    }
    Track2.prototype.isFinished = function() {
      return this._finished;
    };
    Track2.prototype.setFinished = function() {
      this._finished = true;
      if (this._additiveTrack) {
        this._additiveTrack.setFinished();
      }
    };
    Track2.prototype.needsAnimate = function() {
      return this.keyframes.length >= 1;
    };
    Track2.prototype.getAdditiveTrack = function() {
      return this._additiveTrack;
    };
    Track2.prototype.addKeyframe = function(time, rawValue, easing) {
      this._needsSort = true;
      var keyframes = this.keyframes;
      var len2 = keyframes.length;
      var discrete = false;
      var valType = VALUE_TYPE_UNKOWN;
      var value = rawValue;
      if (isArrayLike(rawValue)) {
        var arrayDim = guessArrayDim(rawValue);
        valType = arrayDim;
        if (arrayDim === 1 && !isNumber(rawValue[0]) || arrayDim === 2 && !isNumber(rawValue[0][0])) {
          discrete = true;
        }
      } else {
        if (isNumber(rawValue) && !eqNaN(rawValue)) {
          valType = VALUE_TYPE_NUMBER;
        } else if (isString(rawValue)) {
          if (!isNaN(+rawValue)) {
            valType = VALUE_TYPE_NUMBER;
          } else {
            var colorArray = parse(rawValue);
            if (colorArray) {
              value = colorArray;
              valType = VALUE_TYPE_COLOR;
            }
          }
        } else if (isGradientObject(rawValue)) {
          var parsedGradient = extend({}, value);
          parsedGradient.colorStops = map$1(rawValue.colorStops, function(colorStop) {
            return {
              offset: colorStop.offset,
              color: parse(colorStop.color)
            };
          });
          if (isLinearGradient(rawValue)) {
            valType = VALUE_TYPE_LINEAR_GRADIENT;
          } else if (isRadialGradient(rawValue)) {
            valType = VALUE_TYPE_RADIAL_GRADIENT;
          }
          value = parsedGradient;
        }
      }
      if (len2 === 0) {
        this.valType = valType;
      } else if (valType !== this.valType || valType === VALUE_TYPE_UNKOWN) {
        discrete = true;
      }
      this.discrete = this.discrete || discrete;
      var kf = {
        time,
        value,
        rawValue,
        percent: 0
      };
      if (easing) {
        kf.easing = easing;
        kf.easingFunc = isFunction(easing) ? easing : easingFuncs[easing] || createCubicEasingFunc(easing);
      }
      keyframes.push(kf);
      return kf;
    };
    Track2.prototype.prepare = function(maxTime, additiveTrack) {
      var kfs = this.keyframes;
      if (this._needsSort) {
        kfs.sort(function(a, b) {
          return a.time - b.time;
        });
      }
      var valType = this.valType;
      var kfsLen = kfs.length;
      var lastKf = kfs[kfsLen - 1];
      var isDiscrete = this.discrete;
      var isArr = isArrayValueType(valType);
      var isGradient = isGradientValueType(valType);
      for (var i = 0; i < kfsLen; i++) {
        var kf = kfs[i];
        var value = kf.value;
        var lastValue = lastKf.value;
        kf.percent = kf.time / maxTime;
        if (!isDiscrete) {
          if (isArr && i !== kfsLen - 1) {
            fillArray(value, lastValue, valType);
          } else if (isGradient) {
            fillColorStops(value.colorStops, lastValue.colorStops);
          }
        }
      }
      if (!isDiscrete && valType !== VALUE_TYPE_RADIAL_GRADIENT && additiveTrack && this.needsAnimate() && additiveTrack.needsAnimate() && valType === additiveTrack.valType && !additiveTrack._finished) {
        this._additiveTrack = additiveTrack;
        var startValue = kfs[0].value;
        for (var i = 0; i < kfsLen; i++) {
          if (valType === VALUE_TYPE_NUMBER) {
            kfs[i].additiveValue = kfs[i].value - startValue;
          } else if (valType === VALUE_TYPE_COLOR) {
            kfs[i].additiveValue = add1DArray([], kfs[i].value, startValue, -1);
          } else if (isArrayValueType(valType)) {
            kfs[i].additiveValue = valType === VALUE_TYPE_1D_ARRAY ? add1DArray([], kfs[i].value, startValue, -1) : add2DArray([], kfs[i].value, startValue, -1);
          }
        }
      }
    };
    Track2.prototype.step = function(target, percent) {
      if (this._finished) {
        return;
      }
      if (this._additiveTrack && this._additiveTrack._finished) {
        this._additiveTrack = null;
      }
      var isAdditive = this._additiveTrack != null;
      var valueKey = isAdditive ? "additiveValue" : "value";
      var valType = this.valType;
      var keyframes = this.keyframes;
      var kfsNum = keyframes.length;
      var propName = this.propName;
      var isValueColor = valType === VALUE_TYPE_COLOR;
      var frameIdx;
      var lastFrame = this._lastFr;
      var mathMin2 = Math.min;
      var frame;
      var nextFrame;
      if (kfsNum === 1) {
        frame = nextFrame = keyframes[0];
      } else {
        if (percent < 0) {
          frameIdx = 0;
        } else if (percent < this._lastFrP) {
          var start2 = mathMin2(lastFrame + 1, kfsNum - 1);
          for (frameIdx = start2; frameIdx >= 0; frameIdx--) {
            if (keyframes[frameIdx].percent <= percent) {
              break;
            }
          }
          frameIdx = mathMin2(frameIdx, kfsNum - 2);
        } else {
          for (frameIdx = lastFrame; frameIdx < kfsNum; frameIdx++) {
            if (keyframes[frameIdx].percent > percent) {
              break;
            }
          }
          frameIdx = mathMin2(frameIdx - 1, kfsNum - 2);
        }
        nextFrame = keyframes[frameIdx + 1];
        frame = keyframes[frameIdx];
      }
      if (!(frame && nextFrame)) {
        return;
      }
      this._lastFr = frameIdx;
      this._lastFrP = percent;
      var interval = nextFrame.percent - frame.percent;
      var w = interval === 0 ? 1 : mathMin2((percent - frame.percent) / interval, 1);
      if (nextFrame.easingFunc) {
        w = nextFrame.easingFunc(w);
      }
      var targetArr = isAdditive ? this._additiveValue : isValueColor ? tmpRgba : target[propName];
      if ((isArrayValueType(valType) || isValueColor) && !targetArr) {
        targetArr = this._additiveValue = [];
      }
      if (this.discrete) {
        target[propName] = w < 1 ? frame.rawValue : nextFrame.rawValue;
      } else if (isArrayValueType(valType)) {
        valType === VALUE_TYPE_1D_ARRAY ? interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w) : interpolate2DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);
      } else if (isGradientValueType(valType)) {
        var val = frame[valueKey];
        var nextVal_1 = nextFrame[valueKey];
        var isLinearGradient_1 = valType === VALUE_TYPE_LINEAR_GRADIENT;
        target[propName] = {
          type: isLinearGradient_1 ? "linear" : "radial",
          x: interpolateNumber$1(val.x, nextVal_1.x, w),
          y: interpolateNumber$1(val.y, nextVal_1.y, w),
          colorStops: map$1(val.colorStops, function(colorStop, idx) {
            var nextColorStop = nextVal_1.colorStops[idx];
            return {
              offset: interpolateNumber$1(colorStop.offset, nextColorStop.offset, w),
              color: rgba2String(interpolate1DArray([], colorStop.color, nextColorStop.color, w))
            };
          }),
          global: nextVal_1.global
        };
        if (isLinearGradient_1) {
          target[propName].x2 = interpolateNumber$1(val.x2, nextVal_1.x2, w);
          target[propName].y2 = interpolateNumber$1(val.y2, nextVal_1.y2, w);
        } else {
          target[propName].r = interpolateNumber$1(val.r, nextVal_1.r, w);
        }
      } else if (isValueColor) {
        interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);
        if (!isAdditive) {
          target[propName] = rgba2String(targetArr);
        }
      } else {
        var value = interpolateNumber$1(frame[valueKey], nextFrame[valueKey], w);
        if (isAdditive) {
          this._additiveValue = value;
        } else {
          target[propName] = value;
        }
      }
      if (isAdditive) {
        this._addToTarget(target);
      }
    };
    Track2.prototype._addToTarget = function(target) {
      var valType = this.valType;
      var propName = this.propName;
      var additiveValue = this._additiveValue;
      if (valType === VALUE_TYPE_NUMBER) {
        target[propName] = target[propName] + additiveValue;
      } else if (valType === VALUE_TYPE_COLOR) {
        parse(target[propName], tmpRgba);
        add1DArray(tmpRgba, tmpRgba, additiveValue, 1);
        target[propName] = rgba2String(tmpRgba);
      } else if (valType === VALUE_TYPE_1D_ARRAY) {
        add1DArray(target[propName], target[propName], additiveValue, 1);
      } else if (valType === VALUE_TYPE_2D_ARRAY) {
        add2DArray(target[propName], target[propName], additiveValue, 1);
      }
    };
    return Track2;
  }();
  var Animator = function() {
    function Animator2(target, loop, allowDiscreteAnimation, additiveTo) {
      this._tracks = {};
      this._trackKeys = [];
      this._maxTime = 0;
      this._started = 0;
      this._clip = null;
      this._target = target;
      this._loop = loop;
      if (loop && additiveTo) {
        logError("Can' use additive animation on looped animation.");
        return;
      }
      this._additiveAnimators = additiveTo;
      this._allowDiscrete = allowDiscreteAnimation;
    }
    Animator2.prototype.getMaxTime = function() {
      return this._maxTime;
    };
    Animator2.prototype.getDelay = function() {
      return this._delay;
    };
    Animator2.prototype.getLoop = function() {
      return this._loop;
    };
    Animator2.prototype.getTarget = function() {
      return this._target;
    };
    Animator2.prototype.changeTarget = function(target) {
      this._target = target;
    };
    Animator2.prototype.when = function(time, props, easing) {
      return this.whenWithKeys(time, props, keys(props), easing);
    };
    Animator2.prototype.whenWithKeys = function(time, props, propNames, easing) {
      var tracks = this._tracks;
      for (var i = 0; i < propNames.length; i++) {
        var propName = propNames[i];
        var track = tracks[propName];
        if (!track) {
          track = tracks[propName] = new Track(propName);
          var initialValue = void 0;
          var additiveTrack = this._getAdditiveTrack(propName);
          if (additiveTrack) {
            var addtiveTrackKfs = additiveTrack.keyframes;
            var lastFinalKf = addtiveTrackKfs[addtiveTrackKfs.length - 1];
            initialValue = lastFinalKf && lastFinalKf.value;
            if (additiveTrack.valType === VALUE_TYPE_COLOR && initialValue) {
              initialValue = rgba2String(initialValue);
            }
          } else {
            initialValue = this._target[propName];
          }
          if (initialValue == null) {
            continue;
          }
          if (time > 0) {
            track.addKeyframe(0, cloneValue(initialValue), easing);
          }
          this._trackKeys.push(propName);
        }
        track.addKeyframe(time, cloneValue(props[propName]), easing);
      }
      this._maxTime = Math.max(this._maxTime, time);
      return this;
    };
    Animator2.prototype.pause = function() {
      this._clip.pause();
      this._paused = true;
    };
    Animator2.prototype.resume = function() {
      this._clip.resume();
      this._paused = false;
    };
    Animator2.prototype.isPaused = function() {
      return !!this._paused;
    };
    Animator2.prototype.duration = function(duration) {
      this._maxTime = duration;
      this._force = true;
      return this;
    };
    Animator2.prototype._doneCallback = function() {
      this._setTracksFinished();
      this._clip = null;
      var doneList = this._doneCbs;
      if (doneList) {
        var len2 = doneList.length;
        for (var i = 0; i < len2; i++) {
          doneList[i].call(this);
        }
      }
    };
    Animator2.prototype._abortedCallback = function() {
      this._setTracksFinished();
      var animation = this.animation;
      var abortedList = this._abortedCbs;
      if (animation) {
        animation.removeClip(this._clip);
      }
      this._clip = null;
      if (abortedList) {
        for (var i = 0; i < abortedList.length; i++) {
          abortedList[i].call(this);
        }
      }
    };
    Animator2.prototype._setTracksFinished = function() {
      var tracks = this._tracks;
      var tracksKeys = this._trackKeys;
      for (var i = 0; i < tracksKeys.length; i++) {
        tracks[tracksKeys[i]].setFinished();
      }
    };
    Animator2.prototype._getAdditiveTrack = function(trackName) {
      var additiveTrack;
      var additiveAnimators = this._additiveAnimators;
      if (additiveAnimators) {
        for (var i = 0; i < additiveAnimators.length; i++) {
          var track = additiveAnimators[i].getTrack(trackName);
          if (track) {
            additiveTrack = track;
          }
        }
      }
      return additiveTrack;
    };
    Animator2.prototype.start = function(easing) {
      if (this._started > 0) {
        return;
      }
      this._started = 1;
      var self2 = this;
      var tracks = [];
      var maxTime = this._maxTime || 0;
      for (var i = 0; i < this._trackKeys.length; i++) {
        var propName = this._trackKeys[i];
        var track = this._tracks[propName];
        var additiveTrack = this._getAdditiveTrack(propName);
        var kfs = track.keyframes;
        var kfsNum = kfs.length;
        track.prepare(maxTime, additiveTrack);
        if (track.needsAnimate()) {
          if (!this._allowDiscrete && track.discrete) {
            var lastKf = kfs[kfsNum - 1];
            if (lastKf) {
              self2._target[track.propName] = lastKf.rawValue;
            }
            track.setFinished();
          } else {
            tracks.push(track);
          }
        }
      }
      if (tracks.length || this._force) {
        var clip = new Clip({
          life: maxTime,
          loop: this._loop,
          delay: this._delay || 0,
          onframe: function(percent) {
            self2._started = 2;
            var additiveAnimators = self2._additiveAnimators;
            if (additiveAnimators) {
              var stillHasAdditiveAnimator = false;
              for (var i2 = 0; i2 < additiveAnimators.length; i2++) {
                if (additiveAnimators[i2]._clip) {
                  stillHasAdditiveAnimator = true;
                  break;
                }
              }
              if (!stillHasAdditiveAnimator) {
                self2._additiveAnimators = null;
              }
            }
            for (var i2 = 0; i2 < tracks.length; i2++) {
              tracks[i2].step(self2._target, percent);
            }
            var onframeList = self2._onframeCbs;
            if (onframeList) {
              for (var i2 = 0; i2 < onframeList.length; i2++) {
                onframeList[i2](self2._target, percent);
              }
            }
          },
          ondestroy: function() {
            self2._doneCallback();
          }
        });
        this._clip = clip;
        if (this.animation) {
          this.animation.addClip(clip);
        }
        if (easing) {
          clip.setEasing(easing);
        }
      } else {
        this._doneCallback();
      }
      return this;
    };
    Animator2.prototype.stop = function(forwardToLast) {
      if (!this._clip) {
        return;
      }
      var clip = this._clip;
      if (forwardToLast) {
        clip.onframe(1);
      }
      this._abortedCallback();
    };
    Animator2.prototype.delay = function(time) {
      this._delay = time;
      return this;
    };
    Animator2.prototype.during = function(cb) {
      if (cb) {
        if (!this._onframeCbs) {
          this._onframeCbs = [];
        }
        this._onframeCbs.push(cb);
      }
      return this;
    };
    Animator2.prototype.done = function(cb) {
      if (cb) {
        if (!this._doneCbs) {
          this._doneCbs = [];
        }
        this._doneCbs.push(cb);
      }
      return this;
    };
    Animator2.prototype.aborted = function(cb) {
      if (cb) {
        if (!this._abortedCbs) {
          this._abortedCbs = [];
        }
        this._abortedCbs.push(cb);
      }
      return this;
    };
    Animator2.prototype.getClip = function() {
      return this._clip;
    };
    Animator2.prototype.getTrack = function(propName) {
      return this._tracks[propName];
    };
    Animator2.prototype.getTracks = function() {
      var _this = this;
      return map$1(this._trackKeys, function(key2) {
        return _this._tracks[key2];
      });
    };
    Animator2.prototype.stopTracks = function(propNames, forwardToLast) {
      if (!propNames.length || !this._clip) {
        return true;
      }
      var tracks = this._tracks;
      var tracksKeys = this._trackKeys;
      for (var i = 0; i < propNames.length; i++) {
        var track = tracks[propNames[i]];
        if (track && !track.isFinished()) {
          if (forwardToLast) {
            track.step(this._target, 1);
          } else if (this._started === 1) {
            track.step(this._target, 0);
          }
          track.setFinished();
        }
      }
      var allAborted = true;
      for (var i = 0; i < tracksKeys.length; i++) {
        if (!tracks[tracksKeys[i]].isFinished()) {
          allAborted = false;
          break;
        }
      }
      if (allAborted) {
        this._abortedCallback();
      }
      return allAborted;
    };
    Animator2.prototype.saveTo = function(target, trackKeys, firstOrLast) {
      if (!target) {
        return;
      }
      trackKeys = trackKeys || this._trackKeys;
      for (var i = 0; i < trackKeys.length; i++) {
        var propName = trackKeys[i];
        var track = this._tracks[propName];
        if (!track || track.isFinished()) {
          continue;
        }
        var kfs = track.keyframes;
        var kf = kfs[firstOrLast ? 0 : kfs.length - 1];
        if (kf) {
          target[propName] = cloneValue(kf.rawValue);
        }
      }
    };
    Animator2.prototype.__changeFinalValue = function(finalProps, trackKeys) {
      trackKeys = trackKeys || keys(finalProps);
      for (var i = 0; i < trackKeys.length; i++) {
        var propName = trackKeys[i];
        var track = this._tracks[propName];
        if (!track) {
          continue;
        }
        var kfs = track.keyframes;
        if (kfs.length > 1) {
          var lastKf = kfs.pop();
          track.addKeyframe(lastKf.time, finalProps[propName]);
          track.prepare(this._maxTime, track.getAdditiveTrack());
        }
      }
    };
    return Animator2;
  }();
  function getTime() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  var Animation = function(_super) {
    __extends(Animation2, _super);
    function Animation2(opts) {
      var _this = _super.call(this) || this;
      _this._running = false;
      _this._time = 0;
      _this._pausedTime = 0;
      _this._pauseStart = 0;
      _this._paused = false;
      opts = opts || {};
      _this.stage = opts.stage || {};
      return _this;
    }
    Animation2.prototype.addClip = function(clip) {
      if (clip.animation) {
        this.removeClip(clip);
      }
      if (!this._head) {
        this._head = this._tail = clip;
      } else {
        this._tail.next = clip;
        clip.prev = this._tail;
        clip.next = null;
        this._tail = clip;
      }
      clip.animation = this;
    };
    Animation2.prototype.addAnimator = function(animator) {
      animator.animation = this;
      var clip = animator.getClip();
      if (clip) {
        this.addClip(clip);
      }
    };
    Animation2.prototype.removeClip = function(clip) {
      if (!clip.animation) {
        return;
      }
      var prev = clip.prev;
      var next = clip.next;
      if (prev) {
        prev.next = next;
      } else {
        this._head = next;
      }
      if (next) {
        next.prev = prev;
      } else {
        this._tail = prev;
      }
      clip.next = clip.prev = clip.animation = null;
    };
    Animation2.prototype.removeAnimator = function(animator) {
      var clip = animator.getClip();
      if (clip) {
        this.removeClip(clip);
      }
      animator.animation = null;
    };
    Animation2.prototype.update = function(notTriggerFrameAndStageUpdate) {
      var time = getTime() - this._pausedTime;
      var delta = time - this._time;
      var clip = this._head;
      while (clip) {
        var nextClip = clip.next;
        var finished = clip.step(time, delta);
        if (finished) {
          clip.ondestroy();
          this.removeClip(clip);
          clip = nextClip;
        } else {
          clip = nextClip;
        }
      }
      this._time = time;
      if (!notTriggerFrameAndStageUpdate) {
        this.trigger("frame", delta);
        this.stage.update && this.stage.update();
      }
    };
    Animation2.prototype._startLoop = function() {
      var self2 = this;
      this._running = true;
      function step() {
        if (self2._running) {
          requestAnimationFrame(step);
          !self2._paused && self2.update();
        }
      }
      requestAnimationFrame(step);
    };
    Animation2.prototype.start = function() {
      if (this._running) {
        return;
      }
      this._time = getTime();
      this._pausedTime = 0;
      this._startLoop();
    };
    Animation2.prototype.stop = function() {
      this._running = false;
    };
    Animation2.prototype.pause = function() {
      if (!this._paused) {
        this._pauseStart = getTime();
        this._paused = true;
      }
    };
    Animation2.prototype.resume = function() {
      if (this._paused) {
        this._pausedTime += getTime() - this._pauseStart;
        this._paused = false;
      }
    };
    Animation2.prototype.clear = function() {
      var clip = this._head;
      while (clip) {
        var nextClip = clip.next;
        clip.prev = clip.next = clip.animation = null;
        clip = nextClip;
      }
      this._head = this._tail = null;
    };
    Animation2.prototype.isFinished = function() {
      return this._head == null;
    };
    Animation2.prototype.animate = function(target, options) {
      options = options || {};
      this.start();
      var animator = new Animator(target, options.loop);
      this.addAnimator(animator);
      return animator;
    };
    return Animation2;
  }(Eventful);
  var TOUCH_CLICK_DELAY = 300;
  var globalEventSupported = env.domSupported;
  var localNativeListenerNames = function() {
    var mouseHandlerNames = [
      "click",
      "dblclick",
      "mousewheel",
      "wheel",
      "mouseout",
      "mouseup",
      "mousedown",
      "mousemove",
      "contextmenu"
    ];
    var touchHandlerNames = [
      "touchstart",
      "touchend",
      "touchmove"
    ];
    var pointerEventNameMap = {
      pointerdown: 1,
      pointerup: 1,
      pointermove: 1,
      pointerout: 1
    };
    var pointerHandlerNames = map$1(mouseHandlerNames, function(name) {
      var nm = name.replace("mouse", "pointer");
      return pointerEventNameMap.hasOwnProperty(nm) ? nm : name;
    });
    return {
      mouse: mouseHandlerNames,
      touch: touchHandlerNames,
      pointer: pointerHandlerNames
    };
  }();
  var globalNativeListenerNames = {
    mouse: ["mousemove", "mouseup"],
    pointer: ["pointermove", "pointerup"]
  };
  var wheelEventSupported = false;
  function isPointerFromTouch(event) {
    var pointerType = event.pointerType;
    return pointerType === "pen" || pointerType === "touch";
  }
  function setTouchTimer(scope) {
    scope.touching = true;
    if (scope.touchTimer != null) {
      clearTimeout(scope.touchTimer);
      scope.touchTimer = null;
    }
    scope.touchTimer = setTimeout(function() {
      scope.touching = false;
      scope.touchTimer = null;
    }, 700);
  }
  function markTouch(event) {
    event && (event.zrByTouch = true);
  }
  function normalizeGlobalEvent(instance, event) {
    return normalizeEvent(instance.dom, new FakeGlobalEvent(instance, event), true);
  }
  function isLocalEl(instance, el) {
    var elTmp = el;
    var isLocal = false;
    while (elTmp && elTmp.nodeType !== 9 && !(isLocal = elTmp.domBelongToZr || elTmp !== el && elTmp === instance.painterRoot)) {
      elTmp = elTmp.parentNode;
    }
    return isLocal;
  }
  var FakeGlobalEvent = /* @__PURE__ */ function() {
    function FakeGlobalEvent2(instance, event) {
      this.stopPropagation = noop;
      this.stopImmediatePropagation = noop;
      this.preventDefault = noop;
      this.type = event.type;
      this.target = this.currentTarget = instance.dom;
      this.pointerType = event.pointerType;
      this.clientX = event.clientX;
      this.clientY = event.clientY;
    }
    return FakeGlobalEvent2;
  }();
  var localDOMHandlers = {
    mousedown: function(event) {
      event = normalizeEvent(this.dom, event);
      this.__mayPointerCapture = [event.zrX, event.zrY];
      this.trigger("mousedown", event);
    },
    mousemove: function(event) {
      event = normalizeEvent(this.dom, event);
      var downPoint = this.__mayPointerCapture;
      if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {
        this.__togglePointerCapture(true);
      }
      this.trigger("mousemove", event);
    },
    mouseup: function(event) {
      event = normalizeEvent(this.dom, event);
      this.__togglePointerCapture(false);
      this.trigger("mouseup", event);
    },
    mouseout: function(event) {
      event = normalizeEvent(this.dom, event);
      var element = event.toElement || event.relatedTarget;
      if (!isLocalEl(this, element)) {
        if (this.__pointerCapturing) {
          event.zrEventControl = "no_globalout";
        }
        this.trigger("mouseout", event);
      }
    },
    wheel: function(event) {
      wheelEventSupported = true;
      event = normalizeEvent(this.dom, event);
      this.trigger("mousewheel", event);
    },
    mousewheel: function(event) {
      if (wheelEventSupported) {
        return;
      }
      event = normalizeEvent(this.dom, event);
      this.trigger("mousewheel", event);
    },
    touchstart: function(event) {
      event = normalizeEvent(this.dom, event);
      markTouch(event);
      this.__lastTouchMoment = /* @__PURE__ */ new Date();
      this.handler.processGesture(event, "start");
      localDOMHandlers.mousemove.call(this, event);
      localDOMHandlers.mousedown.call(this, event);
    },
    touchmove: function(event) {
      event = normalizeEvent(this.dom, event);
      markTouch(event);
      this.handler.processGesture(event, "change");
      localDOMHandlers.mousemove.call(this, event);
    },
    touchend: function(event) {
      event = normalizeEvent(this.dom, event);
      markTouch(event);
      this.handler.processGesture(event, "end");
      localDOMHandlers.mouseup.call(this, event);
      if (+/* @__PURE__ */ new Date() - +this.__lastTouchMoment < TOUCH_CLICK_DELAY) {
        localDOMHandlers.click.call(this, event);
      }
    },
    pointerdown: function(event) {
      localDOMHandlers.mousedown.call(this, event);
    },
    pointermove: function(event) {
      if (!isPointerFromTouch(event)) {
        localDOMHandlers.mousemove.call(this, event);
      }
    },
    pointerup: function(event) {
      localDOMHandlers.mouseup.call(this, event);
    },
    pointerout: function(event) {
      if (!isPointerFromTouch(event)) {
        localDOMHandlers.mouseout.call(this, event);
      }
    }
  };
  each$5(["click", "dblclick", "contextmenu"], function(name) {
    localDOMHandlers[name] = function(event) {
      event = normalizeEvent(this.dom, event);
      this.trigger(name, event);
    };
  });
  var globalDOMHandlers = {
    pointermove: function(event) {
      if (!isPointerFromTouch(event)) {
        globalDOMHandlers.mousemove.call(this, event);
      }
    },
    pointerup: function(event) {
      globalDOMHandlers.mouseup.call(this, event);
    },
    mousemove: function(event) {
      this.trigger("mousemove", event);
    },
    mouseup: function(event) {
      var pointerCaptureReleasing = this.__pointerCapturing;
      this.__togglePointerCapture(false);
      this.trigger("mouseup", event);
      if (pointerCaptureReleasing) {
        event.zrEventControl = "only_globalout";
        this.trigger("mouseout", event);
      }
    }
  };
  function mountLocalDOMEventListeners(instance, scope) {
    var domHandlers = scope.domHandlers;
    if (env.pointerEventsSupported) {
      each$5(localNativeListenerNames.pointer, function(nativeEventName) {
        mountSingleDOMEventListener(scope, nativeEventName, function(event) {
          domHandlers[nativeEventName].call(instance, event);
        });
      });
    } else {
      if (env.touchEventsSupported) {
        each$5(localNativeListenerNames.touch, function(nativeEventName) {
          mountSingleDOMEventListener(scope, nativeEventName, function(event) {
            domHandlers[nativeEventName].call(instance, event);
            setTouchTimer(scope);
          });
        });
      }
      each$5(localNativeListenerNames.mouse, function(nativeEventName) {
        mountSingleDOMEventListener(scope, nativeEventName, function(event) {
          event = getNativeEvent(event);
          if (!scope.touching) {
            domHandlers[nativeEventName].call(instance, event);
          }
        });
      });
    }
  }
  function mountGlobalDOMEventListeners(instance, scope) {
    if (env.pointerEventsSupported) {
      each$5(globalNativeListenerNames.pointer, mount);
    } else if (!env.touchEventsSupported) {
      each$5(globalNativeListenerNames.mouse, mount);
    }
    function mount(nativeEventName) {
      function nativeEventListener(event) {
        event = getNativeEvent(event);
        if (!isLocalEl(instance, event.target)) {
          event = normalizeGlobalEvent(instance, event);
          scope.domHandlers[nativeEventName].call(instance, event);
        }
      }
      mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, { capture: true });
    }
  }
  function mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {
    scope.mounted[nativeEventName] = listener;
    scope.listenerOpts[nativeEventName] = opt;
    addEventListener(scope.domTarget, nativeEventName, listener, opt);
  }
  function unmountDOMEventListeners(scope) {
    var mounted = scope.mounted;
    for (var nativeEventName in mounted) {
      if (mounted.hasOwnProperty(nativeEventName)) {
        removeEventListener(scope.domTarget, nativeEventName, mounted[nativeEventName], scope.listenerOpts[nativeEventName]);
      }
    }
    scope.mounted = {};
  }
  var DOMHandlerScope = /* @__PURE__ */ function() {
    function DOMHandlerScope2(domTarget, domHandlers) {
      this.mounted = {};
      this.listenerOpts = {};
      this.touching = false;
      this.domTarget = domTarget;
      this.domHandlers = domHandlers;
    }
    return DOMHandlerScope2;
  }();
  var HandlerDomProxy = function(_super) {
    __extends(HandlerDomProxy2, _super);
    function HandlerDomProxy2(dom, painterRoot) {
      var _this = _super.call(this) || this;
      _this.__pointerCapturing = false;
      _this.dom = dom;
      _this.painterRoot = painterRoot;
      _this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);
      if (globalEventSupported) {
        _this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);
      }
      mountLocalDOMEventListeners(_this, _this._localHandlerScope);
      return _this;
    }
    HandlerDomProxy2.prototype.dispose = function() {
      unmountDOMEventListeners(this._localHandlerScope);
      if (globalEventSupported) {
        unmountDOMEventListeners(this._globalHandlerScope);
      }
    };
    HandlerDomProxy2.prototype.setCursor = function(cursorStyle) {
      this.dom.style && (this.dom.style.cursor = cursorStyle || "default");
    };
    HandlerDomProxy2.prototype.__togglePointerCapture = function(isPointerCapturing) {
      this.__mayPointerCapture = null;
      if (globalEventSupported && +this.__pointerCapturing ^ +isPointerCapturing) {
        this.__pointerCapturing = isPointerCapturing;
        var globalHandlerScope = this._globalHandlerScope;
        isPointerCapturing ? mountGlobalDOMEventListeners(this, globalHandlerScope) : unmountDOMEventListeners(globalHandlerScope);
      }
    };
    return HandlerDomProxy2;
  }(Eventful);
  var dpr = 1;
  if (env.hasGlobalWindow) {
    dpr = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1);
  }
  var devicePixelRatio = dpr;
  var DARK_MODE_THRESHOLD = 0.4;
  var DARK_LABEL_COLOR = "#333";
  var LIGHT_LABEL_COLOR = "#ccc";
  var LIGHTER_LABEL_COLOR = "#eee";
  var mIdentity = identity;
  var EPSILON$1 = 5e-5;
  function isNotAroundZero(val) {
    return val > EPSILON$1 || val < -EPSILON$1;
  }
  var scaleTmp = [];
  var tmpTransform = [];
  var originTransform = create();
  var abs = Math.abs;
  var Transformable = function() {
    function Transformable2() {
    }
    Transformable2.prototype.getLocalTransform = function(m2) {
      return Transformable2.getLocalTransform(this, m2);
    };
    Transformable2.prototype.setPosition = function(arr) {
      this.x = arr[0];
      this.y = arr[1];
    };
    Transformable2.prototype.setScale = function(arr) {
      this.scaleX = arr[0];
      this.scaleY = arr[1];
    };
    Transformable2.prototype.setSkew = function(arr) {
      this.skewX = arr[0];
      this.skewY = arr[1];
    };
    Transformable2.prototype.setOrigin = function(arr) {
      this.originX = arr[0];
      this.originY = arr[1];
    };
    Transformable2.prototype.needLocalTransform = function() {
      return isNotAroundZero(this.rotation) || isNotAroundZero(this.x) || isNotAroundZero(this.y) || isNotAroundZero(this.scaleX - 1) || isNotAroundZero(this.scaleY - 1) || isNotAroundZero(this.skewX) || isNotAroundZero(this.skewY);
    };
    Transformable2.prototype.updateTransform = function() {
      var parentTransform = this.parent && this.parent.transform;
      var needLocalTransform = this.needLocalTransform();
      var m2 = this.transform;
      if (!(needLocalTransform || parentTransform)) {
        if (m2) {
          mIdentity(m2);
          this.invTransform = null;
        }
        return;
      }
      m2 = m2 || create();
      if (needLocalTransform) {
        this.getLocalTransform(m2);
      } else {
        mIdentity(m2);
      }
      if (parentTransform) {
        if (needLocalTransform) {
          mul(m2, parentTransform, m2);
        } else {
          copy(m2, parentTransform);
        }
      }
      this.transform = m2;
      this._resolveGlobalScaleRatio(m2);
    };
    Transformable2.prototype._resolveGlobalScaleRatio = function(m2) {
      var globalScaleRatio = this.globalScaleRatio;
      if (globalScaleRatio != null && globalScaleRatio !== 1) {
        this.getGlobalScale(scaleTmp);
        var relX = scaleTmp[0] < 0 ? -1 : 1;
        var relY = scaleTmp[1] < 0 ? -1 : 1;
        var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;
        var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;
        m2[0] *= sx;
        m2[1] *= sx;
        m2[2] *= sy;
        m2[3] *= sy;
      }
      this.invTransform = this.invTransform || create();
      invert(this.invTransform, m2);
    };
    Transformable2.prototype.getComputedTransform = function() {
      var transformNode = this;
      var ancestors = [];
      while (transformNode) {
        ancestors.push(transformNode);
        transformNode = transformNode.parent;
      }
      while (transformNode = ancestors.pop()) {
        transformNode.updateTransform();
      }
      return this.transform;
    };
    Transformable2.prototype.setLocalTransform = function(m2) {
      if (!m2) {
        return;
      }
      var sx = m2[0] * m2[0] + m2[1] * m2[1];
      var sy = m2[2] * m2[2] + m2[3] * m2[3];
      var rotation = Math.atan2(m2[1], m2[0]);
      var shearX = Math.PI / 2 + rotation - Math.atan2(m2[3], m2[2]);
      sy = Math.sqrt(sy) * Math.cos(shearX);
      sx = Math.sqrt(sx);
      this.skewX = shearX;
      this.skewY = 0;
      this.rotation = -rotation;
      this.x = +m2[4];
      this.y = +m2[5];
      this.scaleX = sx;
      this.scaleY = sy;
      this.originX = 0;
      this.originY = 0;
    };
    Transformable2.prototype.decomposeTransform = function() {
      if (!this.transform) {
        return;
      }
      var parent = this.parent;
      var m2 = this.transform;
      if (parent && parent.transform) {
        parent.invTransform = parent.invTransform || create();
        mul(tmpTransform, parent.invTransform, m2);
        m2 = tmpTransform;
      }
      var ox = this.originX;
      var oy = this.originY;
      if (ox || oy) {
        originTransform[4] = ox;
        originTransform[5] = oy;
        mul(tmpTransform, m2, originTransform);
        tmpTransform[4] -= ox;
        tmpTransform[5] -= oy;
        m2 = tmpTransform;
      }
      this.setLocalTransform(m2);
    };
    Transformable2.prototype.getGlobalScale = function(out2) {
      var m2 = this.transform;
      out2 = out2 || [];
      if (!m2) {
        out2[0] = 1;
        out2[1] = 1;
        return out2;
      }
      out2[0] = Math.sqrt(m2[0] * m2[0] + m2[1] * m2[1]);
      out2[1] = Math.sqrt(m2[2] * m2[2] + m2[3] * m2[3]);
      if (m2[0] < 0) {
        out2[0] = -out2[0];
      }
      if (m2[3] < 0) {
        out2[1] = -out2[1];
      }
      return out2;
    };
    Transformable2.prototype.transformCoordToLocal = function(x, y) {
      var v2 = [x, y];
      var invTransform = this.invTransform;
      if (invTransform) {
        applyTransform$1(v2, v2, invTransform);
      }
      return v2;
    };
    Transformable2.prototype.transformCoordToGlobal = function(x, y) {
      var v2 = [x, y];
      var transform = this.transform;
      if (transform) {
        applyTransform$1(v2, v2, transform);
      }
      return v2;
    };
    Transformable2.prototype.getLineScale = function() {
      var m2 = this.transform;
      return m2 && abs(m2[0] - 1) > 1e-10 && abs(m2[3] - 1) > 1e-10 ? Math.sqrt(abs(m2[0] * m2[3] - m2[2] * m2[1])) : 1;
    };
    Transformable2.prototype.copyTransform = function(source) {
      copyTransform(this, source);
    };
    Transformable2.getLocalTransform = function(target, m2) {
      m2 = m2 || [];
      var ox = target.originX || 0;
      var oy = target.originY || 0;
      var sx = target.scaleX;
      var sy = target.scaleY;
      var ax = target.anchorX;
      var ay = target.anchorY;
      var rotation = target.rotation || 0;
      var x = target.x;
      var y = target.y;
      var skewX = target.skewX ? Math.tan(target.skewX) : 0;
      var skewY = target.skewY ? Math.tan(-target.skewY) : 0;
      if (ox || oy || ax || ay) {
        var dx = ox + ax;
        var dy = oy + ay;
        m2[4] = -dx * sx - skewX * dy * sy;
        m2[5] = -dy * sy - skewY * dx * sx;
      } else {
        m2[4] = m2[5] = 0;
      }
      m2[0] = sx;
      m2[3] = sy;
      m2[1] = skewY * sx;
      m2[2] = skewX * sy;
      rotation && rotate(m2, m2, rotation);
      m2[4] += ox + x;
      m2[5] += oy + y;
      return m2;
    };
    Transformable2.initDefaultProps = function() {
      var proto = Transformable2.prototype;
      proto.scaleX = proto.scaleY = proto.globalScaleRatio = 1;
      proto.x = proto.y = proto.originX = proto.originY = proto.skewX = proto.skewY = proto.rotation = proto.anchorX = proto.anchorY = 0;
    }();
    return Transformable2;
  }();
  var TRANSFORMABLE_PROPS = [
    "x",
    "y",
    "originX",
    "originY",
    "anchorX",
    "anchorY",
    "rotation",
    "scaleX",
    "scaleY",
    "skewX",
    "skewY"
  ];
  function copyTransform(target, source) {
    for (var i = 0; i < TRANSFORMABLE_PROPS.length; i++) {
      var propName = TRANSFORMABLE_PROPS[i];
      target[propName] = source[propName];
    }
  }
  function ensureFontMeasureInfo(font) {
    if (!_fontMeasureInfoCache) {
      _fontMeasureInfoCache = new LRU(100);
    }
    font = font || DEFAULT_FONT;
    var measureInfo = _fontMeasureInfoCache.get(font);
    if (!measureInfo) {
      measureInfo = {
        font,
        strWidthCache: new LRU(500),
        asciiWidthMap: null,
        asciiWidthMapTried: false,
        stWideCharWidth: platformApi.measureText("国", font).width,
        asciiCharWidth: platformApi.measureText("a", font).width
      };
      _fontMeasureInfoCache.put(font, measureInfo);
    }
    return measureInfo;
  }
  var _fontMeasureInfoCache;
  function tryCreateASCIIWidthMap(font) {
    if (_getASCIIWidthMapLongCount >= GET_ASCII_WIDTH_LONG_COUNT_MAX) {
      return;
    }
    font = font || DEFAULT_FONT;
    var asciiWidthMap = [];
    var start2 = +/* @__PURE__ */ new Date();
    for (var code = 0; code <= 127; code++) {
      asciiWidthMap[code] = platformApi.measureText(String.fromCharCode(code), font).width;
    }
    var cost = +/* @__PURE__ */ new Date() - start2;
    if (cost > 16) {
      _getASCIIWidthMapLongCount = GET_ASCII_WIDTH_LONG_COUNT_MAX;
    } else if (cost > 2) {
      _getASCIIWidthMapLongCount++;
    }
    return asciiWidthMap;
  }
  var _getASCIIWidthMapLongCount = 0;
  var GET_ASCII_WIDTH_LONG_COUNT_MAX = 5;
  function measureCharWidth(fontMeasureInfo, charCode) {
    if (!fontMeasureInfo.asciiWidthMapTried) {
      fontMeasureInfo.asciiWidthMap = tryCreateASCIIWidthMap(fontMeasureInfo.font);
      fontMeasureInfo.asciiWidthMapTried = true;
    }
    return 0 <= charCode && charCode <= 127 ? fontMeasureInfo.asciiWidthMap != null ? fontMeasureInfo.asciiWidthMap[charCode] : fontMeasureInfo.asciiCharWidth : fontMeasureInfo.stWideCharWidth;
  }
  function measureWidth(fontMeasureInfo, text) {
    var strWidthCache = fontMeasureInfo.strWidthCache;
    var width = strWidthCache.get(text);
    if (width == null) {
      width = platformApi.measureText(text, fontMeasureInfo.font).width;
      strWidthCache.put(text, width);
    }
    return width;
  }
  function innerGetBoundingRect(text, font, textAlign, textBaseline) {
    var width = measureWidth(ensureFontMeasureInfo(font), text);
    var height = getLineHeight(font);
    var x = adjustTextX(0, width, textAlign);
    var y = adjustTextY(0, height, textBaseline);
    var rect = new BoundingRect(x, y, width, height);
    return rect;
  }
  function getBoundingRect(text, font, textAlign, textBaseline) {
    var textLines = ((text || "") + "").split("\n");
    var len2 = textLines.length;
    if (len2 === 1) {
      return innerGetBoundingRect(textLines[0], font, textAlign, textBaseline);
    } else {
      var uniondRect = new BoundingRect(0, 0, 0, 0);
      for (var i = 0; i < textLines.length; i++) {
        var rect = innerGetBoundingRect(textLines[i], font, textAlign, textBaseline);
        i === 0 ? uniondRect.copy(rect) : uniondRect.union(rect);
      }
      return uniondRect;
    }
  }
  function adjustTextX(x, width, textAlign, inverse) {
    if (textAlign === "right") {
      !inverse ? x -= width : x += width;
    } else if (textAlign === "center") {
      !inverse ? x -= width / 2 : x += width / 2;
    }
    return x;
  }
  function adjustTextY(y, height, verticalAlign, inverse) {
    if (verticalAlign === "middle") {
      !inverse ? y -= height / 2 : y += height / 2;
    } else if (verticalAlign === "bottom") {
      !inverse ? y -= height : y += height;
    }
    return y;
  }
  function getLineHeight(font) {
    return ensureFontMeasureInfo(font).stWideCharWidth;
  }
  function parsePercent$1(value, maxValue) {
    if (typeof value === "string") {
      if (value.lastIndexOf("%") >= 0) {
        return parseFloat(value) / 100 * maxValue;
      }
      return parseFloat(value);
    }
    return value;
  }
  function calculateTextPosition(out2, opts, rect) {
    var textPosition = opts.position || "inside";
    var distance2 = opts.distance != null ? opts.distance : 5;
    var height = rect.height;
    var width = rect.width;
    var halfHeight = height / 2;
    var x = rect.x;
    var y = rect.y;
    var textAlign = "left";
    var textVerticalAlign = "top";
    if (textPosition instanceof Array) {
      x += parsePercent$1(textPosition[0], rect.width);
      y += parsePercent$1(textPosition[1], rect.height);
      textAlign = null;
      textVerticalAlign = null;
    } else {
      switch (textPosition) {
        case "left":
          x -= distance2;
          y += halfHeight;
          textAlign = "right";
          textVerticalAlign = "middle";
          break;
        case "right":
          x += distance2 + width;
          y += halfHeight;
          textVerticalAlign = "middle";
          break;
        case "top":
          x += width / 2;
          y -= distance2;
          textAlign = "center";
          textVerticalAlign = "bottom";
          break;
        case "bottom":
          x += width / 2;
          y += height + distance2;
          textAlign = "center";
          break;
        case "inside":
          x += width / 2;
          y += halfHeight;
          textAlign = "center";
          textVerticalAlign = "middle";
          break;
        case "insideLeft":
          x += distance2;
          y += halfHeight;
          textVerticalAlign = "middle";
          break;
        case "insideRight":
          x += width - distance2;
          y += halfHeight;
          textAlign = "right";
          textVerticalAlign = "middle";
          break;
        case "insideTop":
          x += width / 2;
          y += distance2;
          textAlign = "center";
          break;
        case "insideBottom":
          x += width / 2;
          y += height - distance2;
          textAlign = "center";
          textVerticalAlign = "bottom";
          break;
        case "insideTopLeft":
          x += distance2;
          y += distance2;
          break;
        case "insideTopRight":
          x += width - distance2;
          y += distance2;
          textAlign = "right";
          break;
        case "insideBottomLeft":
          x += distance2;
          y += height - distance2;
          textVerticalAlign = "bottom";
          break;
        case "insideBottomRight":
          x += width - distance2;
          y += height - distance2;
          textAlign = "right";
          textVerticalAlign = "bottom";
          break;
      }
    }
    out2 = out2 || {};
    out2.x = x;
    out2.y = y;
    out2.align = textAlign;
    out2.verticalAlign = textVerticalAlign;
    return out2;
  }
  var define_process_env_default$Q = {};
  var PRESERVED_NORMAL_STATE = "__zr_normal__";
  var PRIMARY_STATES_KEYS$1 = TRANSFORMABLE_PROPS.concat(["ignore"]);
  var DEFAULT_ANIMATABLE_MAP = reduce(TRANSFORMABLE_PROPS, function(obj, key2) {
    obj[key2] = true;
    return obj;
  }, { ignore: false });
  var tmpTextPosCalcRes = {};
  var tmpBoundingRect = new BoundingRect(0, 0, 0, 0);
  var tmpInnerTextTrans = [];
  var Element = function() {
    function Element2(props) {
      this.id = guid();
      this.animators = [];
      this.currentStates = [];
      this.states = {};
      this._init(props);
    }
    Element2.prototype._init = function(props) {
      this.attr(props);
    };
    Element2.prototype.drift = function(dx, dy, e2) {
      switch (this.draggable) {
        case "horizontal":
          dy = 0;
          break;
        case "vertical":
          dx = 0;
          break;
      }
      var m2 = this.transform;
      if (!m2) {
        m2 = this.transform = [1, 0, 0, 1, 0, 0];
      }
      m2[4] += dx;
      m2[5] += dy;
      this.decomposeTransform();
      this.markRedraw();
    };
    Element2.prototype.beforeUpdate = function() {
    };
    Element2.prototype.afterUpdate = function() {
    };
    Element2.prototype.update = function() {
      this.updateTransform();
      if (this.__dirty) {
        this.updateInnerText();
      }
    };
    Element2.prototype.updateInnerText = function(forceUpdate) {
      var textEl = this._textContent;
      if (textEl && (!textEl.ignore || forceUpdate)) {
        if (!this.textConfig) {
          this.textConfig = {};
        }
        var textConfig = this.textConfig;
        var isLocal = textConfig.local;
        var innerTransformable = textEl.innerTransformable;
        var textAlign = void 0;
        var textVerticalAlign = void 0;
        var textStyleChanged = false;
        innerTransformable.parent = isLocal ? this : null;
        var innerOrigin = false;
        innerTransformable.copyTransform(textEl);
        var hasPosition = textConfig.position != null;
        var autoOverflowArea = textConfig.autoOverflowArea;
        var layoutRect = void 0;
        if (autoOverflowArea || hasPosition) {
          layoutRect = tmpBoundingRect;
          if (textConfig.layoutRect) {
            layoutRect.copy(textConfig.layoutRect);
          } else {
            layoutRect.copy(this.getBoundingRect());
          }
          if (!isLocal) {
            layoutRect.applyTransform(this.transform);
          }
        }
        if (hasPosition) {
          if (this.calculateTextPosition) {
            this.calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
          } else {
            calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
          }
          innerTransformable.x = tmpTextPosCalcRes.x;
          innerTransformable.y = tmpTextPosCalcRes.y;
          textAlign = tmpTextPosCalcRes.align;
          textVerticalAlign = tmpTextPosCalcRes.verticalAlign;
          var textOrigin = textConfig.origin;
          if (textOrigin && textConfig.rotation != null) {
            var relOriginX = void 0;
            var relOriginY = void 0;
            if (textOrigin === "center") {
              relOriginX = layoutRect.width * 0.5;
              relOriginY = layoutRect.height * 0.5;
            } else {
              relOriginX = parsePercent$1(textOrigin[0], layoutRect.width);
              relOriginY = parsePercent$1(textOrigin[1], layoutRect.height);
            }
            innerOrigin = true;
            innerTransformable.originX = -innerTransformable.x + relOriginX + (isLocal ? 0 : layoutRect.x);
            innerTransformable.originY = -innerTransformable.y + relOriginY + (isLocal ? 0 : layoutRect.y);
          }
        }
        if (textConfig.rotation != null) {
          innerTransformable.rotation = textConfig.rotation;
        }
        var textOffset = textConfig.offset;
        if (textOffset) {
          innerTransformable.x += textOffset[0];
          innerTransformable.y += textOffset[1];
          if (!innerOrigin) {
            innerTransformable.originX = -textOffset[0];
            innerTransformable.originY = -textOffset[1];
          }
        }
        var innerTextDefaultStyle = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});
        if (autoOverflowArea) {
          var overflowRect = innerTextDefaultStyle.overflowRect = innerTextDefaultStyle.overflowRect || new BoundingRect(0, 0, 0, 0);
          innerTransformable.getLocalTransform(tmpInnerTextTrans);
          invert(tmpInnerTextTrans, tmpInnerTextTrans);
          BoundingRect.copy(overflowRect, layoutRect);
          overflowRect.applyTransform(tmpInnerTextTrans);
        } else {
          innerTextDefaultStyle.overflowRect = null;
        }
        var isInside = textConfig.inside == null ? typeof textConfig.position === "string" && textConfig.position.indexOf("inside") >= 0 : textConfig.inside;
        var textFill = void 0;
        var textStroke = void 0;
        var autoStroke = void 0;
        if (isInside && this.canBeInsideText()) {
          textFill = textConfig.insideFill;
          textStroke = textConfig.insideStroke;
          if (textFill == null || textFill === "auto") {
            textFill = this.getInsideTextFill();
          }
          if (textStroke == null || textStroke === "auto") {
            textStroke = this.getInsideTextStroke(textFill);
            autoStroke = true;
          }
        } else {
          textFill = textConfig.outsideFill;
          textStroke = textConfig.outsideStroke;
          if (textFill == null || textFill === "auto") {
            textFill = this.getOutsideFill();
          }
          if (textStroke == null || textStroke === "auto") {
            textStroke = this.getOutsideStroke(textFill);
            autoStroke = true;
          }
        }
        textFill = textFill || "#000";
        if (textFill !== innerTextDefaultStyle.fill || textStroke !== innerTextDefaultStyle.stroke || autoStroke !== innerTextDefaultStyle.autoStroke || textAlign !== innerTextDefaultStyle.align || textVerticalAlign !== innerTextDefaultStyle.verticalAlign) {
          textStyleChanged = true;
          innerTextDefaultStyle.fill = textFill;
          innerTextDefaultStyle.stroke = textStroke;
          innerTextDefaultStyle.autoStroke = autoStroke;
          innerTextDefaultStyle.align = textAlign;
          innerTextDefaultStyle.verticalAlign = textVerticalAlign;
          textEl.setDefaultTextStyle(innerTextDefaultStyle);
        }
        textEl.__dirty |= REDRAW_BIT;
        if (textStyleChanged) {
          textEl.dirtyStyle(true);
        }
      }
    };
    Element2.prototype.canBeInsideText = function() {
      return true;
    };
    Element2.prototype.getInsideTextFill = function() {
      return "#fff";
    };
    Element2.prototype.getInsideTextStroke = function(textFill) {
      return "#000";
    };
    Element2.prototype.getOutsideFill = function() {
      return this.__zr && this.__zr.isDarkMode() ? LIGHT_LABEL_COLOR : DARK_LABEL_COLOR;
    };
    Element2.prototype.getOutsideStroke = function(textFill) {
      var backgroundColor2 = this.__zr && this.__zr.getBackgroundColor();
      var colorArr = typeof backgroundColor2 === "string" && parse(backgroundColor2);
      if (!colorArr) {
        colorArr = [255, 255, 255, 1];
      }
      var alpha = colorArr[3];
      var isDark = this.__zr.isDarkMode();
      for (var i = 0; i < 3; i++) {
        colorArr[i] = colorArr[i] * alpha + (isDark ? 0 : 255) * (1 - alpha);
      }
      colorArr[3] = 1;
      return stringify(colorArr, "rgba");
    };
    Element2.prototype.traverse = function(cb, context) {
    };
    Element2.prototype.attrKV = function(key2, value) {
      if (key2 === "textConfig") {
        this.setTextConfig(value);
      } else if (key2 === "textContent") {
        this.setTextContent(value);
      } else if (key2 === "clipPath") {
        this.setClipPath(value);
      } else if (key2 === "extra") {
        this.extra = this.extra || {};
        extend(this.extra, value);
      } else {
        this[key2] = value;
      }
    };
    Element2.prototype.hide = function() {
      this.ignore = true;
      this.markRedraw();
    };
    Element2.prototype.show = function() {
      this.ignore = false;
      this.markRedraw();
    };
    Element2.prototype.attr = function(keyOrObj, value) {
      if (typeof keyOrObj === "string") {
        this.attrKV(keyOrObj, value);
      } else if (isObject$2(keyOrObj)) {
        var obj = keyOrObj;
        var keysArr = keys(obj);
        for (var i = 0; i < keysArr.length; i++) {
          var key2 = keysArr[i];
          this.attrKV(key2, keyOrObj[key2]);
        }
      }
      this.markRedraw();
      return this;
    };
    Element2.prototype.saveCurrentToNormalState = function(toState) {
      this._innerSaveToNormal(toState);
      var normalState = this._normalState;
      for (var i = 0; i < this.animators.length; i++) {
        var animator = this.animators[i];
        var fromStateTransition = animator.__fromStateTransition;
        if (animator.getLoop() || fromStateTransition && fromStateTransition !== PRESERVED_NORMAL_STATE) {
          continue;
        }
        var targetName = animator.targetName;
        var target = targetName ? normalState[targetName] : normalState;
        animator.saveTo(target);
      }
    };
    Element2.prototype._innerSaveToNormal = function(toState) {
      var normalState = this._normalState;
      if (!normalState) {
        normalState = this._normalState = {};
      }
      if (toState.textConfig && !normalState.textConfig) {
        normalState.textConfig = this.textConfig;
      }
      this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS$1);
    };
    Element2.prototype._savePrimaryToNormal = function(toState, normalState, primaryKeys) {
      for (var i = 0; i < primaryKeys.length; i++) {
        var key2 = primaryKeys[i];
        if (toState[key2] != null && !(key2 in normalState)) {
          normalState[key2] = this[key2];
        }
      }
    };
    Element2.prototype.hasState = function() {
      return this.currentStates.length > 0;
    };
    Element2.prototype.getState = function(name) {
      return this.states[name];
    };
    Element2.prototype.ensureState = function(name) {
      var states = this.states;
      if (!states[name]) {
        states[name] = {};
      }
      return states[name];
    };
    Element2.prototype.clearStates = function(noAnimation) {
      this.useState(PRESERVED_NORMAL_STATE, false, noAnimation);
    };
    Element2.prototype.useState = function(stateName, keepCurrentStates, noAnimation, forceUseHoverLayer) {
      var toNormalState = stateName === PRESERVED_NORMAL_STATE;
      var hasStates = this.hasState();
      if (!hasStates && toNormalState) {
        return;
      }
      var currentStates = this.currentStates;
      var animationCfg = this.stateTransition;
      if (indexOf(currentStates, stateName) >= 0 && (keepCurrentStates || currentStates.length === 1)) {
        return;
      }
      var state;
      if (this.stateProxy && !toNormalState) {
        state = this.stateProxy(stateName);
      }
      if (!state) {
        state = this.states && this.states[stateName];
      }
      if (!state && !toNormalState) {
        logError("State " + stateName + " not exists.");
        return;
      }
      if (!toNormalState) {
        this.saveCurrentToNormalState(state);
      }
      var useHoverLayer = !!(state && state.hoverLayer || forceUseHoverLayer);
      if (useHoverLayer) {
        this._toggleHoverLayerFlag(true);
      }
      this._applyStateObj(stateName, state, this._normalState, keepCurrentStates, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
      var textContent = this._textContent;
      var textGuide = this._textGuide;
      if (textContent) {
        textContent.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
      }
      if (textGuide) {
        textGuide.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
      }
      if (toNormalState) {
        this.currentStates = [];
        this._normalState = {};
      } else {
        if (!keepCurrentStates) {
          this.currentStates = [stateName];
        } else {
          this.currentStates.push(stateName);
        }
      }
      this._updateAnimationTargets();
      this.markRedraw();
      if (!useHoverLayer && this.__inHover) {
        this._toggleHoverLayerFlag(false);
        this.__dirty &= ~REDRAW_BIT;
      }
      return state;
    };
    Element2.prototype.useStates = function(states, noAnimation, forceUseHoverLayer) {
      if (!states.length) {
        this.clearStates();
      } else {
        var stateObjects = [];
        var currentStates = this.currentStates;
        var len2 = states.length;
        var notChange = len2 === currentStates.length;
        if (notChange) {
          for (var i = 0; i < len2; i++) {
            if (states[i] !== currentStates[i]) {
              notChange = false;
              break;
            }
          }
        }
        if (notChange) {
          return;
        }
        for (var i = 0; i < len2; i++) {
          var stateName = states[i];
          var stateObj = void 0;
          if (this.stateProxy) {
            stateObj = this.stateProxy(stateName, states);
          }
          if (!stateObj) {
            stateObj = this.states[stateName];
          }
          if (stateObj) {
            stateObjects.push(stateObj);
          }
        }
        var lastStateObj = stateObjects[len2 - 1];
        var useHoverLayer = !!(lastStateObj && lastStateObj.hoverLayer || forceUseHoverLayer);
        if (useHoverLayer) {
          this._toggleHoverLayerFlag(true);
        }
        var mergedState = this._mergeStates(stateObjects);
        var animationCfg = this.stateTransition;
        this.saveCurrentToNormalState(mergedState);
        this._applyStateObj(states.join(","), mergedState, this._normalState, false, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
        var textContent = this._textContent;
        var textGuide = this._textGuide;
        if (textContent) {
          textContent.useStates(states, noAnimation, useHoverLayer);
        }
        if (textGuide) {
          textGuide.useStates(states, noAnimation, useHoverLayer);
        }
        this._updateAnimationTargets();
        this.currentStates = states.slice();
        this.markRedraw();
        if (!useHoverLayer && this.__inHover) {
          this._toggleHoverLayerFlag(false);
          this.__dirty &= ~REDRAW_BIT;
        }
      }
    };
    Element2.prototype.isSilent = function() {
      var el = this;
      while (el) {
        if (el.silent) {
          return true;
        }
        var hostEl = el.__hostTarget;
        el = hostEl ? el.ignoreHostSilent ? null : hostEl : el.parent;
      }
      return false;
    };
    Element2.prototype._updateAnimationTargets = function() {
      for (var i = 0; i < this.animators.length; i++) {
        var animator = this.animators[i];
        if (animator.targetName) {
          animator.changeTarget(this[animator.targetName]);
        }
      }
    };
    Element2.prototype.removeState = function(state) {
      var idx = indexOf(this.currentStates, state);
      if (idx >= 0) {
        var currentStates = this.currentStates.slice();
        currentStates.splice(idx, 1);
        this.useStates(currentStates);
      }
    };
    Element2.prototype.replaceState = function(oldState, newState, forceAdd) {
      var currentStates = this.currentStates.slice();
      var idx = indexOf(currentStates, oldState);
      var newStateExists = indexOf(currentStates, newState) >= 0;
      if (idx >= 0) {
        if (!newStateExists) {
          currentStates[idx] = newState;
        } else {
          currentStates.splice(idx, 1);
        }
      } else if (forceAdd && !newStateExists) {
        currentStates.push(newState);
      }
      this.useStates(currentStates);
    };
    Element2.prototype.toggleState = function(state, enable) {
      if (enable) {
        this.useState(state, true);
      } else {
        this.removeState(state);
      }
    };
    Element2.prototype._mergeStates = function(states) {
      var mergedState = {};
      var mergedTextConfig;
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        extend(mergedState, state);
        if (state.textConfig) {
          mergedTextConfig = mergedTextConfig || {};
          extend(mergedTextConfig, state.textConfig);
        }
      }
      if (mergedTextConfig) {
        mergedState.textConfig = mergedTextConfig;
      }
      return mergedState;
    };
    Element2.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
      var needsRestoreToNormal = !(state && keepCurrentStates);
      if (state && state.textConfig) {
        this.textConfig = extend({}, keepCurrentStates ? this.textConfig : normalState.textConfig);
        extend(this.textConfig, state.textConfig);
      } else if (needsRestoreToNormal) {
        if (normalState.textConfig) {
          this.textConfig = normalState.textConfig;
        }
      }
      var transitionTarget = {};
      var hasTransition = false;
      for (var i = 0; i < PRIMARY_STATES_KEYS$1.length; i++) {
        var key2 = PRIMARY_STATES_KEYS$1[i];
        var propNeedsTransition = transition && DEFAULT_ANIMATABLE_MAP[key2];
        if (state && state[key2] != null) {
          if (propNeedsTransition) {
            hasTransition = true;
            transitionTarget[key2] = state[key2];
          } else {
            this[key2] = state[key2];
          }
        } else if (needsRestoreToNormal) {
          if (normalState[key2] != null) {
            if (propNeedsTransition) {
              hasTransition = true;
              transitionTarget[key2] = normalState[key2];
            } else {
              this[key2] = normalState[key2];
            }
          }
        }
      }
      if (!transition) {
        for (var i = 0; i < this.animators.length; i++) {
          var animator = this.animators[i];
          var targetName = animator.targetName;
          if (!animator.getLoop()) {
            animator.__changeFinalValue(targetName ? (state || normalState)[targetName] : state || normalState);
          }
        }
      }
      if (hasTransition) {
        this._transitionState(stateName, transitionTarget, animationCfg);
      }
    };
    Element2.prototype._attachComponent = function(componentEl) {
      if (componentEl.__zr && !componentEl.__hostTarget) {
        if (define_process_env_default$Q.NODE_ENV !== "production") {
          throw new Error("Text element has been added to zrender.");
        }
        return;
      }
      if (componentEl === this) {
        if (define_process_env_default$Q.NODE_ENV !== "production") {
          throw new Error("Recursive component attachment.");
        }
        return;
      }
      var zr = this.__zr;
      if (zr) {
        componentEl.addSelfToZr(zr);
      }
      componentEl.__zr = zr;
      componentEl.__hostTarget = this;
    };
    Element2.prototype._detachComponent = function(componentEl) {
      if (componentEl.__zr) {
        componentEl.removeSelfFromZr(componentEl.__zr);
      }
      componentEl.__zr = null;
      componentEl.__hostTarget = null;
    };
    Element2.prototype.getClipPath = function() {
      return this._clipPath;
    };
    Element2.prototype.setClipPath = function(clipPath) {
      if (this._clipPath && this._clipPath !== clipPath) {
        this.removeClipPath();
      }
      this._attachComponent(clipPath);
      this._clipPath = clipPath;
      this.markRedraw();
    };
    Element2.prototype.removeClipPath = function() {
      var clipPath = this._clipPath;
      if (clipPath) {
        this._detachComponent(clipPath);
        this._clipPath = null;
        this.markRedraw();
      }
    };
    Element2.prototype.getTextContent = function() {
      return this._textContent;
    };
    Element2.prototype.setTextContent = function(textEl) {
      var previousTextContent = this._textContent;
      if (previousTextContent === textEl) {
        return;
      }
      if (previousTextContent && previousTextContent !== textEl) {
        this.removeTextContent();
      }
      if (define_process_env_default$Q.NODE_ENV !== "production") {
        if (textEl.__zr && !textEl.__hostTarget) {
          throw new Error("Text element has been added to zrender.");
        }
      }
      textEl.innerTransformable = new Transformable();
      this._attachComponent(textEl);
      this._textContent = textEl;
      this.markRedraw();
    };
    Element2.prototype.setTextConfig = function(cfg) {
      if (!this.textConfig) {
        this.textConfig = {};
      }
      extend(this.textConfig, cfg);
      this.markRedraw();
    };
    Element2.prototype.removeTextConfig = function() {
      this.textConfig = null;
      this.markRedraw();
    };
    Element2.prototype.removeTextContent = function() {
      var textEl = this._textContent;
      if (textEl) {
        textEl.innerTransformable = null;
        this._detachComponent(textEl);
        this._textContent = null;
        this._innerTextDefaultStyle = null;
        this.markRedraw();
      }
    };
    Element2.prototype.getTextGuideLine = function() {
      return this._textGuide;
    };
    Element2.prototype.setTextGuideLine = function(guideLine) {
      if (this._textGuide && this._textGuide !== guideLine) {
        this.removeTextGuideLine();
      }
      this._attachComponent(guideLine);
      this._textGuide = guideLine;
      this.markRedraw();
    };
    Element2.prototype.removeTextGuideLine = function() {
      var textGuide = this._textGuide;
      if (textGuide) {
        this._detachComponent(textGuide);
        this._textGuide = null;
        this.markRedraw();
      }
    };
    Element2.prototype.markRedraw = function() {
      this.__dirty |= REDRAW_BIT;
      var zr = this.__zr;
      if (zr) {
        if (this.__inHover) {
          zr.refreshHover();
        } else {
          zr.refresh();
        }
      }
      if (this.__hostTarget) {
        this.__hostTarget.markRedraw();
      }
    };
    Element2.prototype.dirty = function() {
      this.markRedraw();
    };
    Element2.prototype._toggleHoverLayerFlag = function(inHover) {
      this.__inHover = inHover;
      var textContent = this._textContent;
      var textGuide = this._textGuide;
      if (textContent) {
        textContent.__inHover = inHover;
      }
      if (textGuide) {
        textGuide.__inHover = inHover;
      }
    };
    Element2.prototype.addSelfToZr = function(zr) {
      if (this.__zr === zr) {
        return;
      }
      this.__zr = zr;
      var animators = this.animators;
      if (animators) {
        for (var i = 0; i < animators.length; i++) {
          zr.animation.addAnimator(animators[i]);
        }
      }
      if (this._clipPath) {
        this._clipPath.addSelfToZr(zr);
      }
      if (this._textContent) {
        this._textContent.addSelfToZr(zr);
      }
      if (this._textGuide) {
        this._textGuide.addSelfToZr(zr);
      }
    };
    Element2.prototype.removeSelfFromZr = function(zr) {
      if (!this.__zr) {
        return;
      }
      this.__zr = null;
      var animators = this.animators;
      if (animators) {
        for (var i = 0; i < animators.length; i++) {
          zr.animation.removeAnimator(animators[i]);
        }
      }
      if (this._clipPath) {
        this._clipPath.removeSelfFromZr(zr);
      }
      if (this._textContent) {
        this._textContent.removeSelfFromZr(zr);
      }
      if (this._textGuide) {
        this._textGuide.removeSelfFromZr(zr);
      }
    };
    Element2.prototype.animate = function(key2, loop, allowDiscreteAnimation) {
      var target = key2 ? this[key2] : this;
      if (define_process_env_default$Q.NODE_ENV !== "production") {
        if (!target) {
          logError('Property "' + key2 + '" is not existed in element ' + this.id);
          return;
        }
      }
      var animator = new Animator(target, loop, allowDiscreteAnimation);
      key2 && (animator.targetName = key2);
      this.addAnimator(animator, key2);
      return animator;
    };
    Element2.prototype.addAnimator = function(animator, key2) {
      var zr = this.__zr;
      var el = this;
      animator.during(function() {
        el.updateDuringAnimation(key2);
      }).done(function() {
        var animators = el.animators;
        var idx = indexOf(animators, animator);
        if (idx >= 0) {
          animators.splice(idx, 1);
        }
      });
      this.animators.push(animator);
      if (zr) {
        zr.animation.addAnimator(animator);
      }
      zr && zr.wakeUp();
    };
    Element2.prototype.updateDuringAnimation = function(key2) {
      this.markRedraw();
    };
    Element2.prototype.stopAnimation = function(scope, forwardToLast) {
      var animators = this.animators;
      var len2 = animators.length;
      var leftAnimators = [];
      for (var i = 0; i < len2; i++) {
        var animator = animators[i];
        if (!scope || scope === animator.scope) {
          animator.stop(forwardToLast);
        } else {
          leftAnimators.push(animator);
        }
      }
      this.animators = leftAnimators;
      return this;
    };
    Element2.prototype.animateTo = function(target, cfg, animationProps) {
      animateTo(this, target, cfg, animationProps);
    };
    Element2.prototype.animateFrom = function(target, cfg, animationProps) {
      animateTo(this, target, cfg, animationProps, true);
    };
    Element2.prototype._transitionState = function(stateName, target, cfg, animationProps) {
      var animators = animateTo(this, target, cfg, animationProps);
      for (var i = 0; i < animators.length; i++) {
        animators[i].__fromStateTransition = stateName;
      }
    };
    Element2.prototype.getBoundingRect = function() {
      return null;
    };
    Element2.prototype.getPaintRect = function() {
      return null;
    };
    Element2.initDefaultProps = function() {
      var elProto = Element2.prototype;
      elProto.type = "element";
      elProto.name = "";
      elProto.ignore = elProto.silent = elProto.ignoreHostSilent = elProto.isGroup = elProto.draggable = elProto.dragging = elProto.ignoreClip = elProto.__inHover = false;
      elProto.__dirty = REDRAW_BIT;
      var logs = {};
      function logDeprecatedError(key2, xKey, yKey) {
        if (!logs[key2 + xKey + yKey]) {
          console.warn("DEPRECATED: '" + key2 + "' has been deprecated. use '" + xKey + "', '" + yKey + "' instead");
          logs[key2 + xKey + yKey] = true;
        }
      }
      function createLegacyProperty(key2, privateKey, xKey, yKey) {
        Object.defineProperty(elProto, key2, {
          get: function() {
            if (define_process_env_default$Q.NODE_ENV !== "production") {
              logDeprecatedError(key2, xKey, yKey);
            }
            if (!this[privateKey]) {
              var pos = this[privateKey] = [];
              enhanceArray(this, pos);
            }
            return this[privateKey];
          },
          set: function(pos) {
            if (define_process_env_default$Q.NODE_ENV !== "production") {
              logDeprecatedError(key2, xKey, yKey);
            }
            this[xKey] = pos[0];
            this[yKey] = pos[1];
            this[privateKey] = pos;
            enhanceArray(this, pos);
          }
        });
        function enhanceArray(self2, pos) {
          Object.defineProperty(pos, 0, {
            get: function() {
              return self2[xKey];
            },
            set: function(val) {
              self2[xKey] = val;
            }
          });
          Object.defineProperty(pos, 1, {
            get: function() {
              return self2[yKey];
            },
            set: function(val) {
              self2[yKey] = val;
            }
          });
        }
      }
      if (Object.defineProperty) {
        createLegacyProperty("position", "_legacyPos", "x", "y");
        createLegacyProperty("scale", "_legacyScale", "scaleX", "scaleY");
        createLegacyProperty("origin", "_legacyOrigin", "originX", "originY");
      }
    }();
    return Element2;
  }();
  mixin(Element, Eventful);
  mixin(Element, Transformable);
  function animateTo(animatable, target, cfg, animationProps, reverse) {
    cfg = cfg || {};
    var animators = [];
    animateToShallow(animatable, "", animatable, target, cfg, animationProps, animators, reverse);
    var finishCount = animators.length;
    var doneHappened = false;
    var cfgDone = cfg.done;
    var cfgAborted = cfg.aborted;
    var doneCb = function() {
      doneHappened = true;
      finishCount--;
      if (finishCount <= 0) {
        doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();
      }
    };
    var abortedCb = function() {
      finishCount--;
      if (finishCount <= 0) {
        doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();
      }
    };
    if (!finishCount) {
      cfgDone && cfgDone();
    }
    if (animators.length > 0 && cfg.during) {
      animators[0].during(function(target2, percent) {
        cfg.during(percent);
      });
    }
    for (var i = 0; i < animators.length; i++) {
      var animator = animators[i];
      if (doneCb) {
        animator.done(doneCb);
      }
      if (abortedCb) {
        animator.aborted(abortedCb);
      }
      if (cfg.force) {
        animator.duration(cfg.duration);
      }
      animator.start(cfg.easing);
    }
    return animators;
  }
  function copyArrShallow(source, target, len2) {
    for (var i = 0; i < len2; i++) {
      source[i] = target[i];
    }
  }
  function is2DArray(value) {
    return isArrayLike(value[0]);
  }
  function copyValue(target, source, key2) {
    if (isArrayLike(source[key2])) {
      if (!isArrayLike(target[key2])) {
        target[key2] = [];
      }
      if (isTypedArray(source[key2])) {
        var len2 = source[key2].length;
        if (target[key2].length !== len2) {
          target[key2] = new source[key2].constructor(len2);
          copyArrShallow(target[key2], source[key2], len2);
        }
      } else {
        var sourceArr = source[key2];
        var targetArr = target[key2];
        var len0 = sourceArr.length;
        if (is2DArray(sourceArr)) {
          var len1 = sourceArr[0].length;
          for (var i = 0; i < len0; i++) {
            if (!targetArr[i]) {
              targetArr[i] = Array.prototype.slice.call(sourceArr[i]);
            } else {
              copyArrShallow(targetArr[i], sourceArr[i], len1);
            }
          }
        } else {
          copyArrShallow(targetArr, sourceArr, len0);
        }
        targetArr.length = sourceArr.length;
      }
    } else {
      target[key2] = source[key2];
    }
  }
  function isValueSame(val1, val2) {
    return val1 === val2 || isArrayLike(val1) && isArrayLike(val2) && is1DArraySame(val1, val2);
  }
  function is1DArraySame(arr0, arr1) {
    var len2 = arr0.length;
    if (len2 !== arr1.length) {
      return false;
    }
    for (var i = 0; i < len2; i++) {
      if (arr0[i] !== arr1[i]) {
        return false;
      }
    }
    return true;
  }
  function animateToShallow(animatable, topKey, animateObj, target, cfg, animationProps, animators, reverse) {
    var targetKeys = keys(target);
    var duration = cfg.duration;
    var delay = cfg.delay;
    var additive = cfg.additive;
    var setToFinal = cfg.setToFinal;
    var animateAll = !isObject$2(animationProps);
    var existsAnimators = animatable.animators;
    var animationKeys = [];
    for (var k = 0; k < targetKeys.length; k++) {
      var innerKey = targetKeys[k];
      var targetVal = target[innerKey];
      if (targetVal != null && animateObj[innerKey] != null && (animateAll || animationProps[innerKey])) {
        if (isObject$2(targetVal) && !isArrayLike(targetVal) && !isGradientObject(targetVal)) {
          if (topKey) {
            if (!reverse) {
              animateObj[innerKey] = targetVal;
              animatable.updateDuringAnimation(topKey);
            }
            continue;
          }
          animateToShallow(animatable, innerKey, animateObj[innerKey], targetVal, cfg, animationProps && animationProps[innerKey], animators, reverse);
        } else {
          animationKeys.push(innerKey);
        }
      } else if (!reverse) {
        animateObj[innerKey] = targetVal;
        animatable.updateDuringAnimation(topKey);
        animationKeys.push(innerKey);
      }
    }
    var keyLen = animationKeys.length;
    if (!additive && keyLen) {
      for (var i = 0; i < existsAnimators.length; i++) {
        var animator = existsAnimators[i];
        if (animator.targetName === topKey) {
          var allAborted = animator.stopTracks(animationKeys);
          if (allAborted) {
            var idx = indexOf(existsAnimators, animator);
            existsAnimators.splice(idx, 1);
          }
        }
      }
    }
    if (!cfg.force) {
      animationKeys = filter(animationKeys, function(key2) {
        return !isValueSame(target[key2], animateObj[key2]);
      });
      keyLen = animationKeys.length;
    }
    if (keyLen > 0 || cfg.force && !animators.length) {
      var revertedSource = void 0;
      var reversedTarget = void 0;
      var sourceClone = void 0;
      if (reverse) {
        reversedTarget = {};
        if (setToFinal) {
          revertedSource = {};
        }
        for (var i = 0; i < keyLen; i++) {
          var innerKey = animationKeys[i];
          reversedTarget[innerKey] = animateObj[innerKey];
          if (setToFinal) {
            revertedSource[innerKey] = target[innerKey];
          } else {
            animateObj[innerKey] = target[innerKey];
          }
        }
      } else if (setToFinal) {
        sourceClone = {};
        for (var i = 0; i < keyLen; i++) {
          var innerKey = animationKeys[i];
          sourceClone[innerKey] = cloneValue(animateObj[innerKey]);
          copyValue(animateObj, target, innerKey);
        }
      }
      var animator = new Animator(animateObj, false, false, additive ? filter(existsAnimators, function(animator2) {
        return animator2.targetName === topKey;
      }) : null);
      animator.targetName = topKey;
      if (cfg.scope) {
        animator.scope = cfg.scope;
      }
      if (setToFinal && revertedSource) {
        animator.whenWithKeys(0, revertedSource, animationKeys);
      }
      if (sourceClone) {
        animator.whenWithKeys(0, sourceClone, animationKeys);
      }
      animator.whenWithKeys(duration == null ? 500 : duration, reverse ? reversedTarget : target, animationKeys).delay(delay || 0);
      animatable.addAnimator(animator, topKey);
      animators.push(animator);
    }
  }
  var define_process_env_default$P = {};
  var Group$2 = function(_super) {
    __extends(Group2, _super);
    function Group2(opts) {
      var _this = _super.call(this) || this;
      _this.isGroup = true;
      _this._children = [];
      _this.attr(opts);
      return _this;
    }
    Group2.prototype.childrenRef = function() {
      return this._children;
    };
    Group2.prototype.children = function() {
      return this._children.slice();
    };
    Group2.prototype.childAt = function(idx) {
      return this._children[idx];
    };
    Group2.prototype.childOfName = function(name) {
      var children = this._children;
      for (var i = 0; i < children.length; i++) {
        if (children[i].name === name) {
          return children[i];
        }
      }
    };
    Group2.prototype.childCount = function() {
      return this._children.length;
    };
    Group2.prototype.add = function(child) {
      if (child) {
        if (child !== this && child.parent !== this) {
          this._children.push(child);
          this._doAdd(child);
        }
        if (define_process_env_default$P.NODE_ENV !== "production") {
          if (child.__hostTarget) {
            throw "This elemenet has been used as an attachment";
          }
        }
      }
      return this;
    };
    Group2.prototype.addBefore = function(child, nextSibling) {
      if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {
        var children = this._children;
        var idx = children.indexOf(nextSibling);
        if (idx >= 0) {
          children.splice(idx, 0, child);
          this._doAdd(child);
        }
      }
      return this;
    };
    Group2.prototype.replace = function(oldChild, newChild) {
      var idx = indexOf(this._children, oldChild);
      if (idx >= 0) {
        this.replaceAt(newChild, idx);
      }
      return this;
    };
    Group2.prototype.replaceAt = function(child, index2) {
      var children = this._children;
      var old = children[index2];
      if (child && child !== this && child.parent !== this && child !== old) {
        children[index2] = child;
        old.parent = null;
        var zr = this.__zr;
        if (zr) {
          old.removeSelfFromZr(zr);
        }
        this._doAdd(child);
      }
      return this;
    };
    Group2.prototype._doAdd = function(child) {
      if (child.parent) {
        child.parent.remove(child);
      }
      child.parent = this;
      var zr = this.__zr;
      if (zr && zr !== child.__zr) {
        child.addSelfToZr(zr);
      }
      zr && zr.refresh();
    };
    Group2.prototype.remove = function(child) {
      var zr = this.__zr;
      var children = this._children;
      var idx = indexOf(children, child);
      if (idx < 0) {
        return this;
      }
      children.splice(idx, 1);
      child.parent = null;
      if (zr) {
        child.removeSelfFromZr(zr);
      }
      zr && zr.refresh();
      return this;
    };
    Group2.prototype.removeAll = function() {
      var children = this._children;
      var zr = this.__zr;
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (zr) {
          child.removeSelfFromZr(zr);
        }
        child.parent = null;
      }
      children.length = 0;
      return this;
    };
    Group2.prototype.eachChild = function(cb, context) {
      var children = this._children;
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        cb.call(context, child, i);
      }
      return this;
    };
    Group2.prototype.traverse = function(cb, context) {
      for (var i = 0; i < this._children.length; i++) {
        var child = this._children[i];
        var stopped = cb.call(context, child);
        if (child.isGroup && !stopped) {
          child.traverse(cb, context);
        }
      }
      return this;
    };
    Group2.prototype.addSelfToZr = function(zr) {
      _super.prototype.addSelfToZr.call(this, zr);
      for (var i = 0; i < this._children.length; i++) {
        var child = this._children[i];
        child.addSelfToZr(zr);
      }
    };
    Group2.prototype.removeSelfFromZr = function(zr) {
      _super.prototype.removeSelfFromZr.call(this, zr);
      for (var i = 0; i < this._children.length; i++) {
        var child = this._children[i];
        child.removeSelfFromZr(zr);
      }
    };
    Group2.prototype.getBoundingRect = function(includeChildren) {
      var tmpRect2 = new BoundingRect(0, 0, 0, 0);
      var children = includeChildren || this._children;
      var tmpMat = [];
      var rect = null;
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (child.ignore || child.invisible) {
          continue;
        }
        var childRect = child.getBoundingRect();
        var transform = child.getLocalTransform(tmpMat);
        if (transform) {
          BoundingRect.applyTransform(tmpRect2, childRect, transform);
          rect = rect || tmpRect2.clone();
          rect.union(tmpRect2);
        } else {
          rect = rect || childRect.clone();
          rect.union(childRect);
        }
      }
      return rect || tmpRect2;
    };
    return Group2;
  }(Element);
  Group$2.prototype.type = "group";
  var define_process_env_default$O = {};
  var painterCtors = {};
  var instances$1 = {};
  function delInstance(id) {
    delete instances$1[id];
  }
  function isDarkMode(backgroundColor2) {
    if (!backgroundColor2) {
      return false;
    }
    if (typeof backgroundColor2 === "string") {
      return lum(backgroundColor2, 1) < DARK_MODE_THRESHOLD;
    } else if (backgroundColor2.colorStops) {
      var colorStops = backgroundColor2.colorStops;
      var totalLum = 0;
      var len2 = colorStops.length;
      for (var i = 0; i < len2; i++) {
        totalLum += lum(colorStops[i].color, 1);
      }
      totalLum /= len2;
      return totalLum < DARK_MODE_THRESHOLD;
    }
    return false;
  }
  var ZRender = function() {
    function ZRender2(id, dom, opts) {
      var _this = this;
      this._sleepAfterStill = 10;
      this._stillFrameAccum = 0;
      this._needsRefresh = true;
      this._needsRefreshHover = true;
      this._darkMode = false;
      opts = opts || {};
      this.dom = dom;
      this.id = id;
      var storage = new Storage();
      var rendererType = opts.renderer || "canvas";
      if (!painterCtors[rendererType]) {
        rendererType = keys(painterCtors)[0];
      }
      if (define_process_env_default$O.NODE_ENV !== "production") {
        if (!painterCtors[rendererType]) {
          throw new Error("Renderer '" + rendererType + "' is not imported. Please import it first.");
        }
      }
      opts.useDirtyRect = opts.useDirtyRect == null ? false : opts.useDirtyRect;
      var painter = new painterCtors[rendererType](dom, storage, opts, id);
      var ssrMode = opts.ssr || painter.ssrOnly;
      this.storage = storage;
      this.painter = painter;
      var handlerProxy = !env.node && !env.worker && !ssrMode ? new HandlerDomProxy(painter.getViewportRoot(), painter.root) : null;
      var useCoarsePointer = opts.useCoarsePointer;
      var usePointerSize = useCoarsePointer == null || useCoarsePointer === "auto" ? env.touchEventsSupported : !!useCoarsePointer;
      var defaultPointerSize = 44;
      var pointerSize;
      if (usePointerSize) {
        pointerSize = retrieve2(opts.pointerSize, defaultPointerSize);
      }
      this.handler = new Handler(storage, painter, handlerProxy, painter.root, pointerSize);
      this.animation = new Animation({
        stage: {
          update: ssrMode ? null : function() {
            return _this._flush(true);
          }
        }
      });
      if (!ssrMode) {
        this.animation.start();
      }
    }
    ZRender2.prototype.add = function(el) {
      if (this._disposed || !el) {
        return;
      }
      this.storage.addRoot(el);
      el.addSelfToZr(this);
      this.refresh();
    };
    ZRender2.prototype.remove = function(el) {
      if (this._disposed || !el) {
        return;
      }
      this.storage.delRoot(el);
      el.removeSelfFromZr(this);
      this.refresh();
    };
    ZRender2.prototype.configLayer = function(zLevel, config) {
      if (this._disposed) {
        return;
      }
      if (this.painter.configLayer) {
        this.painter.configLayer(zLevel, config);
      }
      this.refresh();
    };
    ZRender2.prototype.setBackgroundColor = function(backgroundColor2) {
      if (this._disposed) {
        return;
      }
      if (this.painter.setBackgroundColor) {
        this.painter.setBackgroundColor(backgroundColor2);
      }
      this.refresh();
      this._backgroundColor = backgroundColor2;
      this._darkMode = isDarkMode(backgroundColor2);
    };
    ZRender2.prototype.getBackgroundColor = function() {
      return this._backgroundColor;
    };
    ZRender2.prototype.setDarkMode = function(darkMode) {
      this._darkMode = darkMode;
    };
    ZRender2.prototype.isDarkMode = function() {
      return this._darkMode;
    };
    ZRender2.prototype.refreshImmediately = function(fromInside) {
      if (this._disposed) {
        return;
      }
      if (!fromInside) {
        this.animation.update(true);
      }
      this._needsRefresh = false;
      this.painter.refresh();
      this._needsRefresh = false;
    };
    ZRender2.prototype.refresh = function() {
      if (this._disposed) {
        return;
      }
      this._needsRefresh = true;
      this.animation.start();
    };
    ZRender2.prototype.flush = function() {
      if (this._disposed) {
        return;
      }
      this._flush(false);
    };
    ZRender2.prototype._flush = function(fromInside) {
      var triggerRendered;
      var start2 = getTime();
      if (this._needsRefresh) {
        triggerRendered = true;
        this.refreshImmediately(fromInside);
      }
      if (this._needsRefreshHover) {
        triggerRendered = true;
        this.refreshHoverImmediately();
      }
      var end2 = getTime();
      if (triggerRendered) {
        this._stillFrameAccum = 0;
        this.trigger("rendered", {
          elapsedTime: end2 - start2
        });
      } else if (this._sleepAfterStill > 0) {
        this._stillFrameAccum++;
        if (this._stillFrameAccum > this._sleepAfterStill) {
          this.animation.stop();
        }
      }
    };
    ZRender2.prototype.setSleepAfterStill = function(stillFramesCount) {
      this._sleepAfterStill = stillFramesCount;
    };
    ZRender2.prototype.wakeUp = function() {
      if (this._disposed) {
        return;
      }
      this.animation.start();
      this._stillFrameAccum = 0;
    };
    ZRender2.prototype.refreshHover = function() {
      this._needsRefreshHover = true;
    };
    ZRender2.prototype.refreshHoverImmediately = function() {
      if (this._disposed) {
        return;
      }
      this._needsRefreshHover = false;
      if (this.painter.refreshHover && this.painter.getType() === "canvas") {
        this.painter.refreshHover();
      }
    };
    ZRender2.prototype.resize = function(opts) {
      if (this._disposed) {
        return;
      }
      opts = opts || {};
      this.painter.resize(opts.width, opts.height);
      this.handler.resize();
    };
    ZRender2.prototype.clearAnimation = function() {
      if (this._disposed) {
        return;
      }
      this.animation.clear();
    };
    ZRender2.prototype.getWidth = function() {
      if (this._disposed) {
        return;
      }
      return this.painter.getWidth();
    };
    ZRender2.prototype.getHeight = function() {
      if (this._disposed) {
        return;
      }
      return this.painter.getHeight();
    };
    ZRender2.prototype.setCursorStyle = function(cursorStyle) {
      if (this._disposed) {
        return;
      }
      this.handler.setCursorStyle(cursorStyle);
    };
    ZRender2.prototype.findHover = function(x, y) {
      if (this._disposed) {
        return;
      }
      return this.handler.findHover(x, y);
    };
    ZRender2.prototype.on = function(eventName, eventHandler, context) {
      if (!this._disposed) {
        this.handler.on(eventName, eventHandler, context);
      }
      return this;
    };
    ZRender2.prototype.off = function(eventName, eventHandler) {
      if (this._disposed) {
        return;
      }
      this.handler.off(eventName, eventHandler);
    };
    ZRender2.prototype.trigger = function(eventName, event) {
      if (this._disposed) {
        return;
      }
      this.handler.trigger(eventName, event);
    };
    ZRender2.prototype.clear = function() {
      if (this._disposed) {
        return;
      }
      var roots2 = this.storage.getRoots();
      for (var i = 0; i < roots2.length; i++) {
        if (roots2[i] instanceof Group$2) {
          roots2[i].removeSelfFromZr(this);
        }
      }
      this.storage.delAllRoots();
      this.painter.clear();
    };
    ZRender2.prototype.dispose = function() {
      if (this._disposed) {
        return;
      }
      this.animation.stop();
      this.clear();
      this.storage.dispose();
      this.painter.dispose();
      this.handler.dispose();
      this.animation = this.storage = this.painter = this.handler = null;
      this._disposed = true;
      delInstance(this.id);
    };
    return ZRender2;
  }();
  function init$1(dom, opts) {
    var zr = new ZRender(guid(), dom, opts);
    instances$1[zr.id] = zr;
    return zr;
  }
  function registerPainter(name, Ctor) {
    painterCtors[name] = Ctor;
  }
  var RADIAN_EPSILON = 1e-4;
  var ROUND_SUPPORTED_PRECISION_MAX = 20;
  function _trim(str) {
    return str.replace(/^\s+|\s+$/g, "");
  }
  var mathMin$5 = Math.min;
  var mathMax$5 = Math.max;
  var mathAbs$3 = Math.abs;
  function linearMap(val, domain, range, clamp2) {
    var d0 = domain[0];
    var d1 = domain[1];
    var r0 = range[0];
    var r1 = range[1];
    var subDomain = d1 - d0;
    var subRange = r1 - r0;
    if (subDomain === 0) {
      return subRange === 0 ? r0 : (r0 + r1) / 2;
    }
    if (clamp2) {
      if (subDomain > 0) {
        if (val <= d0) {
          return r0;
        } else if (val >= d1) {
          return r1;
        }
      } else {
        if (val >= d0) {
          return r0;
        } else if (val <= d1) {
          return r1;
        }
      }
    } else {
      if (val === d0) {
        return r0;
      }
      if (val === d1) {
        return r1;
      }
    }
    return (val - d0) / subDomain * subRange + r0;
  }
  var parsePercent = parsePositionOption;
  function parsePositionOption(option, percentBase, percentOffset) {
    switch (option) {
      case "center":
      case "middle":
        option = "50%";
        break;
      case "left":
      case "top":
        option = "0%";
        break;
      case "right":
      case "bottom":
        option = "100%";
        break;
    }
    return parsePositionSizeOption(option, percentBase, percentOffset);
  }
  function parsePositionSizeOption(option, percentBase, percentOffset) {
    if (isString(option)) {
      if (_trim(option).match(/%$/)) {
        return parseFloat(option) / 100 * percentBase + (percentOffset || 0);
      }
      return parseFloat(option);
    }
    return option == null ? NaN : +option;
  }
  function round$1(x, precision, returnStr) {
    if (precision == null) {
      precision = 10;
    }
    precision = Math.min(Math.max(0, precision), ROUND_SUPPORTED_PRECISION_MAX);
    x = (+x).toFixed(precision);
    return returnStr ? x : +x;
  }
  function asc$1(arr) {
    arr.sort(function(a, b) {
      return a - b;
    });
    return arr;
  }
  function getPrecision(val) {
    val = +val;
    if (isNaN(val)) {
      return 0;
    }
    if (val > 1e-14) {
      var e2 = 1;
      for (var i = 0; i < 15; i++, e2 *= 10) {
        if (Math.round(val * e2) / e2 === val) {
          return i;
        }
      }
    }
    return getPrecisionSafe(val);
  }
  function getPrecisionSafe(val) {
    var str = val.toString().toLowerCase();
    var eIndex = str.indexOf("e");
    var exp = eIndex > 0 ? +str.slice(eIndex + 1) : 0;
    var significandPartLen = eIndex > 0 ? eIndex : str.length;
    var dotIndex = str.indexOf(".");
    var decimalPartLen = dotIndex < 0 ? 0 : significandPartLen - 1 - dotIndex;
    return Math.max(0, decimalPartLen - exp);
  }
  function getPixelPrecision(dataExtent, pixelExtent) {
    var log2 = Math.log;
    var LN10 = Math.LN10;
    var dataQuantity = Math.floor(log2(dataExtent[1] - dataExtent[0]) / LN10);
    var sizeQuantity = Math.round(log2(mathAbs$3(pixelExtent[1] - pixelExtent[0])) / LN10);
    var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
    return !isFinite(precision) ? 20 : precision;
  }
  function addSafe(val0, val1) {
    var maxPrecision = Math.max(getPrecision(val0), getPrecision(val1));
    var sum = val0 + val1;
    return maxPrecision > ROUND_SUPPORTED_PRECISION_MAX ? sum : round$1(sum, maxPrecision);
  }
  function remRadian(radian) {
    var pi2 = Math.PI * 2;
    return (radian % pi2 + pi2) % pi2;
  }
  function isRadianAroundZero(val) {
    return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
  }
  var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
  function parseDate(value) {
    if (value instanceof Date) {
      return value;
    } else if (isString(value)) {
      var match = TIME_REG.exec(value);
      if (!match) {
        return /* @__PURE__ */ new Date(NaN);
      }
      if (!match[8]) {
        return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0);
      } else {
        var hour = +match[4] || 0;
        if (match[8].toUpperCase() !== "Z") {
          hour -= +match[8].slice(0, 3);
        }
        return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0));
      }
    } else if (value == null) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return new Date(Math.round(value));
  }
  function quantity(val) {
    return Math.pow(10, quantityExponent(val));
  }
  function quantityExponent(val) {
    if (val === 0) {
      return 0;
    }
    var exp = Math.floor(Math.log(val) / Math.LN10);
    if (val / Math.pow(10, exp) >= 10) {
      exp++;
    }
    return exp;
  }
  function nice(val, round2) {
    var exponent = quantityExponent(val);
    var exp10 = Math.pow(10, exponent);
    var f = val / exp10;
    var nf;
    {
      if (f < 1.5) {
        nf = 1;
      } else if (f < 2.5) {
        nf = 2;
      } else if (f < 4) {
        nf = 3;
      } else if (f < 7) {
        nf = 5;
      } else {
        nf = 10;
      }
    }
    val = nf * exp10;
    return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
  }
  function numericToNumber(val) {
    var valFloat = parseFloat(val);
    return valFloat == val && (valFloat !== 0 || !isString(val) || val.indexOf("x") <= 0) ? valFloat : NaN;
  }
  function isNumeric(val) {
    return !isNaN(numericToNumber(val));
  }
  function getRandomIdBase() {
    return Math.round(Math.random() * 9);
  }
  function getGreatestCommonDividor(a, b) {
    if (b === 0) {
      return a;
    }
    return getGreatestCommonDividor(b, a % b);
  }
  function getLeastCommonMultiple(a, b) {
    if (a == null) {
      return b;
    }
    if (b == null) {
      return a;
    }
    return a * b / getGreatestCommonDividor(a, b);
  }
  var define_process_env_default$N = {};
  var ECHARTS_PREFIX = "[ECharts] ";
  var storedLogs = {};
  var hasConsole = typeof console !== "undefined" && console.warn && console.log;
  function outputLog(type, str, onlyOnce) {
    if (hasConsole) {
      if (onlyOnce) {
        if (storedLogs[str]) {
          return;
        }
        storedLogs[str] = true;
      }
      console[type](ECHARTS_PREFIX + str);
    }
  }
  function log(str, onlyOnce) {
    outputLog("log", str, onlyOnce);
  }
  function warn(str, onlyOnce) {
    outputLog("warn", str, onlyOnce);
  }
  function error(str, onlyOnce) {
    outputLog("error", str, onlyOnce);
  }
  function deprecateLog(str) {
    if (define_process_env_default$N.NODE_ENV !== "production") {
      outputLog("warn", "DEPRECATED: " + str, true);
    }
  }
  function deprecateReplaceLog(oldOpt, newOpt, scope) {
    if (define_process_env_default$N.NODE_ENV !== "production") {
      deprecateLog((scope ? "[" + scope + "]" : "") + (oldOpt + " is deprecated; use " + newOpt + " instead."));
    }
  }
  function makePrintable() {
    var hintInfo = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      hintInfo[_i] = arguments[_i];
    }
    var msg = "";
    if (define_process_env_default$N.NODE_ENV !== "production") {
      var makePrintableStringIfPossible_1 = function(val) {
        return val === void 0 ? "undefined" : val === Infinity ? "Infinity" : val === -Infinity ? "-Infinity" : eqNaN(val) ? "NaN" : val instanceof Date ? "Date(" + val.toISOString() + ")" : isFunction(val) ? "function () { ... }" : isRegExp(val) ? val + "" : null;
      };
      msg = map$1(hintInfo, function(arg) {
        if (isString(arg)) {
          return arg;
        } else {
          var printableStr = makePrintableStringIfPossible_1(arg);
          if (printableStr != null) {
            return printableStr;
          } else if (typeof JSON !== "undefined" && JSON.stringify) {
            try {
              return JSON.stringify(arg, function(n, val) {
                var printableStr2 = makePrintableStringIfPossible_1(val);
                return printableStr2 == null ? val : printableStr2;
              });
            } catch (err) {
              return "?";
            }
          } else {
            return "?";
          }
        }
      }).join(" ");
    }
    return msg;
  }
  function throwError(msg) {
    throw new Error(msg);
  }
  var define_process_env_default$M = {};
  function interpolateNumber(p0, p1, percent) {
    return (p1 - p0) * percent + p0;
  }
  var DUMMY_COMPONENT_NAME_PREFIX = "series\0";
  var INTERNAL_COMPONENT_ID_PREFIX = "\0_ec_\0";
  function normalizeToArray(value) {
    return value instanceof Array ? value : value == null ? [] : [value];
  }
  function defaultEmphasis(opt, key2, subOpts) {
    if (opt) {
      opt[key2] = opt[key2] || {};
      opt.emphasis = opt.emphasis || {};
      opt.emphasis[key2] = opt.emphasis[key2] || {};
      for (var i = 0, len2 = subOpts.length; i < len2; i++) {
        var subOptName = subOpts[i];
        if (!opt.emphasis[key2].hasOwnProperty(subOptName) && opt[key2].hasOwnProperty(subOptName)) {
          opt.emphasis[key2][subOptName] = opt[key2][subOptName];
        }
      }
    }
  }
  var TEXT_STYLE_OPTIONS = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
  function getDataItemValue(dataItem) {
    return isObject$2(dataItem) && !isArray(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;
  }
  function isDataItemOption(dataItem) {
    return isObject$2(dataItem) && !(dataItem instanceof Array);
  }
  function mappingToExists(existings, newCmptOptions, mode) {
    var isNormalMergeMode = mode === "normalMerge";
    var isReplaceMergeMode = mode === "replaceMerge";
    var isReplaceAllMode = mode === "replaceAll";
    existings = existings || [];
    newCmptOptions = (newCmptOptions || []).slice();
    var existingIdIdxMap = createHashMap();
    each$5(newCmptOptions, function(cmptOption, index2) {
      if (!isObject$2(cmptOption)) {
        newCmptOptions[index2] = null;
        return;
      }
      if (define_process_env_default$M.NODE_ENV !== "production") {
        if (cmptOption.id != null && !isValidIdOrName(cmptOption.id)) {
          warnInvalidateIdOrName(cmptOption.id);
        }
        if (cmptOption.name != null && !isValidIdOrName(cmptOption.name)) {
          warnInvalidateIdOrName(cmptOption.name);
        }
      }
    });
    var result = prepareResult(existings, existingIdIdxMap, mode);
    if (isNormalMergeMode || isReplaceMergeMode) {
      mappingById(result, existings, existingIdIdxMap, newCmptOptions);
    }
    if (isNormalMergeMode) {
      mappingByName(result, newCmptOptions);
    }
    if (isNormalMergeMode || isReplaceMergeMode) {
      mappingByIndex(result, newCmptOptions, isReplaceMergeMode);
    } else if (isReplaceAllMode) {
      mappingInReplaceAllMode(result, newCmptOptions);
    }
    makeIdAndName(result);
    return result;
  }
  function prepareResult(existings, existingIdIdxMap, mode) {
    var result = [];
    if (mode === "replaceAll") {
      return result;
    }
    for (var index2 = 0; index2 < existings.length; index2++) {
      var existing = existings[index2];
      if (existing && existing.id != null) {
        existingIdIdxMap.set(existing.id, index2);
      }
      result.push({
        existing: mode === "replaceMerge" || isComponentIdInternal(existing) ? null : existing,
        newOption: null,
        keyInfo: null,
        brandNew: null
      });
    }
    return result;
  }
  function mappingById(result, existings, existingIdIdxMap, newCmptOptions) {
    each$5(newCmptOptions, function(cmptOption, index2) {
      if (!cmptOption || cmptOption.id == null) {
        return;
      }
      var optionId = makeComparableKey(cmptOption.id);
      var existingIdx = existingIdIdxMap.get(optionId);
      if (existingIdx != null) {
        var resultItem = result[existingIdx];
        assert(!resultItem.newOption, 'Duplicated option on id "' + optionId + '".');
        resultItem.newOption = cmptOption;
        resultItem.existing = existings[existingIdx];
        newCmptOptions[index2] = null;
      }
    });
  }
  function mappingByName(result, newCmptOptions) {
    each$5(newCmptOptions, function(cmptOption, index2) {
      if (!cmptOption || cmptOption.name == null) {
        return;
      }
      for (var i = 0; i < result.length; i++) {
        var existing = result[i].existing;
        if (!result[i].newOption && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual("name", existing, cmptOption)) {
          result[i].newOption = cmptOption;
          newCmptOptions[index2] = null;
          return;
        }
      }
    });
  }
  function mappingByIndex(result, newCmptOptions, brandNew) {
    each$5(newCmptOptions, function(cmptOption) {
      if (!cmptOption) {
        return;
      }
      var resultItem;
      var nextIdx = 0;
      while (
        // Be `!resultItem` only when `nextIdx >= result.length`.
        (resultItem = result[nextIdx]) && (resultItem.newOption || isComponentIdInternal(resultItem.existing) || // In mode "replaceMerge", here no not-mapped-non-internal-existing.
        resultItem.existing && cmptOption.id != null && !keyExistAndEqual("id", cmptOption, resultItem.existing))
      ) {
        nextIdx++;
      }
      if (resultItem) {
        resultItem.newOption = cmptOption;
        resultItem.brandNew = brandNew;
      } else {
        result.push({
          newOption: cmptOption,
          brandNew,
          existing: null,
          keyInfo: null
        });
      }
      nextIdx++;
    });
  }
  function mappingInReplaceAllMode(result, newCmptOptions) {
    each$5(newCmptOptions, function(cmptOption) {
      result.push({
        newOption: cmptOption,
        brandNew: true,
        existing: null,
        keyInfo: null
      });
    });
  }
  function makeIdAndName(mapResult) {
    var idMap = createHashMap();
    each$5(mapResult, function(item) {
      var existing = item.existing;
      existing && idMap.set(existing.id, item);
    });
    each$5(mapResult, function(item) {
      var opt = item.newOption;
      assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, "id duplicates: " + (opt && opt.id));
      opt && opt.id != null && idMap.set(opt.id, item);
      !item.keyInfo && (item.keyInfo = {});
    });
    each$5(mapResult, function(item, index2) {
      var existing = item.existing;
      var opt = item.newOption;
      var keyInfo = item.keyInfo;
      if (!isObject$2(opt)) {
        return;
      }
      keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name : DUMMY_COMPONENT_NAME_PREFIX + index2;
      if (existing) {
        keyInfo.id = makeComparableKey(existing.id);
      } else if (opt.id != null) {
        keyInfo.id = makeComparableKey(opt.id);
      } else {
        var idNum = 0;
        do {
          keyInfo.id = "\0" + keyInfo.name + "\0" + idNum++;
        } while (idMap.get(keyInfo.id));
      }
      idMap.set(keyInfo.id, item);
    });
  }
  function keyExistAndEqual(attr, obj1, obj2) {
    var key1 = convertOptionIdName(obj1[attr], null);
    var key2 = convertOptionIdName(obj2[attr], null);
    return key1 != null && key2 != null && key1 === key2;
  }
  function makeComparableKey(val) {
    if (define_process_env_default$M.NODE_ENV !== "production") {
      if (val == null) {
        throw new Error();
      }
    }
    return convertOptionIdName(val, "");
  }
  function convertOptionIdName(idOrName, defaultValue) {
    if (idOrName == null) {
      return defaultValue;
    }
    return isString(idOrName) ? idOrName : isNumber(idOrName) || isStringSafe(idOrName) ? idOrName + "" : defaultValue;
  }
  function warnInvalidateIdOrName(idOrName) {
    if (define_process_env_default$M.NODE_ENV !== "production") {
      warn("`" + idOrName + "` is invalid id or name. Must be a string or number.");
    }
  }
  function isValidIdOrName(idOrName) {
    return isStringSafe(idOrName) || isNumeric(idOrName);
  }
  function isNameSpecified(componentModel) {
    var name = componentModel.name;
    return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
  }
  function isComponentIdInternal(cmptOption) {
    return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;
  }
  function setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {
    each$5(mappingResult, function(item) {
      var newOption = item.newOption;
      if (isObject$2(newOption)) {
        item.keyInfo.mainType = mainType;
        item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);
      }
    });
  }
  function determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {
    var subType = newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType : componentModelCtor.determineSubType(mainType, newCmptOption);
    return subType;
  }
  function queryDataIndex(data, payload) {
    if (payload.dataIndexInside != null) {
      return payload.dataIndexInside;
    } else if (payload.dataIndex != null) {
      return isArray(payload.dataIndex) ? map$1(payload.dataIndex, function(value) {
        return data.indexOfRawIndex(value);
      }) : data.indexOfRawIndex(payload.dataIndex);
    } else if (payload.name != null) {
      return isArray(payload.name) ? map$1(payload.name, function(value) {
        return data.indexOfName(value);
      }) : data.indexOfName(payload.name);
    }
  }
  function makeInner() {
    var key2 = "__ec_inner_" + innerUniqueIndex++;
    return function(hostObj) {
      return hostObj[key2] || (hostObj[key2] = {});
    };
  }
  var innerUniqueIndex = getRandomIdBase();
  function parseFinder(ecModel, finderInput, opt) {
    var _a2 = preParseFinder(finderInput, opt), mainTypeSpecified = _a2.mainTypeSpecified, queryOptionMap = _a2.queryOptionMap, others = _a2.others;
    var result = others;
    var defaultMainType = opt ? opt.defaultMainType : null;
    if (!mainTypeSpecified && defaultMainType) {
      queryOptionMap.set(defaultMainType, {});
    }
    queryOptionMap.each(function(queryOption, mainType) {
      var queryResult = queryReferringComponents(ecModel, mainType, queryOption, {
        useDefault: defaultMainType === mainType,
        enableAll: opt && opt.enableAll != null ? opt.enableAll : true,
        enableNone: opt && opt.enableNone != null ? opt.enableNone : true
      });
      result[mainType + "Models"] = queryResult.models;
      result[mainType + "Model"] = queryResult.models[0];
    });
    return result;
  }
  function preParseFinder(finderInput, opt) {
    var finder;
    if (isString(finderInput)) {
      var obj = {};
      obj[finderInput + "Index"] = 0;
      finder = obj;
    } else {
      finder = finderInput;
    }
    var queryOptionMap = createHashMap();
    var others = {};
    var mainTypeSpecified = false;
    each$5(finder, function(value, key2) {
      if (key2 === "dataIndex" || key2 === "dataIndexInside") {
        others[key2] = value;
        return;
      }
      var parsedKey = key2.match(/^(\w+)(Index|Id|Name)$/) || [];
      var mainType = parsedKey[1];
      var queryType = (parsedKey[2] || "").toLowerCase();
      if (!mainType || !queryType || opt && opt.includeMainTypes && indexOf(opt.includeMainTypes, mainType) < 0) {
        return;
      }
      mainTypeSpecified = mainTypeSpecified || !!mainType;
      var queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});
      queryOption[queryType] = value;
    });
    return {
      mainTypeSpecified,
      queryOptionMap,
      others
    };
  }
  var SINGLE_REFERRING = {
    useDefault: true,
    enableAll: false,
    enableNone: false
  };
  var MULTIPLE_REFERRING = {
    useDefault: false,
    enableAll: true,
    enableNone: true
  };
  function queryReferringComponents(ecModel, mainType, userOption, opt) {
    opt = opt || SINGLE_REFERRING;
    var indexOption = userOption.index;
    var idOption = userOption.id;
    var nameOption = userOption.name;
    var result = {
      models: null,
      specified: indexOption != null || idOption != null || nameOption != null
    };
    if (!result.specified) {
      var firstCmpt = void 0;
      result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];
      return result;
    }
    if (indexOption === "none" || indexOption === false) {
      if (opt.enableNone) {
        result.models = [];
        return result;
      } else {
        if (define_process_env_default$M.NODE_ENV !== "production") {
          error('`"none"` or `false` is not a valid value on index option.');
        }
        indexOption = -1;
      }
    }
    if (indexOption === "all") {
      if (opt.enableAll) {
        indexOption = idOption = nameOption = null;
      } else {
        if (define_process_env_default$M.NODE_ENV !== "production") {
          error('`"all"` is not a valid value on index option.');
        }
        indexOption = -1;
      }
    }
    result.models = ecModel.queryComponents({
      mainType,
      index: indexOption,
      id: idOption,
      name: nameOption
    });
    return result;
  }
  function setAttribute(dom, key2, value) {
    dom.setAttribute ? dom.setAttribute(key2, value) : dom[key2] = value;
  }
  function getAttribute(dom, key2) {
    return dom.getAttribute ? dom.getAttribute(key2) : dom[key2];
  }
  function getTooltipRenderMode(renderModeOption) {
    if (renderModeOption === "auto") {
      return env.domSupported ? "html" : "richText";
    } else {
      return renderModeOption || "html";
    }
  }
  function interpolateRawValues(data, precision, sourceValue, targetValue, percent) {
    var isAutoPrecision = precision == null || precision === "auto";
    if (targetValue == null) {
      return targetValue;
    }
    if (isNumber(targetValue)) {
      var value = interpolateNumber(sourceValue || 0, targetValue, percent);
      return round$1(value, isAutoPrecision ? Math.max(getPrecision(sourceValue || 0), getPrecision(targetValue)) : precision);
    } else if (isString(targetValue)) {
      return percent < 1 ? sourceValue : targetValue;
    } else {
      var interpolated = [];
      var leftArr = sourceValue;
      var rightArr = targetValue;
      var length_1 = Math.max(leftArr ? leftArr.length : 0, rightArr.length);
      for (var i = 0; i < length_1; ++i) {
        var info = data.getDimensionInfo(i);
        if (info && info.type === "ordinal") {
          interpolated[i] = (percent < 1 && leftArr ? leftArr : rightArr)[i];
        } else {
          var leftVal = leftArr && leftArr[i] ? leftArr[i] : 0;
          var rightVal = rightArr[i];
          var value = interpolateNumber(leftVal, rightVal, percent);
          interpolated[i] = round$1(value, isAutoPrecision ? Math.max(getPrecision(leftVal), getPrecision(rightVal)) : precision);
        }
      }
      return interpolated;
    }
  }
  var define_process_env_default$L = {};
  var TYPE_DELIMITER = ".";
  var IS_CONTAINER = "___EC__COMPONENT__CONTAINER___";
  var IS_EXTENDED_CLASS = "___EC__EXTENDED_CLASS___";
  function parseClassType(componentType) {
    var ret = {
      main: "",
      sub: ""
    };
    if (componentType) {
      var typeArr = componentType.split(TYPE_DELIMITER);
      ret.main = typeArr[0] || "";
      ret.sub = typeArr[1] || "";
    }
    return ret;
  }
  function checkClassType(componentType) {
    assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal');
  }
  function isExtendedClass(clz) {
    return !!(clz && clz[IS_EXTENDED_CLASS]);
  }
  function enableClassExtend(rootClz, mandatoryMethods) {
    rootClz.$constructor = rootClz;
    rootClz.extend = function(proto) {
      if (define_process_env_default$L.NODE_ENV !== "production") {
        each$5(mandatoryMethods, function(method) {
          if (!proto[method]) {
            console.warn("Method `" + method + "` should be implemented" + (proto.type ? " in " + proto.type : "") + ".");
          }
        });
      }
      var superClass = this;
      var ExtendedClass;
      if (isESClass(superClass)) {
        ExtendedClass = /** @class */
        function(_super) {
          __extends(class_1, _super);
          function class_1() {
            return _super.apply(this, arguments) || this;
          }
          return class_1;
        }(superClass);
      } else {
        ExtendedClass = function() {
          (proto.$constructor || superClass).apply(this, arguments);
        };
        inherits(ExtendedClass, this);
      }
      extend(ExtendedClass.prototype, proto);
      ExtendedClass[IS_EXTENDED_CLASS] = true;
      ExtendedClass.extend = this.extend;
      ExtendedClass.superCall = superCall;
      ExtendedClass.superApply = superApply;
      ExtendedClass.superClass = superClass;
      return ExtendedClass;
    };
  }
  function isESClass(fn) {
    return isFunction(fn) && /^class\s/.test(Function.prototype.toString.call(fn));
  }
  function mountExtend(SubClz, SupperClz) {
    SubClz.extend = SupperClz.extend;
  }
  var classBase = Math.round(Math.random() * 10);
  function enableClassCheck(target) {
    var classAttr = ["__\0is_clz", classBase++].join("_");
    target.prototype[classAttr] = true;
    if (define_process_env_default$L.NODE_ENV !== "production") {
      assert(!target.isInstance, 'The method "is" can not be defined.');
    }
    target.isInstance = function(obj) {
      return !!(obj && obj[classAttr]);
    };
  }
  function superCall(context, methodName) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    return this.superClass.prototype[methodName].apply(context, args);
  }
  function superApply(context, methodName, args) {
    return this.superClass.prototype[methodName].apply(context, args);
  }
  function enableClassManagement(target) {
    var storage = {};
    target.registerClass = function(clz) {
      var componentFullType = clz.type || clz.prototype.type;
      if (componentFullType) {
        checkClassType(componentFullType);
        clz.prototype.type = componentFullType;
        var componentTypeInfo = parseClassType(componentFullType);
        if (!componentTypeInfo.sub) {
          if (define_process_env_default$L.NODE_ENV !== "production") {
            if (storage[componentTypeInfo.main]) {
              console.warn(componentTypeInfo.main + " exists.");
            }
          }
          storage[componentTypeInfo.main] = clz;
        } else if (componentTypeInfo.sub !== IS_CONTAINER) {
          var container = makeContainer(componentTypeInfo);
          container[componentTypeInfo.sub] = clz;
        }
      }
      return clz;
    };
    target.getClass = function(mainType, subType, throwWhenNotFound) {
      var clz = storage[mainType];
      if (clz && clz[IS_CONTAINER]) {
        clz = subType ? clz[subType] : null;
      }
      if (throwWhenNotFound && !clz) {
        throw new Error(!subType ? mainType + ".type should be specified." : "Component " + mainType + "." + (subType || "") + " is used but not imported.");
      }
      return clz;
    };
    target.getClassesByMainType = function(componentType) {
      var componentTypeInfo = parseClassType(componentType);
      var result = [];
      var obj = storage[componentTypeInfo.main];
      if (obj && obj[IS_CONTAINER]) {
        each$5(obj, function(o, type) {
          type !== IS_CONTAINER && result.push(o);
        });
      } else {
        result.push(obj);
      }
      return result;
    };
    target.hasClass = function(componentType) {
      var componentTypeInfo = parseClassType(componentType);
      return !!storage[componentTypeInfo.main];
    };
    target.getAllClassMainTypes = function() {
      var types = [];
      each$5(storage, function(obj, type) {
        types.push(type);
      });
      return types;
    };
    target.hasSubTypes = function(componentType) {
      var componentTypeInfo = parseClassType(componentType);
      var obj = storage[componentTypeInfo.main];
      return obj && obj[IS_CONTAINER];
    };
    function makeContainer(componentTypeInfo) {
      var container = storage[componentTypeInfo.main];
      if (!container || !container[IS_CONTAINER]) {
        container = storage[componentTypeInfo.main] = {};
        container[IS_CONTAINER] = true;
      }
      return container;
    }
  }
  function makeStyleMapper(properties, ignoreParent) {
    for (var i = 0; i < properties.length; i++) {
      if (!properties[i][1]) {
        properties[i][1] = properties[i][0];
      }
    }
    ignoreParent = ignoreParent || false;
    return function(model, excludes, includes) {
      var style = {};
      for (var i2 = 0; i2 < properties.length; i2++) {
        var propName = properties[i2][1];
        if (excludes && indexOf(excludes, propName) >= 0 || includes && indexOf(includes, propName) < 0) {
          continue;
        }
        var val = model.getShallow(propName, ignoreParent);
        if (val != null) {
          style[properties[i2][0]] = val;
        }
      }
      return style;
    };
  }
  var AREA_STYLE_KEY_MAP = [
    ["fill", "color"],
    ["shadowBlur"],
    ["shadowOffsetX"],
    ["shadowOffsetY"],
    ["opacity"],
    ["shadowColor"]
    // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
    // So do not transfer decal directly.
  ];
  var getAreaStyle = makeStyleMapper(AREA_STYLE_KEY_MAP);
  var AreaStyleMixin = (
    /** @class */
    function() {
      function AreaStyleMixin2() {
      }
      AreaStyleMixin2.prototype.getAreaStyle = function(excludes, includes) {
        return getAreaStyle(this, excludes, includes);
      };
      return AreaStyleMixin2;
    }()
  );
  var globalImageCache = new LRU(50);
  function findExistImage(newImageOrSrc) {
    if (typeof newImageOrSrc === "string") {
      var cachedImgObj = globalImageCache.get(newImageOrSrc);
      return cachedImgObj && cachedImgObj.image;
    } else {
      return newImageOrSrc;
    }
  }
  function createOrUpdateImage(newImageOrSrc, image, hostEl, onload, cbPayload) {
    if (!newImageOrSrc) {
      return image;
    } else if (typeof newImageOrSrc === "string") {
      if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
        return image;
      }
      var cachedImgObj = globalImageCache.get(newImageOrSrc);
      var pendingWrap = { hostEl, cb: onload, cbPayload };
      if (cachedImgObj) {
        image = cachedImgObj.image;
        !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
      } else {
        image = platformApi.loadImage(newImageOrSrc, imageOnLoad, imageOnLoad);
        image.__zrImageSrc = newImageOrSrc;
        globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
          image,
          pending: [pendingWrap]
        });
      }
      return image;
    } else {
      return newImageOrSrc;
    }
  }
  function imageOnLoad() {
    var cachedImgObj = this.__cachedImgObj;
    this.onload = this.onerror = this.__cachedImgObj = null;
    for (var i = 0; i < cachedImgObj.pending.length; i++) {
      var pendingWrap = cachedImgObj.pending[i];
      var cb = pendingWrap.cb;
      cb && cb(this, pendingWrap.cbPayload);
      pendingWrap.hostEl.dirty();
    }
    cachedImgObj.pending.length = 0;
  }
  function isImageReady(image) {
    return image && image.width && image.height;
  }
  var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
  function truncateText2(out2, text, containerWidth, font, ellipsis, options) {
    if (!containerWidth) {
      out2.text = "";
      out2.isTruncated = false;
      return;
    }
    var textLines = (text + "").split("\n");
    options = prepareTruncateOptions(containerWidth, font, ellipsis, options);
    var isTruncated = false;
    var truncateOut = {};
    for (var i = 0, len2 = textLines.length; i < len2; i++) {
      truncateSingleLine(truncateOut, textLines[i], options);
      textLines[i] = truncateOut.textLine;
      isTruncated = isTruncated || truncateOut.isTruncated;
    }
    out2.text = textLines.join("\n");
    out2.isTruncated = isTruncated;
  }
  function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
    options = options || {};
    var preparedOpts = extend({}, options);
    ellipsis = retrieve2(ellipsis, "...");
    preparedOpts.maxIterations = retrieve2(options.maxIterations, 2);
    var minChar = preparedOpts.minChar = retrieve2(options.minChar, 0);
    var fontMeasureInfo = preparedOpts.fontMeasureInfo = ensureFontMeasureInfo(font);
    var ascCharWidth = fontMeasureInfo.asciiCharWidth;
    preparedOpts.placeholder = retrieve2(options.placeholder, "");
    var contentWidth = containerWidth = Math.max(0, containerWidth - 1);
    for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
      contentWidth -= ascCharWidth;
    }
    var ellipsisWidth = measureWidth(fontMeasureInfo, ellipsis);
    if (ellipsisWidth > contentWidth) {
      ellipsis = "";
      ellipsisWidth = 0;
    }
    contentWidth = containerWidth - ellipsisWidth;
    preparedOpts.ellipsis = ellipsis;
    preparedOpts.ellipsisWidth = ellipsisWidth;
    preparedOpts.contentWidth = contentWidth;
    preparedOpts.containerWidth = containerWidth;
    return preparedOpts;
  }
  function truncateSingleLine(out2, textLine, options) {
    var containerWidth = options.containerWidth;
    var contentWidth = options.contentWidth;
    var fontMeasureInfo = options.fontMeasureInfo;
    if (!containerWidth) {
      out2.textLine = "";
      out2.isTruncated = false;
      return;
    }
    var lineWidth = measureWidth(fontMeasureInfo, textLine);
    if (lineWidth <= containerWidth) {
      out2.textLine = textLine;
      out2.isTruncated = false;
      return;
    }
    for (var j = 0; ; j++) {
      if (lineWidth <= contentWidth || j >= options.maxIterations) {
        textLine += options.ellipsis;
        break;
      }
      var subLength = j === 0 ? estimateLength(textLine, contentWidth, fontMeasureInfo) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
      textLine = textLine.substr(0, subLength);
      lineWidth = measureWidth(fontMeasureInfo, textLine);
    }
    if (textLine === "") {
      textLine = options.placeholder;
    }
    out2.textLine = textLine;
    out2.isTruncated = true;
  }
  function estimateLength(text, contentWidth, fontMeasureInfo) {
    var width = 0;
    var i = 0;
    for (var len2 = text.length; i < len2 && width < contentWidth; i++) {
      width += measureCharWidth(fontMeasureInfo, text.charCodeAt(i));
    }
    return i;
  }
  function parsePlainText(rawText, style, defaultOuterWidth, defaultOuterHeight) {
    var text = formatText(rawText);
    var overflow = style.overflow;
    var padding = style.padding;
    var paddingH = padding ? padding[1] + padding[3] : 0;
    var paddingV = padding ? padding[0] + padding[2] : 0;
    var font = style.font;
    var truncate = overflow === "truncate";
    var calculatedLineHeight = getLineHeight(font);
    var lineHeight = retrieve2(style.lineHeight, calculatedLineHeight);
    var truncateLineOverflow = style.lineOverflow === "truncate";
    var isTruncated = false;
    var width = style.width;
    if (width == null && defaultOuterWidth != null) {
      width = defaultOuterWidth - paddingH;
    }
    var height = style.height;
    if (height == null && defaultOuterHeight != null) {
      height = defaultOuterHeight - paddingV;
    }
    var lines;
    if (width != null && (overflow === "break" || overflow === "breakAll")) {
      lines = text ? wrapText(text, style.font, width, overflow === "breakAll", 0).lines : [];
    } else {
      lines = text ? text.split("\n") : [];
    }
    var contentHeight = lines.length * lineHeight;
    if (height == null) {
      height = contentHeight;
    }
    if (contentHeight > height && truncateLineOverflow) {
      var lineCount = Math.floor(height / lineHeight);
      isTruncated = isTruncated || lines.length > lineCount;
      lines = lines.slice(0, lineCount);
      contentHeight = lines.length * lineHeight;
    }
    if (text && truncate && width != null) {
      var options = prepareTruncateOptions(width, font, style.ellipsis, {
        minChar: style.truncateMinChar,
        placeholder: style.placeholder
      });
      var singleOut = {};
      for (var i = 0; i < lines.length; i++) {
        truncateSingleLine(singleOut, lines[i], options);
        lines[i] = singleOut.textLine;
        isTruncated = isTruncated || singleOut.isTruncated;
      }
    }
    var outerHeight = height;
    var contentWidth = 0;
    var fontMeasureInfo = ensureFontMeasureInfo(font);
    for (var i = 0; i < lines.length; i++) {
      contentWidth = Math.max(measureWidth(fontMeasureInfo, lines[i]), contentWidth);
    }
    if (width == null) {
      width = contentWidth;
    }
    var outerWidth = width;
    outerHeight += paddingV;
    outerWidth += paddingH;
    return {
      lines,
      height,
      outerWidth,
      outerHeight,
      lineHeight,
      calculatedLineHeight,
      contentWidth,
      contentHeight,
      width,
      isTruncated
    };
  }
  var RichTextToken = /* @__PURE__ */ function() {
    function RichTextToken2() {
    }
    return RichTextToken2;
  }();
  var RichTextLine = /* @__PURE__ */ function() {
    function RichTextLine2(tokens2) {
      this.tokens = [];
      if (tokens2) {
        this.tokens = tokens2;
      }
    }
    return RichTextLine2;
  }();
  var RichTextContentBlock = /* @__PURE__ */ function() {
    function RichTextContentBlock2() {
      this.width = 0;
      this.height = 0;
      this.contentWidth = 0;
      this.contentHeight = 0;
      this.outerWidth = 0;
      this.outerHeight = 0;
      this.lines = [];
      this.isTruncated = false;
    }
    return RichTextContentBlock2;
  }();
  function parseRichText(rawText, style, defaultOuterWidth, defaultOuterHeight, topTextAlign) {
    var contentBlock = new RichTextContentBlock();
    var text = formatText(rawText);
    if (!text) {
      return contentBlock;
    }
    var stlPadding = style.padding;
    var stlPaddingH = stlPadding ? stlPadding[1] + stlPadding[3] : 0;
    var stlPaddingV = stlPadding ? stlPadding[0] + stlPadding[2] : 0;
    var topWidth = style.width;
    if (topWidth == null && defaultOuterWidth != null) {
      topWidth = defaultOuterWidth - stlPaddingH;
    }
    var topHeight = style.height;
    if (topHeight == null && defaultOuterHeight != null) {
      topHeight = defaultOuterHeight - stlPaddingV;
    }
    var overflow = style.overflow;
    var wrapInfo = (overflow === "break" || overflow === "breakAll") && topWidth != null ? { width: topWidth, accumWidth: 0, breakAll: overflow === "breakAll" } : null;
    var lastIndex = STYLE_REG.lastIndex = 0;
    var result;
    while ((result = STYLE_REG.exec(text)) != null) {
      var matchedIndex = result.index;
      if (matchedIndex > lastIndex) {
        pushTokens(contentBlock, text.substring(lastIndex, matchedIndex), style, wrapInfo);
      }
      pushTokens(contentBlock, result[2], style, wrapInfo, result[1]);
      lastIndex = STYLE_REG.lastIndex;
    }
    if (lastIndex < text.length) {
      pushTokens(contentBlock, text.substring(lastIndex, text.length), style, wrapInfo);
    }
    var pendingList = [];
    var calculatedHeight = 0;
    var calculatedWidth = 0;
    var truncate = overflow === "truncate";
    var truncateLine = style.lineOverflow === "truncate";
    var tmpTruncateOut = {};
    function finishLine(line2, lineWidth2, lineHeight2) {
      line2.width = lineWidth2;
      line2.lineHeight = lineHeight2;
      calculatedHeight += lineHeight2;
      calculatedWidth = Math.max(calculatedWidth, lineWidth2);
    }
    outer: for (var i = 0; i < contentBlock.lines.length; i++) {
      var line = contentBlock.lines[i];
      var lineHeight = 0;
      var lineWidth = 0;
      for (var j = 0; j < line.tokens.length; j++) {
        var token = line.tokens[j];
        var tokenStyle = token.styleName && style.rich[token.styleName] || {};
        var textPadding = token.textPadding = tokenStyle.padding;
        var paddingH = textPadding ? textPadding[1] + textPadding[3] : 0;
        var font = token.font = tokenStyle.font || style.font;
        token.contentHeight = getLineHeight(font);
        var tokenHeight = retrieve2(tokenStyle.height, token.contentHeight);
        token.innerHeight = tokenHeight;
        textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
        token.height = tokenHeight;
        token.lineHeight = retrieve3(tokenStyle.lineHeight, style.lineHeight, tokenHeight);
        token.align = tokenStyle && tokenStyle.align || topTextAlign;
        token.verticalAlign = tokenStyle && tokenStyle.verticalAlign || "middle";
        if (truncateLine && topHeight != null && calculatedHeight + token.lineHeight > topHeight) {
          var originalLength = contentBlock.lines.length;
          if (j > 0) {
            line.tokens = line.tokens.slice(0, j);
            finishLine(line, lineWidth, lineHeight);
            contentBlock.lines = contentBlock.lines.slice(0, i + 1);
          } else {
            contentBlock.lines = contentBlock.lines.slice(0, i);
          }
          contentBlock.isTruncated = contentBlock.isTruncated || contentBlock.lines.length < originalLength;
          break outer;
        }
        var styleTokenWidth = tokenStyle.width;
        var tokenWidthNotSpecified = styleTokenWidth == null || styleTokenWidth === "auto";
        if (typeof styleTokenWidth === "string" && styleTokenWidth.charAt(styleTokenWidth.length - 1) === "%") {
          token.percentWidth = styleTokenWidth;
          pendingList.push(token);
          token.contentWidth = measureWidth(ensureFontMeasureInfo(font), token.text);
        } else {
          if (tokenWidthNotSpecified) {
            var textBackgroundColor = tokenStyle.backgroundColor;
            var bgImg = textBackgroundColor && textBackgroundColor.image;
            if (bgImg) {
              bgImg = findExistImage(bgImg);
              if (isImageReady(bgImg)) {
                token.width = Math.max(token.width, bgImg.width * tokenHeight / bgImg.height);
              }
            }
          }
          var remainTruncWidth = truncate && topWidth != null ? topWidth - lineWidth : null;
          if (remainTruncWidth != null && remainTruncWidth < token.width) {
            if (!tokenWidthNotSpecified || remainTruncWidth < paddingH) {
              token.text = "";
              token.width = token.contentWidth = 0;
            } else {
              truncateText2(tmpTruncateOut, token.text, remainTruncWidth - paddingH, font, style.ellipsis, { minChar: style.truncateMinChar });
              token.text = tmpTruncateOut.text;
              contentBlock.isTruncated = contentBlock.isTruncated || tmpTruncateOut.isTruncated;
              token.width = token.contentWidth = measureWidth(ensureFontMeasureInfo(font), token.text);
            }
          } else {
            token.contentWidth = measureWidth(ensureFontMeasureInfo(font), token.text);
          }
        }
        token.width += paddingH;
        lineWidth += token.width;
        tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
      }
      finishLine(line, lineWidth, lineHeight);
    }
    contentBlock.outerWidth = contentBlock.width = retrieve2(topWidth, calculatedWidth);
    contentBlock.outerHeight = contentBlock.height = retrieve2(topHeight, calculatedHeight);
    contentBlock.contentHeight = calculatedHeight;
    contentBlock.contentWidth = calculatedWidth;
    contentBlock.outerWidth += stlPaddingH;
    contentBlock.outerHeight += stlPaddingV;
    for (var i = 0; i < pendingList.length; i++) {
      var token = pendingList[i];
      var percentWidth = token.percentWidth;
      token.width = parseInt(percentWidth, 10) / 100 * contentBlock.width;
    }
    return contentBlock;
  }
  function pushTokens(block, str, style, wrapInfo, styleName) {
    var isEmptyStr = str === "";
    var tokenStyle = styleName && style.rich[styleName] || {};
    var lines = block.lines;
    var font = tokenStyle.font || style.font;
    var newLine = false;
    var strLines;
    var linesWidths;
    if (wrapInfo) {
      var tokenPadding = tokenStyle.padding;
      var tokenPaddingH = tokenPadding ? tokenPadding[1] + tokenPadding[3] : 0;
      if (tokenStyle.width != null && tokenStyle.width !== "auto") {
        var outerWidth_1 = parsePercent$1(tokenStyle.width, wrapInfo.width) + tokenPaddingH;
        if (lines.length > 0) {
          if (outerWidth_1 + wrapInfo.accumWidth > wrapInfo.width) {
            strLines = str.split("\n");
            newLine = true;
          }
        }
        wrapInfo.accumWidth = outerWidth_1;
      } else {
        var res = wrapText(str, font, wrapInfo.width, wrapInfo.breakAll, wrapInfo.accumWidth);
        wrapInfo.accumWidth = res.accumWidth + tokenPaddingH;
        linesWidths = res.linesWidths;
        strLines = res.lines;
      }
    }
    if (!strLines) {
      strLines = str.split("\n");
    }
    var fontMeasureInfo = ensureFontMeasureInfo(font);
    for (var i = 0; i < strLines.length; i++) {
      var text = strLines[i];
      var token = new RichTextToken();
      token.styleName = styleName;
      token.text = text;
      token.isLineHolder = !text && !isEmptyStr;
      if (typeof tokenStyle.width === "number") {
        token.width = tokenStyle.width;
      } else {
        token.width = linesWidths ? linesWidths[i] : measureWidth(fontMeasureInfo, text);
      }
      if (!i && !newLine) {
        var tokens2 = (lines[lines.length - 1] || (lines[0] = new RichTextLine())).tokens;
        var tokensLen = tokens2.length;
        tokensLen === 1 && tokens2[0].isLineHolder ? tokens2[0] = token : (text || !tokensLen || isEmptyStr) && tokens2.push(token);
      } else {
        lines.push(new RichTextLine([token]));
      }
    }
  }
  function isAlphabeticLetter(ch) {
    var code = ch.charCodeAt(0);
    return code >= 32 && code <= 591 || code >= 880 && code <= 4351 || code >= 4608 && code <= 5119 || code >= 7680 && code <= 8303;
  }
  var breakCharMap = reduce(",&?/;] ".split(""), function(obj, ch) {
    obj[ch] = true;
    return obj;
  }, {});
  function isWordBreakChar(ch) {
    if (isAlphabeticLetter(ch)) {
      if (breakCharMap[ch]) {
        return true;
      }
      return false;
    }
    return true;
  }
  function wrapText(text, font, lineWidth, isBreakAll, lastAccumWidth) {
    var lines = [];
    var linesWidths = [];
    var line = "";
    var currentWord = "";
    var currentWordWidth = 0;
    var accumWidth = 0;
    var fontMeasureInfo = ensureFontMeasureInfo(font);
    for (var i = 0; i < text.length; i++) {
      var ch = text.charAt(i);
      if (ch === "\n") {
        if (currentWord) {
          line += currentWord;
          accumWidth += currentWordWidth;
        }
        lines.push(line);
        linesWidths.push(accumWidth);
        line = "";
        currentWord = "";
        currentWordWidth = 0;
        accumWidth = 0;
        continue;
      }
      var chWidth = measureCharWidth(fontMeasureInfo, ch.charCodeAt(0));
      var inWord = isBreakAll ? false : !isWordBreakChar(ch);
      if (!lines.length ? lastAccumWidth + accumWidth + chWidth > lineWidth : accumWidth + chWidth > lineWidth) {
        if (!accumWidth) {
          if (inWord) {
            lines.push(currentWord);
            linesWidths.push(currentWordWidth);
            currentWord = ch;
            currentWordWidth = chWidth;
          } else {
            lines.push(ch);
            linesWidths.push(chWidth);
          }
        } else if (line || currentWord) {
          if (inWord) {
            if (!line) {
              line = currentWord;
              currentWord = "";
              currentWordWidth = 0;
              accumWidth = currentWordWidth;
            }
            lines.push(line);
            linesWidths.push(accumWidth - currentWordWidth);
            currentWord += ch;
            currentWordWidth += chWidth;
            line = "";
            accumWidth = currentWordWidth;
          } else {
            if (currentWord) {
              line += currentWord;
              currentWord = "";
              currentWordWidth = 0;
            }
            lines.push(line);
            linesWidths.push(accumWidth);
            line = ch;
            accumWidth = chWidth;
          }
        }
        continue;
      }
      accumWidth += chWidth;
      if (inWord) {
        currentWord += ch;
        currentWordWidth += chWidth;
      } else {
        if (currentWord) {
          line += currentWord;
          currentWord = "";
          currentWordWidth = 0;
        }
        line += ch;
      }
    }
    if (currentWord) {
      line += currentWord;
    }
    if (line) {
      lines.push(line);
      linesWidths.push(accumWidth);
    }
    if (lines.length === 1) {
      accumWidth += lastAccumWidth;
    }
    return {
      accumWidth,
      lines,
      linesWidths
    };
  }
  function calcInnerTextOverflowArea(out2, overflowRect, baseX, baseY, textAlign, textVerticalAlign) {
    out2.baseX = baseX;
    out2.baseY = baseY;
    out2.outerWidth = out2.outerHeight = null;
    if (!overflowRect) {
      return;
    }
    var textWidth = overflowRect.width * 2;
    var textHeight = overflowRect.height * 2;
    BoundingRect.set(tmpCITCTextRect, adjustTextX(baseX, textWidth, textAlign), adjustTextY(baseY, textHeight, textVerticalAlign), textWidth, textHeight);
    BoundingRect.intersect(overflowRect, tmpCITCTextRect, null, tmpCITCIntersectRectOpt);
    var outIntersectRect = tmpCITCIntersectRectOpt.outIntersectRect;
    out2.outerWidth = outIntersectRect.width;
    out2.outerHeight = outIntersectRect.height;
    out2.baseX = adjustTextX(outIntersectRect.x, outIntersectRect.width, textAlign, true);
    out2.baseY = adjustTextY(outIntersectRect.y, outIntersectRect.height, textVerticalAlign, true);
  }
  var tmpCITCTextRect = new BoundingRect(0, 0, 0, 0);
  var tmpCITCIntersectRectOpt = { outIntersectRect: {}, clamp: true };
  function formatText(text) {
    return text != null ? text += "" : text = "";
  }
  function tSpanCreateBoundingRect(style) {
    var text = formatText(style.text);
    var font = style.font;
    var contentWidth = measureWidth(ensureFontMeasureInfo(font), text);
    var contentHeight = getLineHeight(font);
    return tSpanCreateBoundingRect2(style, contentWidth, contentHeight, null);
  }
  function tSpanCreateBoundingRect2(style, contentWidth, contentHeight, forceLineWidth) {
    var rect = new BoundingRect(adjustTextX(style.x || 0, contentWidth, style.textAlign), adjustTextY(style.y || 0, contentHeight, style.textBaseline), contentWidth, contentHeight);
    var lineWidth = forceLineWidth != null ? forceLineWidth : tSpanHasStroke(style) ? style.lineWidth : 0;
    if (lineWidth > 0) {
      rect.x -= lineWidth / 2;
      rect.y -= lineWidth / 2;
      rect.width += lineWidth;
      rect.height += lineWidth;
    }
    return rect;
  }
  function tSpanHasStroke(style) {
    var stroke = style.stroke;
    return stroke != null && stroke !== "none" && style.lineWidth > 0;
  }
  var STYLE_MAGIC_KEY = "__zr_style_" + Math.round(Math.random() * 10);
  var DEFAULT_COMMON_STYLE = {
    shadowBlur: 0,
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    shadowColor: "#000",
    opacity: 1,
    blend: "source-over"
  };
  var DEFAULT_COMMON_ANIMATION_PROPS = {
    style: {
      shadowBlur: true,
      shadowOffsetX: true,
      shadowOffsetY: true,
      shadowColor: true,
      opacity: true
    }
  };
  DEFAULT_COMMON_STYLE[STYLE_MAGIC_KEY] = true;
  var PRIMARY_STATES_KEYS = ["z", "z2", "invisible"];
  var PRIMARY_STATES_KEYS_IN_HOVER_LAYER = ["invisible"];
  var Displayable = function(_super) {
    __extends(Displayable2, _super);
    function Displayable2(props) {
      return _super.call(this, props) || this;
    }
    Displayable2.prototype._init = function(props) {
      var keysArr = keys(props);
      for (var i = 0; i < keysArr.length; i++) {
        var key2 = keysArr[i];
        if (key2 === "style") {
          this.useStyle(props[key2]);
        } else {
          _super.prototype.attrKV.call(this, key2, props[key2]);
        }
      }
      if (!this.style) {
        this.useStyle({});
      }
    };
    Displayable2.prototype.beforeBrush = function() {
    };
    Displayable2.prototype.afterBrush = function() {
    };
    Displayable2.prototype.innerBeforeBrush = function() {
    };
    Displayable2.prototype.innerAfterBrush = function() {
    };
    Displayable2.prototype.shouldBePainted = function(viewWidth, viewHeight, considerClipPath, considerAncestors) {
      var m2 = this.transform;
      if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && isDisplayableCulled(this, viewWidth, viewHeight) || m2 && !m2[0] && !m2[3]) {
        return false;
      }
      if (considerClipPath && this.__clipPaths && this.__clipPaths.length) {
        for (var i = 0; i < this.__clipPaths.length; ++i) {
          if (this.__clipPaths[i].isZeroArea()) {
            return false;
          }
        }
      }
      if (considerAncestors && this.parent) {
        var parent_1 = this.parent;
        while (parent_1) {
          if (parent_1.ignore) {
            return false;
          }
          parent_1 = parent_1.parent;
        }
      }
      return true;
    };
    Displayable2.prototype.contain = function(x, y) {
      return this.rectContain(x, y);
    };
    Displayable2.prototype.traverse = function(cb, context) {
      cb.call(context, this);
    };
    Displayable2.prototype.rectContain = function(x, y) {
      var coord = this.transformCoordToLocal(x, y);
      var rect = this.getBoundingRect();
      return rect.contain(coord[0], coord[1]);
    };
    Displayable2.prototype.getPaintRect = function() {
      var rect = this._paintRect;
      if (!this._paintRect || this.__dirty) {
        var transform = this.transform;
        var elRect = this.getBoundingRect();
        var style = this.style;
        var shadowSize = style.shadowBlur || 0;
        var shadowOffsetX = style.shadowOffsetX || 0;
        var shadowOffsetY = style.shadowOffsetY || 0;
        rect = this._paintRect || (this._paintRect = new BoundingRect(0, 0, 0, 0));
        if (transform) {
          BoundingRect.applyTransform(rect, elRect, transform);
        } else {
          rect.copy(elRect);
        }
        if (shadowSize || shadowOffsetX || shadowOffsetY) {
          rect.width += shadowSize * 2 + Math.abs(shadowOffsetX);
          rect.height += shadowSize * 2 + Math.abs(shadowOffsetY);
          rect.x = Math.min(rect.x, rect.x + shadowOffsetX - shadowSize);
          rect.y = Math.min(rect.y, rect.y + shadowOffsetY - shadowSize);
        }
        var tolerance = this.dirtyRectTolerance;
        if (!rect.isZero()) {
          rect.x = Math.floor(rect.x - tolerance);
          rect.y = Math.floor(rect.y - tolerance);
          rect.width = Math.ceil(rect.width + 1 + tolerance * 2);
          rect.height = Math.ceil(rect.height + 1 + tolerance * 2);
        }
      }
      return rect;
    };
    Displayable2.prototype.setPrevPaintRect = function(paintRect) {
      if (paintRect) {
        this._prevPaintRect = this._prevPaintRect || new BoundingRect(0, 0, 0, 0);
        this._prevPaintRect.copy(paintRect);
      } else {
        this._prevPaintRect = null;
      }
    };
    Displayable2.prototype.getPrevPaintRect = function() {
      return this._prevPaintRect;
    };
    Displayable2.prototype.animateStyle = function(loop) {
      return this.animate("style", loop);
    };
    Displayable2.prototype.updateDuringAnimation = function(targetKey) {
      if (targetKey === "style") {
        this.dirtyStyle();
      } else {
        this.markRedraw();
      }
    };
    Displayable2.prototype.attrKV = function(key2, value) {
      if (key2 !== "style") {
        _super.prototype.attrKV.call(this, key2, value);
      } else {
        if (!this.style) {
          this.useStyle(value);
        } else {
          this.setStyle(value);
        }
      }
    };
    Displayable2.prototype.setStyle = function(keyOrObj, value) {
      if (typeof keyOrObj === "string") {
        this.style[keyOrObj] = value;
      } else {
        extend(this.style, keyOrObj);
      }
      this.dirtyStyle();
      return this;
    };
    Displayable2.prototype.dirtyStyle = function(notRedraw) {
      if (!notRedraw) {
        this.markRedraw();
      }
      this.__dirty |= STYLE_CHANGED_BIT;
      if (this._rect) {
        this._rect = null;
      }
    };
    Displayable2.prototype.dirty = function() {
      this.dirtyStyle();
    };
    Displayable2.prototype.styleChanged = function() {
      return !!(this.__dirty & STYLE_CHANGED_BIT);
    };
    Displayable2.prototype.styleUpdated = function() {
      this.__dirty &= ~STYLE_CHANGED_BIT;
    };
    Displayable2.prototype.createStyle = function(obj) {
      return createObject(DEFAULT_COMMON_STYLE, obj);
    };
    Displayable2.prototype.useStyle = function(obj) {
      if (!obj[STYLE_MAGIC_KEY]) {
        obj = this.createStyle(obj);
      }
      if (this.__inHover) {
        this.__hoverStyle = obj;
      } else {
        this.style = obj;
      }
      this.dirtyStyle();
    };
    Displayable2.prototype.isStyleObject = function(obj) {
      return obj[STYLE_MAGIC_KEY];
    };
    Displayable2.prototype._innerSaveToNormal = function(toState) {
      _super.prototype._innerSaveToNormal.call(this, toState);
      var normalState = this._normalState;
      if (toState.style && !normalState.style) {
        normalState.style = this._mergeStyle(this.createStyle(), this.style);
      }
      this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS);
    };
    Displayable2.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
      _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg);
      var needsRestoreToNormal = !(state && keepCurrentStates);
      var targetStyle;
      if (state && state.style) {
        if (transition) {
          if (keepCurrentStates) {
            targetStyle = state.style;
          } else {
            targetStyle = this._mergeStyle(this.createStyle(), normalState.style);
            this._mergeStyle(targetStyle, state.style);
          }
        } else {
          targetStyle = this._mergeStyle(this.createStyle(), keepCurrentStates ? this.style : normalState.style);
          this._mergeStyle(targetStyle, state.style);
        }
      } else if (needsRestoreToNormal) {
        targetStyle = normalState.style;
      }
      if (targetStyle) {
        if (transition) {
          var sourceStyle = this.style;
          this.style = this.createStyle(needsRestoreToNormal ? {} : sourceStyle);
          if (needsRestoreToNormal) {
            var changedKeys = keys(sourceStyle);
            for (var i = 0; i < changedKeys.length; i++) {
              var key2 = changedKeys[i];
              if (key2 in targetStyle) {
                targetStyle[key2] = targetStyle[key2];
                this.style[key2] = sourceStyle[key2];
              }
            }
          }
          var targetKeys = keys(targetStyle);
          for (var i = 0; i < targetKeys.length; i++) {
            var key2 = targetKeys[i];
            this.style[key2] = this.style[key2];
          }
          this._transitionState(stateName, {
            style: targetStyle
          }, animationCfg, this.getAnimationStyleProps());
        } else {
          this.useStyle(targetStyle);
        }
      }
      var statesKeys = this.__inHover ? PRIMARY_STATES_KEYS_IN_HOVER_LAYER : PRIMARY_STATES_KEYS;
      for (var i = 0; i < statesKeys.length; i++) {
        var key2 = statesKeys[i];
        if (state && state[key2] != null) {
          this[key2] = state[key2];
        } else if (needsRestoreToNormal) {
          if (normalState[key2] != null) {
            this[key2] = normalState[key2];
          }
        }
      }
    };
    Displayable2.prototype._mergeStates = function(states) {
      var mergedState = _super.prototype._mergeStates.call(this, states);
      var mergedStyle;
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        if (state.style) {
          mergedStyle = mergedStyle || {};
          this._mergeStyle(mergedStyle, state.style);
        }
      }
      if (mergedStyle) {
        mergedState.style = mergedStyle;
      }
      return mergedState;
    };
    Displayable2.prototype._mergeStyle = function(targetStyle, sourceStyle) {
      extend(targetStyle, sourceStyle);
      return targetStyle;
    };
    Displayable2.prototype.getAnimationStyleProps = function() {
      return DEFAULT_COMMON_ANIMATION_PROPS;
    };
    Displayable2.initDefaultProps = function() {
      var dispProto = Displayable2.prototype;
      dispProto.type = "displayable";
      dispProto.invisible = false;
      dispProto.z = 0;
      dispProto.z2 = 0;
      dispProto.zlevel = 0;
      dispProto.culling = false;
      dispProto.cursor = "pointer";
      dispProto.rectHover = false;
      dispProto.incremental = false;
      dispProto._rect = null;
      dispProto.dirtyRectTolerance = 0;
      dispProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT;
    }();
    return Displayable2;
  }(Element);
  var tmpRect = new BoundingRect(0, 0, 0, 0);
  var viewRect = new BoundingRect(0, 0, 0, 0);
  function isDisplayableCulled(el, width, height) {
    tmpRect.copy(el.getBoundingRect());
    if (el.transform) {
      tmpRect.applyTransform(el.transform);
    }
    viewRect.width = width;
    viewRect.height = height;
    return !tmpRect.intersect(viewRect);
  }
  var mathMin$4 = Math.min;
  var mathMax$4 = Math.max;
  var mathSin$3 = Math.sin;
  var mathCos$3 = Math.cos;
  var PI2$5 = Math.PI * 2;
  var start = create$1();
  var end = create$1();
  var extremity = create$1();
  function fromLine(x0, y0, x1, y1, min3, max3) {
    min3[0] = mathMin$4(x0, x1);
    min3[1] = mathMin$4(y0, y1);
    max3[0] = mathMax$4(x0, x1);
    max3[1] = mathMax$4(y0, y1);
  }
  var xDim = [];
  var yDim = [];
  function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min3, max3) {
    var cubicExtrema$1 = cubicExtrema;
    var cubicAt$1 = cubicAt;
    var n = cubicExtrema$1(x0, x1, x2, x3, xDim);
    min3[0] = Infinity;
    min3[1] = Infinity;
    max3[0] = -Infinity;
    max3[1] = -Infinity;
    for (var i = 0; i < n; i++) {
      var x = cubicAt$1(x0, x1, x2, x3, xDim[i]);
      min3[0] = mathMin$4(x, min3[0]);
      max3[0] = mathMax$4(x, max3[0]);
    }
    n = cubicExtrema$1(y0, y1, y2, y3, yDim);
    for (var i = 0; i < n; i++) {
      var y = cubicAt$1(y0, y1, y2, y3, yDim[i]);
      min3[1] = mathMin$4(y, min3[1]);
      max3[1] = mathMax$4(y, max3[1]);
    }
    min3[0] = mathMin$4(x0, min3[0]);
    max3[0] = mathMax$4(x0, max3[0]);
    min3[0] = mathMin$4(x3, min3[0]);
    max3[0] = mathMax$4(x3, max3[0]);
    min3[1] = mathMin$4(y0, min3[1]);
    max3[1] = mathMax$4(y0, max3[1]);
    min3[1] = mathMin$4(y3, min3[1]);
    max3[1] = mathMax$4(y3, max3[1]);
  }
  function fromQuadratic(x0, y0, x1, y1, x2, y2, min3, max3) {
    var quadraticExtremum$1 = quadraticExtremum;
    var quadraticAt$1 = quadraticAt;
    var tx = mathMax$4(mathMin$4(quadraticExtremum$1(x0, x1, x2), 1), 0);
    var ty = mathMax$4(mathMin$4(quadraticExtremum$1(y0, y1, y2), 1), 0);
    var x = quadraticAt$1(x0, x1, x2, tx);
    var y = quadraticAt$1(y0, y1, y2, ty);
    min3[0] = mathMin$4(x0, x2, x);
    min3[1] = mathMin$4(y0, y2, y);
    max3[0] = mathMax$4(x0, x2, x);
    max3[1] = mathMax$4(y0, y2, y);
  }
  function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min3, max3) {
    var vec2Min = min$1;
    var vec2Max = max$1;
    var diff = Math.abs(startAngle - endAngle);
    if (diff % PI2$5 < 1e-4 && diff > 1e-4) {
      min3[0] = x - rx;
      min3[1] = y - ry;
      max3[0] = x + rx;
      max3[1] = y + ry;
      return;
    }
    start[0] = mathCos$3(startAngle) * rx + x;
    start[1] = mathSin$3(startAngle) * ry + y;
    end[0] = mathCos$3(endAngle) * rx + x;
    end[1] = mathSin$3(endAngle) * ry + y;
    vec2Min(min3, start, end);
    vec2Max(max3, start, end);
    startAngle = startAngle % PI2$5;
    if (startAngle < 0) {
      startAngle = startAngle + PI2$5;
    }
    endAngle = endAngle % PI2$5;
    if (endAngle < 0) {
      endAngle = endAngle + PI2$5;
    }
    if (startAngle > endAngle && !anticlockwise) {
      endAngle += PI2$5;
    } else if (startAngle < endAngle && anticlockwise) {
      startAngle += PI2$5;
    }
    if (anticlockwise) {
      var tmp = endAngle;
      endAngle = startAngle;
      startAngle = tmp;
    }
    for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
      if (angle > startAngle) {
        extremity[0] = mathCos$3(angle) * rx + x;
        extremity[1] = mathSin$3(angle) * ry + y;
        vec2Min(min3, extremity, min3);
        vec2Max(max3, extremity, max3);
      }
    }
  }
  var CMD$2 = {
    M: 1,
    L: 2,
    C: 3,
    Q: 4,
    A: 5,
    Z: 6,
    R: 7
  };
  var tmpOutX = [];
  var tmpOutY = [];
  var min = [];
  var max = [];
  var min2 = [];
  var max2 = [];
  var mathMin$3 = Math.min;
  var mathMax$3 = Math.max;
  var mathCos$2 = Math.cos;
  var mathSin$2 = Math.sin;
  var mathAbs$2 = Math.abs;
  var PI$4 = Math.PI;
  var PI2$4 = PI$4 * 2;
  var hasTypedArray = typeof Float32Array !== "undefined";
  var tmpAngles = [];
  function modPI2(radian) {
    var n = Math.round(radian / PI$4 * 1e8) / 1e8;
    return n % 2 * PI$4;
  }
  function normalizeArcAngles(angles, anticlockwise) {
    var newStartAngle = modPI2(angles[0]);
    if (newStartAngle < 0) {
      newStartAngle += PI2$4;
    }
    var delta = newStartAngle - angles[0];
    var newEndAngle = angles[1];
    newEndAngle += delta;
    if (!anticlockwise && newEndAngle - newStartAngle >= PI2$4) {
      newEndAngle = newStartAngle + PI2$4;
    } else if (anticlockwise && newStartAngle - newEndAngle >= PI2$4) {
      newEndAngle = newStartAngle - PI2$4;
    } else if (!anticlockwise && newStartAngle > newEndAngle) {
      newEndAngle = newStartAngle + (PI2$4 - modPI2(newStartAngle - newEndAngle));
    } else if (anticlockwise && newStartAngle < newEndAngle) {
      newEndAngle = newStartAngle - (PI2$4 - modPI2(newEndAngle - newStartAngle));
    }
    angles[0] = newStartAngle;
    angles[1] = newEndAngle;
  }
  var PathProxy = function() {
    function PathProxy2(notSaveData) {
      this.dpr = 1;
      this._xi = 0;
      this._yi = 0;
      this._x0 = 0;
      this._y0 = 0;
      this._len = 0;
      if (notSaveData) {
        this._saveData = false;
      }
      if (this._saveData) {
        this.data = [];
      }
    }
    PathProxy2.prototype.increaseVersion = function() {
      this._version++;
    };
    PathProxy2.prototype.getVersion = function() {
      return this._version;
    };
    PathProxy2.prototype.setScale = function(sx, sy, segmentIgnoreThreshold) {
      segmentIgnoreThreshold = segmentIgnoreThreshold || 0;
      if (segmentIgnoreThreshold > 0) {
        this._ux = mathAbs$2(segmentIgnoreThreshold / devicePixelRatio / sx) || 0;
        this._uy = mathAbs$2(segmentIgnoreThreshold / devicePixelRatio / sy) || 0;
      }
    };
    PathProxy2.prototype.setDPR = function(dpr2) {
      this.dpr = dpr2;
    };
    PathProxy2.prototype.setContext = function(ctx) {
      this._ctx = ctx;
    };
    PathProxy2.prototype.getContext = function() {
      return this._ctx;
    };
    PathProxy2.prototype.beginPath = function() {
      this._ctx && this._ctx.beginPath();
      this.reset();
      return this;
    };
    PathProxy2.prototype.reset = function() {
      if (this._saveData) {
        this._len = 0;
      }
      if (this._pathSegLen) {
        this._pathSegLen = null;
        this._pathLen = 0;
      }
      this._version++;
    };
    PathProxy2.prototype.moveTo = function(x, y) {
      this._drawPendingPt();
      this.addData(CMD$2.M, x, y);
      this._ctx && this._ctx.moveTo(x, y);
      this._x0 = x;
      this._y0 = y;
      this._xi = x;
      this._yi = y;
      return this;
    };
    PathProxy2.prototype.lineTo = function(x, y) {
      var dx = mathAbs$2(x - this._xi);
      var dy = mathAbs$2(y - this._yi);
      var exceedUnit = dx > this._ux || dy > this._uy;
      this.addData(CMD$2.L, x, y);
      if (this._ctx && exceedUnit) {
        this._ctx.lineTo(x, y);
      }
      if (exceedUnit) {
        this._xi = x;
        this._yi = y;
        this._pendingPtDist = 0;
      } else {
        var d2 = dx * dx + dy * dy;
        if (d2 > this._pendingPtDist) {
          this._pendingPtX = x;
          this._pendingPtY = y;
          this._pendingPtDist = d2;
        }
      }
      return this;
    };
    PathProxy2.prototype.bezierCurveTo = function(x1, y1, x2, y2, x3, y3) {
      this._drawPendingPt();
      this.addData(CMD$2.C, x1, y1, x2, y2, x3, y3);
      if (this._ctx) {
        this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
      }
      this._xi = x3;
      this._yi = y3;
      return this;
    };
    PathProxy2.prototype.quadraticCurveTo = function(x1, y1, x2, y2) {
      this._drawPendingPt();
      this.addData(CMD$2.Q, x1, y1, x2, y2);
      if (this._ctx) {
        this._ctx.quadraticCurveTo(x1, y1, x2, y2);
      }
      this._xi = x2;
      this._yi = y2;
      return this;
    };
    PathProxy2.prototype.arc = function(cx, cy, r, startAngle, endAngle, anticlockwise) {
      this._drawPendingPt();
      tmpAngles[0] = startAngle;
      tmpAngles[1] = endAngle;
      normalizeArcAngles(tmpAngles, anticlockwise);
      startAngle = tmpAngles[0];
      endAngle = tmpAngles[1];
      var delta = endAngle - startAngle;
      this.addData(CMD$2.A, cx, cy, r, r, startAngle, delta, 0, anticlockwise ? 0 : 1);
      this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
      this._xi = mathCos$2(endAngle) * r + cx;
      this._yi = mathSin$2(endAngle) * r + cy;
      return this;
    };
    PathProxy2.prototype.arcTo = function(x1, y1, x2, y2, radius) {
      this._drawPendingPt();
      if (this._ctx) {
        this._ctx.arcTo(x1, y1, x2, y2, radius);
      }
      return this;
    };
    PathProxy2.prototype.rect = function(x, y, w, h) {
      this._drawPendingPt();
      this._ctx && this._ctx.rect(x, y, w, h);
      this.addData(CMD$2.R, x, y, w, h);
      return this;
    };
    PathProxy2.prototype.closePath = function() {
      this._drawPendingPt();
      this.addData(CMD$2.Z);
      var ctx = this._ctx;
      var x0 = this._x0;
      var y0 = this._y0;
      if (ctx) {
        ctx.closePath();
      }
      this._xi = x0;
      this._yi = y0;
      return this;
    };
    PathProxy2.prototype.fill = function(ctx) {
      ctx && ctx.fill();
      this.toStatic();
    };
    PathProxy2.prototype.stroke = function(ctx) {
      ctx && ctx.stroke();
      this.toStatic();
    };
    PathProxy2.prototype.len = function() {
      return this._len;
    };
    PathProxy2.prototype.setData = function(data) {
      if (!this._saveData) {
        return;
      }
      var len2 = data.length;
      if (!(this.data && this.data.length === len2) && hasTypedArray) {
        this.data = new Float32Array(len2);
      }
      for (var i = 0; i < len2; i++) {
        this.data[i] = data[i];
      }
      this._len = len2;
    };
    PathProxy2.prototype.appendPath = function(path) {
      if (!this._saveData) {
        return;
      }
      if (!(path instanceof Array)) {
        path = [path];
      }
      var len2 = path.length;
      var appendSize = 0;
      var offset = this._len;
      for (var i = 0; i < len2; i++) {
        appendSize += path[i].len();
      }
      var oldData = this.data;
      if (hasTypedArray && (oldData instanceof Float32Array || !oldData)) {
        this.data = new Float32Array(offset + appendSize);
        if (offset > 0 && oldData) {
          for (var k = 0; k < offset; k++) {
            this.data[k] = oldData[k];
          }
        }
      }
      for (var i = 0; i < len2; i++) {
        var appendPathData = path[i].data;
        for (var k = 0; k < appendPathData.length; k++) {
          this.data[offset++] = appendPathData[k];
        }
      }
      this._len = offset;
    };
    PathProxy2.prototype.addData = function(cmd, a, b, c, d, e2, f, g, h) {
      if (!this._saveData) {
        return;
      }
      var data = this.data;
      if (this._len + arguments.length > data.length) {
        this._expandData();
        data = this.data;
      }
      for (var i = 0; i < arguments.length; i++) {
        data[this._len++] = arguments[i];
      }
    };
    PathProxy2.prototype._drawPendingPt = function() {
      if (this._pendingPtDist > 0) {
        this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY);
        this._pendingPtDist = 0;
      }
    };
    PathProxy2.prototype._expandData = function() {
      if (!(this.data instanceof Array)) {
        var newData = [];
        for (var i = 0; i < this._len; i++) {
          newData[i] = this.data[i];
        }
        this.data = newData;
      }
    };
    PathProxy2.prototype.toStatic = function() {
      if (!this._saveData) {
        return;
      }
      this._drawPendingPt();
      var data = this.data;
      if (data instanceof Array) {
        data.length = this._len;
        if (hasTypedArray && this._len > 11) {
          this.data = new Float32Array(data);
        }
      }
    };
    PathProxy2.prototype.getBoundingRect = function() {
      min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
      max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
      var data = this.data;
      var xi = 0;
      var yi = 0;
      var x0 = 0;
      var y0 = 0;
      var i;
      for (i = 0; i < this._len; ) {
        var cmd = data[i++];
        var isFirst = i === 1;
        if (isFirst) {
          xi = data[i];
          yi = data[i + 1];
          x0 = xi;
          y0 = yi;
        }
        switch (cmd) {
          case CMD$2.M:
            xi = x0 = data[i++];
            yi = y0 = data[i++];
            min2[0] = x0;
            min2[1] = y0;
            max2[0] = x0;
            max2[1] = y0;
            break;
          case CMD$2.L:
            fromLine(xi, yi, data[i], data[i + 1], min2, max2);
            xi = data[i++];
            yi = data[i++];
            break;
          case CMD$2.C:
            fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
            xi = data[i++];
            yi = data[i++];
            break;
          case CMD$2.Q:
            fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
            xi = data[i++];
            yi = data[i++];
            break;
          case CMD$2.A:
            var cx = data[i++];
            var cy = data[i++];
            var rx = data[i++];
            var ry = data[i++];
            var startAngle = data[i++];
            var endAngle = data[i++] + startAngle;
            i += 1;
            var anticlockwise = !data[i++];
            if (isFirst) {
              x0 = mathCos$2(startAngle) * rx + cx;
              y0 = mathSin$2(startAngle) * ry + cy;
            }
            fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
            xi = mathCos$2(endAngle) * rx + cx;
            yi = mathSin$2(endAngle) * ry + cy;
            break;
          case CMD$2.R:
            x0 = xi = data[i++];
            y0 = yi = data[i++];
            var width = data[i++];
            var height = data[i++];
            fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
            break;
          case CMD$2.Z:
            xi = x0;
            yi = y0;
            break;
        }
        min$1(min, min, min2);
        max$1(max, max, max2);
      }
      if (i === 0) {
        min[0] = min[1] = max[0] = max[1] = 0;
      }
      return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
    };
    PathProxy2.prototype._calculateLength = function() {
      var data = this.data;
      var len2 = this._len;
      var ux = this._ux;
      var uy = this._uy;
      var xi = 0;
      var yi = 0;
      var x0 = 0;
      var y0 = 0;
      if (!this._pathSegLen) {
        this._pathSegLen = [];
      }
      var pathSegLen = this._pathSegLen;
      var pathTotalLen = 0;
      var segCount = 0;
      for (var i = 0; i < len2; ) {
        var cmd = data[i++];
        var isFirst = i === 1;
        if (isFirst) {
          xi = data[i];
          yi = data[i + 1];
          x0 = xi;
          y0 = yi;
        }
        var l = -1;
        switch (cmd) {
          case CMD$2.M:
            xi = x0 = data[i++];
            yi = y0 = data[i++];
            break;
          case CMD$2.L: {
            var x2 = data[i++];
            var y2 = data[i++];
            var dx = x2 - xi;
            var dy = y2 - yi;
            if (mathAbs$2(dx) > ux || mathAbs$2(dy) > uy || i === len2 - 1) {
              l = Math.sqrt(dx * dx + dy * dy);
              xi = x2;
              yi = y2;
            }
            break;
          }
          case CMD$2.C: {
            var x1 = data[i++];
            var y1 = data[i++];
            var x2 = data[i++];
            var y2 = data[i++];
            var x3 = data[i++];
            var y3 = data[i++];
            l = cubicLength(xi, yi, x1, y1, x2, y2, x3, y3, 10);
            xi = x3;
            yi = y3;
            break;
          }
          case CMD$2.Q: {
            var x1 = data[i++];
            var y1 = data[i++];
            var x2 = data[i++];
            var y2 = data[i++];
            l = quadraticLength(xi, yi, x1, y1, x2, y2, 10);
            xi = x2;
            yi = y2;
            break;
          }
          case CMD$2.A:
            var cx = data[i++];
            var cy = data[i++];
            var rx = data[i++];
            var ry = data[i++];
            var startAngle = data[i++];
            var delta = data[i++];
            var endAngle = delta + startAngle;
            i += 1;
            if (isFirst) {
              x0 = mathCos$2(startAngle) * rx + cx;
              y0 = mathSin$2(startAngle) * ry + cy;
            }
            l = mathMax$3(rx, ry) * mathMin$3(PI2$4, Math.abs(delta));
            xi = mathCos$2(endAngle) * rx + cx;
            yi = mathSin$2(endAngle) * ry + cy;
            break;
          case CMD$2.R: {
            x0 = xi = data[i++];
            y0 = yi = data[i++];
            var width = data[i++];
            var height = data[i++];
            l = width * 2 + height * 2;
            break;
          }
          case CMD$2.Z: {
            var dx = x0 - xi;
            var dy = y0 - yi;
            l = Math.sqrt(dx * dx + dy * dy);
            xi = x0;
            yi = y0;
            break;
          }
        }
        if (l >= 0) {
          pathSegLen[segCount++] = l;
          pathTotalLen += l;
        }
      }
      this._pathLen = pathTotalLen;
      return pathTotalLen;
    };
    PathProxy2.prototype.rebuildPath = function(ctx, percent) {
      var d = this.data;
      var ux = this._ux;
      var uy = this._uy;
      var len2 = this._len;
      var x0;
      var y0;
      var xi;
      var yi;
      var x;
      var y;
      var drawPart = percent < 1;
      var pathSegLen;
      var pathTotalLen;
      var accumLength = 0;
      var segCount = 0;
      var displayedLength;
      var pendingPtDist = 0;
      var pendingPtX;
      var pendingPtY;
      if (drawPart) {
        if (!this._pathSegLen) {
          this._calculateLength();
        }
        pathSegLen = this._pathSegLen;
        pathTotalLen = this._pathLen;
        displayedLength = percent * pathTotalLen;
        if (!displayedLength) {
          return;
        }
      }
      lo: for (var i = 0; i < len2; ) {
        var cmd = d[i++];
        var isFirst = i === 1;
        if (isFirst) {
          xi = d[i];
          yi = d[i + 1];
          x0 = xi;
          y0 = yi;
        }
        if (cmd !== CMD$2.L && pendingPtDist > 0) {
          ctx.lineTo(pendingPtX, pendingPtY);
          pendingPtDist = 0;
        }
        switch (cmd) {
          case CMD$2.M:
            x0 = xi = d[i++];
            y0 = yi = d[i++];
            ctx.moveTo(xi, yi);
            break;
          case CMD$2.L: {
            x = d[i++];
            y = d[i++];
            var dx = mathAbs$2(x - xi);
            var dy = mathAbs$2(y - yi);
            if (dx > ux || dy > uy) {
              if (drawPart) {
                var l = pathSegLen[segCount++];
                if (accumLength + l > displayedLength) {
                  var t = (displayedLength - accumLength) / l;
                  ctx.lineTo(xi * (1 - t) + x * t, yi * (1 - t) + y * t);
                  break lo;
                }
                accumLength += l;
              }
              ctx.lineTo(x, y);
              xi = x;
              yi = y;
              pendingPtDist = 0;
            } else {
              var d2 = dx * dx + dy * dy;
              if (d2 > pendingPtDist) {
                pendingPtX = x;
                pendingPtY = y;
                pendingPtDist = d2;
              }
            }
            break;
          }
          case CMD$2.C: {
            var x1 = d[i++];
            var y1 = d[i++];
            var x2 = d[i++];
            var y2 = d[i++];
            var x3 = d[i++];
            var y3 = d[i++];
            if (drawPart) {
              var l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                var t = (displayedLength - accumLength) / l;
                cubicSubdivide(xi, x1, x2, x3, t, tmpOutX);
                cubicSubdivide(yi, y1, y2, y3, t, tmpOutY);
                ctx.bezierCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2], tmpOutX[3], tmpOutY[3]);
                break lo;
              }
              accumLength += l;
            }
            ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
            xi = x3;
            yi = y3;
            break;
          }
          case CMD$2.Q: {
            var x1 = d[i++];
            var y1 = d[i++];
            var x2 = d[i++];
            var y2 = d[i++];
            if (drawPart) {
              var l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                var t = (displayedLength - accumLength) / l;
                quadraticSubdivide(xi, x1, x2, t, tmpOutX);
                quadraticSubdivide(yi, y1, y2, t, tmpOutY);
                ctx.quadraticCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2]);
                break lo;
              }
              accumLength += l;
            }
            ctx.quadraticCurveTo(x1, y1, x2, y2);
            xi = x2;
            yi = y2;
            break;
          }
          case CMD$2.A:
            var cx = d[i++];
            var cy = d[i++];
            var rx = d[i++];
            var ry = d[i++];
            var startAngle = d[i++];
            var delta = d[i++];
            var psi = d[i++];
            var anticlockwise = !d[i++];
            var r = rx > ry ? rx : ry;
            var isEllipse = mathAbs$2(rx - ry) > 1e-3;
            var endAngle = startAngle + delta;
            var breakBuild = false;
            if (drawPart) {
              var l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                endAngle = startAngle + delta * (displayedLength - accumLength) / l;
                breakBuild = true;
              }
              accumLength += l;
            }
            if (isEllipse && ctx.ellipse) {
              ctx.ellipse(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise);
            } else {
              ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
            }
            if (breakBuild) {
              break lo;
            }
            if (isFirst) {
              x0 = mathCos$2(startAngle) * rx + cx;
              y0 = mathSin$2(startAngle) * ry + cy;
            }
            xi = mathCos$2(endAngle) * rx + cx;
            yi = mathSin$2(endAngle) * ry + cy;
            break;
          case CMD$2.R:
            x0 = xi = d[i];
            y0 = yi = d[i + 1];
            x = d[i++];
            y = d[i++];
            var width = d[i++];
            var height = d[i++];
            if (drawPart) {
              var l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                var d_1 = displayedLength - accumLength;
                ctx.moveTo(x, y);
                ctx.lineTo(x + mathMin$3(d_1, width), y);
                d_1 -= width;
                if (d_1 > 0) {
                  ctx.lineTo(x + width, y + mathMin$3(d_1, height));
                }
                d_1 -= height;
                if (d_1 > 0) {
                  ctx.lineTo(x + mathMax$3(width - d_1, 0), y + height);
                }
                d_1 -= width;
                if (d_1 > 0) {
                  ctx.lineTo(x, y + mathMax$3(height - d_1, 0));
                }
                break lo;
              }
              accumLength += l;
            }
            ctx.rect(x, y, width, height);
            break;
          case CMD$2.Z:
            if (drawPart) {
              var l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                var t = (displayedLength - accumLength) / l;
                ctx.lineTo(xi * (1 - t) + x0 * t, yi * (1 - t) + y0 * t);
                break lo;
              }
              accumLength += l;
            }
            ctx.closePath();
            xi = x0;
            yi = y0;
        }
      }
    };
    PathProxy2.prototype.clone = function() {
      var newProxy = new PathProxy2();
      var data = this.data;
      newProxy.data = data.slice ? data.slice() : Array.prototype.slice.call(data);
      newProxy._len = this._len;
      return newProxy;
    };
    PathProxy2.prototype.canSave = function() {
      return !!this._saveData;
    };
    PathProxy2.CMD = CMD$2;
    PathProxy2.initDefaultProps = function() {
      var proto = PathProxy2.prototype;
      proto._saveData = true;
      proto._ux = 0;
      proto._uy = 0;
      proto._pendingPtDist = 0;
      proto._version = 0;
    }();
    return PathProxy2;
  }();
  function containStroke$4(x0, y0, x1, y1, lineWidth, x, y) {
    if (lineWidth === 0) {
      return false;
    }
    var _l = lineWidth;
    var _a2 = 0;
    var _b2 = x0;
    if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
      return false;
    }
    if (x0 !== x1) {
      _a2 = (y0 - y1) / (x0 - x1);
      _b2 = (x0 * y1 - x1 * y0) / (x0 - x1);
    } else {
      return Math.abs(x - x0) <= _l / 2;
    }
    var tmp = _a2 * x - y + _b2;
    var _s = tmp * tmp / (_a2 * _a2 + 1);
    return _s <= _l / 2 * _l / 2;
  }
  function containStroke$3(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
    if (lineWidth === 0) {
      return false;
    }
    var _l = lineWidth;
    if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
      return false;
    }
    var d = cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y);
    return d <= _l / 2;
  }
  function containStroke$2(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
    if (lineWidth === 0) {
      return false;
    }
    var _l = lineWidth;
    if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
      return false;
    }
    var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y);
    return d <= _l / 2;
  }
  var PI2$3 = Math.PI * 2;
  function normalizeRadian(angle) {
    angle %= PI2$3;
    if (angle < 0) {
      angle += PI2$3;
    }
    return angle;
  }
  var PI2$2 = Math.PI * 2;
  function containStroke$1(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
    if (lineWidth === 0) {
      return false;
    }
    var _l = lineWidth;
    x -= cx;
    y -= cy;
    var d = Math.sqrt(x * x + y * y);
    if (d - _l > r || d + _l < r) {
      return false;
    }
    if (Math.abs(startAngle - endAngle) % PI2$2 < 1e-4) {
      return true;
    }
    if (anticlockwise) {
      var tmp = startAngle;
      startAngle = normalizeRadian(endAngle);
      endAngle = normalizeRadian(tmp);
    } else {
      startAngle = normalizeRadian(startAngle);
      endAngle = normalizeRadian(endAngle);
    }
    if (startAngle > endAngle) {
      endAngle += PI2$2;
    }
    var angle = Math.atan2(y, x);
    if (angle < 0) {
      angle += PI2$2;
    }
    return angle >= startAngle && angle <= endAngle || angle + PI2$2 >= startAngle && angle + PI2$2 <= endAngle;
  }
  function windingLine(x0, y0, x1, y1, x, y) {
    if (y > y0 && y > y1 || y < y0 && y < y1) {
      return 0;
    }
    if (y1 === y0) {
      return 0;
    }
    var t = (y - y0) / (y1 - y0);
    var dir = y1 < y0 ? 1 : -1;
    if (t === 1 || t === 0) {
      dir = y1 < y0 ? 0.5 : -0.5;
    }
    var x_ = t * (x1 - x0) + x0;
    return x_ === x ? Infinity : x_ > x ? dir : 0;
  }
  var CMD$1 = PathProxy.CMD;
  var PI2$1 = Math.PI * 2;
  var EPSILON = 1e-4;
  function isAroundEqual(a, b) {
    return Math.abs(a - b) < EPSILON;
  }
  var roots = [-1, -1, -1];
  var extrema = [-1, -1];
  function swapExtrema() {
    var tmp = extrema[0];
    extrema[0] = extrema[1];
    extrema[1] = tmp;
  }
  function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
    if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
      return 0;
    }
    var nRoots = cubicRootAt(y0, y1, y2, y3, y, roots);
    if (nRoots === 0) {
      return 0;
    } else {
      var w = 0;
      var nExtrema = -1;
      var y0_ = void 0;
      var y1_ = void 0;
      for (var i = 0; i < nRoots; i++) {
        var t = roots[i];
        var unit = t === 0 || t === 1 ? 0.5 : 1;
        var x_ = cubicAt(x0, x1, x2, x3, t);
        if (x_ < x) {
          continue;
        }
        if (nExtrema < 0) {
          nExtrema = cubicExtrema(y0, y1, y2, y3, extrema);
          if (extrema[1] < extrema[0] && nExtrema > 1) {
            swapExtrema();
          }
          y0_ = cubicAt(y0, y1, y2, y3, extrema[0]);
          if (nExtrema > 1) {
            y1_ = cubicAt(y0, y1, y2, y3, extrema[1]);
          }
        }
        if (nExtrema === 2) {
          if (t < extrema[0]) {
            w += y0_ < y0 ? unit : -unit;
          } else if (t < extrema[1]) {
            w += y1_ < y0_ ? unit : -unit;
          } else {
            w += y3 < y1_ ? unit : -unit;
          }
        } else {
          if (t < extrema[0]) {
            w += y0_ < y0 ? unit : -unit;
          } else {
            w += y3 < y0_ ? unit : -unit;
          }
        }
      }
      return w;
    }
  }
  function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
    if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
      return 0;
    }
    var nRoots = quadraticRootAt(y0, y1, y2, y, roots);
    if (nRoots === 0) {
      return 0;
    } else {
      var t = quadraticExtremum(y0, y1, y2);
      if (t >= 0 && t <= 1) {
        var w = 0;
        var y_ = quadraticAt(y0, y1, y2, t);
        for (var i = 0; i < nRoots; i++) {
          var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
          var x_ = quadraticAt(x0, x1, x2, roots[i]);
          if (x_ < x) {
            continue;
          }
          if (roots[i] < t) {
            w += y_ < y0 ? unit : -unit;
          } else {
            w += y2 < y_ ? unit : -unit;
          }
        }
        return w;
      } else {
        var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
        var x_ = quadraticAt(x0, x1, x2, roots[0]);
        if (x_ < x) {
          return 0;
        }
        return y2 < y0 ? unit : -unit;
      }
    }
  }
  function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
    y -= cy;
    if (y > r || y < -r) {
      return 0;
    }
    var tmp = Math.sqrt(r * r - y * y);
    roots[0] = -tmp;
    roots[1] = tmp;
    var dTheta = Math.abs(startAngle - endAngle);
    if (dTheta < 1e-4) {
      return 0;
    }
    if (dTheta >= PI2$1 - 1e-4) {
      startAngle = 0;
      endAngle = PI2$1;
      var dir = anticlockwise ? 1 : -1;
      if (x >= roots[0] + cx && x <= roots[1] + cx) {
        return dir;
      } else {
        return 0;
      }
    }
    if (startAngle > endAngle) {
      var tmp_1 = startAngle;
      startAngle = endAngle;
      endAngle = tmp_1;
    }
    if (startAngle < 0) {
      startAngle += PI2$1;
      endAngle += PI2$1;
    }
    var w = 0;
    for (var i = 0; i < 2; i++) {
      var x_ = roots[i];
      if (x_ + cx > x) {
        var angle = Math.atan2(y, x_);
        var dir = anticlockwise ? 1 : -1;
        if (angle < 0) {
          angle = PI2$1 + angle;
        }
        if (angle >= startAngle && angle <= endAngle || angle + PI2$1 >= startAngle && angle + PI2$1 <= endAngle) {
          if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
            dir = -dir;
          }
          w += dir;
        }
      }
    }
    return w;
  }
  function containPath(path, lineWidth, isStroke, x, y) {
    var data = path.data;
    var len2 = path.len();
    var w = 0;
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;
    var x1;
    var y1;
    for (var i = 0; i < len2; ) {
      var cmd = data[i++];
      var isFirst = i === 1;
      if (cmd === CMD$1.M && i > 1) {
        if (!isStroke) {
          w += windingLine(xi, yi, x0, y0, x, y);
        }
      }
      if (isFirst) {
        xi = data[i];
        yi = data[i + 1];
        x0 = xi;
        y0 = yi;
      }
      switch (cmd) {
        case CMD$1.M:
          x0 = data[i++];
          y0 = data[i++];
          xi = x0;
          yi = y0;
          break;
        case CMD$1.L:
          if (isStroke) {
            if (containStroke$4(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
              return true;
            }
          } else {
            w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
          }
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD$1.C:
          if (isStroke) {
            if (containStroke$3(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
              return true;
            }
          } else {
            w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
          }
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD$1.Q:
          if (isStroke) {
            if (containStroke$2(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
              return true;
            }
          } else {
            w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
          }
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD$1.A:
          var cx = data[i++];
          var cy = data[i++];
          var rx = data[i++];
          var ry = data[i++];
          var theta = data[i++];
          var dTheta = data[i++];
          i += 1;
          var anticlockwise = !!(1 - data[i++]);
          x1 = Math.cos(theta) * rx + cx;
          y1 = Math.sin(theta) * ry + cy;
          if (!isFirst) {
            w += windingLine(xi, yi, x1, y1, x, y);
          } else {
            x0 = x1;
            y0 = y1;
          }
          var _x = (x - cx) * ry / rx + cx;
          if (isStroke) {
            if (containStroke$1(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
              return true;
            }
          } else {
            w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
          }
          xi = Math.cos(theta + dTheta) * rx + cx;
          yi = Math.sin(theta + dTheta) * ry + cy;
          break;
        case CMD$1.R:
          x0 = xi = data[i++];
          y0 = yi = data[i++];
          var width = data[i++];
          var height = data[i++];
          x1 = x0 + width;
          y1 = y0 + height;
          if (isStroke) {
            if (containStroke$4(x0, y0, x1, y0, lineWidth, x, y) || containStroke$4(x1, y0, x1, y1, lineWidth, x, y) || containStroke$4(x1, y1, x0, y1, lineWidth, x, y) || containStroke$4(x0, y1, x0, y0, lineWidth, x, y)) {
              return true;
            }
          } else {
            w += windingLine(x1, y0, x1, y1, x, y);
            w += windingLine(x0, y1, x0, y0, x, y);
          }
          break;
        case CMD$1.Z:
          if (isStroke) {
            if (containStroke$4(xi, yi, x0, y0, lineWidth, x, y)) {
              return true;
            }
          } else {
            w += windingLine(xi, yi, x0, y0, x, y);
          }
          xi = x0;
          yi = y0;
          break;
      }
    }
    if (!isStroke && !isAroundEqual(yi, y0)) {
      w += windingLine(xi, yi, x0, y0, x, y) || 0;
    }
    return w !== 0;
  }
  function contain$1(pathProxy, x, y) {
    return containPath(pathProxy, 0, false, x, y);
  }
  function containStroke(pathProxy, lineWidth, x, y) {
    return containPath(pathProxy, lineWidth, true, x, y);
  }
  var DEFAULT_PATH_STYLE = defaults({
    fill: "#000",
    stroke: null,
    strokePercent: 1,
    fillOpacity: 1,
    strokeOpacity: 1,
    lineDashOffset: 0,
    lineWidth: 1,
    lineCap: "butt",
    miterLimit: 10,
    strokeNoScale: false,
    strokeFirst: false
  }, DEFAULT_COMMON_STYLE);
  var DEFAULT_PATH_ANIMATION_PROPS = {
    style: defaults({
      fill: true,
      stroke: true,
      strokePercent: true,
      fillOpacity: true,
      strokeOpacity: true,
      lineDashOffset: true,
      lineWidth: true,
      miterLimit: true
    }, DEFAULT_COMMON_ANIMATION_PROPS.style)
  };
  var pathCopyParams = TRANSFORMABLE_PROPS.concat([
    "invisible",
    "culling",
    "z",
    "z2",
    "zlevel",
    "parent"
  ]);
  var Path = function(_super) {
    __extends(Path2, _super);
    function Path2(opts) {
      return _super.call(this, opts) || this;
    }
    Path2.prototype.update = function() {
      var _this = this;
      _super.prototype.update.call(this);
      var style = this.style;
      if (style.decal) {
        var decalEl = this._decalEl = this._decalEl || new Path2();
        if (decalEl.buildPath === Path2.prototype.buildPath) {
          decalEl.buildPath = function(ctx) {
            _this.buildPath(ctx, _this.shape);
          };
        }
        decalEl.silent = true;
        var decalElStyle = decalEl.style;
        for (var key2 in style) {
          if (decalElStyle[key2] !== style[key2]) {
            decalElStyle[key2] = style[key2];
          }
        }
        decalElStyle.fill = style.fill ? style.decal : null;
        decalElStyle.decal = null;
        decalElStyle.shadowColor = null;
        style.strokeFirst && (decalElStyle.stroke = null);
        for (var i = 0; i < pathCopyParams.length; ++i) {
          decalEl[pathCopyParams[i]] = this[pathCopyParams[i]];
        }
        decalEl.__dirty |= REDRAW_BIT;
      } else if (this._decalEl) {
        this._decalEl = null;
      }
    };
    Path2.prototype.getDecalElement = function() {
      return this._decalEl;
    };
    Path2.prototype._init = function(props) {
      var keysArr = keys(props);
      this.shape = this.getDefaultShape();
      var defaultStyle = this.getDefaultStyle();
      if (defaultStyle) {
        this.useStyle(defaultStyle);
      }
      for (var i = 0; i < keysArr.length; i++) {
        var key2 = keysArr[i];
        var value = props[key2];
        if (key2 === "style") {
          if (!this.style) {
            this.useStyle(value);
          } else {
            extend(this.style, value);
          }
        } else if (key2 === "shape") {
          extend(this.shape, value);
        } else {
          _super.prototype.attrKV.call(this, key2, value);
        }
      }
      if (!this.style) {
        this.useStyle({});
      }
    };
    Path2.prototype.getDefaultStyle = function() {
      return null;
    };
    Path2.prototype.getDefaultShape = function() {
      return {};
    };
    Path2.prototype.canBeInsideText = function() {
      return this.hasFill();
    };
    Path2.prototype.getInsideTextFill = function() {
      var pathFill = this.style.fill;
      if (pathFill !== "none") {
        if (isString(pathFill)) {
          var fillLum = lum(pathFill, 0);
          if (fillLum > 0.5) {
            return DARK_LABEL_COLOR;
          } else if (fillLum > 0.2) {
            return LIGHTER_LABEL_COLOR;
          }
          return LIGHT_LABEL_COLOR;
        } else if (pathFill) {
          return LIGHT_LABEL_COLOR;
        }
      }
      return DARK_LABEL_COLOR;
    };
    Path2.prototype.getInsideTextStroke = function(textFill) {
      var pathFill = this.style.fill;
      if (isString(pathFill)) {
        var zr = this.__zr;
        var isDarkMode2 = !!(zr && zr.isDarkMode());
        var isDarkLabel = lum(textFill, 0) < DARK_MODE_THRESHOLD;
        if (isDarkMode2 === isDarkLabel) {
          return pathFill;
        }
      }
    };
    Path2.prototype.buildPath = function(ctx, shapeCfg, inBatch) {
    };
    Path2.prototype.pathUpdated = function() {
      this.__dirty &= ~SHAPE_CHANGED_BIT;
    };
    Path2.prototype.getUpdatedPathProxy = function(inBatch) {
      !this.path && this.createPathProxy();
      this.path.beginPath();
      this.buildPath(this.path, this.shape, inBatch);
      return this.path;
    };
    Path2.prototype.createPathProxy = function() {
      this.path = new PathProxy(false);
    };
    Path2.prototype.hasStroke = function() {
      var style = this.style;
      var stroke = style.stroke;
      return !(stroke == null || stroke === "none" || !(style.lineWidth > 0));
    };
    Path2.prototype.hasFill = function() {
      var style = this.style;
      var fill = style.fill;
      return fill != null && fill !== "none";
    };
    Path2.prototype.getBoundingRect = function() {
      var rect = this._rect;
      var style = this.style;
      var needsUpdateRect = !rect;
      if (needsUpdateRect) {
        var firstInvoke = false;
        if (!this.path) {
          firstInvoke = true;
          this.createPathProxy();
        }
        var path = this.path;
        if (firstInvoke || this.__dirty & SHAPE_CHANGED_BIT) {
          path.beginPath();
          this.buildPath(path, this.shape, false);
          this.pathUpdated();
        }
        rect = path.getBoundingRect();
      }
      this._rect = rect;
      if (this.hasStroke() && this.path && this.path.len() > 0) {
        var rectStroke = this._rectStroke || (this._rectStroke = rect.clone());
        if (this.__dirty || needsUpdateRect) {
          rectStroke.copy(rect);
          var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
          var w = style.lineWidth;
          if (!this.hasFill()) {
            var strokeContainThreshold = this.strokeContainThreshold;
            w = Math.max(w, strokeContainThreshold == null ? 4 : strokeContainThreshold);
          }
          if (lineScale > 1e-10) {
            rectStroke.width += w / lineScale;
            rectStroke.height += w / lineScale;
            rectStroke.x -= w / lineScale / 2;
            rectStroke.y -= w / lineScale / 2;
          }
        }
        return rectStroke;
      }
      return rect;
    };
    Path2.prototype.contain = function(x, y) {
      var localPos = this.transformCoordToLocal(x, y);
      var rect = this.getBoundingRect();
      var style = this.style;
      x = localPos[0];
      y = localPos[1];
      if (rect.contain(x, y)) {
        var pathProxy = this.path;
        if (this.hasStroke()) {
          var lineWidth = style.lineWidth;
          var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
          if (lineScale > 1e-10) {
            if (!this.hasFill()) {
              lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
            }
            if (containStroke(pathProxy, lineWidth / lineScale, x, y)) {
              return true;
            }
          }
        }
        if (this.hasFill()) {
          return contain$1(pathProxy, x, y);
        }
      }
      return false;
    };
    Path2.prototype.dirtyShape = function() {
      this.__dirty |= SHAPE_CHANGED_BIT;
      if (this._rect) {
        this._rect = null;
      }
      if (this._decalEl) {
        this._decalEl.dirtyShape();
      }
      this.markRedraw();
    };
    Path2.prototype.dirty = function() {
      this.dirtyStyle();
      this.dirtyShape();
    };
    Path2.prototype.animateShape = function(loop) {
      return this.animate("shape", loop);
    };
    Path2.prototype.updateDuringAnimation = function(targetKey) {
      if (targetKey === "style") {
        this.dirtyStyle();
      } else if (targetKey === "shape") {
        this.dirtyShape();
      } else {
        this.markRedraw();
      }
    };
    Path2.prototype.attrKV = function(key2, value) {
      if (key2 === "shape") {
        this.setShape(value);
      } else {
        _super.prototype.attrKV.call(this, key2, value);
      }
    };
    Path2.prototype.setShape = function(keyOrObj, value) {
      var shape = this.shape;
      if (!shape) {
        shape = this.shape = {};
      }
      if (typeof keyOrObj === "string") {
        shape[keyOrObj] = value;
      } else {
        extend(shape, keyOrObj);
      }
      this.dirtyShape();
      return this;
    };
    Path2.prototype.shapeChanged = function() {
      return !!(this.__dirty & SHAPE_CHANGED_BIT);
    };
    Path2.prototype.createStyle = function(obj) {
      return createObject(DEFAULT_PATH_STYLE, obj);
    };
    Path2.prototype._innerSaveToNormal = function(toState) {
      _super.prototype._innerSaveToNormal.call(this, toState);
      var normalState = this._normalState;
      if (toState.shape && !normalState.shape) {
        normalState.shape = extend({}, this.shape);
      }
    };
    Path2.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
      _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg);
      var needsRestoreToNormal = !(state && keepCurrentStates);
      var targetShape;
      if (state && state.shape) {
        if (transition) {
          if (keepCurrentStates) {
            targetShape = state.shape;
          } else {
            targetShape = extend({}, normalState.shape);
            extend(targetShape, state.shape);
          }
        } else {
          targetShape = extend({}, keepCurrentStates ? this.shape : normalState.shape);
          extend(targetShape, state.shape);
        }
      } else if (needsRestoreToNormal) {
        targetShape = normalState.shape;
      }
      if (targetShape) {
        if (transition) {
          this.shape = extend({}, this.shape);
          var targetShapePrimaryProps = {};
          var shapeKeys = keys(targetShape);
          for (var i = 0; i < shapeKeys.length; i++) {
            var key2 = shapeKeys[i];
            if (typeof targetShape[key2] === "object") {
              this.shape[key2] = targetShape[key2];
            } else {
              targetShapePrimaryProps[key2] = targetShape[key2];
            }
          }
          this._transitionState(stateName, {
            shape: targetShapePrimaryProps
          }, animationCfg);
        } else {
          this.shape = targetShape;
          this.dirtyShape();
        }
      }
    };
    Path2.prototype._mergeStates = function(states) {
      var mergedState = _super.prototype._mergeStates.call(this, states);
      var mergedShape;
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        if (state.shape) {
          mergedShape = mergedShape || {};
          this._mergeStyle(mergedShape, state.shape);
        }
      }
      if (mergedShape) {
        mergedState.shape = mergedShape;
      }
      return mergedState;
    };
    Path2.prototype.getAnimationStyleProps = function() {
      return DEFAULT_PATH_ANIMATION_PROPS;
    };
    Path2.prototype.isZeroArea = function() {
      return false;
    };
    Path2.extend = function(defaultProps) {
      var Sub = function(_super2) {
        __extends(Sub2, _super2);
        function Sub2(opts) {
          var _this = _super2.call(this, opts) || this;
          defaultProps.init && defaultProps.init.call(_this, opts);
          return _this;
        }
        Sub2.prototype.getDefaultStyle = function() {
          return clone$2(defaultProps.style);
        };
        Sub2.prototype.getDefaultShape = function() {
          return clone$2(defaultProps.shape);
        };
        return Sub2;
      }(Path2);
      for (var key2 in defaultProps) {
        if (typeof defaultProps[key2] === "function") {
          Sub.prototype[key2] = defaultProps[key2];
        }
      }
      return Sub;
    };
    Path2.initDefaultProps = function() {
      var pathProto = Path2.prototype;
      pathProto.type = "path";
      pathProto.strokeContainThreshold = 5;
      pathProto.segmentIgnoreThreshold = 0;
      pathProto.subPixelOptimize = false;
      pathProto.autoBatch = false;
      pathProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT | SHAPE_CHANGED_BIT;
    }();
    return Path2;
  }(Displayable);
  var DEFAULT_TSPAN_STYLE = defaults({
    strokeFirst: true,
    font: DEFAULT_FONT,
    x: 0,
    y: 0,
    textAlign: "left",
    textBaseline: "top",
    miterLimit: 2
  }, DEFAULT_PATH_STYLE);
  var TSpan = function(_super) {
    __extends(TSpan2, _super);
    function TSpan2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TSpan2.prototype.hasStroke = function() {
      return tSpanHasStroke(this.style);
    };
    TSpan2.prototype.hasFill = function() {
      var style = this.style;
      var fill = style.fill;
      return fill != null && fill !== "none";
    };
    TSpan2.prototype.createStyle = function(obj) {
      return createObject(DEFAULT_TSPAN_STYLE, obj);
    };
    TSpan2.prototype.setBoundingRect = function(rect) {
      this._rect = rect;
    };
    TSpan2.prototype.getBoundingRect = function() {
      if (!this._rect) {
        this._rect = tSpanCreateBoundingRect(this.style);
      }
      return this._rect;
    };
    TSpan2.initDefaultProps = function() {
      var tspanProto = TSpan2.prototype;
      tspanProto.dirtyRectTolerance = 10;
    }();
    return TSpan2;
  }(Displayable);
  TSpan.prototype.type = "tspan";
  var DEFAULT_IMAGE_STYLE = defaults({
    x: 0,
    y: 0
  }, DEFAULT_COMMON_STYLE);
  var DEFAULT_IMAGE_ANIMATION_PROPS = {
    style: defaults({
      x: true,
      y: true,
      width: true,
      height: true,
      sx: true,
      sy: true,
      sWidth: true,
      sHeight: true
    }, DEFAULT_COMMON_ANIMATION_PROPS.style)
  };
  function isImageLike(source) {
    return !!(source && typeof source !== "string" && source.width && source.height);
  }
  var ZRImage = function(_super) {
    __extends(ZRImage2, _super);
    function ZRImage2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ZRImage2.prototype.createStyle = function(obj) {
      return createObject(DEFAULT_IMAGE_STYLE, obj);
    };
    ZRImage2.prototype._getSize = function(dim) {
      var style = this.style;
      var size = style[dim];
      if (size != null) {
        return size;
      }
      var imageSource = isImageLike(style.image) ? style.image : this.__image;
      if (!imageSource) {
        return 0;
      }
      var otherDim = dim === "width" ? "height" : "width";
      var otherDimSize = style[otherDim];
      if (otherDimSize == null) {
        return imageSource[dim];
      } else {
        return imageSource[dim] / imageSource[otherDim] * otherDimSize;
      }
    };
    ZRImage2.prototype.getWidth = function() {
      return this._getSize("width");
    };
    ZRImage2.prototype.getHeight = function() {
      return this._getSize("height");
    };
    ZRImage2.prototype.getAnimationStyleProps = function() {
      return DEFAULT_IMAGE_ANIMATION_PROPS;
    };
    ZRImage2.prototype.getBoundingRect = function() {
      var style = this.style;
      if (!this._rect) {
        this._rect = new BoundingRect(style.x || 0, style.y || 0, this.getWidth(), this.getHeight());
      }
      return this._rect;
    };
    return ZRImage2;
  }(Displayable);
  ZRImage.prototype.type = "image";
  function buildPath$2(ctx, shape) {
    var x = shape.x;
    var y = shape.y;
    var width = shape.width;
    var height = shape.height;
    var r = shape.r;
    var r1;
    var r2;
    var r3;
    var r4;
    if (width < 0) {
      x = x + width;
      width = -width;
    }
    if (height < 0) {
      y = y + height;
      height = -height;
    }
    if (typeof r === "number") {
      r1 = r2 = r3 = r4 = r;
    } else if (r instanceof Array) {
      if (r.length === 1) {
        r1 = r2 = r3 = r4 = r[0];
      } else if (r.length === 2) {
        r1 = r3 = r[0];
        r2 = r4 = r[1];
      } else if (r.length === 3) {
        r1 = r[0];
        r2 = r4 = r[1];
        r3 = r[2];
      } else {
        r1 = r[0];
        r2 = r[1];
        r3 = r[2];
        r4 = r[3];
      }
    } else {
      r1 = r2 = r3 = r4 = 0;
    }
    var total;
    if (r1 + r2 > width) {
      total = r1 + r2;
      r1 *= width / total;
      r2 *= width / total;
    }
    if (r3 + r4 > width) {
      total = r3 + r4;
      r3 *= width / total;
      r4 *= width / total;
    }
    if (r2 + r3 > height) {
      total = r2 + r3;
      r2 *= height / total;
      r3 *= height / total;
    }
    if (r1 + r4 > height) {
      total = r1 + r4;
      r1 *= height / total;
      r4 *= height / total;
    }
    ctx.moveTo(x + r1, y);
    ctx.lineTo(x + width - r2, y);
    r2 !== 0 && ctx.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
    ctx.lineTo(x + width, y + height - r3);
    r3 !== 0 && ctx.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
    ctx.lineTo(x + r4, y + height);
    r4 !== 0 && ctx.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
    ctx.lineTo(x, y + r1);
    r1 !== 0 && ctx.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
  }
  var round = Math.round;
  function subPixelOptimizeLine$1(outputShape, inputShape, style) {
    if (!inputShape) {
      return;
    }
    var x1 = inputShape.x1;
    var x2 = inputShape.x2;
    var y1 = inputShape.y1;
    var y2 = inputShape.y2;
    outputShape.x1 = x1;
    outputShape.x2 = x2;
    outputShape.y1 = y1;
    outputShape.y2 = y2;
    var lineWidth = style && style.lineWidth;
    if (!lineWidth) {
      return outputShape;
    }
    if (round(x1 * 2) === round(x2 * 2)) {
      outputShape.x1 = outputShape.x2 = subPixelOptimize$1(x1, lineWidth, true);
    }
    if (round(y1 * 2) === round(y2 * 2)) {
      outputShape.y1 = outputShape.y2 = subPixelOptimize$1(y1, lineWidth, true);
    }
    return outputShape;
  }
  function subPixelOptimizeRect$1(outputShape, inputShape, style) {
    if (!inputShape) {
      return;
    }
    var originX = inputShape.x;
    var originY = inputShape.y;
    var originWidth = inputShape.width;
    var originHeight = inputShape.height;
    outputShape.x = originX;
    outputShape.y = originY;
    outputShape.width = originWidth;
    outputShape.height = originHeight;
    var lineWidth = style && style.lineWidth;
    if (!lineWidth) {
      return outputShape;
    }
    outputShape.x = subPixelOptimize$1(originX, lineWidth, true);
    outputShape.y = subPixelOptimize$1(originY, lineWidth, true);
    outputShape.width = Math.max(subPixelOptimize$1(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);
    outputShape.height = Math.max(subPixelOptimize$1(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);
    return outputShape;
  }
  function subPixelOptimize$1(position, lineWidth, positiveOrNegative) {
    if (!lineWidth) {
      return position;
    }
    var doubledPosition = round(position * 2);
    return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
  }
  var RectShape = /* @__PURE__ */ function() {
    function RectShape2() {
      this.x = 0;
      this.y = 0;
      this.width = 0;
      this.height = 0;
    }
    return RectShape2;
  }();
  var subPixelOptimizeOutputShape$1 = {};
  var Rect$1 = function(_super) {
    __extends(Rect2, _super);
    function Rect2(opts) {
      return _super.call(this, opts) || this;
    }
    Rect2.prototype.getDefaultShape = function() {
      return new RectShape();
    };
    Rect2.prototype.buildPath = function(ctx, shape) {
      var x;
      var y;
      var width;
      var height;
      if (this.subPixelOptimize) {
        var optimizedShape = subPixelOptimizeRect$1(subPixelOptimizeOutputShape$1, shape, this.style);
        x = optimizedShape.x;
        y = optimizedShape.y;
        width = optimizedShape.width;
        height = optimizedShape.height;
        optimizedShape.r = shape.r;
        shape = optimizedShape;
      } else {
        x = shape.x;
        y = shape.y;
        width = shape.width;
        height = shape.height;
      }
      if (!shape.r) {
        ctx.rect(x, y, width, height);
      } else {
        buildPath$2(ctx, shape);
      }
    };
    Rect2.prototype.isZeroArea = function() {
      return !this.shape.width || !this.shape.height;
    };
    return Rect2;
  }(Path);
  Rect$1.prototype.type = "rect";
  var define_process_env_default$K = {};
  var DEFAULT_RICH_TEXT_COLOR = {
    fill: "#000"
  };
  var DEFAULT_STROKE_LINE_WIDTH = 2;
  var tmpCITOverflowAreaOut = {};
  var DEFAULT_TEXT_ANIMATION_PROPS = {
    style: defaults({
      fill: true,
      stroke: true,
      fillOpacity: true,
      strokeOpacity: true,
      lineWidth: true,
      fontSize: true,
      lineHeight: true,
      width: true,
      height: true,
      textShadowColor: true,
      textShadowBlur: true,
      textShadowOffsetX: true,
      textShadowOffsetY: true,
      backgroundColor: true,
      padding: true,
      borderColor: true,
      borderWidth: true,
      borderRadius: true
    }, DEFAULT_COMMON_ANIMATION_PROPS.style)
  };
  var ZRText = function(_super) {
    __extends(ZRText2, _super);
    function ZRText2(opts) {
      var _this = _super.call(this) || this;
      _this.type = "text";
      _this._children = [];
      _this._defaultStyle = DEFAULT_RICH_TEXT_COLOR;
      _this.attr(opts);
      return _this;
    }
    ZRText2.prototype.childrenRef = function() {
      return this._children;
    };
    ZRText2.prototype.update = function() {
      _super.prototype.update.call(this);
      if (this.styleChanged()) {
        this._updateSubTexts();
      }
      for (var i = 0; i < this._children.length; i++) {
        var child = this._children[i];
        child.zlevel = this.zlevel;
        child.z = this.z;
        child.z2 = this.z2;
        child.culling = this.culling;
        child.cursor = this.cursor;
        child.invisible = this.invisible;
      }
    };
    ZRText2.prototype.updateTransform = function() {
      var innerTransformable = this.innerTransformable;
      if (innerTransformable) {
        innerTransformable.updateTransform();
        if (innerTransformable.transform) {
          this.transform = innerTransformable.transform;
        }
      } else {
        _super.prototype.updateTransform.call(this);
      }
    };
    ZRText2.prototype.getLocalTransform = function(m2) {
      var innerTransformable = this.innerTransformable;
      return innerTransformable ? innerTransformable.getLocalTransform(m2) : _super.prototype.getLocalTransform.call(this, m2);
    };
    ZRText2.prototype.getComputedTransform = function() {
      if (this.__hostTarget) {
        this.__hostTarget.getComputedTransform();
        this.__hostTarget.updateInnerText(true);
      }
      return _super.prototype.getComputedTransform.call(this);
    };
    ZRText2.prototype._updateSubTexts = function() {
      this._childCursor = 0;
      normalizeTextStyle(this.style);
      this.style.rich ? this._updateRichTexts() : this._updatePlainTexts();
      this._children.length = this._childCursor;
      this.styleUpdated();
    };
    ZRText2.prototype.addSelfToZr = function(zr) {
      _super.prototype.addSelfToZr.call(this, zr);
      for (var i = 0; i < this._children.length; i++) {
        this._children[i].__zr = zr;
      }
    };
    ZRText2.prototype.removeSelfFromZr = function(zr) {
      _super.prototype.removeSelfFromZr.call(this, zr);
      for (var i = 0; i < this._children.length; i++) {
        this._children[i].__zr = null;
      }
    };
    ZRText2.prototype.getBoundingRect = function() {
      if (this.styleChanged()) {
        this._updateSubTexts();
      }
      if (!this._rect) {
        var tmpRect2 = new BoundingRect(0, 0, 0, 0);
        var children = this._children;
        var tmpMat = [];
        var rect = null;
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          var childRect = child.getBoundingRect();
          var transform = child.getLocalTransform(tmpMat);
          if (transform) {
            tmpRect2.copy(childRect);
            tmpRect2.applyTransform(transform);
            rect = rect || tmpRect2.clone();
            rect.union(tmpRect2);
          } else {
            rect = rect || childRect.clone();
            rect.union(childRect);
          }
        }
        this._rect = rect || tmpRect2;
      }
      return this._rect;
    };
    ZRText2.prototype.setDefaultTextStyle = function(defaultTextStyle) {
      this._defaultStyle = defaultTextStyle || DEFAULT_RICH_TEXT_COLOR;
    };
    ZRText2.prototype.setTextContent = function(textContent) {
      if (define_process_env_default$K.NODE_ENV !== "production") {
        throw new Error("Can't attach text on another text");
      }
    };
    ZRText2.prototype._mergeStyle = function(targetStyle, sourceStyle) {
      if (!sourceStyle) {
        return targetStyle;
      }
      var sourceRich = sourceStyle.rich;
      var targetRich = targetStyle.rich || sourceRich && {};
      extend(targetStyle, sourceStyle);
      if (sourceRich && targetRich) {
        this._mergeRich(targetRich, sourceRich);
        targetStyle.rich = targetRich;
      } else if (targetRich) {
        targetStyle.rich = targetRich;
      }
      return targetStyle;
    };
    ZRText2.prototype._mergeRich = function(targetRich, sourceRich) {
      var richNames = keys(sourceRich);
      for (var i = 0; i < richNames.length; i++) {
        var richName = richNames[i];
        targetRich[richName] = targetRich[richName] || {};
        extend(targetRich[richName], sourceRich[richName]);
      }
    };
    ZRText2.prototype.getAnimationStyleProps = function() {
      return DEFAULT_TEXT_ANIMATION_PROPS;
    };
    ZRText2.prototype._getOrCreateChild = function(Ctor) {
      var child = this._children[this._childCursor];
      if (!child || !(child instanceof Ctor)) {
        child = new Ctor();
      }
      this._children[this._childCursor++] = child;
      child.__zr = this.__zr;
      child.parent = this;
      return child;
    };
    ZRText2.prototype._updatePlainTexts = function() {
      var style = this.style;
      var textFont = style.font || DEFAULT_FONT;
      var textPadding = style.padding;
      var defaultStyle = this._defaultStyle;
      var baseX = style.x || 0;
      var baseY = style.y || 0;
      var textAlign = style.align || defaultStyle.align || "left";
      var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign || "top";
      calcInnerTextOverflowArea(tmpCITOverflowAreaOut, defaultStyle.overflowRect, baseX, baseY, textAlign, verticalAlign);
      baseX = tmpCITOverflowAreaOut.baseX;
      baseY = tmpCITOverflowAreaOut.baseY;
      var text = getStyleText(style);
      var contentBlock = parsePlainText(text, style, tmpCITOverflowAreaOut.outerWidth, tmpCITOverflowAreaOut.outerHeight);
      var needDrawBg = needDrawBackground(style);
      var bgColorDrawn = !!style.backgroundColor;
      var outerHeight = contentBlock.outerHeight;
      var outerWidth = contentBlock.outerWidth;
      var textLines = contentBlock.lines;
      var lineHeight = contentBlock.lineHeight;
      this.isTruncated = !!contentBlock.isTruncated;
      var textX = baseX;
      var textY = adjustTextY(baseY, contentBlock.contentHeight, verticalAlign);
      if (needDrawBg || textPadding) {
        var boxX = adjustTextX(baseX, outerWidth, textAlign);
        var boxY = adjustTextY(baseY, outerHeight, verticalAlign);
        needDrawBg && this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
      }
      textY += lineHeight / 2;
      if (textPadding) {
        textX = getTextXForPadding(baseX, textAlign, textPadding);
        if (verticalAlign === "top") {
          textY += textPadding[0];
        } else if (verticalAlign === "bottom") {
          textY -= textPadding[2];
        }
      }
      var defaultLineWidth = 0;
      var usingDefaultStroke = false;
      var useDefaultFill = false;
      var textFill = getFill("fill" in style ? style.fill : (useDefaultFill = true, defaultStyle.fill));
      var textStroke = getStroke("stroke" in style ? style.stroke : !bgColorDrawn && (!defaultStyle.autoStroke || useDefaultFill) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, usingDefaultStroke = true, defaultStyle.stroke) : null);
      var hasShadow = style.textShadowBlur > 0;
      for (var i = 0; i < textLines.length; i++) {
        var el = this._getOrCreateChild(TSpan);
        var subElStyle = el.createStyle();
        el.useStyle(subElStyle);
        subElStyle.text = textLines[i];
        subElStyle.x = textX;
        subElStyle.y = textY;
        {
          subElStyle.textAlign = textAlign;
        }
        subElStyle.textBaseline = "middle";
        subElStyle.opacity = style.opacity;
        subElStyle.strokeFirst = true;
        if (hasShadow) {
          subElStyle.shadowBlur = style.textShadowBlur || 0;
          subElStyle.shadowColor = style.textShadowColor || "transparent";
          subElStyle.shadowOffsetX = style.textShadowOffsetX || 0;
          subElStyle.shadowOffsetY = style.textShadowOffsetY || 0;
        }
        subElStyle.stroke = textStroke;
        subElStyle.fill = textFill;
        if (textStroke) {
          subElStyle.lineWidth = style.lineWidth || defaultLineWidth;
          subElStyle.lineDash = style.lineDash;
          subElStyle.lineDashOffset = style.lineDashOffset || 0;
        }
        subElStyle.font = textFont;
        setSeparateFont(subElStyle, style);
        textY += lineHeight;
        el.setBoundingRect(tSpanCreateBoundingRect2(subElStyle, contentBlock.contentWidth, contentBlock.calculatedLineHeight, usingDefaultStroke ? 0 : null));
      }
    };
    ZRText2.prototype._updateRichTexts = function() {
      var style = this.style;
      var defaultStyle = this._defaultStyle;
      var textAlign = style.align || defaultStyle.align;
      var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign;
      var baseX = style.x || 0;
      var baseY = style.y || 0;
      calcInnerTextOverflowArea(tmpCITOverflowAreaOut, defaultStyle.overflowRect, baseX, baseY, textAlign, verticalAlign);
      baseX = tmpCITOverflowAreaOut.baseX;
      baseY = tmpCITOverflowAreaOut.baseY;
      var text = getStyleText(style);
      var contentBlock = parseRichText(text, style, tmpCITOverflowAreaOut.outerWidth, tmpCITOverflowAreaOut.outerHeight, textAlign);
      var contentWidth = contentBlock.width;
      var outerWidth = contentBlock.outerWidth;
      var outerHeight = contentBlock.outerHeight;
      var textPadding = style.padding;
      this.isTruncated = !!contentBlock.isTruncated;
      var boxX = adjustTextX(baseX, outerWidth, textAlign);
      var boxY = adjustTextY(baseY, outerHeight, verticalAlign);
      var xLeft = boxX;
      var lineTop = boxY;
      if (textPadding) {
        xLeft += textPadding[3];
        lineTop += textPadding[0];
      }
      var xRight = xLeft + contentWidth;
      if (needDrawBackground(style)) {
        this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
      }
      var bgColorDrawn = !!style.backgroundColor;
      for (var i = 0; i < contentBlock.lines.length; i++) {
        var line = contentBlock.lines[i];
        var tokens2 = line.tokens;
        var tokenCount = tokens2.length;
        var lineHeight = line.lineHeight;
        var remainedWidth = line.width;
        var leftIndex = 0;
        var lineXLeft = xLeft;
        var lineXRight = xRight;
        var rightIndex = tokenCount - 1;
        var token = void 0;
        while (leftIndex < tokenCount && (token = tokens2[leftIndex], !token.align || token.align === "left")) {
          this._placeToken(token, style, lineHeight, lineTop, lineXLeft, "left", bgColorDrawn);
          remainedWidth -= token.width;
          lineXLeft += token.width;
          leftIndex++;
        }
        while (rightIndex >= 0 && (token = tokens2[rightIndex], token.align === "right")) {
          this._placeToken(token, style, lineHeight, lineTop, lineXRight, "right", bgColorDrawn);
          remainedWidth -= token.width;
          lineXRight -= token.width;
          rightIndex--;
        }
        lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - remainedWidth) / 2;
        while (leftIndex <= rightIndex) {
          token = tokens2[leftIndex];
          this._placeToken(token, style, lineHeight, lineTop, lineXLeft + token.width / 2, "center", bgColorDrawn);
          lineXLeft += token.width;
          leftIndex++;
        }
        lineTop += lineHeight;
      }
    };
    ZRText2.prototype._placeToken = function(token, style, lineHeight, lineTop, x, textAlign, parentBgColorDrawn) {
      var tokenStyle = style.rich[token.styleName] || {};
      tokenStyle.text = token.text;
      var verticalAlign = token.verticalAlign;
      var y = lineTop + lineHeight / 2;
      if (verticalAlign === "top") {
        y = lineTop + token.height / 2;
      } else if (verticalAlign === "bottom") {
        y = lineTop + lineHeight - token.height / 2;
      }
      var needDrawBg = !token.isLineHolder && needDrawBackground(tokenStyle);
      needDrawBg && this._renderBackground(tokenStyle, style, textAlign === "right" ? x - token.width : textAlign === "center" ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);
      var bgColorDrawn = !!tokenStyle.backgroundColor;
      var textPadding = token.textPadding;
      if (textPadding) {
        x = getTextXForPadding(x, textAlign, textPadding);
        y -= token.height / 2 - textPadding[0] - token.innerHeight / 2;
      }
      var el = this._getOrCreateChild(TSpan);
      var subElStyle = el.createStyle();
      el.useStyle(subElStyle);
      var defaultStyle = this._defaultStyle;
      var useDefaultFill = false;
      var defaultLineWidth = 0;
      var usingDefaultStroke = false;
      var textFill = getFill("fill" in tokenStyle ? tokenStyle.fill : "fill" in style ? style.fill : (useDefaultFill = true, defaultStyle.fill));
      var textStroke = getStroke("stroke" in tokenStyle ? tokenStyle.stroke : "stroke" in style ? style.stroke : !bgColorDrawn && !parentBgColorDrawn && (!defaultStyle.autoStroke || useDefaultFill) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, usingDefaultStroke = true, defaultStyle.stroke) : null);
      var hasShadow = tokenStyle.textShadowBlur > 0 || style.textShadowBlur > 0;
      subElStyle.text = token.text;
      subElStyle.x = x;
      subElStyle.y = y;
      if (hasShadow) {
        subElStyle.shadowBlur = tokenStyle.textShadowBlur || style.textShadowBlur || 0;
        subElStyle.shadowColor = tokenStyle.textShadowColor || style.textShadowColor || "transparent";
        subElStyle.shadowOffsetX = tokenStyle.textShadowOffsetX || style.textShadowOffsetX || 0;
        subElStyle.shadowOffsetY = tokenStyle.textShadowOffsetY || style.textShadowOffsetY || 0;
      }
      subElStyle.textAlign = textAlign;
      subElStyle.textBaseline = "middle";
      subElStyle.font = token.font || DEFAULT_FONT;
      subElStyle.opacity = retrieve3(tokenStyle.opacity, style.opacity, 1);
      setSeparateFont(subElStyle, tokenStyle);
      if (textStroke) {
        subElStyle.lineWidth = retrieve3(tokenStyle.lineWidth, style.lineWidth, defaultLineWidth);
        subElStyle.lineDash = retrieve2(tokenStyle.lineDash, style.lineDash);
        subElStyle.lineDashOffset = style.lineDashOffset || 0;
        subElStyle.stroke = textStroke;
      }
      if (textFill) {
        subElStyle.fill = textFill;
      }
      el.setBoundingRect(tSpanCreateBoundingRect2(subElStyle, token.contentWidth, token.contentHeight, usingDefaultStroke ? 0 : null));
    };
    ZRText2.prototype._renderBackground = function(style, topStyle, x, y, width, height) {
      var textBackgroundColor = style.backgroundColor;
      var textBorderWidth = style.borderWidth;
      var textBorderColor = style.borderColor;
      var isImageBg = textBackgroundColor && textBackgroundColor.image;
      var isPlainOrGradientBg = textBackgroundColor && !isImageBg;
      var textBorderRadius = style.borderRadius;
      var self2 = this;
      var rectEl;
      var imgEl;
      if (isPlainOrGradientBg || style.lineHeight || textBorderWidth && textBorderColor) {
        rectEl = this._getOrCreateChild(Rect$1);
        rectEl.useStyle(rectEl.createStyle());
        rectEl.style.fill = null;
        var rectShape = rectEl.shape;
        rectShape.x = x;
        rectShape.y = y;
        rectShape.width = width;
        rectShape.height = height;
        rectShape.r = textBorderRadius;
        rectEl.dirtyShape();
      }
      if (isPlainOrGradientBg) {
        var rectStyle = rectEl.style;
        rectStyle.fill = textBackgroundColor || null;
        rectStyle.fillOpacity = retrieve2(style.fillOpacity, 1);
      } else if (isImageBg) {
        imgEl = this._getOrCreateChild(ZRImage);
        imgEl.onload = function() {
          self2.dirtyStyle();
        };
        var imgStyle = imgEl.style;
        imgStyle.image = textBackgroundColor.image;
        imgStyle.x = x;
        imgStyle.y = y;
        imgStyle.width = width;
        imgStyle.height = height;
      }
      if (textBorderWidth && textBorderColor) {
        var rectStyle = rectEl.style;
        rectStyle.lineWidth = textBorderWidth;
        rectStyle.stroke = textBorderColor;
        rectStyle.strokeOpacity = retrieve2(style.strokeOpacity, 1);
        rectStyle.lineDash = style.borderDash;
        rectStyle.lineDashOffset = style.borderDashOffset || 0;
        rectEl.strokeContainThreshold = 0;
        if (rectEl.hasFill() && rectEl.hasStroke()) {
          rectStyle.strokeFirst = true;
          rectStyle.lineWidth *= 2;
        }
      }
      var commonStyle = (rectEl || imgEl).style;
      commonStyle.shadowBlur = style.shadowBlur || 0;
      commonStyle.shadowColor = style.shadowColor || "transparent";
      commonStyle.shadowOffsetX = style.shadowOffsetX || 0;
      commonStyle.shadowOffsetY = style.shadowOffsetY || 0;
      commonStyle.opacity = retrieve3(style.opacity, topStyle.opacity, 1);
    };
    ZRText2.makeFont = function(style) {
      var font = "";
      if (hasSeparateFont(style)) {
        font = [
          style.fontStyle,
          style.fontWeight,
          parseFontSize(style.fontSize),
          style.fontFamily || "sans-serif"
        ].join(" ");
      }
      return font && trim(font) || style.textFont || style.font;
    };
    return ZRText2;
  }(Displayable);
  var VALID_TEXT_ALIGN = { left: true, right: 1, center: 1 };
  var VALID_TEXT_VERTICAL_ALIGN = { top: 1, bottom: 1, middle: 1 };
  var FONT_PARTS = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
  function parseFontSize(fontSize) {
    if (typeof fontSize === "string" && (fontSize.indexOf("px") !== -1 || fontSize.indexOf("rem") !== -1 || fontSize.indexOf("em") !== -1)) {
      return fontSize;
    } else if (!isNaN(+fontSize)) {
      return fontSize + "px";
    } else {
      return DEFAULT_FONT_SIZE + "px";
    }
  }
  function setSeparateFont(targetStyle, sourceStyle) {
    for (var i = 0; i < FONT_PARTS.length; i++) {
      var fontProp = FONT_PARTS[i];
      var val = sourceStyle[fontProp];
      if (val != null) {
        targetStyle[fontProp] = val;
      }
    }
  }
  function hasSeparateFont(style) {
    return style.fontSize != null || style.fontFamily || style.fontWeight;
  }
  function normalizeTextStyle(style) {
    normalizeStyle(style);
    each$5(style.rich, normalizeStyle);
    return style;
  }
  function normalizeStyle(style) {
    if (style) {
      style.font = ZRText.makeFont(style);
      var textAlign = style.align;
      textAlign === "middle" && (textAlign = "center");
      style.align = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : "left";
      var verticalAlign = style.verticalAlign;
      verticalAlign === "center" && (verticalAlign = "middle");
      style.verticalAlign = verticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[verticalAlign] ? verticalAlign : "top";
      var textPadding = style.padding;
      if (textPadding) {
        style.padding = normalizeCssArray$1(style.padding);
      }
    }
  }
  function getStroke(stroke, lineWidth) {
    return stroke == null || lineWidth <= 0 || stroke === "transparent" || stroke === "none" ? null : stroke.image || stroke.colorStops ? "#000" : stroke;
  }
  function getFill(fill) {
    return fill == null || fill === "none" ? null : fill.image || fill.colorStops ? "#000" : fill;
  }
  function getTextXForPadding(x, textAlign, textPadding) {
    return textAlign === "right" ? x - textPadding[1] : textAlign === "center" ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
  }
  function getStyleText(style) {
    var text = style.text;
    text != null && (text += "");
    return text;
  }
  function needDrawBackground(style) {
    return !!(style.backgroundColor || style.lineHeight || style.borderWidth && style.borderColor);
  }
  var getECData = makeInner();
  var setCommonECData = function(seriesIndex, dataType, dataIdx, el) {
    if (el) {
      var ecData = getECData(el);
      ecData.dataIndex = dataIdx;
      ecData.dataType = dataType;
      ecData.seriesIndex = seriesIndex;
      ecData.ssrType = "chart";
      if (el.type === "group") {
        el.traverse(function(child) {
          var childECData = getECData(child);
          childECData.seriesIndex = seriesIndex;
          childECData.dataIndex = dataIdx;
          childECData.dataType = dataType;
          childECData.ssrType = "chart";
        });
      }
    }
  };
  var define_process_env_default$J = {};
  var _highlightNextDigit = 1;
  var _highlightKeyMap = {};
  var getSavedStates = makeInner();
  var getComponentStates = makeInner();
  var HOVER_STATE_NORMAL = 0;
  var HOVER_STATE_BLUR = 1;
  var HOVER_STATE_EMPHASIS = 2;
  var SPECIAL_STATES = ["emphasis", "blur", "select"];
  var DISPLAY_STATES = ["normal", "emphasis", "blur", "select"];
  var Z2_EMPHASIS_LIFT = 10;
  var Z2_SELECT_LIFT = 9;
  var HIGHLIGHT_ACTION_TYPE = "highlight";
  var DOWNPLAY_ACTION_TYPE = "downplay";
  var SELECT_ACTION_TYPE = "select";
  var UNSELECT_ACTION_TYPE = "unselect";
  var TOGGLE_SELECT_ACTION_TYPE = "toggleSelect";
  var SELECT_CHANGED_EVENT_TYPE = "selectchanged";
  function hasFillOrStroke(fillOrStroke) {
    return fillOrStroke != null && fillOrStroke !== "none";
  }
  function doChangeHoverState(el, stateName, hoverStateEnum) {
    if (el.onHoverStateChange && (el.hoverState || 0) !== hoverStateEnum) {
      el.onHoverStateChange(stateName);
    }
    el.hoverState = hoverStateEnum;
  }
  function singleEnterEmphasis(el) {
    doChangeHoverState(el, "emphasis", HOVER_STATE_EMPHASIS);
  }
  function singleLeaveEmphasis(el) {
    if (el.hoverState === HOVER_STATE_EMPHASIS) {
      doChangeHoverState(el, "normal", HOVER_STATE_NORMAL);
    }
  }
  function singleEnterBlur(el) {
    doChangeHoverState(el, "blur", HOVER_STATE_BLUR);
  }
  function singleLeaveBlur(el) {
    if (el.hoverState === HOVER_STATE_BLUR) {
      doChangeHoverState(el, "normal", HOVER_STATE_NORMAL);
    }
  }
  function singleEnterSelect(el) {
    el.selected = true;
  }
  function singleLeaveSelect(el) {
    el.selected = false;
  }
  function updateElementState(el, updater, commonParam) {
    updater(el, commonParam);
  }
  function traverseUpdateState(el, updater, commonParam) {
    updateElementState(el, updater, commonParam);
    el.isGroup && el.traverse(function(child) {
      updateElementState(child, updater, commonParam);
    });
  }
  function setStatesFlag(el, stateName) {
    switch (stateName) {
      case "emphasis":
        el.hoverState = HOVER_STATE_EMPHASIS;
        break;
      case "normal":
        el.hoverState = HOVER_STATE_NORMAL;
        break;
      case "blur":
        el.hoverState = HOVER_STATE_BLUR;
        break;
      case "select":
        el.selected = true;
    }
  }
  function getFromStateStyle(el, props, toStateName, defaultValue) {
    var style = el.style;
    var fromState = {};
    for (var i = 0; i < props.length; i++) {
      var propName = props[i];
      var val = style[propName];
      fromState[propName] = val == null ? defaultValue && defaultValue[propName] : val;
    }
    for (var i = 0; i < el.animators.length; i++) {
      var animator = el.animators[i];
      if (animator.__fromStateTransition && animator.__fromStateTransition.indexOf(toStateName) < 0 && animator.targetName === "style") {
        animator.saveTo(fromState, props);
      }
    }
    return fromState;
  }
  function createEmphasisDefaultState(el, stateName, targetStates, state) {
    var hasSelect = targetStates && indexOf(targetStates, "select") >= 0;
    var cloned = false;
    if (el instanceof Path) {
      var store = getSavedStates(el);
      var fromFill = hasSelect ? store.selectFill || store.normalFill : store.normalFill;
      var fromStroke = hasSelect ? store.selectStroke || store.normalStroke : store.normalStroke;
      if (hasFillOrStroke(fromFill) || hasFillOrStroke(fromStroke)) {
        state = state || {};
        var emphasisStyle = state.style || {};
        if (emphasisStyle.fill === "inherit") {
          cloned = true;
          state = extend({}, state);
          emphasisStyle = extend({}, emphasisStyle);
          emphasisStyle.fill = fromFill;
        } else if (!hasFillOrStroke(emphasisStyle.fill) && hasFillOrStroke(fromFill)) {
          cloned = true;
          state = extend({}, state);
          emphasisStyle = extend({}, emphasisStyle);
          emphasisStyle.fill = liftColor(fromFill);
        } else if (!hasFillOrStroke(emphasisStyle.stroke) && hasFillOrStroke(fromStroke)) {
          if (!cloned) {
            state = extend({}, state);
            emphasisStyle = extend({}, emphasisStyle);
          }
          emphasisStyle.stroke = liftColor(fromStroke);
        }
        state.style = emphasisStyle;
      }
    }
    if (state) {
      if (state.z2 == null) {
        if (!cloned) {
          state = extend({}, state);
        }
        var z2EmphasisLift = el.z2EmphasisLift;
        state.z2 = el.z2 + (z2EmphasisLift != null ? z2EmphasisLift : Z2_EMPHASIS_LIFT);
      }
    }
    return state;
  }
  function createSelectDefaultState(el, stateName, state) {
    if (state) {
      if (state.z2 == null) {
        state = extend({}, state);
        var z2SelectLift = el.z2SelectLift;
        state.z2 = el.z2 + (z2SelectLift != null ? z2SelectLift : Z2_SELECT_LIFT);
      }
    }
    return state;
  }
  function createBlurDefaultState(el, stateName, state) {
    var hasBlur = indexOf(el.currentStates, stateName) >= 0;
    var currentOpacity = el.style.opacity;
    var fromState = !hasBlur ? getFromStateStyle(el, ["opacity"], stateName, {
      opacity: 1
    }) : null;
    state = state || {};
    var blurStyle = state.style || {};
    if (blurStyle.opacity == null) {
      state = extend({}, state);
      blurStyle = extend({
        // Already being applied 'emphasis'. DON'T mul opacity multiple times.
        opacity: hasBlur ? currentOpacity : fromState.opacity * 0.1
      }, blurStyle);
      state.style = blurStyle;
    }
    return state;
  }
  function elementStateProxy(stateName, targetStates) {
    var state = this.states[stateName];
    if (this.style) {
      if (stateName === "emphasis") {
        return createEmphasisDefaultState(this, stateName, targetStates, state);
      } else if (stateName === "blur") {
        return createBlurDefaultState(this, stateName, state);
      } else if (stateName === "select") {
        return createSelectDefaultState(this, stateName, state);
      }
    }
    return state;
  }
  function setDefaultStateProxy(el) {
    el.stateProxy = elementStateProxy;
    var textContent = el.getTextContent();
    var textGuide = el.getTextGuideLine();
    if (textContent) {
      textContent.stateProxy = elementStateProxy;
    }
    if (textGuide) {
      textGuide.stateProxy = elementStateProxy;
    }
  }
  function enterEmphasisWhenMouseOver(el, e2) {
    !shouldSilent(el, e2) && !el.__highByOuter && traverseUpdateState(el, singleEnterEmphasis);
  }
  function leaveEmphasisWhenMouseOut(el, e2) {
    !shouldSilent(el, e2) && !el.__highByOuter && traverseUpdateState(el, singleLeaveEmphasis);
  }
  function enterEmphasis(el, highlightDigit) {
    el.__highByOuter |= 1 << (highlightDigit || 0);
    traverseUpdateState(el, singleEnterEmphasis);
  }
  function leaveEmphasis(el, highlightDigit) {
    !(el.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdateState(el, singleLeaveEmphasis);
  }
  function enterBlur(el) {
    traverseUpdateState(el, singleEnterBlur);
  }
  function leaveBlur(el) {
    traverseUpdateState(el, singleLeaveBlur);
  }
  function enterSelect(el) {
    traverseUpdateState(el, singleEnterSelect);
  }
  function leaveSelect(el) {
    traverseUpdateState(el, singleLeaveSelect);
  }
  function shouldSilent(el, e2) {
    return el.__highDownSilentOnTouch && e2.zrByTouch;
  }
  function allLeaveBlur(api) {
    var model = api.getModel();
    var leaveBlurredSeries = [];
    var allComponentViews = [];
    model.eachComponent(function(componentType, componentModel) {
      var componentStates = getComponentStates(componentModel);
      var isSeries2 = componentType === "series";
      var view = isSeries2 ? api.getViewOfSeriesModel(componentModel) : api.getViewOfComponentModel(componentModel);
      !isSeries2 && allComponentViews.push(view);
      if (componentStates.isBlured) {
        view.group.traverse(function(child) {
          singleLeaveBlur(child);
        });
        isSeries2 && leaveBlurredSeries.push(componentModel);
      }
      componentStates.isBlured = false;
    });
    each$5(allComponentViews, function(view) {
      if (view && view.toggleBlurSeries) {
        view.toggleBlurSeries(leaveBlurredSeries, false, model);
      }
    });
  }
  function blurSeries(targetSeriesIndex, focus, blurScope, api) {
    var ecModel = api.getModel();
    blurScope = blurScope || "coordinateSystem";
    function leaveBlurOfIndices(data, dataIndices) {
      for (var i = 0; i < dataIndices.length; i++) {
        var itemEl = data.getItemGraphicEl(dataIndices[i]);
        itemEl && leaveBlur(itemEl);
      }
    }
    if (targetSeriesIndex == null) {
      return;
    }
    if (!focus || focus === "none") {
      return;
    }
    var targetSeriesModel = ecModel.getSeriesByIndex(targetSeriesIndex);
    var targetCoordSys = targetSeriesModel.coordinateSystem;
    if (targetCoordSys && targetCoordSys.master) {
      targetCoordSys = targetCoordSys.master;
    }
    var blurredSeries = [];
    ecModel.eachSeries(function(seriesModel) {
      var sameSeries = targetSeriesModel === seriesModel;
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys && coordSys.master) {
        coordSys = coordSys.master;
      }
      var sameCoordSys = coordSys && targetCoordSys ? coordSys === targetCoordSys : sameSeries;
      if (!// Not blur other series if blurScope series
      (blurScope === "series" && !sameSeries || blurScope === "coordinateSystem" && !sameCoordSys || focus === "series" && sameSeries)) {
        var view = api.getViewOfSeriesModel(seriesModel);
        view.group.traverse(function(child) {
          if (child.__highByOuter && sameSeries && focus === "self") {
            return;
          }
          singleEnterBlur(child);
        });
        if (isArrayLike(focus)) {
          leaveBlurOfIndices(seriesModel.getData(), focus);
        } else if (isObject$2(focus)) {
          var dataTypes = keys(focus);
          for (var d = 0; d < dataTypes.length; d++) {
            leaveBlurOfIndices(seriesModel.getData(dataTypes[d]), focus[dataTypes[d]]);
          }
        }
        blurredSeries.push(seriesModel);
        getComponentStates(seriesModel).isBlured = true;
      }
    });
    ecModel.eachComponent(function(componentType, componentModel) {
      if (componentType === "series") {
        return;
      }
      var view = api.getViewOfComponentModel(componentModel);
      if (view && view.toggleBlurSeries) {
        view.toggleBlurSeries(blurredSeries, true, ecModel);
      }
    });
  }
  function blurComponent(componentMainType, componentIndex, api) {
    if (componentMainType == null || componentIndex == null) {
      return;
    }
    var componentModel = api.getModel().getComponent(componentMainType, componentIndex);
    if (!componentModel) {
      return;
    }
    getComponentStates(componentModel).isBlured = true;
    var view = api.getViewOfComponentModel(componentModel);
    if (!view || !view.focusBlurEnabled) {
      return;
    }
    view.group.traverse(function(child) {
      singleEnterBlur(child);
    });
  }
  function blurSeriesFromHighlightPayload(seriesModel, payload, api) {
    var seriesIndex = seriesModel.seriesIndex;
    var data = seriesModel.getData(payload.dataType);
    if (!data) {
      if (define_process_env_default$J.NODE_ENV !== "production") {
        error("Unknown dataType " + payload.dataType);
      }
      return;
    }
    var dataIndex = queryDataIndex(data, payload);
    dataIndex = (isArray(dataIndex) ? dataIndex[0] : dataIndex) || 0;
    var el = data.getItemGraphicEl(dataIndex);
    if (!el) {
      var count = data.count();
      var current = 0;
      while (!el && current < count) {
        el = data.getItemGraphicEl(current++);
      }
    }
    if (el) {
      var ecData = getECData(el);
      blurSeries(seriesIndex, ecData.focus, ecData.blurScope, api);
    } else {
      var focus_1 = seriesModel.get(["emphasis", "focus"]);
      var blurScope = seriesModel.get(["emphasis", "blurScope"]);
      if (focus_1 != null) {
        blurSeries(seriesIndex, focus_1, blurScope, api);
      }
    }
  }
  function findComponentHighDownDispatchers(componentMainType, componentIndex, name, api) {
    var ret = {
      focusSelf: false,
      dispatchers: null
    };
    if (componentMainType == null || componentMainType === "series" || componentIndex == null || name == null) {
      return ret;
    }
    var componentModel = api.getModel().getComponent(componentMainType, componentIndex);
    if (!componentModel) {
      return ret;
    }
    var view = api.getViewOfComponentModel(componentModel);
    if (!view || !view.findHighDownDispatchers) {
      return ret;
    }
    var dispatchers = view.findHighDownDispatchers(name);
    var focusSelf;
    for (var i = 0; i < dispatchers.length; i++) {
      if (define_process_env_default$J.NODE_ENV !== "production" && !isHighDownDispatcher(dispatchers[i])) {
        error("param should be highDownDispatcher");
      }
      if (getECData(dispatchers[i]).focus === "self") {
        focusSelf = true;
        break;
      }
    }
    return {
      focusSelf,
      dispatchers
    };
  }
  function handleGlobalMouseOverForHighDown(dispatcher, e2, api) {
    if (define_process_env_default$J.NODE_ENV !== "production" && !isHighDownDispatcher(dispatcher)) {
      error("param should be highDownDispatcher");
    }
    var ecData = getECData(dispatcher);
    var _a2 = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api), dispatchers = _a2.dispatchers, focusSelf = _a2.focusSelf;
    if (dispatchers) {
      if (focusSelf) {
        blurComponent(ecData.componentMainType, ecData.componentIndex, api);
      }
      each$5(dispatchers, function(dispatcher2) {
        return enterEmphasisWhenMouseOver(dispatcher2, e2);
      });
    } else {
      blurSeries(ecData.seriesIndex, ecData.focus, ecData.blurScope, api);
      if (ecData.focus === "self") {
        blurComponent(ecData.componentMainType, ecData.componentIndex, api);
      }
      enterEmphasisWhenMouseOver(dispatcher, e2);
    }
  }
  function handleGlobalMouseOutForHighDown(dispatcher, e2, api) {
    if (define_process_env_default$J.NODE_ENV !== "production" && !isHighDownDispatcher(dispatcher)) {
      error("param should be highDownDispatcher");
    }
    allLeaveBlur(api);
    var ecData = getECData(dispatcher);
    var dispatchers = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api).dispatchers;
    if (dispatchers) {
      each$5(dispatchers, function(dispatcher2) {
        return leaveEmphasisWhenMouseOut(dispatcher2, e2);
      });
    } else {
      leaveEmphasisWhenMouseOut(dispatcher, e2);
    }
  }
  function toggleSelectionFromPayload(seriesModel, payload, api) {
    if (!isSelectChangePayload(payload)) {
      return;
    }
    var dataType = payload.dataType;
    var data = seriesModel.getData(dataType);
    var dataIndex = queryDataIndex(data, payload);
    if (!isArray(dataIndex)) {
      dataIndex = [dataIndex];
    }
    seriesModel[payload.type === TOGGLE_SELECT_ACTION_TYPE ? "toggleSelect" : payload.type === SELECT_ACTION_TYPE ? "select" : "unselect"](dataIndex, dataType);
  }
  function updateSeriesElementSelection(seriesModel) {
    var allData = seriesModel.getAllData();
    each$5(allData, function(_a2) {
      var data = _a2.data, type = _a2.type;
      data.eachItemGraphicEl(function(el, idx) {
        seriesModel.isSelected(idx, type) ? enterSelect(el) : leaveSelect(el);
      });
    });
  }
  function getAllSelectedIndices(ecModel) {
    var ret = [];
    ecModel.eachSeries(function(seriesModel) {
      var allData = seriesModel.getAllData();
      each$5(allData, function(_a2) {
        _a2.data;
        var type = _a2.type;
        var dataIndices = seriesModel.getSelectedDataIndices();
        if (dataIndices.length > 0) {
          var item = {
            dataIndex: dataIndices,
            seriesIndex: seriesModel.seriesIndex
          };
          if (type != null) {
            item.dataType = type;
          }
          ret.push(item);
        }
      });
    });
    return ret;
  }
  function enableHoverEmphasis(el, focus, blurScope) {
    setAsHighDownDispatcher(el, true);
    traverseUpdateState(el, setDefaultStateProxy);
    enableHoverFocus(el, focus, blurScope);
  }
  function disableHoverEmphasis(el) {
    setAsHighDownDispatcher(el, false);
  }
  function toggleHoverEmphasis(el, focus, blurScope, isDisabled) {
    isDisabled ? disableHoverEmphasis(el) : enableHoverEmphasis(el, focus, blurScope);
  }
  function enableHoverFocus(el, focus, blurScope) {
    var ecData = getECData(el);
    if (focus != null) {
      ecData.focus = focus;
      ecData.blurScope = blurScope;
    } else if (ecData.focus) {
      ecData.focus = null;
    }
  }
  var OTHER_STATES = ["emphasis", "blur", "select"];
  var defaultStyleGetterMap = {
    itemStyle: "getItemStyle",
    lineStyle: "getLineStyle",
    areaStyle: "getAreaStyle"
  };
  function setStatesStylesFromModel(el, itemModel, styleType, getter) {
    styleType = styleType || "itemStyle";
    for (var i = 0; i < OTHER_STATES.length; i++) {
      var stateName = OTHER_STATES[i];
      var model = itemModel.getModel([stateName, styleType]);
      var state = el.ensureState(stateName);
      state.style = model[defaultStyleGetterMap[styleType]]();
    }
  }
  function setAsHighDownDispatcher(el, asDispatcher) {
    var disable = asDispatcher === false;
    var extendedEl = el;
    if (el.highDownSilentOnTouch) {
      extendedEl.__highDownSilentOnTouch = el.highDownSilentOnTouch;
    }
    if (!disable || extendedEl.__highDownDispatcher) {
      extendedEl.__highByOuter = extendedEl.__highByOuter || 0;
      extendedEl.__highDownDispatcher = !disable;
    }
  }
  function isHighDownDispatcher(el) {
    return !!(el && el.__highDownDispatcher);
  }
  function getHighlightDigit(highlightKey) {
    var highlightDigit = _highlightKeyMap[highlightKey];
    if (highlightDigit == null && _highlightNextDigit <= 32) {
      highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++;
    }
    return highlightDigit;
  }
  function isSelectChangePayload(payload) {
    var payloadType = payload.type;
    return payloadType === SELECT_ACTION_TYPE || payloadType === UNSELECT_ACTION_TYPE || payloadType === TOGGLE_SELECT_ACTION_TYPE;
  }
  function isHighDownPayload(payload) {
    var payloadType = payload.type;
    return payloadType === HIGHLIGHT_ACTION_TYPE || payloadType === DOWNPLAY_ACTION_TYPE;
  }
  function savePathStates(el) {
    var store = getSavedStates(el);
    store.normalFill = el.style.fill;
    store.normalStroke = el.style.stroke;
    var selectState = el.states.select || {};
    store.selectFill = selectState.style && selectState.style.fill || null;
    store.selectStroke = selectState.style && selectState.style.stroke || null;
  }
  var CMD = PathProxy.CMD;
  var points = [[], [], []];
  var mathSqrt$2 = Math.sqrt;
  var mathAtan2 = Math.atan2;
  function transformPath(path, m2) {
    if (!m2) {
      return;
    }
    var data = path.data;
    var len2 = path.len();
    var cmd;
    var nPoint;
    var i;
    var j;
    var k;
    var p;
    var M = CMD.M;
    var C = CMD.C;
    var L = CMD.L;
    var R = CMD.R;
    var A = CMD.A;
    var Q = CMD.Q;
    for (i = 0, j = 0; i < len2; ) {
      cmd = data[i++];
      j = i;
      nPoint = 0;
      switch (cmd) {
        case M:
          nPoint = 1;
          break;
        case L:
          nPoint = 1;
          break;
        case C:
          nPoint = 3;
          break;
        case Q:
          nPoint = 2;
          break;
        case A:
          var x = m2[4];
          var y = m2[5];
          var sx = mathSqrt$2(m2[0] * m2[0] + m2[1] * m2[1]);
          var sy = mathSqrt$2(m2[2] * m2[2] + m2[3] * m2[3]);
          var angle = mathAtan2(-m2[1] / sy, m2[0] / sx);
          data[i] *= sx;
          data[i++] += x;
          data[i] *= sy;
          data[i++] += y;
          data[i++] *= sx;
          data[i++] *= sy;
          data[i++] += angle;
          data[i++] += angle;
          i += 2;
          j = i;
          break;
        case R:
          p[0] = data[i++];
          p[1] = data[i++];
          applyTransform$1(p, p, m2);
          data[j++] = p[0];
          data[j++] = p[1];
          p[0] += data[i++];
          p[1] += data[i++];
          applyTransform$1(p, p, m2);
          data[j++] = p[0];
          data[j++] = p[1];
      }
      for (k = 0; k < nPoint; k++) {
        var p_1 = points[k];
        p_1[0] = data[i++];
        p_1[1] = data[i++];
        applyTransform$1(p_1, p_1, m2);
        data[j++] = p_1[0];
        data[j++] = p_1[1];
      }
    }
    path.increaseVersion();
  }
  var mathSqrt$1 = Math.sqrt;
  var mathSin$1 = Math.sin;
  var mathCos$1 = Math.cos;
  var PI$3 = Math.PI;
  function vMag(v) {
    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  }
  function vRatio(u, v) {
    return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
  }
  function vAngle(u, v) {
    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
  }
  function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
    var psi = psiDeg * (PI$3 / 180);
    var xp = mathCos$1(psi) * (x1 - x2) / 2 + mathSin$1(psi) * (y1 - y2) / 2;
    var yp = -1 * mathSin$1(psi) * (x1 - x2) / 2 + mathCos$1(psi) * (y1 - y2) / 2;
    var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
    if (lambda > 1) {
      rx *= mathSqrt$1(lambda);
      ry *= mathSqrt$1(lambda);
    }
    var f = (fa === fs ? -1 : 1) * mathSqrt$1((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
    var cxp = f * rx * yp / ry;
    var cyp = f * -ry * xp / rx;
    var cx = (x1 + x2) / 2 + mathCos$1(psi) * cxp - mathSin$1(psi) * cyp;
    var cy = (y1 + y2) / 2 + mathSin$1(psi) * cxp + mathCos$1(psi) * cyp;
    var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
    var u = [(xp - cxp) / rx, (yp - cyp) / ry];
    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    var dTheta = vAngle(u, v);
    if (vRatio(u, v) <= -1) {
      dTheta = PI$3;
    }
    if (vRatio(u, v) >= 1) {
      dTheta = 0;
    }
    if (dTheta < 0) {
      var n = Math.round(dTheta / PI$3 * 1e6) / 1e6;
      dTheta = PI$3 * 2 + n % 2 * PI$3;
    }
    path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
  }
  var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig;
  var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
  function createPathProxyFromString(data) {
    var path = new PathProxy();
    if (!data) {
      return path;
    }
    var cpx = 0;
    var cpy = 0;
    var subpathX = cpx;
    var subpathY = cpy;
    var prevCmd;
    var CMD2 = PathProxy.CMD;
    var cmdList = data.match(commandReg);
    if (!cmdList) {
      return path;
    }
    for (var l = 0; l < cmdList.length; l++) {
      var cmdText = cmdList[l];
      var cmdStr = cmdText.charAt(0);
      var cmd = void 0;
      var p = cmdText.match(numberReg) || [];
      var pLen = p.length;
      for (var i = 0; i < pLen; i++) {
        p[i] = parseFloat(p[i]);
      }
      var off = 0;
      while (off < pLen) {
        var ctlPtx = void 0;
        var ctlPty = void 0;
        var rx = void 0;
        var ry = void 0;
        var psi = void 0;
        var fa = void 0;
        var fs = void 0;
        var x1 = cpx;
        var y1 = cpy;
        var len2 = void 0;
        var pathData = void 0;
        switch (cmdStr) {
          case "l":
            cpx += p[off++];
            cpy += p[off++];
            cmd = CMD2.L;
            path.addData(cmd, cpx, cpy);
            break;
          case "L":
            cpx = p[off++];
            cpy = p[off++];
            cmd = CMD2.L;
            path.addData(cmd, cpx, cpy);
            break;
          case "m":
            cpx += p[off++];
            cpy += p[off++];
            cmd = CMD2.M;
            path.addData(cmd, cpx, cpy);
            subpathX = cpx;
            subpathY = cpy;
            cmdStr = "l";
            break;
          case "M":
            cpx = p[off++];
            cpy = p[off++];
            cmd = CMD2.M;
            path.addData(cmd, cpx, cpy);
            subpathX = cpx;
            subpathY = cpy;
            cmdStr = "L";
            break;
          case "h":
            cpx += p[off++];
            cmd = CMD2.L;
            path.addData(cmd, cpx, cpy);
            break;
          case "H":
            cpx = p[off++];
            cmd = CMD2.L;
            path.addData(cmd, cpx, cpy);
            break;
          case "v":
            cpy += p[off++];
            cmd = CMD2.L;
            path.addData(cmd, cpx, cpy);
            break;
          case "V":
            cpy = p[off++];
            cmd = CMD2.L;
            path.addData(cmd, cpx, cpy);
            break;
          case "C":
            cmd = CMD2.C;
            path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
            cpx = p[off - 2];
            cpy = p[off - 1];
            break;
          case "c":
            cmd = CMD2.C;
            path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
            cpx += p[off - 2];
            cpy += p[off - 1];
            break;
          case "S":
            ctlPtx = cpx;
            ctlPty = cpy;
            len2 = path.len();
            pathData = path.data;
            if (prevCmd === CMD2.C) {
              ctlPtx += cpx - pathData[len2 - 4];
              ctlPty += cpy - pathData[len2 - 3];
            }
            cmd = CMD2.C;
            x1 = p[off++];
            y1 = p[off++];
            cpx = p[off++];
            cpy = p[off++];
            path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
            break;
          case "s":
            ctlPtx = cpx;
            ctlPty = cpy;
            len2 = path.len();
            pathData = path.data;
            if (prevCmd === CMD2.C) {
              ctlPtx += cpx - pathData[len2 - 4];
              ctlPty += cpy - pathData[len2 - 3];
            }
            cmd = CMD2.C;
            x1 = cpx + p[off++];
            y1 = cpy + p[off++];
            cpx += p[off++];
            cpy += p[off++];
            path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
            break;
          case "Q":
            x1 = p[off++];
            y1 = p[off++];
            cpx = p[off++];
            cpy = p[off++];
            cmd = CMD2.Q;
            path.addData(cmd, x1, y1, cpx, cpy);
            break;
          case "q":
            x1 = p[off++] + cpx;
            y1 = p[off++] + cpy;
            cpx += p[off++];
            cpy += p[off++];
            cmd = CMD2.Q;
            path.addData(cmd, x1, y1, cpx, cpy);
            break;
          case "T":
            ctlPtx = cpx;
            ctlPty = cpy;
            len2 = path.len();
            pathData = path.data;
            if (prevCmd === CMD2.Q) {
              ctlPtx += cpx - pathData[len2 - 4];
              ctlPty += cpy - pathData[len2 - 3];
            }
            cpx = p[off++];
            cpy = p[off++];
            cmd = CMD2.Q;
            path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
            break;
          case "t":
            ctlPtx = cpx;
            ctlPty = cpy;
            len2 = path.len();
            pathData = path.data;
            if (prevCmd === CMD2.Q) {
              ctlPtx += cpx - pathData[len2 - 4];
              ctlPty += cpy - pathData[len2 - 3];
            }
            cpx += p[off++];
            cpy += p[off++];
            cmd = CMD2.Q;
            path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
            break;
          case "A":
            rx = p[off++];
            ry = p[off++];
            psi = p[off++];
            fa = p[off++];
            fs = p[off++];
            x1 = cpx, y1 = cpy;
            cpx = p[off++];
            cpy = p[off++];
            cmd = CMD2.A;
            processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
            break;
          case "a":
            rx = p[off++];
            ry = p[off++];
            psi = p[off++];
            fa = p[off++];
            fs = p[off++];
            x1 = cpx, y1 = cpy;
            cpx += p[off++];
            cpy += p[off++];
            cmd = CMD2.A;
            processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
            break;
        }
      }
      if (cmdStr === "z" || cmdStr === "Z") {
        cmd = CMD2.Z;
        path.addData(cmd);
        cpx = subpathX;
        cpy = subpathY;
      }
      prevCmd = cmd;
    }
    path.toStatic();
    return path;
  }
  var SVGPath = function(_super) {
    __extends(SVGPath2, _super);
    function SVGPath2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SVGPath2.prototype.applyTransform = function(m2) {
    };
    return SVGPath2;
  }(Path);
  function isPathProxy(path) {
    return path.setData != null;
  }
  function createPathOptions(str, opts) {
    var pathProxy = createPathProxyFromString(str);
    var innerOpts = extend({}, opts);
    innerOpts.buildPath = function(path) {
      var beProxy = isPathProxy(path);
      if (beProxy && path.canSave()) {
        path.appendPath(pathProxy);
        var ctx = path.getContext();
        if (ctx) {
          path.rebuildPath(ctx, 1);
        }
      } else {
        var ctx = beProxy ? path.getContext() : path;
        if (ctx) {
          pathProxy.rebuildPath(ctx, 1);
        }
      }
    };
    innerOpts.applyTransform = function(m2) {
      transformPath(pathProxy, m2);
      this.dirtyShape();
    };
    return innerOpts;
  }
  function createFromString(str, opts) {
    return new SVGPath(createPathOptions(str, opts));
  }
  function extendFromString(str, defaultOpts) {
    var innerOpts = createPathOptions(str, defaultOpts);
    var Sub = function(_super) {
      __extends(Sub2, _super);
      function Sub2(opts) {
        var _this = _super.call(this, opts) || this;
        _this.applyTransform = innerOpts.applyTransform;
        _this.buildPath = innerOpts.buildPath;
        return _this;
      }
      return Sub2;
    }(SVGPath);
    return Sub;
  }
  function mergePath$1(pathEls, opts) {
    var pathList = [];
    var len2 = pathEls.length;
    for (var i = 0; i < len2; i++) {
      var pathEl = pathEls[i];
      pathList.push(pathEl.getUpdatedPathProxy(true));
    }
    var pathBundle = new Path(opts);
    pathBundle.createPathProxy();
    pathBundle.buildPath = function(path) {
      if (isPathProxy(path)) {
        path.appendPath(pathList);
        var ctx = path.getContext();
        if (ctx) {
          path.rebuildPath(ctx, 1);
        }
      }
    };
    return pathBundle;
  }
  var CircleShape = /* @__PURE__ */ function() {
    function CircleShape2() {
      this.cx = 0;
      this.cy = 0;
      this.r = 0;
    }
    return CircleShape2;
  }();
  var Circle = function(_super) {
    __extends(Circle2, _super);
    function Circle2(opts) {
      return _super.call(this, opts) || this;
    }
    Circle2.prototype.getDefaultShape = function() {
      return new CircleShape();
    };
    Circle2.prototype.buildPath = function(ctx, shape) {
      ctx.moveTo(shape.cx + shape.r, shape.cy);
      ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2);
    };
    return Circle2;
  }(Path);
  Circle.prototype.type = "circle";
  var EllipseShape = /* @__PURE__ */ function() {
    function EllipseShape2() {
      this.cx = 0;
      this.cy = 0;
      this.rx = 0;
      this.ry = 0;
    }
    return EllipseShape2;
  }();
  var Ellipse = function(_super) {
    __extends(Ellipse2, _super);
    function Ellipse2(opts) {
      return _super.call(this, opts) || this;
    }
    Ellipse2.prototype.getDefaultShape = function() {
      return new EllipseShape();
    };
    Ellipse2.prototype.buildPath = function(ctx, shape) {
      var k = 0.5522848;
      var x = shape.cx;
      var y = shape.cy;
      var a = shape.rx;
      var b = shape.ry;
      var ox = a * k;
      var oy = b * k;
      ctx.moveTo(x - a, y);
      ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
      ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
      ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
      ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
      ctx.closePath();
    };
    return Ellipse2;
  }(Path);
  Ellipse.prototype.type = "ellipse";
  var PI$2 = Math.PI;
  var PI2 = PI$2 * 2;
  var mathSin = Math.sin;
  var mathCos = Math.cos;
  var mathACos = Math.acos;
  var mathATan2 = Math.atan2;
  var mathAbs$1 = Math.abs;
  var mathSqrt = Math.sqrt;
  var mathMax$2 = Math.max;
  var mathMin$2 = Math.min;
  var e = 1e-4;
  function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
    var dx10 = x1 - x0;
    var dy10 = y1 - y0;
    var dx32 = x3 - x2;
    var dy32 = y3 - y2;
    var t = dy32 * dx10 - dx32 * dy10;
    if (t * t < e) {
      return;
    }
    t = (dx32 * (y0 - y2) - dy32 * (x0 - x2)) / t;
    return [x0 + t * dx10, y0 + t * dy10];
  }
  function computeCornerTangents(x0, y0, x1, y1, radius, cr, clockwise) {
    var x01 = x0 - x1;
    var y01 = y0 - y1;
    var lo = (clockwise ? cr : -cr) / mathSqrt(x01 * x01 + y01 * y01);
    var ox = lo * y01;
    var oy = -lo * x01;
    var x11 = x0 + ox;
    var y11 = y0 + oy;
    var x10 = x1 + ox;
    var y10 = y1 + oy;
    var x00 = (x11 + x10) / 2;
    var y00 = (y11 + y10) / 2;
    var dx = x10 - x11;
    var dy = y10 - y11;
    var d2 = dx * dx + dy * dy;
    var r = radius - cr;
    var s = x11 * y10 - x10 * y11;
    var d = (dy < 0 ? -1 : 1) * mathSqrt(mathMax$2(0, r * r * d2 - s * s));
    var cx0 = (s * dy - dx * d) / d2;
    var cy0 = (-s * dx - dy * d) / d2;
    var cx1 = (s * dy + dx * d) / d2;
    var cy1 = (-s * dx + dy * d) / d2;
    var dx0 = cx0 - x00;
    var dy0 = cy0 - y00;
    var dx1 = cx1 - x00;
    var dy1 = cy1 - y00;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
      cx0 = cx1;
      cy0 = cy1;
    }
    return {
      cx: cx0,
      cy: cy0,
      x0: -ox,
      y0: -oy,
      x1: cx0 * (radius / r - 1),
      y1: cy0 * (radius / r - 1)
    };
  }
  function normalizeCornerRadius(cr) {
    var arr;
    if (isArray(cr)) {
      var len2 = cr.length;
      if (!len2) {
        return cr;
      }
      if (len2 === 1) {
        arr = [cr[0], cr[0], 0, 0];
      } else if (len2 === 2) {
        arr = [cr[0], cr[0], cr[1], cr[1]];
      } else if (len2 === 3) {
        arr = cr.concat(cr[2]);
      } else {
        arr = cr;
      }
    } else {
      arr = [cr, cr, cr, cr];
    }
    return arr;
  }
  function buildPath$1(ctx, shape) {
    var _a2;
    var radius = mathMax$2(shape.r, 0);
    var innerRadius = mathMax$2(shape.r0 || 0, 0);
    var hasRadius = radius > 0;
    var hasInnerRadius = innerRadius > 0;
    if (!hasRadius && !hasInnerRadius) {
      return;
    }
    if (!hasRadius) {
      radius = innerRadius;
      innerRadius = 0;
    }
    if (innerRadius > radius) {
      var tmp = radius;
      radius = innerRadius;
      innerRadius = tmp;
    }
    var startAngle = shape.startAngle, endAngle = shape.endAngle;
    if (isNaN(startAngle) || isNaN(endAngle)) {
      return;
    }
    var cx = shape.cx, cy = shape.cy;
    var clockwise = !!shape.clockwise;
    var arc = mathAbs$1(endAngle - startAngle);
    var mod = arc > PI2 && arc % PI2;
    mod > e && (arc = mod);
    if (!(radius > e)) {
      ctx.moveTo(cx, cy);
    } else if (arc > PI2 - e) {
      ctx.moveTo(cx + radius * mathCos(startAngle), cy + radius * mathSin(startAngle));
      ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
      if (innerRadius > e) {
        ctx.moveTo(cx + innerRadius * mathCos(endAngle), cy + innerRadius * mathSin(endAngle));
        ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
      }
    } else {
      var icrStart = void 0;
      var icrEnd = void 0;
      var ocrStart = void 0;
      var ocrEnd = void 0;
      var ocrs = void 0;
      var ocre = void 0;
      var icrs = void 0;
      var icre = void 0;
      var ocrMax = void 0;
      var icrMax = void 0;
      var limitedOcrMax = void 0;
      var limitedIcrMax = void 0;
      var xre = void 0;
      var yre = void 0;
      var xirs = void 0;
      var yirs = void 0;
      var xrs = radius * mathCos(startAngle);
      var yrs = radius * mathSin(startAngle);
      var xire = innerRadius * mathCos(endAngle);
      var yire = innerRadius * mathSin(endAngle);
      var hasArc = arc > e;
      if (hasArc) {
        var cornerRadius = shape.cornerRadius;
        if (cornerRadius) {
          _a2 = normalizeCornerRadius(cornerRadius), icrStart = _a2[0], icrEnd = _a2[1], ocrStart = _a2[2], ocrEnd = _a2[3];
        }
        var halfRd = mathAbs$1(radius - innerRadius) / 2;
        ocrs = mathMin$2(halfRd, ocrStart);
        ocre = mathMin$2(halfRd, ocrEnd);
        icrs = mathMin$2(halfRd, icrStart);
        icre = mathMin$2(halfRd, icrEnd);
        limitedOcrMax = ocrMax = mathMax$2(ocrs, ocre);
        limitedIcrMax = icrMax = mathMax$2(icrs, icre);
        if (ocrMax > e || icrMax > e) {
          xre = radius * mathCos(endAngle);
          yre = radius * mathSin(endAngle);
          xirs = innerRadius * mathCos(startAngle);
          yirs = innerRadius * mathSin(startAngle);
          if (arc < PI$2) {
            var it_1 = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire);
            if (it_1) {
              var x0 = xrs - it_1[0];
              var y0 = yrs - it_1[1];
              var x1 = xre - it_1[0];
              var y1 = yre - it_1[1];
              var a = 1 / mathSin(mathACos((x0 * x1 + y0 * y1) / (mathSqrt(x0 * x0 + y0 * y0) * mathSqrt(x1 * x1 + y1 * y1))) / 2);
              var b = mathSqrt(it_1[0] * it_1[0] + it_1[1] * it_1[1]);
              limitedOcrMax = mathMin$2(ocrMax, (radius - b) / (a + 1));
              limitedIcrMax = mathMin$2(icrMax, (innerRadius - b) / (a - 1));
            }
          }
        }
      }
      if (!hasArc) {
        ctx.moveTo(cx + xrs, cy + yrs);
      } else if (limitedOcrMax > e) {
        var crStart = mathMin$2(ocrStart, limitedOcrMax);
        var crEnd = mathMin$2(ocrEnd, limitedOcrMax);
        var ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, radius, crStart, clockwise);
        var ct1 = computeCornerTangents(xre, yre, xire, yire, radius, crEnd, clockwise);
        ctx.moveTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
        if (limitedOcrMax < ocrMax && crStart === crEnd) {
          ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedOcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
        } else {
          crStart > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crStart, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
          ctx.arc(cx, cy, radius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), !clockwise);
          crEnd > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crEnd, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
        }
      } else {
        ctx.moveTo(cx + xrs, cy + yrs);
        ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
      }
      if (!(innerRadius > e) || !hasArc) {
        ctx.lineTo(cx + xire, cy + yire);
      } else if (limitedIcrMax > e) {
        var crStart = mathMin$2(icrStart, limitedIcrMax);
        var crEnd = mathMin$2(icrEnd, limitedIcrMax);
        var ct0 = computeCornerTangents(xire, yire, xre, yre, innerRadius, -crEnd, clockwise);
        var ct1 = computeCornerTangents(xrs, yrs, xirs, yirs, innerRadius, -crStart, clockwise);
        ctx.lineTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
        if (limitedIcrMax < icrMax && crStart === crEnd) {
          ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedIcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
        } else {
          crEnd > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crEnd, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
          ctx.arc(cx, cy, innerRadius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), clockwise);
          crStart > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crStart, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
        }
      } else {
        ctx.lineTo(cx + xire, cy + yire);
        ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
      }
    }
    ctx.closePath();
  }
  var SectorShape = /* @__PURE__ */ function() {
    function SectorShape2() {
      this.cx = 0;
      this.cy = 0;
      this.r0 = 0;
      this.r = 0;
      this.startAngle = 0;
      this.endAngle = Math.PI * 2;
      this.clockwise = true;
      this.cornerRadius = 0;
    }
    return SectorShape2;
  }();
  var Sector = function(_super) {
    __extends(Sector2, _super);
    function Sector2(opts) {
      return _super.call(this, opts) || this;
    }
    Sector2.prototype.getDefaultShape = function() {
      return new SectorShape();
    };
    Sector2.prototype.buildPath = function(ctx, shape) {
      buildPath$1(ctx, shape);
    };
    Sector2.prototype.isZeroArea = function() {
      return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
    };
    return Sector2;
  }(Path);
  Sector.prototype.type = "sector";
  var RingShape = /* @__PURE__ */ function() {
    function RingShape2() {
      this.cx = 0;
      this.cy = 0;
      this.r = 0;
      this.r0 = 0;
    }
    return RingShape2;
  }();
  var Ring = function(_super) {
    __extends(Ring2, _super);
    function Ring2(opts) {
      return _super.call(this, opts) || this;
    }
    Ring2.prototype.getDefaultShape = function() {
      return new RingShape();
    };
    Ring2.prototype.buildPath = function(ctx, shape) {
      var x = shape.cx;
      var y = shape.cy;
      var PI22 = Math.PI * 2;
      ctx.moveTo(x + shape.r, y);
      ctx.arc(x, y, shape.r, 0, PI22, false);
      ctx.moveTo(x + shape.r0, y);
      ctx.arc(x, y, shape.r0, 0, PI22, true);
    };
    return Ring2;
  }(Path);
  Ring.prototype.type = "ring";
  function smoothBezier(points2, smooth, isLoop, constraint) {
    var cps = [];
    var v = [];
    var v1 = [];
    var v2 = [];
    var prevPoint;
    var nextPoint;
    var min3;
    var max3;
    if (constraint) {
      min3 = [Infinity, Infinity];
      max3 = [-Infinity, -Infinity];
      for (var i = 0, len2 = points2.length; i < len2; i++) {
        min$1(min3, min3, points2[i]);
        max$1(max3, max3, points2[i]);
      }
      min$1(min3, min3, constraint[0]);
      max$1(max3, max3, constraint[1]);
    }
    for (var i = 0, len2 = points2.length; i < len2; i++) {
      var point = points2[i];
      if (isLoop) {
        prevPoint = points2[i ? i - 1 : len2 - 1];
        nextPoint = points2[(i + 1) % len2];
      } else {
        if (i === 0 || i === len2 - 1) {
          cps.push(clone$1(points2[i]));
          continue;
        } else {
          prevPoint = points2[i - 1];
          nextPoint = points2[i + 1];
        }
      }
      sub(v, nextPoint, prevPoint);
      scale$2(v, v, smooth);
      var d0 = distance(point, prevPoint);
      var d1 = distance(point, nextPoint);
      var sum = d0 + d1;
      if (sum !== 0) {
        d0 /= sum;
        d1 /= sum;
      }
      scale$2(v1, v, -d0);
      scale$2(v2, v, d1);
      var cp0 = add([], point, v1);
      var cp1 = add([], point, v2);
      if (constraint) {
        max$1(cp0, cp0, min3);
        min$1(cp0, cp0, max3);
        max$1(cp1, cp1, min3);
        min$1(cp1, cp1, max3);
      }
      cps.push(cp0);
      cps.push(cp1);
    }
    if (isLoop) {
      cps.push(cps.shift());
    }
    return cps;
  }
  function buildPath(ctx, shape, closePath) {
    var smooth = shape.smooth;
    var points2 = shape.points;
    if (points2 && points2.length >= 2) {
      if (smooth) {
        var controlPoints = smoothBezier(points2, smooth, closePath, shape.smoothConstraint);
        ctx.moveTo(points2[0][0], points2[0][1]);
        var len2 = points2.length;
        for (var i = 0; i < (closePath ? len2 : len2 - 1); i++) {
          var cp1 = controlPoints[i * 2];
          var cp2 = controlPoints[i * 2 + 1];
          var p = points2[(i + 1) % len2];
          ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
        }
      } else {
        ctx.moveTo(points2[0][0], points2[0][1]);
        for (var i = 1, l = points2.length; i < l; i++) {
          ctx.lineTo(points2[i][0], points2[i][1]);
        }
      }
      closePath && ctx.closePath();
    }
  }
  var PolygonShape = /* @__PURE__ */ function() {
    function PolygonShape2() {
      this.points = null;
      this.smooth = 0;
      this.smoothConstraint = null;
    }
    return PolygonShape2;
  }();
  var Polygon = function(_super) {
    __extends(Polygon2, _super);
    function Polygon2(opts) {
      return _super.call(this, opts) || this;
    }
    Polygon2.prototype.getDefaultShape = function() {
      return new PolygonShape();
    };
    Polygon2.prototype.buildPath = function(ctx, shape) {
      buildPath(ctx, shape, true);
    };
    return Polygon2;
  }(Path);
  Polygon.prototype.type = "polygon";
  var PolylineShape = /* @__PURE__ */ function() {
    function PolylineShape2() {
      this.points = null;
      this.percent = 1;
      this.smooth = 0;
      this.smoothConstraint = null;
    }
    return PolylineShape2;
  }();
  var Polyline = function(_super) {
    __extends(Polyline2, _super);
    function Polyline2(opts) {
      return _super.call(this, opts) || this;
    }
    Polyline2.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    };
    Polyline2.prototype.getDefaultShape = function() {
      return new PolylineShape();
    };
    Polyline2.prototype.buildPath = function(ctx, shape) {
      buildPath(ctx, shape, false);
    };
    return Polyline2;
  }(Path);
  Polyline.prototype.type = "polyline";
  var subPixelOptimizeOutputShape = {};
  var LineShape = /* @__PURE__ */ function() {
    function LineShape2() {
      this.x1 = 0;
      this.y1 = 0;
      this.x2 = 0;
      this.y2 = 0;
      this.percent = 1;
    }
    return LineShape2;
  }();
  var Line = function(_super) {
    __extends(Line2, _super);
    function Line2(opts) {
      return _super.call(this, opts) || this;
    }
    Line2.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    };
    Line2.prototype.getDefaultShape = function() {
      return new LineShape();
    };
    Line2.prototype.buildPath = function(ctx, shape) {
      var x1;
      var y1;
      var x2;
      var y2;
      if (this.subPixelOptimize) {
        var optimizedShape = subPixelOptimizeLine$1(subPixelOptimizeOutputShape, shape, this.style);
        x1 = optimizedShape.x1;
        y1 = optimizedShape.y1;
        x2 = optimizedShape.x2;
        y2 = optimizedShape.y2;
      } else {
        x1 = shape.x1;
        y1 = shape.y1;
        x2 = shape.x2;
        y2 = shape.y2;
      }
      var percent = shape.percent;
      if (percent === 0) {
        return;
      }
      ctx.moveTo(x1, y1);
      if (percent < 1) {
        x2 = x1 * (1 - percent) + x2 * percent;
        y2 = y1 * (1 - percent) + y2 * percent;
      }
      ctx.lineTo(x2, y2);
    };
    Line2.prototype.pointAt = function(p) {
      var shape = this.shape;
      return [
        shape.x1 * (1 - p) + shape.x2 * p,
        shape.y1 * (1 - p) + shape.y2 * p
      ];
    };
    return Line2;
  }(Path);
  Line.prototype.type = "line";
  var out = [];
  var BezierCurveShape = /* @__PURE__ */ function() {
    function BezierCurveShape2() {
      this.x1 = 0;
      this.y1 = 0;
      this.x2 = 0;
      this.y2 = 0;
      this.cpx1 = 0;
      this.cpy1 = 0;
      this.percent = 1;
    }
    return BezierCurveShape2;
  }();
  function someVectorAt(shape, t, isTangent) {
    var cpx2 = shape.cpx2;
    var cpy2 = shape.cpy2;
    if (cpx2 != null || cpy2 != null) {
      return [
        (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),
        (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)
      ];
    } else {
      return [
        (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),
        (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)
      ];
    }
  }
  var BezierCurve = function(_super) {
    __extends(BezierCurve2, _super);
    function BezierCurve2(opts) {
      return _super.call(this, opts) || this;
    }
    BezierCurve2.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    };
    BezierCurve2.prototype.getDefaultShape = function() {
      return new BezierCurveShape();
    };
    BezierCurve2.prototype.buildPath = function(ctx, shape) {
      var x1 = shape.x1;
      var y1 = shape.y1;
      var x2 = shape.x2;
      var y2 = shape.y2;
      var cpx1 = shape.cpx1;
      var cpy1 = shape.cpy1;
      var cpx2 = shape.cpx2;
      var cpy2 = shape.cpy2;
      var percent = shape.percent;
      if (percent === 0) {
        return;
      }
      ctx.moveTo(x1, y1);
      if (cpx2 == null || cpy2 == null) {
        if (percent < 1) {
          quadraticSubdivide(x1, cpx1, x2, percent, out);
          cpx1 = out[1];
          x2 = out[2];
          quadraticSubdivide(y1, cpy1, y2, percent, out);
          cpy1 = out[1];
          y2 = out[2];
        }
        ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
      } else {
        if (percent < 1) {
          cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
          cpx1 = out[1];
          cpx2 = out[2];
          x2 = out[3];
          cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
          cpy1 = out[1];
          cpy2 = out[2];
          y2 = out[3];
        }
        ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
      }
    };
    BezierCurve2.prototype.pointAt = function(t) {
      return someVectorAt(this.shape, t, false);
    };
    BezierCurve2.prototype.tangentAt = function(t) {
      var p = someVectorAt(this.shape, t, true);
      return normalize$1(p, p);
    };
    return BezierCurve2;
  }(Path);
  BezierCurve.prototype.type = "bezier-curve";
  var ArcShape = /* @__PURE__ */ function() {
    function ArcShape2() {
      this.cx = 0;
      this.cy = 0;
      this.r = 0;
      this.startAngle = 0;
      this.endAngle = Math.PI * 2;
      this.clockwise = true;
    }
    return ArcShape2;
  }();
  var Arc = function(_super) {
    __extends(Arc2, _super);
    function Arc2(opts) {
      return _super.call(this, opts) || this;
    }
    Arc2.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    };
    Arc2.prototype.getDefaultShape = function() {
      return new ArcShape();
    };
    Arc2.prototype.buildPath = function(ctx, shape) {
      var x = shape.cx;
      var y = shape.cy;
      var r = Math.max(shape.r, 0);
      var startAngle = shape.startAngle;
      var endAngle = shape.endAngle;
      var clockwise = shape.clockwise;
      var unitX = Math.cos(startAngle);
      var unitY = Math.sin(startAngle);
      ctx.moveTo(unitX * r + x, unitY * r + y);
      ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
    };
    return Arc2;
  }(Path);
  Arc.prototype.type = "arc";
  var CompoundPath = function(_super) {
    __extends(CompoundPath2, _super);
    function CompoundPath2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "compound";
      return _this;
    }
    CompoundPath2.prototype._updatePathDirty = function() {
      var paths = this.shape.paths;
      var dirtyPath = this.shapeChanged();
      for (var i = 0; i < paths.length; i++) {
        dirtyPath = dirtyPath || paths[i].shapeChanged();
      }
      if (dirtyPath) {
        this.dirtyShape();
      }
    };
    CompoundPath2.prototype.beforeBrush = function() {
      this._updatePathDirty();
      var paths = this.shape.paths || [];
      var scale2 = this.getGlobalScale();
      for (var i = 0; i < paths.length; i++) {
        if (!paths[i].path) {
          paths[i].createPathProxy();
        }
        paths[i].path.setScale(scale2[0], scale2[1], paths[i].segmentIgnoreThreshold);
      }
    };
    CompoundPath2.prototype.buildPath = function(ctx, shape) {
      var paths = shape.paths || [];
      for (var i = 0; i < paths.length; i++) {
        paths[i].buildPath(ctx, paths[i].shape, true);
      }
    };
    CompoundPath2.prototype.afterBrush = function() {
      var paths = this.shape.paths || [];
      for (var i = 0; i < paths.length; i++) {
        paths[i].pathUpdated();
      }
    };
    CompoundPath2.prototype.getBoundingRect = function() {
      this._updatePathDirty.call(this);
      return Path.prototype.getBoundingRect.call(this);
    };
    return CompoundPath2;
  }(Path);
  var Gradient = function() {
    function Gradient2(colorStops) {
      this.colorStops = colorStops || [];
    }
    Gradient2.prototype.addColorStop = function(offset, color2) {
      this.colorStops.push({
        offset,
        color: color2
      });
    };
    return Gradient2;
  }();
  var LinearGradient = function(_super) {
    __extends(LinearGradient2, _super);
    function LinearGradient2(x, y, x2, y2, colorStops, globalCoord) {
      var _this = _super.call(this, colorStops) || this;
      _this.x = x == null ? 0 : x;
      _this.y = y == null ? 0 : y;
      _this.x2 = x2 == null ? 1 : x2;
      _this.y2 = y2 == null ? 0 : y2;
      _this.type = "linear";
      _this.global = globalCoord || false;
      return _this;
    }
    return LinearGradient2;
  }(Gradient);
  var RadialGradient = function(_super) {
    __extends(RadialGradient2, _super);
    function RadialGradient2(x, y, r, colorStops, globalCoord) {
      var _this = _super.call(this, colorStops) || this;
      _this.x = x == null ? 0.5 : x;
      _this.y = y == null ? 0.5 : y;
      _this.r = r == null ? 0.5 : r;
      _this.type = "radial";
      _this.global = globalCoord || false;
      return _this;
    }
    return RadialGradient2;
  }(Gradient);
  var mathMin$1 = Math.min;
  var mathMax$1 = Math.max;
  var mathAbs = Math.abs;
  var _extent = [0, 0];
  var _extent2 = [0, 0];
  var _intersectCtx = createIntersectContext();
  var _minTv = _intersectCtx.minTv;
  var _maxTv = _intersectCtx.maxTv;
  var OrientedBoundingRect = function() {
    function OrientedBoundingRect2(rect, transform) {
      this._corners = [];
      this._axes = [];
      this._origin = [0, 0];
      for (var i = 0; i < 4; i++) {
        this._corners[i] = new Point();
      }
      for (var i = 0; i < 2; i++) {
        this._axes[i] = new Point();
      }
      if (rect) {
        this.fromBoundingRect(rect, transform);
      }
    }
    OrientedBoundingRect2.prototype.fromBoundingRect = function(rect, transform) {
      var corners = this._corners;
      var axes = this._axes;
      var x = rect.x;
      var y = rect.y;
      var x2 = x + rect.width;
      var y2 = y + rect.height;
      corners[0].set(x, y);
      corners[1].set(x2, y);
      corners[2].set(x2, y2);
      corners[3].set(x, y2);
      if (transform) {
        for (var i = 0; i < 4; i++) {
          corners[i].transform(transform);
        }
      }
      Point.sub(axes[0], corners[1], corners[0]);
      Point.sub(axes[1], corners[3], corners[0]);
      axes[0].normalize();
      axes[1].normalize();
      for (var i = 0; i < 2; i++) {
        this._origin[i] = axes[i].dot(corners[0]);
      }
    };
    OrientedBoundingRect2.prototype.intersect = function(other, mtv, opt) {
      var overlapped = true;
      var noMtv = !mtv;
      if (mtv) {
        Point.set(mtv, 0, 0);
      }
      _intersectCtx.reset(opt, !noMtv);
      if (!this._intersectCheckOneSide(this, other, noMtv, 1)) {
        overlapped = false;
        if (noMtv) {
          return overlapped;
        }
      }
      if (!this._intersectCheckOneSide(other, this, noMtv, -1)) {
        overlapped = false;
        if (noMtv) {
          return overlapped;
        }
      }
      if (!noMtv && !_intersectCtx.negativeSize) {
        Point.copy(mtv, overlapped ? _intersectCtx.useDir ? _intersectCtx.dirMinTv : _minTv : _maxTv);
      }
      return overlapped;
    };
    OrientedBoundingRect2.prototype._intersectCheckOneSide = function(self2, other, noMtv, inverse) {
      var overlapped = true;
      for (var i = 0; i < 2; i++) {
        var axis = self2._axes[i];
        self2._getProjMinMaxOnAxis(i, self2._corners, _extent);
        self2._getProjMinMaxOnAxis(i, other._corners, _extent2);
        if (_intersectCtx.negativeSize || _extent[1] < _extent2[0] || _extent[0] > _extent2[1]) {
          overlapped = false;
          if (_intersectCtx.negativeSize || noMtv) {
            return overlapped;
          }
          var dist0 = mathAbs(_extent2[0] - _extent[1]);
          var dist1 = mathAbs(_extent[0] - _extent2[1]);
          if (mathMin$1(dist0, dist1) > _maxTv.len()) {
            if (dist0 < dist1) {
              Point.scale(_maxTv, axis, -dist0 * inverse);
            } else {
              Point.scale(_maxTv, axis, dist1 * inverse);
            }
          }
        } else if (!noMtv) {
          var dist0 = mathAbs(_extent2[0] - _extent[1]);
          var dist1 = mathAbs(_extent[0] - _extent2[1]);
          if (_intersectCtx.useDir || mathMin$1(dist0, dist1) < _minTv.len()) {
            if (dist0 < dist1 || !_intersectCtx.bidirectional) {
              Point.scale(_minTv, axis, dist0 * inverse);
              if (_intersectCtx.useDir) {
                _intersectCtx.calcDirMTV();
              }
            }
            if (dist0 >= dist1 || !_intersectCtx.bidirectional) {
              Point.scale(_minTv, axis, -dist1 * inverse);
              if (_intersectCtx.useDir) {
                _intersectCtx.calcDirMTV();
              }
            }
          }
        }
      }
      return overlapped;
    };
    OrientedBoundingRect2.prototype._getProjMinMaxOnAxis = function(dim, corners, out2) {
      var axis = this._axes[dim];
      var origin2 = this._origin;
      var proj = corners[0].dot(axis) + origin2[dim];
      var min3 = proj;
      var max3 = proj;
      for (var i = 1; i < corners.length; i++) {
        var proj_1 = corners[i].dot(axis) + origin2[dim];
        min3 = mathMin$1(proj_1, min3);
        max3 = mathMax$1(proj_1, max3);
      }
      out2[0] = min3 + _intersectCtx.touchThreshold;
      out2[1] = max3 - _intersectCtx.touchThreshold;
      _intersectCtx.negativeSize = out2[1] < out2[0];
    };
    return OrientedBoundingRect2;
  }();
  var m = [];
  var IncrementalDisplayable = function(_super) {
    __extends(IncrementalDisplayable2, _super);
    function IncrementalDisplayable2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.notClear = true;
      _this.incremental = true;
      _this._displayables = [];
      _this._temporaryDisplayables = [];
      _this._cursor = 0;
      return _this;
    }
    IncrementalDisplayable2.prototype.traverse = function(cb, context) {
      cb.call(context, this);
    };
    IncrementalDisplayable2.prototype.useStyle = function() {
      this.style = {};
    };
    IncrementalDisplayable2.prototype.getCursor = function() {
      return this._cursor;
    };
    IncrementalDisplayable2.prototype.innerAfterBrush = function() {
      this._cursor = this._displayables.length;
    };
    IncrementalDisplayable2.prototype.clearDisplaybles = function() {
      this._displayables = [];
      this._temporaryDisplayables = [];
      this._cursor = 0;
      this.markRedraw();
      this.notClear = false;
    };
    IncrementalDisplayable2.prototype.clearTemporalDisplayables = function() {
      this._temporaryDisplayables = [];
    };
    IncrementalDisplayable2.prototype.addDisplayable = function(displayable, notPersistent) {
      if (notPersistent) {
        this._temporaryDisplayables.push(displayable);
      } else {
        this._displayables.push(displayable);
      }
      this.markRedraw();
    };
    IncrementalDisplayable2.prototype.addDisplayables = function(displayables, notPersistent) {
      notPersistent = notPersistent || false;
      for (var i = 0; i < displayables.length; i++) {
        this.addDisplayable(displayables[i], notPersistent);
      }
    };
    IncrementalDisplayable2.prototype.getDisplayables = function() {
      return this._displayables;
    };
    IncrementalDisplayable2.prototype.getTemporalDisplayables = function() {
      return this._temporaryDisplayables;
    };
    IncrementalDisplayable2.prototype.eachPendingDisplayable = function(cb) {
      for (var i = this._cursor; i < this._displayables.length; i++) {
        cb && cb(this._displayables[i]);
      }
      for (var i = 0; i < this._temporaryDisplayables.length; i++) {
        cb && cb(this._temporaryDisplayables[i]);
      }
    };
    IncrementalDisplayable2.prototype.update = function() {
      this.updateTransform();
      for (var i = this._cursor; i < this._displayables.length; i++) {
        var displayable = this._displayables[i];
        displayable.parent = this;
        displayable.update();
        displayable.parent = null;
      }
      for (var i = 0; i < this._temporaryDisplayables.length; i++) {
        var displayable = this._temporaryDisplayables[i];
        displayable.parent = this;
        displayable.update();
        displayable.parent = null;
      }
    };
    IncrementalDisplayable2.prototype.getBoundingRect = function() {
      if (!this._rect) {
        var rect = new BoundingRect(Infinity, Infinity, -Infinity, -Infinity);
        for (var i = 0; i < this._displayables.length; i++) {
          var displayable = this._displayables[i];
          var childRect = displayable.getBoundingRect().clone();
          if (displayable.needLocalTransform()) {
            childRect.applyTransform(displayable.getLocalTransform(m));
          }
          rect.union(childRect);
        }
        this._rect = rect;
      }
      return this._rect;
    };
    IncrementalDisplayable2.prototype.contain = function(x, y) {
      var localPos = this.transformCoordToLocal(x, y);
      var rect = this.getBoundingRect();
      if (rect.contain(localPos[0], localPos[1])) {
        for (var i = 0; i < this._displayables.length; i++) {
          var displayable = this._displayables[i];
          if (displayable.contain(x, y)) {
            return true;
          }
        }
      }
      return false;
    };
    return IncrementalDisplayable2;
  }(Displayable);
  var transitionStore = makeInner();
  function getAnimationConfig(animationType, animatableModel, dataIndex, extraOpts, extraDelayParams) {
    var animationPayload;
    if (animatableModel && animatableModel.ecModel) {
      var updatePayload = animatableModel.ecModel.getUpdatePayload();
      animationPayload = updatePayload && updatePayload.animation;
    }
    var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();
    var isUpdate = animationType === "update";
    if (animationEnabled) {
      var duration = void 0;
      var easing = void 0;
      var delay = void 0;
      if (extraOpts) {
        duration = retrieve2(extraOpts.duration, 200);
        easing = retrieve2(extraOpts.easing, "cubicOut");
        delay = 0;
      } else {
        duration = animatableModel.getShallow(isUpdate ? "animationDurationUpdate" : "animationDuration");
        easing = animatableModel.getShallow(isUpdate ? "animationEasingUpdate" : "animationEasing");
        delay = animatableModel.getShallow(isUpdate ? "animationDelayUpdate" : "animationDelay");
      }
      if (animationPayload) {
        animationPayload.duration != null && (duration = animationPayload.duration);
        animationPayload.easing != null && (easing = animationPayload.easing);
        animationPayload.delay != null && (delay = animationPayload.delay);
      }
      if (isFunction(delay)) {
        delay = delay(dataIndex, extraDelayParams);
      }
      if (isFunction(duration)) {
        duration = duration(dataIndex);
      }
      var config = {
        duration: duration || 0,
        delay,
        easing
      };
      return config;
    } else {
      return null;
    }
  }
  function animateOrSetProps(animationType, el, props, animatableModel, dataIndex, cb, during) {
    var isFrom = false;
    var removeOpt;
    if (isFunction(dataIndex)) {
      during = cb;
      cb = dataIndex;
      dataIndex = null;
    } else if (isObject$2(dataIndex)) {
      cb = dataIndex.cb;
      during = dataIndex.during;
      isFrom = dataIndex.isFrom;
      removeOpt = dataIndex.removeOpt;
      dataIndex = dataIndex.dataIndex;
    }
    var isRemove = animationType === "leave";
    if (!isRemove) {
      el.stopAnimation("leave");
    }
    var animationConfig = getAnimationConfig(animationType, animatableModel, dataIndex, isRemove ? removeOpt || {} : null, animatableModel && animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);
    if (animationConfig && animationConfig.duration > 0) {
      var duration = animationConfig.duration;
      var animationDelay = animationConfig.delay;
      var animationEasing = animationConfig.easing;
      var animateConfig = {
        duration,
        delay: animationDelay || 0,
        easing: animationEasing,
        done: cb,
        force: !!cb || !!during,
        // Set to final state in update/init animation.
        // So the post processing based on the path shape can be done correctly.
        setToFinal: !isRemove,
        scope: animationType,
        during
      };
      isFrom ? el.animateFrom(props, animateConfig) : el.animateTo(props, animateConfig);
    } else {
      el.stopAnimation();
      !isFrom && el.attr(props);
      during && during(1);
      cb && cb();
    }
  }
  function updateProps$1(el, props, animatableModel, dataIndex, cb, during) {
    animateOrSetProps("update", el, props, animatableModel, dataIndex, cb, during);
  }
  function initProps(el, props, animatableModel, dataIndex, cb, during) {
    animateOrSetProps("enter", el, props, animatableModel, dataIndex, cb, during);
  }
  function isElementRemoved(el) {
    if (!el.__zr) {
      return true;
    }
    for (var i = 0; i < el.animators.length; i++) {
      var animator = el.animators[i];
      if (animator.scope === "leave") {
        return true;
      }
    }
    return false;
  }
  function removeElement(el, props, animatableModel, dataIndex, cb, during) {
    if (isElementRemoved(el)) {
      return;
    }
    animateOrSetProps("leave", el, props, animatableModel, dataIndex, cb, during);
  }
  function fadeOutDisplayable(el, animatableModel, dataIndex, done) {
    el.removeTextContent();
    el.removeTextGuideLine();
    removeElement(el, {
      style: {
        opacity: 0
      }
    }, animatableModel, dataIndex, done);
  }
  function removeElementWithFadeOut(el, animatableModel, dataIndex) {
    function doRemove() {
      el.parent && el.parent.remove(el);
    }
    if (!el.isGroup) {
      fadeOutDisplayable(el, animatableModel, dataIndex, doRemove);
    } else {
      el.traverse(function(disp) {
        if (!disp.isGroup) {
          fadeOutDisplayable(disp, animatableModel, dataIndex, doRemove);
        }
      });
    }
  }
  function saveOldStyle(el) {
    transitionStore(el).oldStyle = el.style;
  }
  var define_process_env_default$I = {};
  var _customShapeMap = {};
  var XY$1 = ["x", "y"];
  var WH$1 = ["width", "height"];
  function extendShape(opts) {
    return Path.extend(opts);
  }
  var extendPathFromString = extendFromString;
  function extendPath(pathData, opts) {
    return extendPathFromString(pathData, opts);
  }
  function registerShape(name, ShapeClass) {
    _customShapeMap[name] = ShapeClass;
  }
  function getShapeClass(name) {
    if (_customShapeMap.hasOwnProperty(name)) {
      return _customShapeMap[name];
    }
  }
  function makePath(pathData, opts, rect, layout2) {
    var path = createFromString(pathData, opts);
    if (rect) {
      if (layout2 === "center") {
        rect = centerGraphic(rect, path.getBoundingRect());
      }
      resizePath(path, rect);
    }
    return path;
  }
  function makeImage(imageUrl, rect, layout2) {
    var zrImg = new ZRImage({
      style: {
        image: imageUrl,
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height
      },
      onload: function(img) {
        if (layout2 === "center") {
          var boundingRect = {
            width: img.width,
            height: img.height
          };
          zrImg.setStyle(centerGraphic(rect, boundingRect));
        }
      }
    });
    return zrImg;
  }
  function centerGraphic(rect, boundingRect) {
    var aspect = boundingRect.width / boundingRect.height;
    var width = rect.height * aspect;
    var height;
    if (width <= rect.width) {
      height = rect.height;
    } else {
      width = rect.width;
      height = width / aspect;
    }
    var cx = rect.x + rect.width / 2;
    var cy = rect.y + rect.height / 2;
    return {
      x: cx - width / 2,
      y: cy - height / 2,
      width,
      height
    };
  }
  var mergePath = mergePath$1;
  function resizePath(path, rect) {
    if (!path.applyTransform) {
      return;
    }
    var pathRect = path.getBoundingRect();
    var m2 = pathRect.calculateTransform(rect);
    path.applyTransform(m2);
  }
  function subPixelOptimizeLine(shape, lineWidth) {
    subPixelOptimizeLine$1(shape, shape, {
      lineWidth
    });
    return shape;
  }
  function subPixelOptimizeRect(shape, style) {
    subPixelOptimizeRect$1(shape, shape, style);
    return shape;
  }
  var subPixelOptimize = subPixelOptimize$1;
  function getTransform(target, ancestor) {
    var mat = identity([]);
    while (target && target !== ancestor) {
      mul(mat, target.getLocalTransform(), mat);
      target = target.parent;
    }
    return mat;
  }
  function applyTransform(target, transform, invert$1) {
    if (transform && !isArrayLike(transform)) {
      transform = Transformable.getLocalTransform(transform);
    }
    if (invert$1) {
      transform = invert([], transform);
    }
    return applyTransform$1([], target, transform);
  }
  function transformDirection(direction, transform, invert2) {
    var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : mathAbs$3(2 * transform[4] / transform[0]);
    var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : mathAbs$3(2 * transform[4] / transform[2]);
    var vertex = [direction === "left" ? -hBase : direction === "right" ? hBase : 0, direction === "top" ? -vBase : direction === "bottom" ? vBase : 0];
    vertex = applyTransform(vertex, transform, invert2);
    return mathAbs$3(vertex[0]) > mathAbs$3(vertex[1]) ? vertex[0] > 0 ? "right" : "left" : vertex[1] > 0 ? "bottom" : "top";
  }
  function isNotGroup(el) {
    return !el.isGroup;
  }
  function isPath(el) {
    return el.shape != null;
  }
  function groupTransition(g1, g2, animatableModel) {
    if (!g1 || !g2) {
      return;
    }
    function getElMap(g) {
      var elMap = {};
      g.traverse(function(el) {
        if (isNotGroup(el) && el.anid) {
          elMap[el.anid] = el;
        }
      });
      return elMap;
    }
    function getAnimatableProps(el) {
      var obj = {
        x: el.x,
        y: el.y,
        rotation: el.rotation
      };
      if (isPath(el)) {
        obj.shape = clone$2(el.shape);
      }
      return obj;
    }
    var elMap1 = getElMap(g1);
    g2.traverse(function(el) {
      if (isNotGroup(el) && el.anid) {
        var oldEl = elMap1[el.anid];
        if (oldEl) {
          var newProp = getAnimatableProps(el);
          el.attr(getAnimatableProps(oldEl));
          updateProps$1(el, newProp, animatableModel, getECData(el).dataIndex);
        }
      }
    });
  }
  function clipPointsByRect(points2, rect) {
    return map$1(points2, function(point) {
      var x = point[0];
      x = mathMax$5(x, rect.x);
      x = mathMin$5(x, rect.x + rect.width);
      var y = point[1];
      y = mathMax$5(y, rect.y);
      y = mathMin$5(y, rect.y + rect.height);
      return [x, y];
    });
  }
  function clipRectByRect(targetRect, rect) {
    var x = mathMax$5(targetRect.x, rect.x);
    var x2 = mathMin$5(targetRect.x + targetRect.width, rect.x + rect.width);
    var y = mathMax$5(targetRect.y, rect.y);
    var y2 = mathMin$5(targetRect.y + targetRect.height, rect.y + rect.height);
    if (x2 >= x && y2 >= y) {
      return {
        x,
        y,
        width: x2 - x,
        height: y2 - y
      };
    }
  }
  function createIcon(iconStr, opt, rect) {
    var innerOpts = extend({
      rectHover: true
    }, opt);
    var style = innerOpts.style = {
      strokeNoScale: true
    };
    rect = rect || {
      x: -1,
      y: -1,
      width: 2,
      height: 2
    };
    if (iconStr) {
      return iconStr.indexOf("image://") === 0 ? (style.image = iconStr.slice(8), defaults(style, rect), new ZRImage(innerOpts)) : makePath(iconStr.replace("path://", ""), innerOpts, rect, "center");
    }
  }
  function linePolygonIntersect(a1x, a1y, a2x, a2y, points2) {
    for (var i = 0, p2 = points2[points2.length - 1]; i < points2.length; i++) {
      var p = points2[i];
      if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) {
        return true;
      }
      p2 = p;
    }
  }
  function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
    var mx = a2x - a1x;
    var my = a2y - a1y;
    var nx = b2x - b1x;
    var ny = b2y - b1y;
    var nmCrossProduct = crossProduct2d(nx, ny, mx, my);
    if (nearZero(nmCrossProduct)) {
      return false;
    }
    var b1a1x = a1x - b1x;
    var b1a1y = a1y - b1y;
    var q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;
    if (q < 0 || q > 1) {
      return false;
    }
    var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
    if (p < 0 || p > 1) {
      return false;
    }
    return true;
  }
  function crossProduct2d(x1, y1, x2, y2) {
    return x1 * y2 - x2 * y1;
  }
  function nearZero(val) {
    return val <= 1e-6 && val >= -1e-6;
  }
  function expandOrShrinkRect(rect, delta, shrinkOrExpand, noNegative, minSize) {
    if (delta == null) {
      return rect;
    } else if (isNumber(delta)) {
      _tmpExpandRectDelta[0] = _tmpExpandRectDelta[1] = _tmpExpandRectDelta[2] = _tmpExpandRectDelta[3] = delta;
    } else {
      if (define_process_env_default$I.NODE_ENV !== "production") {
        assert(delta.length === 4);
      }
      _tmpExpandRectDelta[0] = delta[0];
      _tmpExpandRectDelta[1] = delta[1];
      _tmpExpandRectDelta[2] = delta[2];
      _tmpExpandRectDelta[3] = delta[3];
    }
    if (noNegative) {
      _tmpExpandRectDelta[0] = mathMax$5(0, _tmpExpandRectDelta[0]);
      _tmpExpandRectDelta[1] = mathMax$5(0, _tmpExpandRectDelta[1]);
      _tmpExpandRectDelta[2] = mathMax$5(0, _tmpExpandRectDelta[2]);
      _tmpExpandRectDelta[3] = mathMax$5(0, _tmpExpandRectDelta[3]);
    }
    if (shrinkOrExpand) {
      _tmpExpandRectDelta[0] = -_tmpExpandRectDelta[0];
      _tmpExpandRectDelta[1] = -_tmpExpandRectDelta[1];
      _tmpExpandRectDelta[2] = -_tmpExpandRectDelta[2];
      _tmpExpandRectDelta[3] = -_tmpExpandRectDelta[3];
    }
    expandRectOnOneDimension(rect, _tmpExpandRectDelta, "x", "width", 3, 1, minSize && minSize[0] || 0);
    expandRectOnOneDimension(rect, _tmpExpandRectDelta, "y", "height", 0, 2, minSize && minSize[1] || 0);
    return rect;
  }
  var _tmpExpandRectDelta = [0, 0, 0, 0];
  function expandRectOnOneDimension(rect, delta, xy, wh, ltIdx, rbIdx, minSize) {
    var deltaSum = delta[rbIdx] + delta[ltIdx];
    var oldSize = rect[wh];
    rect[wh] += deltaSum;
    minSize = mathMax$5(0, mathMin$5(minSize, oldSize));
    if (rect[wh] < minSize) {
      rect[wh] = minSize;
      rect[xy] += delta[ltIdx] >= 0 ? -delta[ltIdx] : delta[rbIdx] >= 0 ? oldSize + delta[rbIdx] : mathAbs$3(deltaSum) > 1e-8 ? (oldSize - minSize) * delta[ltIdx] / deltaSum : 0;
    } else {
      rect[xy] -= delta[ltIdx];
    }
  }
  function setTooltipConfig(opt) {
    var itemTooltipOption = opt.itemTooltipOption;
    var componentModel = opt.componentModel;
    var itemName = opt.itemName;
    var itemTooltipOptionObj = isString(itemTooltipOption) ? {
      formatter: itemTooltipOption
    } : itemTooltipOption;
    var mainType = componentModel.mainType;
    var componentIndex = componentModel.componentIndex;
    var formatterParams = {
      componentType: mainType,
      name: itemName,
      $vars: ["name"]
    };
    formatterParams[mainType + "Index"] = componentIndex;
    var formatterParamsExtra = opt.formatterParamsExtra;
    if (formatterParamsExtra) {
      each$5(keys(formatterParamsExtra), function(key2) {
        if (!hasOwn(formatterParams, key2)) {
          formatterParams[key2] = formatterParamsExtra[key2];
          formatterParams.$vars.push(key2);
        }
      });
    }
    var ecData = getECData(opt.el);
    ecData.componentMainType = mainType;
    ecData.componentIndex = componentIndex;
    ecData.tooltipConfig = {
      name: itemName,
      option: defaults({
        content: itemName,
        encodeHTMLContent: true,
        formatterParams
      }, itemTooltipOptionObj)
    };
  }
  function traverseElement(el, cb) {
    var stopped;
    if (el.isGroup) {
      stopped = cb(el);
    }
    if (!stopped) {
      el.traverse(cb);
    }
  }
  function traverseElements(els, cb) {
    if (els) {
      if (isArray(els)) {
        for (var i = 0; i < els.length; i++) {
          traverseElement(els[i], cb);
        }
      } else {
        traverseElement(els, cb);
      }
    }
  }
  function isBoundingRectAxisAligned(transform) {
    return !transform || mathAbs$3(transform[1]) < AXIS_ALIGN_EPSILON && mathAbs$3(transform[2]) < AXIS_ALIGN_EPSILON || mathAbs$3(transform[0]) < AXIS_ALIGN_EPSILON && mathAbs$3(transform[3]) < AXIS_ALIGN_EPSILON;
  }
  var AXIS_ALIGN_EPSILON = 1e-5;
  function ensureCopyRect(target, source) {
    return target ? BoundingRect.copy(target, source) : source.clone();
  }
  function ensureCopyTransform(target, source) {
    return source ? copy(target || create(), source) : void 0;
  }
  function retrieveZInfo(model) {
    return {
      z: model.get("z") || 0,
      zlevel: model.get("zlevel") || 0
    };
  }
  function calcZ2Range(el) {
    var max3 = -Infinity;
    var min3 = Infinity;
    traverseElement(el, function(el2) {
      visitEl(el2);
      visitEl(el2.getTextContent());
      visitEl(el2.getTextGuideLine());
    });
    function visitEl(el2) {
      if (!el2 || el2.isGroup) {
        return;
      }
      var currentStates = el2.currentStates;
      if (currentStates.length) {
        for (var idx = 0; idx < currentStates.length; idx++) {
          calcZ2(el2.states[currentStates[idx]]);
        }
      }
      calcZ2(el2);
    }
    function calcZ2(entity) {
      if (entity) {
        var z2 = entity.z2;
        if (z2 > max3) {
          max3 = z2;
        }
        if (z2 < min3) {
          min3 = z2;
        }
      }
    }
    if (min3 > max3) {
      min3 = max3 = 0;
    }
    return {
      min: min3,
      max: max3
    };
  }
  function traverseUpdateZ(el, z, zlevel) {
    doUpdateZ(el, z, zlevel, -Infinity);
  }
  function doUpdateZ(el, z, zlevel, maxZ2) {
    if (el.ignoreModelZ) {
      return maxZ2;
    }
    var label = el.getTextContent();
    var labelLine = el.getTextGuideLine();
    var isGroup = el.isGroup;
    if (isGroup) {
      var children = el.childrenRef();
      for (var i = 0; i < children.length; i++) {
        maxZ2 = mathMax$5(doUpdateZ(children[i], z, zlevel, maxZ2), maxZ2);
      }
    } else {
      el.z = z;
      el.zlevel = zlevel;
      maxZ2 = mathMax$5(el.z2 || 0, maxZ2);
    }
    if (label) {
      label.z = z;
      label.zlevel = zlevel;
      isFinite(maxZ2) && (label.z2 = maxZ2 + 2);
    }
    if (labelLine) {
      var textGuideLineConfig = el.textGuideLineConfig;
      labelLine.z = z;
      labelLine.zlevel = zlevel;
      isFinite(maxZ2) && (labelLine.z2 = maxZ2 + (textGuideLineConfig && textGuideLineConfig.showAbove ? 1 : -1));
    }
    return maxZ2;
  }
  registerShape("circle", Circle);
  registerShape("ellipse", Ellipse);
  registerShape("sector", Sector);
  registerShape("ring", Ring);
  registerShape("polygon", Polygon);
  registerShape("polyline", Polyline);
  registerShape("rect", Rect$1);
  registerShape("line", Line);
  registerShape("bezierCurve", BezierCurve);
  registerShape("arc", Arc);
  const graphic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Arc,
    BezierCurve,
    BoundingRect,
    Circle,
    CompoundPath,
    Ellipse,
    Group: Group$2,
    Image: ZRImage,
    IncrementalDisplayable,
    Line,
    LinearGradient,
    OrientedBoundingRect,
    Path,
    Point,
    Polygon,
    Polyline,
    RadialGradient,
    Rect: Rect$1,
    Ring,
    Sector,
    Text: ZRText,
    WH: WH$1,
    XY: XY$1,
    applyTransform,
    calcZ2Range,
    clipPointsByRect,
    clipRectByRect,
    createIcon,
    ensureCopyRect,
    ensureCopyTransform,
    expandOrShrinkRect,
    extendPath,
    extendShape,
    getShapeClass,
    getTransform,
    groupTransition,
    initProps,
    isBoundingRectAxisAligned,
    isElementRemoved,
    lineLineIntersect,
    linePolygonIntersect,
    makeImage,
    makePath,
    mergePath,
    registerShape,
    removeElement,
    removeElementWithFadeOut,
    resizePath,
    retrieveZInfo,
    setTooltipConfig,
    subPixelOptimize,
    subPixelOptimizeLine,
    subPixelOptimizeRect,
    transformDirection,
    traverseElements,
    traverseUpdateZ,
    updateProps: updateProps$1
  }, Symbol.toStringTag, { value: "Module" }));
  var define_process_env_default$H = {};
  var EMPTY_OBJ = {};
  function setLabelText(label, labelTexts) {
    for (var i = 0; i < SPECIAL_STATES.length; i++) {
      var stateName = SPECIAL_STATES[i];
      var text = labelTexts[stateName];
      var state = label.ensureState(stateName);
      state.style = state.style || {};
      state.style.text = text;
    }
    var oldStates = label.currentStates.slice();
    label.clearStates(true);
    label.setStyle({
      text: labelTexts.normal
    });
    label.useStates(oldStates, true);
  }
  function getLabelText(opt, stateModels, interpolatedValue) {
    var labelFetcher = opt.labelFetcher;
    var labelDataIndex = opt.labelDataIndex;
    var labelDimIndex = opt.labelDimIndex;
    var normalModel = stateModels.normal;
    var baseText;
    if (labelFetcher) {
      baseText = labelFetcher.getFormattedLabel(labelDataIndex, "normal", null, labelDimIndex, normalModel && normalModel.get("formatter"), interpolatedValue != null ? {
        interpolatedValue
      } : null);
    }
    if (baseText == null) {
      baseText = isFunction(opt.defaultText) ? opt.defaultText(labelDataIndex, opt, interpolatedValue) : opt.defaultText;
    }
    var statesText = {
      normal: baseText
    };
    for (var i = 0; i < SPECIAL_STATES.length; i++) {
      var stateName = SPECIAL_STATES[i];
      var stateModel = stateModels[stateName];
      statesText[stateName] = retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, stateName, null, labelDimIndex, stateModel && stateModel.get("formatter")) : null, baseText);
    }
    return statesText;
  }
  function setLabelStyle(targetEl, labelStatesModels, opt, stateSpecified) {
    opt = opt || EMPTY_OBJ;
    var isSetOnText = targetEl instanceof ZRText;
    var needsCreateText = false;
    for (var i = 0; i < DISPLAY_STATES.length; i++) {
      var stateModel = labelStatesModels[DISPLAY_STATES[i]];
      if (stateModel && stateModel.getShallow("show")) {
        needsCreateText = true;
        break;
      }
    }
    var textContent = isSetOnText ? targetEl : targetEl.getTextContent();
    if (needsCreateText) {
      if (!isSetOnText) {
        if (!textContent) {
          textContent = new ZRText();
          targetEl.setTextContent(textContent);
        }
        if (targetEl.stateProxy) {
          textContent.stateProxy = targetEl.stateProxy;
        }
      }
      var labelStatesTexts = getLabelText(opt, labelStatesModels);
      var normalModel = labelStatesModels.normal;
      var showNormal = !!normalModel.getShallow("show");
      var normalStyle = createTextStyle(normalModel, stateSpecified && stateSpecified.normal, opt, false, !isSetOnText);
      normalStyle.text = labelStatesTexts.normal;
      if (!isSetOnText) {
        targetEl.setTextConfig(createTextConfig(normalModel, opt, false));
      }
      for (var i = 0; i < SPECIAL_STATES.length; i++) {
        var stateName = SPECIAL_STATES[i];
        var stateModel = labelStatesModels[stateName];
        if (stateModel) {
          var stateObj = textContent.ensureState(stateName);
          var stateShow = !!retrieve2(stateModel.getShallow("show"), showNormal);
          if (stateShow !== showNormal) {
            stateObj.ignore = !stateShow;
          }
          stateObj.style = createTextStyle(stateModel, stateSpecified && stateSpecified[stateName], opt, true, !isSetOnText);
          stateObj.style.text = labelStatesTexts[stateName];
          if (!isSetOnText) {
            var targetElEmphasisState = targetEl.ensureState(stateName);
            targetElEmphasisState.textConfig = createTextConfig(stateModel, opt, true);
          }
        }
      }
      textContent.silent = !!normalModel.getShallow("silent");
      if (textContent.style.x != null) {
        normalStyle.x = textContent.style.x;
      }
      if (textContent.style.y != null) {
        normalStyle.y = textContent.style.y;
      }
      textContent.ignore = !showNormal;
      textContent.useStyle(normalStyle);
      textContent.dirty();
      if (opt.enableTextSetter) {
        labelInner(textContent).setLabelText = function(interpolatedValue) {
          var labelStatesTexts2 = getLabelText(opt, labelStatesModels, interpolatedValue);
          setLabelText(textContent, labelStatesTexts2);
        };
      }
    } else if (textContent) {
      textContent.ignore = true;
    }
    targetEl.dirty();
  }
  function getLabelStatesModels(itemModel, labelName) {
    labelName = labelName || "label";
    var statesModels = {
      normal: itemModel.getModel(labelName)
    };
    for (var i = 0; i < SPECIAL_STATES.length; i++) {
      var stateName = SPECIAL_STATES[i];
      statesModels[stateName] = itemModel.getModel([stateName, labelName]);
    }
    return statesModels;
  }
  function createTextStyle(textStyleModel, specifiedTextStyle, opt, isNotNormal, isAttached) {
    var textStyle = {};
    setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached);
    specifiedTextStyle && extend(textStyle, specifiedTextStyle);
    return textStyle;
  }
  function createTextConfig(textStyleModel, opt, isNotNormal) {
    opt = opt || {};
    var textConfig = {};
    var labelPosition;
    var labelRotate = textStyleModel.getShallow("rotate");
    var labelDistance = retrieve2(textStyleModel.getShallow("distance"), isNotNormal ? null : 5);
    var labelOffset = textStyleModel.getShallow("offset");
    labelPosition = textStyleModel.getShallow("position") || (isNotNormal ? null : "inside");
    labelPosition === "outside" && (labelPosition = opt.defaultOutsidePosition || "top");
    if (labelPosition != null) {
      textConfig.position = labelPosition;
    }
    if (labelOffset != null) {
      textConfig.offset = labelOffset;
    }
    if (labelRotate != null) {
      labelRotate *= Math.PI / 180;
      textConfig.rotation = labelRotate;
    }
    if (labelDistance != null) {
      textConfig.distance = labelDistance;
    }
    textConfig.outsideFill = textStyleModel.get("color") === "inherit" ? opt.inheritColor || null : "auto";
    if (opt.autoOverflowArea != null) {
      textConfig.autoOverflowArea = opt.autoOverflowArea;
    }
    if (opt.layoutRect != null) {
      textConfig.layoutRect = opt.layoutRect;
    }
    return textConfig;
  }
  function setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached) {
    opt = opt || EMPTY_OBJ;
    var ecModel = textStyleModel.ecModel;
    var globalTextStyle = ecModel && ecModel.option.textStyle;
    var richItemNames = getRichItemNames(textStyleModel);
    var richResult;
    if (richItemNames) {
      richResult = {};
      var richInheritPlainLabelOptionName = "richInheritPlainLabel";
      var richInheritPlainLabel = retrieve2(textStyleModel.get(richInheritPlainLabelOptionName), ecModel ? ecModel.get(richInheritPlainLabelOptionName) : void 0);
      for (var name_1 in richItemNames) {
        if (richItemNames.hasOwnProperty(name_1)) {
          var richTextStyle = textStyleModel.getModel(["rich", name_1]);
          setTokenTextStyle(richResult[name_1] = {}, richTextStyle, globalTextStyle, textStyleModel, richInheritPlainLabel, opt, isNotNormal, isAttached, false, true);
        }
      }
    }
    if (richResult) {
      textStyle.rich = richResult;
    }
    var overflow = textStyleModel.get("overflow");
    if (overflow) {
      textStyle.overflow = overflow;
    }
    var lineOverflow = textStyleModel.get("lineOverflow");
    if (lineOverflow) {
      textStyle.lineOverflow = lineOverflow;
    }
    var labelTextStyle = textStyle;
    var minMargin = textStyleModel.get("minMargin");
    if (minMargin != null) {
      minMargin = !isNumber(minMargin) ? 0 : minMargin / 2;
      labelTextStyle.margin = [minMargin, minMargin, minMargin, minMargin];
      labelTextStyle.__marginType = LabelMarginType.minMargin;
    } else {
      var textMargin = textStyleModel.get("textMargin");
      if (textMargin != null) {
        labelTextStyle.margin = normalizeCssArray$1(textMargin);
        labelTextStyle.__marginType = LabelMarginType.textMargin;
      }
    }
    setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, null, null, opt, isNotNormal, isAttached, true, false);
  }
  function getRichItemNames(textStyleModel) {
    var richItemNameMap;
    while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
      var rich = (textStyleModel.option || EMPTY_OBJ).rich;
      if (rich) {
        richItemNameMap = richItemNameMap || {};
        var richKeys = keys(rich);
        for (var i = 0; i < richKeys.length; i++) {
          var richKey = richKeys[i];
          richItemNameMap[richKey] = 1;
        }
      }
      textStyleModel = textStyleModel.parentModel;
    }
    return richItemNameMap;
  }
  var TEXT_PROPS_WITH_GLOBAL = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"];
  var TEXT_PROPS_SELF = ["align", "lineHeight", "width", "height", "tag", "verticalAlign", "ellipsis"];
  var TEXT_PROPS_BOX = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
  function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, plainTextModel, richInheritPlainLabel, opt, isNotNormal, isAttached, isBlock, inRich) {
    globalTextStyle = !isNotNormal && globalTextStyle || EMPTY_OBJ;
    var inheritColor = opt && opt.inheritColor;
    var fillColor = textStyleModel.getShallow("color");
    var strokeColor = textStyleModel.getShallow("textBorderColor");
    var opacity = retrieve2(textStyleModel.getShallow("opacity"), globalTextStyle.opacity);
    if (fillColor === "inherit" || fillColor === "auto") {
      if (define_process_env_default$H.NODE_ENV !== "production") {
        if (fillColor === "auto") {
          deprecateReplaceLog("color: 'auto'", "color: 'inherit'");
        }
      }
      if (inheritColor) {
        fillColor = inheritColor;
      } else {
        fillColor = null;
      }
    }
    if (strokeColor === "inherit" || strokeColor === "auto") {
      if (define_process_env_default$H.NODE_ENV !== "production") {
        if (strokeColor === "auto") {
          deprecateReplaceLog("color: 'auto'", "color: 'inherit'");
        }
      }
      if (inheritColor) {
        strokeColor = inheritColor;
      } else {
        strokeColor = null;
      }
    }
    if (!isAttached) {
      fillColor = fillColor || globalTextStyle.color;
      strokeColor = strokeColor || globalTextStyle.textBorderColor;
    }
    if (fillColor != null) {
      textStyle.fill = fillColor;
    }
    if (strokeColor != null) {
      textStyle.stroke = strokeColor;
    }
    var textBorderWidth = retrieve2(textStyleModel.getShallow("textBorderWidth"), globalTextStyle.textBorderWidth);
    if (textBorderWidth != null) {
      textStyle.lineWidth = textBorderWidth;
    }
    var textBorderType = retrieve2(textStyleModel.getShallow("textBorderType"), globalTextStyle.textBorderType);
    if (textBorderType != null) {
      textStyle.lineDash = textBorderType;
    }
    var textBorderDashOffset = retrieve2(textStyleModel.getShallow("textBorderDashOffset"), globalTextStyle.textBorderDashOffset);
    if (textBorderDashOffset != null) {
      textStyle.lineDashOffset = textBorderDashOffset;
    }
    if (!isNotNormal && opacity == null && !inRich) {
      opacity = opt && opt.defaultOpacity;
    }
    if (opacity != null) {
      textStyle.opacity = opacity;
    }
    if (!isNotNormal && !isAttached) {
      if (textStyle.fill == null && opt.inheritColor) {
        textStyle.fill = opt.inheritColor;
      }
    }
    for (var i = 0; i < TEXT_PROPS_WITH_GLOBAL.length; i++) {
      var key2 = TEXT_PROPS_WITH_GLOBAL[i];
      var val = richInheritPlainLabel !== false && plainTextModel ? retrieve3(textStyleModel.getShallow(key2), plainTextModel.getShallow(key2), globalTextStyle[key2]) : retrieve2(textStyleModel.getShallow(key2), globalTextStyle[key2]);
      if (val != null) {
        textStyle[key2] = val;
      }
    }
    for (var i = 0; i < TEXT_PROPS_SELF.length; i++) {
      var key2 = TEXT_PROPS_SELF[i];
      var val = textStyleModel.getShallow(key2);
      if (val != null) {
        textStyle[key2] = val;
      }
    }
    if (textStyle.verticalAlign == null) {
      var baseline = textStyleModel.getShallow("baseline");
      if (baseline != null) {
        textStyle.verticalAlign = baseline;
      }
    }
    if (!isBlock || !opt.disableBox) {
      for (var i = 0; i < TEXT_PROPS_BOX.length; i++) {
        var key2 = TEXT_PROPS_BOX[i];
        var val = textStyleModel.getShallow(key2);
        if (val != null) {
          textStyle[key2] = val;
        }
      }
      var borderType = textStyleModel.getShallow("borderType");
      if (borderType != null) {
        textStyle.borderDash = borderType;
      }
      if ((textStyle.backgroundColor === "auto" || textStyle.backgroundColor === "inherit") && inheritColor) {
        if (define_process_env_default$H.NODE_ENV !== "production") {
          if (textStyle.backgroundColor === "auto") {
            deprecateReplaceLog("backgroundColor: 'auto'", "backgroundColor: 'inherit'");
          }
        }
        textStyle.backgroundColor = inheritColor;
      }
      if ((textStyle.borderColor === "auto" || textStyle.borderColor === "inherit") && inheritColor) {
        if (define_process_env_default$H.NODE_ENV !== "production") {
          if (textStyle.borderColor === "auto") {
            deprecateReplaceLog("borderColor: 'auto'", "borderColor: 'inherit'");
          }
        }
        textStyle.borderColor = inheritColor;
      }
    }
  }
  function getFont(opt, ecModel) {
    var gTextStyleModel = ecModel && ecModel.getModel("textStyle");
    return trim([
      // FIXME in node-canvas fontWeight is before fontStyle
      opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow("fontStyle") || "",
      opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow("fontWeight") || "",
      (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow("fontSize") || 12) + "px",
      opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow("fontFamily") || "sans-serif"
    ].join(" "));
  }
  var labelInner = makeInner();
  var LabelMarginType = {
    minMargin: 1,
    textMargin: 2
  };
  var PATH_COLOR = ["textStyle", "color"];
  var textStyleParams = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"];
  var tmpText = new ZRText();
  var TextStyleMixin = (
    /** @class */
    function() {
      function TextStyleMixin2() {
      }
      TextStyleMixin2.prototype.getTextColor = function(isEmphasis) {
        var ecModel = this.ecModel;
        return this.getShallow("color") || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
      };
      TextStyleMixin2.prototype.getFont = function() {
        return getFont({
          fontStyle: this.getShallow("fontStyle"),
          fontWeight: this.getShallow("fontWeight"),
          fontSize: this.getShallow("fontSize"),
          fontFamily: this.getShallow("fontFamily")
        }, this.ecModel);
      };
      TextStyleMixin2.prototype.getTextRect = function(text) {
        var style = {
          text,
          verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
        };
        for (var i = 0; i < textStyleParams.length; i++) {
          style[textStyleParams[i]] = this.getShallow(textStyleParams[i]);
        }
        tmpText.useStyle(style);
        tmpText.update();
        return tmpText.getBoundingRect();
      };
      return TextStyleMixin2;
    }()
  );
  var LINE_STYLE_KEY_MAP = [
    ["lineWidth", "width"],
    ["stroke", "color"],
    ["opacity"],
    ["shadowBlur"],
    ["shadowOffsetX"],
    ["shadowOffsetY"],
    ["shadowColor"],
    ["lineDash", "type"],
    ["lineDashOffset", "dashOffset"],
    ["lineCap", "cap"],
    ["lineJoin", "join"],
    ["miterLimit"]
    // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
    // So do not transfer decal directly.
  ];
  var getLineStyle = makeStyleMapper(LINE_STYLE_KEY_MAP);
  var LineStyleMixin = (
    /** @class */
    function() {
      function LineStyleMixin2() {
      }
      LineStyleMixin2.prototype.getLineStyle = function(excludes) {
        return getLineStyle(this, excludes);
      };
      return LineStyleMixin2;
    }()
  );
  var ITEM_STYLE_KEY_MAP = [
    ["fill", "color"],
    ["stroke", "borderColor"],
    ["lineWidth", "borderWidth"],
    ["opacity"],
    ["shadowBlur"],
    ["shadowOffsetX"],
    ["shadowOffsetY"],
    ["shadowColor"],
    ["lineDash", "borderType"],
    ["lineDashOffset", "borderDashOffset"],
    ["lineCap", "borderCap"],
    ["lineJoin", "borderJoin"],
    ["miterLimit", "borderMiterLimit"]
    // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
    // So do not transfer decal directly.
  ];
  var getItemStyle = makeStyleMapper(ITEM_STYLE_KEY_MAP);
  var ItemStyleMixin = (
    /** @class */
    function() {
      function ItemStyleMixin2() {
      }
      ItemStyleMixin2.prototype.getItemStyle = function(excludes, includes) {
        return getItemStyle(this, excludes, includes);
      };
      return ItemStyleMixin2;
    }()
  );
  var Model = (
    /** @class */
    function() {
      function Model2(option, parentModel, ecModel) {
        this.parentModel = parentModel;
        this.ecModel = ecModel;
        this.option = option;
      }
      Model2.prototype.init = function(option, parentModel, ecModel) {
      };
      Model2.prototype.mergeOption = function(option, ecModel) {
        merge(this.option, option, true);
      };
      Model2.prototype.get = function(path, ignoreParent) {
        if (path == null) {
          return this.option;
        }
        return this._doGet(this.parsePath(path), !ignoreParent && this.parentModel);
      };
      Model2.prototype.getShallow = function(key2, ignoreParent) {
        var option = this.option;
        var val = option == null ? option : option[key2];
        if (val == null && !ignoreParent) {
          var parentModel = this.parentModel;
          if (parentModel) {
            val = parentModel.getShallow(key2);
          }
        }
        return val;
      };
      Model2.prototype.getModel = function(path, parentModel) {
        var hasPath = path != null;
        var pathFinal = hasPath ? this.parsePath(path) : null;
        var obj = hasPath ? this._doGet(pathFinal) : this.option;
        parentModel = parentModel || this.parentModel && this.parentModel.getModel(this.resolveParentPath(pathFinal));
        return new Model2(obj, parentModel, this.ecModel);
      };
      Model2.prototype.isEmpty = function() {
        return this.option == null;
      };
      Model2.prototype.restoreData = function() {
      };
      Model2.prototype.clone = function() {
        var Ctor = this.constructor;
        return new Ctor(clone$2(this.option));
      };
      Model2.prototype.parsePath = function(path) {
        if (typeof path === "string") {
          return path.split(".");
        }
        return path;
      };
      Model2.prototype.resolveParentPath = function(path) {
        return path;
      };
      Model2.prototype.isAnimationEnabled = function() {
        if (!env.node && this.option) {
          if (this.option.animation != null) {
            return !!this.option.animation;
          } else if (this.parentModel) {
            return this.parentModel.isAnimationEnabled();
          }
        }
      };
      Model2.prototype._doGet = function(pathArr, parentModel) {
        var obj = this.option;
        if (!pathArr) {
          return obj;
        }
        for (var i = 0; i < pathArr.length; i++) {
          if (!pathArr[i]) {
            continue;
          }
          obj = obj && typeof obj === "object" ? obj[pathArr[i]] : null;
          if (obj == null) {
            break;
          }
        }
        if (obj == null && parentModel) {
          obj = parentModel._doGet(this.resolveParentPath(pathArr), parentModel.parentModel);
        }
        return obj;
      };
      return Model2;
    }()
  );
  enableClassExtend(Model);
  enableClassCheck(Model);
  mixin(Model, LineStyleMixin);
  mixin(Model, ItemStyleMixin);
  mixin(Model, AreaStyleMixin);
  mixin(Model, TextStyleMixin);
  var define_process_env_default$G = {};
  var base = Math.round(Math.random() * 10);
  function getUID(type) {
    return [type || "", base++].join("_");
  }
  function enableSubTypeDefaulter(target) {
    var subTypeDefaulters = {};
    target.registerSubTypeDefaulter = function(componentType, defaulter) {
      var componentTypeInfo = parseClassType(componentType);
      subTypeDefaulters[componentTypeInfo.main] = defaulter;
    };
    target.determineSubType = function(componentType, option) {
      var type = option.type;
      if (!type) {
        var componentTypeMain = parseClassType(componentType).main;
        if (target.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
          type = subTypeDefaulters[componentTypeMain](option);
        }
      }
      return type;
    };
  }
  function enableTopologicalTravel(entity, dependencyGetter) {
    entity.topologicalTravel = function(targetNameList, fullNameList, callback, context) {
      if (!targetNameList.length) {
        return;
      }
      var result = makeDepndencyGraph(fullNameList);
      var graph = result.graph;
      var noEntryList = result.noEntryList;
      var targetNameSet = {};
      each$5(targetNameList, function(name) {
        targetNameSet[name] = true;
      });
      while (noEntryList.length) {
        var currComponentType = noEntryList.pop();
        var currVertex = graph[currComponentType];
        var isInTargetNameSet = !!targetNameSet[currComponentType];
        if (isInTargetNameSet) {
          callback.call(context, currComponentType, currVertex.originalDeps.slice());
          delete targetNameSet[currComponentType];
        }
        each$5(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
      }
      each$5(targetNameSet, function() {
        var errMsg = "";
        if (define_process_env_default$G.NODE_ENV !== "production") {
          errMsg = makePrintable("Circular dependency may exists: ", targetNameSet, targetNameList, fullNameList);
        }
        throw new Error(errMsg);
      });
      function removeEdge(succComponentType) {
        graph[succComponentType].entryCount--;
        if (graph[succComponentType].entryCount === 0) {
          noEntryList.push(succComponentType);
        }
      }
      function removeEdgeAndAdd(succComponentType) {
        targetNameSet[succComponentType] = true;
        removeEdge(succComponentType);
      }
    };
    function makeDepndencyGraph(fullNameList) {
      var graph = {};
      var noEntryList = [];
      each$5(fullNameList, function(name) {
        var thisItem = createDependencyGraphItem(graph, name);
        var originalDeps = thisItem.originalDeps = dependencyGetter(name);
        var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
        thisItem.entryCount = availableDeps.length;
        if (thisItem.entryCount === 0) {
          noEntryList.push(name);
        }
        each$5(availableDeps, function(dependentName) {
          if (indexOf(thisItem.predecessor, dependentName) < 0) {
            thisItem.predecessor.push(dependentName);
          }
          var thatItem = createDependencyGraphItem(graph, dependentName);
          if (indexOf(thatItem.successor, dependentName) < 0) {
            thatItem.successor.push(name);
          }
        });
      });
      return {
        graph,
        noEntryList
      };
    }
    function createDependencyGraphItem(graph, name) {
      if (!graph[name]) {
        graph[name] = {
          predecessor: [],
          successor: []
        };
      }
      return graph[name];
    }
    function getAvailableDependencies(originalDeps, fullNameList) {
      var availableDeps = [];
      each$5(originalDeps, function(dep) {
        indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
      });
      return availableDeps;
    }
  }
  function inheritDefaultOption(superOption, subOption) {
    return merge(merge({}, superOption, true), subOption, true);
  }
  const langEN = {
    time: {
      month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
    },
    legend: {
      selector: {
        all: "All",
        inverse: "Inv"
      }
    },
    toolbox: {
      brush: {
        title: {
          rect: "Box Select",
          polygon: "Lasso Select",
          lineX: "Horizontally Select",
          lineY: "Vertically Select",
          keep: "Keep Selections",
          clear: "Clear Selections"
        }
      },
      dataView: {
        title: "Data View",
        lang: ["Data View", "Close", "Refresh"]
      },
      dataZoom: {
        title: {
          zoom: "Zoom",
          back: "Zoom Reset"
        }
      },
      magicType: {
        title: {
          line: "Switch to Line Chart",
          bar: "Switch to Bar Chart",
          stack: "Stack",
          tiled: "Tile"
        }
      },
      restore: {
        title: "Restore"
      },
      saveAsImage: {
        title: "Save as Image",
        lang: ["Right Click to Save Image"]
      }
    },
    series: {
      typeNames: {
        pie: "Pie chart",
        bar: "Bar chart",
        line: "Line chart",
        scatter: "Scatter plot",
        effectScatter: "Ripple scatter plot",
        radar: "Radar chart",
        tree: "Tree",
        treemap: "Treemap",
        boxplot: "Boxplot",
        candlestick: "Candlestick",
        k: "K line chart",
        heatmap: "Heat map",
        map: "Map",
        parallel: "Parallel coordinate map",
        lines: "Line graph",
        graph: "Relationship graph",
        sankey: "Sankey diagram",
        funnel: "Funnel chart",
        gauge: "Gauge",
        pictorialBar: "Pictorial bar",
        themeRiver: "Theme River Map",
        sunburst: "Sunburst",
        custom: "Custom chart",
        chart: "Chart"
      }
    },
    aria: {
      general: {
        withTitle: 'This is a chart about "{title}"',
        withoutTitle: "This is a chart"
      },
      series: {
        single: {
          prefix: "",
          withName: " with type {seriesType} named {seriesName}.",
          withoutName: " with type {seriesType}."
        },
        multiple: {
          prefix: ". It consists of {seriesCount} series count.",
          withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
          withoutName: " The {seriesId} series is a {seriesType}.",
          separator: {
            middle: "",
            end: ""
          }
        }
      },
      data: {
        allData: "The data is as follows: ",
        partialData: "The first {displayCnt} items are: ",
        withName: "the data for {name} is {value}",
        withoutName: "{value}",
        separator: {
          middle: ", ",
          end: ". "
        }
      }
    }
  };
  const langZH = {
    time: {
      month: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
      monthAbbr: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
      dayOfWeek: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
      dayOfWeekAbbr: ["日", "一", "二", "三", "四", "五", "六"]
    },
    legend: {
      selector: {
        all: "全选",
        inverse: "反选"
      }
    },
    toolbox: {
      brush: {
        title: {
          rect: "矩形选择",
          polygon: "圈选",
          lineX: "横向选择",
          lineY: "纵向选择",
          keep: "保持选择",
          clear: "清除选择"
        }
      },
      dataView: {
        title: "数据视图",
        lang: ["数据视图", "关闭", "刷新"]
      },
      dataZoom: {
        title: {
          zoom: "区域缩放",
          back: "区域缩放还原"
        }
      },
      magicType: {
        title: {
          line: "切换为折线图",
          bar: "切换为柱状图",
          stack: "切换为堆叠",
          tiled: "切换为平铺"
        }
      },
      restore: {
        title: "还原"
      },
      saveAsImage: {
        title: "保存为图片",
        lang: ["右键另存为图片"]
      }
    },
    series: {
      typeNames: {
        pie: "饼图",
        bar: "柱状图",
        line: "折线图",
        scatter: "散点图",
        effectScatter: "涟漪散点图",
        radar: "雷达图",
        tree: "树图",
        treemap: "矩形树图",
        boxplot: "箱型图",
        candlestick: "K线图",
        k: "K线图",
        heatmap: "热力图",
        map: "地图",
        parallel: "平行坐标图",
        lines: "线图",
        graph: "关系图",
        sankey: "桑基图",
        funnel: "漏斗图",
        gauge: "仪表盘图",
        pictorialBar: "象形柱图",
        themeRiver: "主题河流图",
        sunburst: "旭日图",
        custom: "自定义图表",
        chart: "图表"
      }
    },
    aria: {
      general: {
        withTitle: "这是一个关于“{title}”的图表。",
        withoutTitle: "这是一个图表，"
      },
      series: {
        single: {
          prefix: "",
          withName: "图表类型是{seriesType}，表示{seriesName}。",
          withoutName: "图表类型是{seriesType}。"
        },
        multiple: {
          prefix: "它由{seriesCount}个图表系列组成。",
          withName: "第{seriesId}个系列是一个表示{seriesName}的{seriesType}，",
          withoutName: "第{seriesId}个系列是一个{seriesType}，",
          separator: {
            middle: "；",
            end: "。"
          }
        }
      },
      data: {
        allData: "其数据是——",
        partialData: "其中，前{displayCnt}项是——",
        withName: "{name}的数据是{value}",
        withoutName: "{value}",
        separator: {
          middle: "，",
          end: ""
        }
      }
    }
  };
  var LOCALE_ZH = "ZH";
  var LOCALE_EN = "EN";
  var DEFAULT_LOCALE = LOCALE_EN;
  var localeStorage = {};
  var localeModels = {};
  var SYSTEM_LANG = !env.domSupported ? DEFAULT_LOCALE : function() {
    var langStr = (
      /* eslint-disable-next-line */
      (document.documentElement.lang || navigator.language || navigator.browserLanguage || DEFAULT_LOCALE).toUpperCase()
    );
    return langStr.indexOf(LOCALE_ZH) > -1 ? LOCALE_ZH : DEFAULT_LOCALE;
  }();
  function registerLocale(locale, localeObj) {
    locale = locale.toUpperCase();
    localeModels[locale] = new Model(localeObj);
    localeStorage[locale] = localeObj;
  }
  function createLocaleObject(locale) {
    if (isString(locale)) {
      var localeObj = localeStorage[locale.toUpperCase()] || {};
      if (locale === LOCALE_ZH || locale === LOCALE_EN) {
        return clone$2(localeObj);
      } else {
        return merge(clone$2(localeObj), clone$2(localeStorage[DEFAULT_LOCALE]), false);
      }
    } else {
      return merge(clone$2(locale), clone$2(localeStorage[DEFAULT_LOCALE]), false);
    }
  }
  function getLocaleModel(lang) {
    return localeModels[lang];
  }
  function getDefaultLocaleModel() {
    return localeModels[DEFAULT_LOCALE];
  }
  registerLocale(LOCALE_EN, langEN);
  registerLocale(LOCALE_ZH, langZH);
  var _impl$1 = null;
  function getScaleBreakHelper() {
    return _impl$1;
  }
  var ONE_SECOND = 1e3;
  var ONE_MINUTE = ONE_SECOND * 60;
  var ONE_HOUR = ONE_MINUTE * 60;
  var ONE_DAY = ONE_HOUR * 24;
  var ONE_YEAR = ONE_DAY * 365;
  var primaryTimeUnitFormatterMatchers = {
    year: /({yyyy}|{yy})/,
    month: /({MMMM}|{MMM}|{MM}|{M})/,
    day: /({dd}|{d})/,
    hour: /({HH}|{H}|{hh}|{h})/,
    minute: /({mm}|{m})/,
    second: /({ss}|{s})/,
    millisecond: /({SSS}|{S})/
  };
  var defaultFormatterSeed = {
    year: "{yyyy}",
    month: "{MMM}",
    day: "{d}",
    hour: "{HH}:{mm}",
    minute: "{HH}:{mm}",
    second: "{HH}:{mm}:{ss}",
    millisecond: "{HH}:{mm}:{ss} {SSS}"
  };
  var defaultFullFormatter = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}";
  var fullDayFormatter = "{yyyy}-{MM}-{dd}";
  var fullLeveledFormatter = {
    year: "{yyyy}",
    month: "{yyyy}-{MM}",
    day: fullDayFormatter,
    hour: fullDayFormatter + " " + defaultFormatterSeed.hour,
    minute: fullDayFormatter + " " + defaultFormatterSeed.minute,
    second: fullDayFormatter + " " + defaultFormatterSeed.second,
    millisecond: defaultFullFormatter
  };
  var primaryTimeUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
  var timeUnits = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day", "hour", "minute", "second", "millisecond"];
  function parseTimeAxisLabelFormatter(formatter) {
    return !isString(formatter) && !isFunction(formatter) ? parseTimeAxisLabelFormatterDictionary(formatter) : formatter;
  }
  function parseTimeAxisLabelFormatterDictionary(dictOption) {
    dictOption = dictOption || {};
    var dict = {};
    var canAddHighlight = true;
    each$5(primaryTimeUnits, function(lowestUnit) {
      canAddHighlight && (canAddHighlight = dictOption[lowestUnit] == null);
    });
    each$5(primaryTimeUnits, function(lowestUnit, lowestUnitIdx) {
      var upperDictOption = dictOption[lowestUnit];
      dict[lowestUnit] = {};
      var lowerTpl = null;
      for (var upperUnitIdx = lowestUnitIdx; upperUnitIdx >= 0; upperUnitIdx--) {
        var upperUnit = primaryTimeUnits[upperUnitIdx];
        var upperDictItemOption = isObject$2(upperDictOption) && !isArray(upperDictOption) ? upperDictOption[upperUnit] : upperDictOption;
        var tplArr = void 0;
        if (isArray(upperDictItemOption)) {
          tplArr = upperDictItemOption.slice();
          lowerTpl = tplArr[0] || "";
        } else if (isString(upperDictItemOption)) {
          lowerTpl = upperDictItemOption;
          tplArr = [lowerTpl];
        } else {
          if (lowerTpl == null) {
            lowerTpl = defaultFormatterSeed[lowestUnit];
          } else if (!primaryTimeUnitFormatterMatchers[upperUnit].test(lowerTpl)) {
            lowerTpl = dict[upperUnit][upperUnit][0] + " " + lowerTpl;
          }
          tplArr = [lowerTpl];
          if (canAddHighlight) {
            tplArr[1] = "{primary|" + lowerTpl + "}";
          }
        }
        dict[lowestUnit][upperUnit] = tplArr;
      }
    });
    return dict;
  }
  function pad(str, len2) {
    str += "";
    return "0000".substr(0, len2 - str.length) + str;
  }
  function getPrimaryTimeUnit(timeUnit) {
    switch (timeUnit) {
      case "half-year":
      case "quarter":
        return "month";
      case "week":
      case "half-week":
        return "day";
      case "half-day":
      case "quarter-day":
        return "hour";
      default:
        return timeUnit;
    }
  }
  function isPrimaryTimeUnit(timeUnit) {
    return timeUnit === getPrimaryTimeUnit(timeUnit);
  }
  function getDefaultFormatPrecisionOfInterval(timeUnit) {
    switch (timeUnit) {
      case "year":
      case "month":
        return "day";
      case "millisecond":
        return "millisecond";
      default:
        return "second";
    }
  }
  function format(time, template, isUTC, lang) {
    var date = parseDate(time);
    var y = date[fullYearGetterName(isUTC)]();
    var M = date[monthGetterName(isUTC)]() + 1;
    var q = Math.floor((M - 1) / 3) + 1;
    var d = date[dateGetterName(isUTC)]();
    var e2 = date["get" + (isUTC ? "UTC" : "") + "Day"]();
    var H = date[hoursGetterName(isUTC)]();
    var h = (H - 1) % 12 + 1;
    var m2 = date[minutesGetterName(isUTC)]();
    var s = date[secondsGetterName(isUTC)]();
    var S = date[millisecondsGetterName(isUTC)]();
    var a = H >= 12 ? "pm" : "am";
    var A = a.toUpperCase();
    var localeModel = lang instanceof Model ? lang : getLocaleModel(lang || SYSTEM_LANG) || getDefaultLocaleModel();
    var timeModel = localeModel.getModel("time");
    var month = timeModel.get("month");
    var monthAbbr = timeModel.get("monthAbbr");
    var dayOfWeek = timeModel.get("dayOfWeek");
    var dayOfWeekAbbr = timeModel.get("dayOfWeekAbbr");
    return (template || "").replace(/{a}/g, a + "").replace(/{A}/g, A + "").replace(/{yyyy}/g, y + "").replace(/{yy}/g, pad(y % 100 + "", 2)).replace(/{Q}/g, q + "").replace(/{MMMM}/g, month[M - 1]).replace(/{MMM}/g, monthAbbr[M - 1]).replace(/{MM}/g, pad(M, 2)).replace(/{M}/g, M + "").replace(/{dd}/g, pad(d, 2)).replace(/{d}/g, d + "").replace(/{eeee}/g, dayOfWeek[e2]).replace(/{ee}/g, dayOfWeekAbbr[e2]).replace(/{e}/g, e2 + "").replace(/{HH}/g, pad(H, 2)).replace(/{H}/g, H + "").replace(/{hh}/g, pad(h + "", 2)).replace(/{h}/g, h + "").replace(/{mm}/g, pad(m2, 2)).replace(/{m}/g, m2 + "").replace(/{ss}/g, pad(s, 2)).replace(/{s}/g, s + "").replace(/{SSS}/g, pad(S, 3)).replace(/{S}/g, S + "");
  }
  function leveledFormat(tick, idx, formatter, lang, isUTC) {
    var template = null;
    if (isString(formatter)) {
      template = formatter;
    } else if (isFunction(formatter)) {
      var extra = {
        time: tick.time,
        level: tick.time.level
      };
      var scaleBreakHelper = getScaleBreakHelper();
      if (scaleBreakHelper) {
        scaleBreakHelper.makeAxisLabelFormatterParamBreak(extra, tick["break"]);
      }
      template = formatter(tick.value, idx, extra);
    } else {
      var tickTime = tick.time;
      if (tickTime) {
        var leveledTplArr = formatter[tickTime.lowerTimeUnit][tickTime.upperTimeUnit];
        template = leveledTplArr[Math.min(tickTime.level, leveledTplArr.length - 1)] || "";
      } else {
        var unit = getUnitFromValue(tick.value, isUTC);
        template = formatter[unit][unit][0];
      }
    }
    return format(new Date(tick.value), template, isUTC, lang);
  }
  function getUnitFromValue(value, isUTC) {
    var date = parseDate(value);
    var M = date[monthGetterName(isUTC)]() + 1;
    var d = date[dateGetterName(isUTC)]();
    var h = date[hoursGetterName(isUTC)]();
    var m2 = date[minutesGetterName(isUTC)]();
    var s = date[secondsGetterName(isUTC)]();
    var S = date[millisecondsGetterName(isUTC)]();
    var isSecond = S === 0;
    var isMinute = isSecond && s === 0;
    var isHour = isMinute && m2 === 0;
    var isDay = isHour && h === 0;
    var isMonth = isDay && d === 1;
    var isYear = isMonth && M === 1;
    if (isYear) {
      return "year";
    } else if (isMonth) {
      return "month";
    } else if (isDay) {
      return "day";
    } else if (isHour) {
      return "hour";
    } else if (isMinute) {
      return "minute";
    } else if (isSecond) {
      return "second";
    } else {
      return "millisecond";
    }
  }
  function roundTime(date, timeUnit, isUTC) {
    switch (timeUnit) {
      case "year":
        date[monthSetterName(isUTC)](0);
      case "month":
        date[dateSetterName(isUTC)](1);
      case "day":
        date[hoursSetterName(isUTC)](0);
      case "hour":
        date[minutesSetterName(isUTC)](0);
      case "minute":
        date[secondsSetterName(isUTC)](0);
      case "second":
        date[millisecondsSetterName(isUTC)](0);
    }
    return date;
  }
  function fullYearGetterName(isUTC) {
    return isUTC ? "getUTCFullYear" : "getFullYear";
  }
  function monthGetterName(isUTC) {
    return isUTC ? "getUTCMonth" : "getMonth";
  }
  function dateGetterName(isUTC) {
    return isUTC ? "getUTCDate" : "getDate";
  }
  function hoursGetterName(isUTC) {
    return isUTC ? "getUTCHours" : "getHours";
  }
  function minutesGetterName(isUTC) {
    return isUTC ? "getUTCMinutes" : "getMinutes";
  }
  function secondsGetterName(isUTC) {
    return isUTC ? "getUTCSeconds" : "getSeconds";
  }
  function millisecondsGetterName(isUTC) {
    return isUTC ? "getUTCMilliseconds" : "getMilliseconds";
  }
  function fullYearSetterName(isUTC) {
    return isUTC ? "setUTCFullYear" : "setFullYear";
  }
  function monthSetterName(isUTC) {
    return isUTC ? "setUTCMonth" : "setMonth";
  }
  function dateSetterName(isUTC) {
    return isUTC ? "setUTCDate" : "setDate";
  }
  function hoursSetterName(isUTC) {
    return isUTC ? "setUTCHours" : "setHours";
  }
  function minutesSetterName(isUTC) {
    return isUTC ? "setUTCMinutes" : "setMinutes";
  }
  function secondsSetterName(isUTC) {
    return isUTC ? "setUTCSeconds" : "setSeconds";
  }
  function millisecondsSetterName(isUTC) {
    return isUTC ? "setUTCMilliseconds" : "setMilliseconds";
  }
  function addCommas(x) {
    if (!isNumeric(x)) {
      return isString(x) ? x : "-";
    }
    var parts = (x + "").split(".");
    return parts[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (parts.length > 1 ? "." + parts[1] : "");
  }
  function toCamelCase(str, upperCaseFirst) {
    str = (str || "").toLowerCase().replace(/-(.)/g, function(match, group1) {
      return group1.toUpperCase();
    });
    if (upperCaseFirst && str) {
      str = str.charAt(0).toUpperCase() + str.slice(1);
    }
    return str;
  }
  var normalizeCssArray = normalizeCssArray$1;
  function makeValueReadable(value, valueType, useUTC) {
    var USER_READABLE_DEFUALT_TIME_PATTERN = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
    function stringToUserReadable(str) {
      return str && trim(str) ? str : "-";
    }
    function isNumberUserReadable(num) {
      return !!(num != null && !isNaN(num) && isFinite(num));
    }
    var isTypeTime = valueType === "time";
    var isValueDate = value instanceof Date;
    if (isTypeTime || isValueDate) {
      var date = isTypeTime ? parseDate(value) : value;
      if (!isNaN(+date)) {
        return format(date, USER_READABLE_DEFUALT_TIME_PATTERN, useUTC);
      } else if (isValueDate) {
        return "-";
      }
    }
    if (valueType === "ordinal") {
      return isStringSafe(value) ? stringToUserReadable(value) : isNumber(value) ? isNumberUserReadable(value) ? value + "" : "-" : "-";
    }
    var numericResult = numericToNumber(value);
    return isNumberUserReadable(numericResult) ? addCommas(numericResult) : isStringSafe(value) ? stringToUserReadable(value) : typeof value === "boolean" ? value + "" : "-";
  }
  var TPL_VAR_ALIAS = ["a", "b", "c", "d", "e", "f", "g"];
  var wrapVar = function(varName, seriesIdx) {
    return "{" + varName + (seriesIdx == null ? "" : seriesIdx) + "}";
  };
  function formatTpl(tpl, paramsList, encode2) {
    if (!isArray(paramsList)) {
      paramsList = [paramsList];
    }
    var seriesLen = paramsList.length;
    if (!seriesLen) {
      return "";
    }
    var $vars = paramsList[0].$vars || [];
    for (var i = 0; i < $vars.length; i++) {
      var alias = TPL_VAR_ALIAS[i];
      tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));
    }
    for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
      for (var k = 0; k < $vars.length; k++) {
        var val = paramsList[seriesIdx][$vars[k]];
        tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode2 ? encodeHTML(val) : val);
      }
    }
    return tpl;
  }
  function getTooltipMarker(inOpt, extraCssText) {
    var opt = isString(inOpt) ? {
      color: inOpt,
      extraCssText
    } : inOpt || {};
    var color2 = opt.color;
    var type = opt.type;
    extraCssText = opt.extraCssText;
    var renderMode = opt.renderMode || "html";
    if (!color2) {
      return "";
    }
    if (renderMode === "html") {
      return type === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + encodeHTML(color2) + ";" + (extraCssText || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + encodeHTML(color2) + ";" + (extraCssText || "") + '"></span>';
    } else {
      var markerId = opt.markerId || "markerX";
      return {
        renderMode,
        content: "{" + markerId + "|}  ",
        style: type === "subItem" ? {
          width: 4,
          height: 4,
          borderRadius: 2,
          backgroundColor: color2
        } : {
          width: 10,
          height: 10,
          borderRadius: 5,
          backgroundColor: color2
        }
      };
    }
  }
  function convertToColorString(color2, defaultColor) {
    defaultColor = defaultColor || "transparent";
    return isString(color2) ? color2 : isObject$2(color2) ? color2.colorStops && (color2.colorStops[0] || {}).color || defaultColor : defaultColor;
  }
  function windowOpen(link, target) {
    if (target === "_blank" || target === "blank") {
      var blank = window.open();
      blank.opener = null;
      blank.location.href = link;
    } else {
      window.open(link, target);
    }
  }
  var define_process_env_default$F = {};
  var nonSeriesBoxCoordSysCreators = {};
  var normalCoordSysCreators = {};
  var CoordinateSystemManager = (
    /** @class */
    function() {
      function CoordinateSystemManager2() {
        this._normalMasterList = [];
        this._nonSeriesBoxMasterList = [];
      }
      CoordinateSystemManager2.prototype.create = function(ecModel, api) {
        this._nonSeriesBoxMasterList = dealCreate(nonSeriesBoxCoordSysCreators, true);
        this._normalMasterList = dealCreate(normalCoordSysCreators, false);
        function dealCreate(creatorMap, canBeNonSeriesBox) {
          var coordinateSystems = [];
          each$5(creatorMap, function(creator, type) {
            var list = creator.create(ecModel, api);
            coordinateSystems = coordinateSystems.concat(list || []);
            if (define_process_env_default$F.NODE_ENV !== "production") {
              if (canBeNonSeriesBox) {
                each$5(list, function(master) {
                  return assert(!master.update);
                });
              }
            }
          });
          return coordinateSystems;
        }
      };
      CoordinateSystemManager2.prototype.update = function(ecModel, api) {
        each$5(this._normalMasterList, function(coordSys) {
          coordSys.update && coordSys.update(ecModel, api);
        });
      };
      CoordinateSystemManager2.prototype.getCoordinateSystems = function() {
        return this._normalMasterList.concat(this._nonSeriesBoxMasterList);
      };
      CoordinateSystemManager2.register = function(type, creator) {
        if (type === "matrix" || type === "calendar") {
          nonSeriesBoxCoordSysCreators[type] = creator;
          return;
        }
        normalCoordSysCreators[type] = creator;
      };
      CoordinateSystemManager2.get = function(type) {
        return normalCoordSysCreators[type] || nonSeriesBoxCoordSysCreators[type];
      };
      return CoordinateSystemManager2;
    }()
  );
  function canBeNonSeriesBoxCoordSys(coordSysType) {
    return !!nonSeriesBoxCoordSysCreators[coordSysType];
  }
  var BoxCoordinateSystemCoordFrom = {
    // By default fetch coord from `model.get('coord')`.
    coord: 1,
    // Some model/series, such as pie, is allowed to also get coord from `model.get('center')`,
    // if cannot get from `model.get('coord')`. But historically pie use `center` option, but
    // geo use `layoutCenter` option to specify layout center; they are not able to be unified.
    // Therefor it is not recommended.
    coord2: 2
  };
  var coordSysUseMap = createHashMap();
  function getCoordForBoxCoordSys(model) {
    var coord = model.getShallow("coord", true);
    var from = BoxCoordinateSystemCoordFrom.coord;
    if (coord == null) {
      var store = coordSysUseMap.get(model.type);
      if (store && store.getCoord2) {
        from = BoxCoordinateSystemCoordFrom.coord2;
        coord = store.getCoord2(model);
      }
    }
    return {
      coord,
      from
    };
  }
  var CoordinateSystemUsageKind = {
    none: 0,
    dataCoordSys: 1,
    boxCoordSys: 2
  };
  function decideCoordSysUsageKind(model, printError) {
    var coordSysType = model.getShallow("coordinateSystem");
    var coordSysUsageOption = model.getShallow("coordinateSystemUsage", true);
    var isDeclaredExplicitly = coordSysUsageOption != null;
    var kind = CoordinateSystemUsageKind.none;
    if (coordSysType) {
      var isSeries2 = model.mainType === "series";
      if (coordSysUsageOption == null) {
        coordSysUsageOption = isSeries2 ? "data" : "box";
      }
      if (coordSysUsageOption === "data") {
        kind = CoordinateSystemUsageKind.dataCoordSys;
        if (!isSeries2) {
          if (define_process_env_default$F.NODE_ENV !== "production") {
            if (isDeclaredExplicitly && printError) {
              error('coordinateSystemUsage "data" is not supported in non-series components.');
            }
          }
          kind = CoordinateSystemUsageKind.none;
        }
      } else if (coordSysUsageOption === "box") {
        kind = CoordinateSystemUsageKind.boxCoordSys;
        if (!isSeries2 && !canBeNonSeriesBoxCoordSys(coordSysType)) {
          if (define_process_env_default$F.NODE_ENV !== "production") {
            if (isDeclaredExplicitly && printError) {
              error('coordinateSystem "' + coordSysType + '" cannot be used' + (' as coordinateSystemUsage "box" for "' + model.type + '" yet.'));
            }
          }
          kind = CoordinateSystemUsageKind.none;
        }
      }
    }
    return {
      coordSysType,
      kind
    };
  }
  function injectCoordSysByOption(opt) {
    var targetModel = opt.targetModel, coordSysType = opt.coordSysType, coordSysProvider = opt.coordSysProvider, isDefaultDataCoordSys = opt.isDefaultDataCoordSys, allowNotFound = opt.allowNotFound;
    if (define_process_env_default$F.NODE_ENV !== "production") {
      assert(!!coordSysType);
    }
    var _a2 = decideCoordSysUsageKind(targetModel, true), kind = _a2.kind, declaredType = _a2.coordSysType;
    if (isDefaultDataCoordSys && kind !== CoordinateSystemUsageKind.dataCoordSys) {
      kind = CoordinateSystemUsageKind.dataCoordSys;
      declaredType = coordSysType;
    }
    if (kind === CoordinateSystemUsageKind.none || declaredType !== coordSysType) {
      return false;
    }
    var coordSys = coordSysProvider(coordSysType, targetModel);
    if (!coordSys) {
      if (define_process_env_default$F.NODE_ENV !== "production") {
        if (!allowNotFound) {
          error(coordSysType + " cannot be found for" + (" " + targetModel.type + " (index: " + targetModel.componentIndex + ")."));
        }
      }
      return false;
    }
    if (kind === CoordinateSystemUsageKind.dataCoordSys) {
      if (define_process_env_default$F.NODE_ENV !== "production") {
        assert(targetModel.mainType === "series");
      }
      targetModel.coordinateSystem = coordSys;
    } else {
      targetModel.boxCoordinateSystem = coordSys;
    }
    return true;
  }
  var define_process_env_default$E = {};
  var each$4 = each$5;
  var LOCATION_PARAMS = ["left", "right", "top", "bottom", "width", "height"];
  var HV_NAMES = [["width", "left", "right"], ["height", "top", "bottom"]];
  function boxLayout(orient, group, gap, maxWidth, maxHeight) {
    var x = 0;
    var y = 0;
    if (maxWidth == null) {
      maxWidth = Infinity;
    }
    if (maxHeight == null) {
      maxHeight = Infinity;
    }
    var currentLineMaxSize = 0;
    group.eachChild(function(child, idx) {
      var rect = child.getBoundingRect();
      var nextChild = group.childAt(idx + 1);
      var nextChildRect = nextChild && nextChild.getBoundingRect();
      var nextX;
      var nextY;
      if (orient === "horizontal") {
        var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
        nextX = x + moveX;
        if (nextX > maxWidth || child.newline) {
          x = 0;
          nextX = moveX;
          y += currentLineMaxSize + gap;
          currentLineMaxSize = rect.height;
        } else {
          currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
        }
      } else {
        var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
        nextY = y + moveY;
        if (nextY > maxHeight || child.newline) {
          x += currentLineMaxSize + gap;
          y = 0;
          nextY = moveY;
          currentLineMaxSize = rect.width;
        } else {
          currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
        }
      }
      if (child.newline) {
        return;
      }
      child.x = x;
      child.y = y;
      child.markRedraw();
      orient === "horizontal" ? x = nextX + gap : y = nextY + gap;
    });
  }
  var box = boxLayout;
  curry$1(boxLayout, "vertical");
  curry$1(boxLayout, "horizontal");
  function getBoxLayoutParams(boxLayoutModel, ignoreParent) {
    return {
      left: boxLayoutModel.getShallow("left", ignoreParent),
      top: boxLayoutModel.getShallow("top", ignoreParent),
      right: boxLayoutModel.getShallow("right", ignoreParent),
      bottom: boxLayoutModel.getShallow("bottom", ignoreParent),
      width: boxLayoutModel.getShallow("width", ignoreParent),
      height: boxLayoutModel.getShallow("height", ignoreParent)
    };
  }
  function getLayoutRect(positionInfo, containerRect, margin) {
    margin = normalizeCssArray(margin || 0);
    var containerWidth = containerRect.width;
    var containerHeight = containerRect.height;
    var left = parsePercent(positionInfo.left, containerWidth);
    var top = parsePercent(positionInfo.top, containerHeight);
    var right = parsePercent(positionInfo.right, containerWidth);
    var bottom = parsePercent(positionInfo.bottom, containerHeight);
    var width = parsePercent(positionInfo.width, containerWidth);
    var height = parsePercent(positionInfo.height, containerHeight);
    var verticalMargin = margin[2] + margin[0];
    var horizontalMargin = margin[1] + margin[3];
    var aspect = positionInfo.aspect;
    if (isNaN(width)) {
      width = containerWidth - right - horizontalMargin - left;
    }
    if (isNaN(height)) {
      height = containerHeight - bottom - verticalMargin - top;
    }
    if (aspect != null) {
      if (isNaN(width) && isNaN(height)) {
        if (aspect > containerWidth / containerHeight) {
          width = containerWidth * 0.8;
        } else {
          height = containerHeight * 0.8;
        }
      }
      if (isNaN(width)) {
        width = aspect * height;
      }
      if (isNaN(height)) {
        height = width / aspect;
      }
    }
    if (isNaN(left)) {
      left = containerWidth - right - width - horizontalMargin;
    }
    if (isNaN(top)) {
      top = containerHeight - bottom - height - verticalMargin;
    }
    switch (positionInfo.left || positionInfo.right) {
      case "center":
        left = containerWidth / 2 - width / 2 - margin[3];
        break;
      case "right":
        left = containerWidth - width - horizontalMargin;
        break;
    }
    switch (positionInfo.top || positionInfo.bottom) {
      case "middle":
      case "center":
        top = containerHeight / 2 - height / 2 - margin[0];
        break;
      case "bottom":
        top = containerHeight - height - verticalMargin;
        break;
    }
    left = left || 0;
    top = top || 0;
    if (isNaN(width)) {
      width = containerWidth - horizontalMargin - left - (right || 0);
    }
    if (isNaN(height)) {
      height = containerHeight - verticalMargin - top - (bottom || 0);
    }
    var rect = new BoundingRect((containerRect.x || 0) + left + margin[3], (containerRect.y || 0) + top + margin[0], width, height);
    rect.margin = margin;
    return rect;
  }
  var BoxLayoutReferenceType = {
    rect: 1
  };
  function createBoxLayoutReference(model, api, opt) {
    var refContainer;
    var refPoint;
    var layoutRefType;
    var boxCoordSys = model.boxCoordinateSystem;
    var boxCoordFrom;
    if (boxCoordSys) {
      var _a2 = getCoordForBoxCoordSys(model), coord = _a2.coord, from = _a2.from;
      if (boxCoordSys.dataToLayout) {
        layoutRefType = BoxLayoutReferenceType.rect;
        boxCoordFrom = from;
        var result = boxCoordSys.dataToLayout(coord);
        refContainer = result.contentRect || result.rect;
      } else {
        if (define_process_env_default$E.NODE_ENV !== "production") {
          error(model.type + "[" + model.componentIndex + "]" + (" layout based on " + boxCoordSys.type + " is not supported."));
        }
      }
    }
    if (layoutRefType == null) {
      layoutRefType = BoxLayoutReferenceType.rect;
    }
    if (layoutRefType === BoxLayoutReferenceType.rect) {
      if (!refContainer) {
        refContainer = {
          x: 0,
          y: 0,
          width: api.getWidth(),
          height: api.getHeight()
        };
      }
      refPoint = [refContainer.x + refContainer.width / 2, refContainer.y + refContainer.height / 2];
    }
    return {
      type: layoutRefType,
      refContainer,
      refPoint,
      boxCoordFrom
    };
  }
  function fetchLayoutMode(ins) {
    var layoutMode = ins.layoutMode || ins.constructor.layoutMode;
    return isObject$2(layoutMode) ? layoutMode : layoutMode ? {
      type: layoutMode
    } : null;
  }
  function mergeLayoutParam(targetOption, newOption, opt) {
    var ignoreSize = opt && opt.ignoreSize;
    !isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);
    var hResult = merge2(HV_NAMES[0], 0);
    var vResult = merge2(HV_NAMES[1], 1);
    copy2(HV_NAMES[0], targetOption, hResult);
    copy2(HV_NAMES[1], targetOption, vResult);
    function merge2(names, hvIdx) {
      var newParams = {};
      var newValueCount = 0;
      var merged = {};
      var mergedValueCount = 0;
      var enoughParamNumber = 2;
      each$4(names, function(name) {
        merged[name] = targetOption[name];
      });
      each$4(names, function(name) {
        hasOwn(newOption, name) && (newParams[name] = merged[name] = newOption[name]);
        hasValue(newParams, name) && newValueCount++;
        hasValue(merged, name) && mergedValueCount++;
      });
      if (ignoreSize[hvIdx]) {
        if (hasValue(newOption, names[1])) {
          merged[names[2]] = null;
        } else if (hasValue(newOption, names[2])) {
          merged[names[1]] = null;
        }
        return merged;
      }
      if (mergedValueCount === enoughParamNumber || !newValueCount) {
        return merged;
      } else if (newValueCount >= enoughParamNumber) {
        return newParams;
      } else {
        for (var i = 0; i < names.length; i++) {
          var name_1 = names[i];
          if (!hasOwn(newParams, name_1) && hasOwn(targetOption, name_1)) {
            newParams[name_1] = targetOption[name_1];
            break;
          }
        }
        return newParams;
      }
    }
    function hasValue(obj, name) {
      return obj[name] != null && obj[name] !== "auto";
    }
    function copy2(names, target, source) {
      each$4(names, function(name) {
        target[name] = source[name];
      });
    }
  }
  function getLayoutParams(source) {
    return copyLayoutParams({}, source);
  }
  function copyLayoutParams(target, source) {
    source && target && each$4(LOCATION_PARAMS, function(name) {
      hasOwn(source, name) && (target[name] = source[name]);
    });
    return target;
  }
  var inner$a = makeInner();
  var ComponentModel = (
    /** @class */
    function(_super) {
      __extends(ComponentModel2, _super);
      function ComponentModel2(option, parentModel, ecModel) {
        var _this = _super.call(this, option, parentModel, ecModel) || this;
        _this.uid = getUID("ec_cpt_model");
        return _this;
      }
      ComponentModel2.prototype.init = function(option, parentModel, ecModel) {
        this.mergeDefaultAndTheme(option, ecModel);
      };
      ComponentModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
        var layoutMode = fetchLayoutMode(this);
        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
        var themeModel = ecModel.getTheme();
        merge(option, themeModel.get(this.mainType));
        merge(option, this.getDefaultOption());
        if (layoutMode) {
          mergeLayoutParam(option, inputPositionParams, layoutMode);
        }
      };
      ComponentModel2.prototype.mergeOption = function(option, ecModel) {
        merge(this.option, option, true);
        var layoutMode = fetchLayoutMode(this);
        if (layoutMode) {
          mergeLayoutParam(this.option, option, layoutMode);
        }
      };
      ComponentModel2.prototype.optionUpdated = function(newCptOption, isInit) {
      };
      ComponentModel2.prototype.getDefaultOption = function() {
        var ctor = this.constructor;
        if (!isExtendedClass(ctor)) {
          return ctor.defaultOption;
        }
        var fields = inner$a(this);
        if (!fields.defaultOption) {
          var optList = [];
          var clz = ctor;
          while (clz) {
            var opt = clz.prototype.defaultOption;
            opt && optList.push(opt);
            clz = clz.superClass;
          }
          var defaultOption2 = {};
          for (var i = optList.length - 1; i >= 0; i--) {
            defaultOption2 = merge(defaultOption2, optList[i], true);
          }
          fields.defaultOption = defaultOption2;
        }
        return fields.defaultOption;
      };
      ComponentModel2.prototype.getReferringComponents = function(mainType, opt) {
        var indexKey = mainType + "Index";
        var idKey = mainType + "Id";
        return queryReferringComponents(this.ecModel, mainType, {
          index: this.get(indexKey, true),
          id: this.get(idKey, true)
        }, opt);
      };
      ComponentModel2.prototype.getBoxLayoutParams = function() {
        return getBoxLayoutParams(this, false);
      };
      ComponentModel2.prototype.getZLevelKey = function() {
        return "";
      };
      ComponentModel2.prototype.setZLevel = function(zlevel) {
        this.option.zlevel = zlevel;
      };
      ComponentModel2.protoInitialize = function() {
        var proto = ComponentModel2.prototype;
        proto.type = "component";
        proto.id = "";
        proto.name = "";
        proto.mainType = "";
        proto.subType = "";
        proto.componentIndex = 0;
      }();
      return ComponentModel2;
    }(Model)
  );
  mountExtend(ComponentModel, Model);
  enableClassManagement(ComponentModel);
  enableSubTypeDefaulter(ComponentModel);
  enableTopologicalTravel(ComponentModel, getDependencies);
  function getDependencies(componentType) {
    var deps = [];
    each$5(ComponentModel.getClassesByMainType(componentType), function(clz) {
      deps = deps.concat(clz.dependencies || clz.prototype.dependencies || []);
    });
    deps = map$1(deps, function(type) {
      return parseClassType(type).main;
    });
    if (componentType !== "dataset" && indexOf(deps, "dataset") <= 0) {
      deps.unshift("dataset");
    }
    return deps;
  }
  var tokens = {
    color: {},
    darkColor: {},
    size: {}
  };
  var color$1 = tokens.color = {
    theme: ["#5070dd", "#b6d634", "#505372", "#ff994d", "#0ca8df", "#ffd10a", "#fb628b", "#785db0", "#3fbe95"],
    neutral00: "#fff",
    neutral05: "#f4f7fd",
    neutral10: "#e8ebf0",
    neutral15: "#dbdee4",
    neutral20: "#cfd2d7",
    neutral25: "#c3c5cb",
    neutral30: "#b7b9be",
    neutral35: "#aaacb2",
    neutral40: "#9ea0a5",
    neutral45: "#929399",
    neutral50: "#86878c",
    neutral55: "#797b7f",
    neutral60: "#6d6e73",
    neutral65: "#616266",
    neutral70: "#54555a",
    neutral75: "#48494d",
    neutral80: "#3c3c41",
    neutral85: "#303034",
    neutral90: "#232328",
    neutral95: "#17171b",
    neutral99: "#000",
    accent05: "#eff1f9",
    accent10: "#e0e4f2",
    accent15: "#d0d6ec",
    accent20: "#c0c9e6",
    accent25: "#b1bbdf",
    accent30: "#a1aed9",
    accent35: "#91a0d3",
    accent40: "#8292cc",
    accent45: "#7285c6",
    accent50: "#6578ba",
    accent55: "#5c6da9",
    accent60: "#536298",
    accent65: "#4a5787",
    accent70: "#404c76",
    accent75: "#374165",
    accent80: "#2e3654",
    accent85: "#252b43",
    accent90: "#1b2032",
    accent95: "#121521",
    transparent: "rgba(0,0,0,0)",
    highlight: "rgba(255,231,130,0.8)"
  };
  extend(color$1, {
    primary: color$1.neutral80,
    secondary: color$1.neutral70,
    tertiary: color$1.neutral60,
    quaternary: color$1.neutral50,
    disabled: color$1.neutral20,
    border: color$1.neutral30,
    borderTint: color$1.neutral20,
    borderShade: color$1.neutral40,
    background: color$1.neutral05,
    backgroundTint: "rgba(234,237,245,0.5)",
    backgroundTransparent: "rgba(255,255,255,0)",
    backgroundShade: color$1.neutral10,
    shadow: "rgba(0,0,0,0.2)",
    shadowTint: "rgba(129,130,136,0.2)",
    axisLine: color$1.neutral70,
    axisLineTint: color$1.neutral40,
    axisTick: color$1.neutral70,
    axisTickMinor: color$1.neutral60,
    axisLabel: color$1.neutral70,
    axisSplitLine: color$1.neutral15,
    axisMinorSplitLine: color$1.neutral05
  });
  for (var key in color$1) {
    if (color$1.hasOwnProperty(key)) {
      var hex = color$1[key];
      if (key === "theme") {
        tokens.darkColor.theme = color$1.theme.slice();
      } else if (key === "highlight") {
        tokens.darkColor.highlight = "rgba(255,231,130,0.4)";
      } else if (key.indexOf("accent") === 0) {
        tokens.darkColor[key] = modifyHSL(hex, null, function(s) {
          return s * 0.5;
        }, function(l) {
          return Math.min(1, 1.3 - l);
        });
      } else {
        tokens.darkColor[key] = modifyHSL(hex, null, function(s) {
          return s * 0.9;
        }, function(l) {
          return 1 - Math.pow(l, 1.5);
        });
      }
    }
  }
  tokens.size = {
    xxs: 2,
    xs: 5,
    s: 10,
    m: 15,
    l: 20,
    xl: 30,
    xxl: 40,
    xxxl: 50
  };
  var platform = "";
  if (typeof navigator !== "undefined") {
    platform = navigator.platform || "";
  }
  var decalColor = "rgba(0, 0, 0, 0.2)";
  var themeColor = tokens.color.theme[0];
  var lightThemeColor = modifyHSL(themeColor, null, null, 0.9);
  const globalDefault = {
    darkMode: "auto",
    // backgroundColor: 'rgba(0,0,0,0)',
    colorBy: "series",
    color: tokens.color.theme,
    gradientColor: [lightThemeColor, themeColor],
    aria: {
      decal: {
        decals: [{
          color: decalColor,
          dashArrayX: [1, 0],
          dashArrayY: [2, 5],
          symbolSize: 1,
          rotation: Math.PI / 6
        }, {
          color: decalColor,
          symbol: "circle",
          dashArrayX: [[8, 8], [0, 8, 8, 0]],
          dashArrayY: [6, 0],
          symbolSize: 0.8
        }, {
          color: decalColor,
          dashArrayX: [1, 0],
          dashArrayY: [4, 3],
          rotation: -Math.PI / 4
        }, {
          color: decalColor,
          dashArrayX: [[6, 6], [0, 6, 6, 0]],
          dashArrayY: [6, 0]
        }, {
          color: decalColor,
          dashArrayX: [[1, 0], [1, 6]],
          dashArrayY: [1, 0, 6, 0],
          rotation: Math.PI / 4
        }, {
          color: decalColor,
          symbol: "triangle",
          dashArrayX: [[9, 9], [0, 9, 9, 0]],
          dashArrayY: [7, 2],
          symbolSize: 0.75
        }]
      }
    },
    // If xAxis and yAxis declared, grid is created by default.
    // grid: {},
    textStyle: {
      // color: '#000',
      // decoration: 'none',
      // PENDING
      fontFamily: platform.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
      // fontFamily: 'Arial, Verdana, sans-serif',
      fontSize: 12,
      fontStyle: "normal",
      fontWeight: "normal"
    },
    // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
    // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
    // Default is source-over
    blendMode: null,
    stateAnimation: {
      duration: 300,
      easing: "cubicOut"
    },
    animation: "auto",
    animationDuration: 1e3,
    animationDurationUpdate: 500,
    animationEasing: "cubicInOut",
    animationEasingUpdate: "cubicInOut",
    animationThreshold: 2e3,
    // Configuration for progressive/incremental rendering
    progressiveThreshold: 3e3,
    progressive: 400,
    // Threshold of if use single hover layer to optimize.
    // It is recommended that `hoverLayerThreshold` is equivalent to or less than
    // `progressiveThreshold`, otherwise hover will cause restart of progressive,
    // which is unexpected.
    // see example <echarts/test/heatmap-large.html>.
    hoverLayerThreshold: 3e3,
    // See: module:echarts/scale/Time
    useUTC: false
  };
  var VISUAL_DIMENSIONS = createHashMap(["tooltip", "label", "itemName", "itemId", "itemGroupId", "itemChildGroupId", "seriesName"]);
  var SOURCE_FORMAT_ORIGINAL = "original";
  var SOURCE_FORMAT_ARRAY_ROWS = "arrayRows";
  var SOURCE_FORMAT_OBJECT_ROWS = "objectRows";
  var SOURCE_FORMAT_KEYED_COLUMNS = "keyedColumns";
  var SOURCE_FORMAT_TYPED_ARRAY = "typedArray";
  var SOURCE_FORMAT_UNKNOWN = "unknown";
  var SERIES_LAYOUT_BY_COLUMN = "column";
  var SERIES_LAYOUT_BY_ROW = "row";
  var BE_ORDINAL = {
    Must: 1,
    Might: 2,
    Not: 3
    // Other cases
  };
  var innerGlobalModel = makeInner();
  function resetSourceDefaulter(ecModel) {
    innerGlobalModel(ecModel).datasetMap = createHashMap();
  }
  function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {
    var encode2 = {};
    var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
    if (!datasetModel || !coordDimensions) {
      return encode2;
    }
    var encodeItemName = [];
    var encodeSeriesName = [];
    var ecModel = seriesModel.ecModel;
    var datasetMap = innerGlobalModel(ecModel).datasetMap;
    var key2 = datasetModel.uid + "_" + source.seriesLayoutBy;
    var baseCategoryDimIndex;
    var categoryWayValueDimStart;
    coordDimensions = coordDimensions.slice();
    each$5(coordDimensions, function(coordDimInfoLoose, coordDimIdx) {
      var coordDimInfo = isObject$2(coordDimInfoLoose) ? coordDimInfoLoose : coordDimensions[coordDimIdx] = {
        name: coordDimInfoLoose
      };
      if (coordDimInfo.type === "ordinal" && baseCategoryDimIndex == null) {
        baseCategoryDimIndex = coordDimIdx;
        categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimInfo);
      }
      encode2[coordDimInfo.name] = [];
    });
    var datasetRecord = datasetMap.get(key2) || datasetMap.set(key2, {
      categoryWayDim: categoryWayValueDimStart,
      valueWayDim: 0
    });
    each$5(coordDimensions, function(coordDimInfo, coordDimIdx) {
      var coordDimName = coordDimInfo.name;
      var count = getDataDimCountOnCoordDim(coordDimInfo);
      if (baseCategoryDimIndex == null) {
        var start2 = datasetRecord.valueWayDim;
        pushDim(encode2[coordDimName], start2, count);
        pushDim(encodeSeriesName, start2, count);
        datasetRecord.valueWayDim += count;
      } else if (baseCategoryDimIndex === coordDimIdx) {
        pushDim(encode2[coordDimName], 0, count);
        pushDim(encodeItemName, 0, count);
      } else {
        var start2 = datasetRecord.categoryWayDim;
        pushDim(encode2[coordDimName], start2, count);
        pushDim(encodeSeriesName, start2, count);
        datasetRecord.categoryWayDim += count;
      }
    });
    function pushDim(dimIdxArr, idxFrom, idxCount) {
      for (var i = 0; i < idxCount; i++) {
        dimIdxArr.push(idxFrom + i);
      }
    }
    function getDataDimCountOnCoordDim(coordDimInfo) {
      var dimsDef = coordDimInfo.dimsDef;
      return dimsDef ? dimsDef.length : 1;
    }
    encodeItemName.length && (encode2.itemName = encodeItemName);
    encodeSeriesName.length && (encode2.seriesName = encodeSeriesName);
    return encode2;
  }
  function querySeriesUpstreamDatasetModel(seriesModel) {
    var thisData = seriesModel.get("data", true);
    if (!thisData) {
      return queryReferringComponents(seriesModel.ecModel, "dataset", {
        index: seriesModel.get("datasetIndex", true),
        id: seriesModel.get("datasetId", true)
      }, SINGLE_REFERRING).models[0];
    }
  }
  function queryDatasetUpstreamDatasetModels(datasetModel) {
    if (!datasetModel.get("transform", true) && !datasetModel.get("fromTransformResult", true)) {
      return [];
    }
    return queryReferringComponents(datasetModel.ecModel, "dataset", {
      index: datasetModel.get("fromDatasetIndex", true),
      id: datasetModel.get("fromDatasetId", true)
    }, SINGLE_REFERRING).models;
  }
  function guessOrdinal(source, dimIndex) {
    return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);
  }
  function doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {
    var result;
    var maxLoop = 5;
    if (isTypedArray(data)) {
      return BE_ORDINAL.Not;
    }
    var dimName;
    var dimType;
    if (dimensionsDefine) {
      var dimDefItem = dimensionsDefine[dimIndex];
      if (isObject$2(dimDefItem)) {
        dimName = dimDefItem.name;
        dimType = dimDefItem.type;
      } else if (isString(dimDefItem)) {
        dimName = dimDefItem;
      }
    }
    if (dimType != null) {
      return dimType === "ordinal" ? BE_ORDINAL.Must : BE_ORDINAL.Not;
    }
    if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
      var dataArrayRows = data;
      if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
        var sample = dataArrayRows[dimIndex];
        for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {
          if ((result = detectValue(sample[startIndex + i])) != null) {
            return result;
          }
        }
      } else {
        for (var i = 0; i < dataArrayRows.length && i < maxLoop; i++) {
          var row = dataArrayRows[startIndex + i];
          if (row && (result = detectValue(row[dimIndex])) != null) {
            return result;
          }
        }
      }
    } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
      var dataObjectRows = data;
      if (!dimName) {
        return BE_ORDINAL.Not;
      }
      for (var i = 0; i < dataObjectRows.length && i < maxLoop; i++) {
        var item = dataObjectRows[i];
        if (item && (result = detectValue(item[dimName])) != null) {
          return result;
        }
      }
    } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
      var dataKeyedColumns = data;
      if (!dimName) {
        return BE_ORDINAL.Not;
      }
      var sample = dataKeyedColumns[dimName];
      if (!sample || isTypedArray(sample)) {
        return BE_ORDINAL.Not;
      }
      for (var i = 0; i < sample.length && i < maxLoop; i++) {
        if ((result = detectValue(sample[i])) != null) {
          return result;
        }
      }
    } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
      var dataOriginal = data;
      for (var i = 0; i < dataOriginal.length && i < maxLoop; i++) {
        var item = dataOriginal[i];
        var val = getDataItemValue(item);
        if (!isArray(val)) {
          return BE_ORDINAL.Not;
        }
        if ((result = detectValue(val[dimIndex])) != null) {
          return result;
        }
      }
    }
    function detectValue(val2) {
      var beStr = isString(val2);
      if (val2 != null && Number.isFinite(Number(val2)) && val2 !== "") {
        return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;
      } else if (beStr && val2 !== "-") {
        return BE_ORDINAL.Must;
      }
    }
    return BE_ORDINAL.Not;
  }
  var define_process_env_default$D = {};
  var internalOptionCreatorMap = createHashMap();
  function concatInternalOptions(ecModel, mainType, newCmptOptionList) {
    var internalOptionCreator = internalOptionCreatorMap.get(mainType);
    if (!internalOptionCreator) {
      return newCmptOptionList;
    }
    var internalOptions = internalOptionCreator(ecModel);
    if (!internalOptions) {
      return newCmptOptionList;
    }
    if (define_process_env_default$D.NODE_ENV !== "production") {
      for (var i = 0; i < internalOptions.length; i++) {
        assert(isComponentIdInternal(internalOptions[i]));
      }
    }
    return newCmptOptionList.concat(internalOptions);
  }
  var innerColor = makeInner();
  makeInner();
  var PaletteMixin = (
    /** @class */
    function() {
      function PaletteMixin2() {
      }
      PaletteMixin2.prototype.getColorFromPalette = function(name, scope, requestNum) {
        var defaultPalette = normalizeToArray(this.get("color", true));
        var layeredPalette = this.get("colorLayer", true);
        return getFromPalette(this, innerColor, defaultPalette, layeredPalette, name, scope, requestNum);
      };
      PaletteMixin2.prototype.clearColorPalette = function() {
        clearPalette(this, innerColor);
      };
      return PaletteMixin2;
    }()
  );
  function getNearestPalette(palettes, requestColorNum) {
    var paletteNum = palettes.length;
    for (var i = 0; i < paletteNum; i++) {
      if (palettes[i].length > requestColorNum) {
        return palettes[i];
      }
    }
    return palettes[paletteNum - 1];
  }
  function getFromPalette(that, inner2, defaultPalette, layeredPalette, name, scope, requestNum) {
    scope = scope || that;
    var scopeFields = inner2(scope);
    var paletteIdx = scopeFields.paletteIdx || 0;
    var paletteNameMap = scopeFields.paletteNameMap = scopeFields.paletteNameMap || {};
    if (paletteNameMap.hasOwnProperty(name)) {
      return paletteNameMap[name];
    }
    var palette = requestNum == null || !layeredPalette ? defaultPalette : getNearestPalette(layeredPalette, requestNum);
    palette = palette || defaultPalette;
    if (!palette || !palette.length) {
      return;
    }
    var pickedPaletteItem = palette[paletteIdx];
    if (name) {
      paletteNameMap[name] = pickedPaletteItem;
    }
    scopeFields.paletteIdx = (paletteIdx + 1) % palette.length;
    return pickedPaletteItem;
  }
  function clearPalette(that, inner2) {
    inner2(that).paletteIdx = 0;
    inner2(that).paletteNameMap = {};
  }
  var define_process_env_default$C = {};
  var reCreateSeriesIndices;
  var assertSeriesInitialized;
  var initBase;
  var OPTION_INNER_KEY = "\0_ec_inner";
  var OPTION_INNER_VALUE = 1;
  var BUITIN_COMPONENTS_MAP = {
    grid: "GridComponent",
    polar: "PolarComponent",
    geo: "GeoComponent",
    singleAxis: "SingleAxisComponent",
    parallel: "ParallelComponent",
    calendar: "CalendarComponent",
    matrix: "MatrixComponent",
    graphic: "GraphicComponent",
    toolbox: "ToolboxComponent",
    tooltip: "TooltipComponent",
    axisPointer: "AxisPointerComponent",
    brush: "BrushComponent",
    title: "TitleComponent",
    timeline: "TimelineComponent",
    markPoint: "MarkPointComponent",
    markLine: "MarkLineComponent",
    markArea: "MarkAreaComponent",
    legend: "LegendComponent",
    dataZoom: "DataZoomComponent",
    visualMap: "VisualMapComponent",
    // aria: 'AriaComponent',
    // dataset: 'DatasetComponent',
    // Dependencies
    xAxis: "GridComponent",
    yAxis: "GridComponent",
    angleAxis: "PolarComponent",
    radiusAxis: "PolarComponent"
  };
  var BUILTIN_CHARTS_MAP = {
    line: "LineChart",
    bar: "BarChart",
    pie: "PieChart",
    scatter: "ScatterChart",
    radar: "RadarChart",
    map: "MapChart",
    tree: "TreeChart",
    treemap: "TreemapChart",
    graph: "GraphChart",
    chord: "ChordChart",
    gauge: "GaugeChart",
    funnel: "FunnelChart",
    parallel: "ParallelChart",
    sankey: "SankeyChart",
    boxplot: "BoxplotChart",
    candlestick: "CandlestickChart",
    effectScatter: "EffectScatterChart",
    lines: "LinesChart",
    heatmap: "HeatmapChart",
    pictorialBar: "PictorialBarChart",
    themeRiver: "ThemeRiverChart",
    sunburst: "SunburstChart",
    custom: "CustomChart"
  };
  var componetsMissingLogPrinted = {};
  function checkMissingComponents(option) {
    each$5(option, function(componentOption, mainType) {
      if (!ComponentModel.hasClass(mainType)) {
        var componentImportName = BUITIN_COMPONENTS_MAP[mainType];
        if (componentImportName && !componetsMissingLogPrinted[componentImportName]) {
          error("Component " + mainType + " is used but not imported.\nimport { " + componentImportName + " } from 'echarts/components';\necharts.use([" + componentImportName + "]);");
          componetsMissingLogPrinted[componentImportName] = true;
        }
      }
    });
  }
  var GlobalModel = (
    /** @class */
    function(_super) {
      __extends(GlobalModel2, _super);
      function GlobalModel2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      GlobalModel2.prototype.init = function(option, parentModel, ecModel, theme2, locale, optionManager) {
        theme2 = theme2 || {};
        this.option = null;
        this._theme = new Model(theme2);
        this._locale = new Model(locale);
        this._optionManager = optionManager;
      };
      GlobalModel2.prototype.setOption = function(option, opts, optionPreprocessorFuncs2) {
        if (define_process_env_default$C.NODE_ENV !== "production") {
          assert(option != null, "option is null/undefined");
          assert(option[OPTION_INNER_KEY] !== OPTION_INNER_VALUE, "please use chart.getOption()");
        }
        var innerOpt = normalizeSetOptionInput(opts);
        this._optionManager.setOption(option, optionPreprocessorFuncs2, innerOpt);
        this._resetOption(null, innerOpt);
      };
      GlobalModel2.prototype.resetOption = function(type, opt) {
        return this._resetOption(type, normalizeSetOptionInput(opt));
      };
      GlobalModel2.prototype._resetOption = function(type, opt) {
        var optionChanged = false;
        var optionManager = this._optionManager;
        if (!type || type === "recreate") {
          var baseOption = optionManager.mountOption(type === "recreate");
          if (define_process_env_default$C.NODE_ENV !== "production") {
            checkMissingComponents(baseOption);
          }
          if (!this.option || type === "recreate") {
            initBase(this, baseOption);
          } else {
            this.restoreData();
            this._mergeOption(baseOption, opt);
          }
          optionChanged = true;
        }
        if (type === "timeline" || type === "media") {
          this.restoreData();
        }
        if (!type || type === "recreate" || type === "timeline") {
          var timelineOption = optionManager.getTimelineOption(this);
          if (timelineOption) {
            optionChanged = true;
            this._mergeOption(timelineOption, opt);
          }
        }
        if (!type || type === "recreate" || type === "media") {
          var mediaOptions = optionManager.getMediaOption(this);
          if (mediaOptions.length) {
            each$5(mediaOptions, function(mediaOption) {
              optionChanged = true;
              this._mergeOption(mediaOption, opt);
            }, this);
          }
        }
        return optionChanged;
      };
      GlobalModel2.prototype.mergeOption = function(option) {
        this._mergeOption(option, null);
      };
      GlobalModel2.prototype._mergeOption = function(newOption, opt) {
        var option = this.option;
        var componentsMap = this._componentsMap;
        var componentsCount = this._componentsCount;
        var newCmptTypes = [];
        var newCmptTypeMap = createHashMap();
        var replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap;
        resetSourceDefaulter(this);
        each$5(newOption, function(componentOption, mainType) {
          if (componentOption == null) {
            return;
          }
          if (!ComponentModel.hasClass(mainType)) {
            option[mainType] = option[mainType] == null ? clone$2(componentOption) : merge(option[mainType], componentOption, true);
          } else if (mainType) {
            newCmptTypes.push(mainType);
            newCmptTypeMap.set(mainType, true);
          }
        });
        if (replaceMergeMainTypeMap) {
          replaceMergeMainTypeMap.each(function(val, mainTypeInReplaceMerge) {
            if (ComponentModel.hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {
              newCmptTypes.push(mainTypeInReplaceMerge);
              newCmptTypeMap.set(mainTypeInReplaceMerge, true);
            }
          });
        }
        ComponentModel.topologicalTravel(newCmptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);
        function visitComponent(mainType) {
          var newCmptOptionList = concatInternalOptions(this, mainType, normalizeToArray(newOption[mainType]));
          var oldCmptList = componentsMap.get(mainType);
          var mergeMode = (
            // `!oldCmptList` means init. See the comment in `mappingToExists`
            !oldCmptList ? "replaceAll" : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? "replaceMerge" : "normalMerge"
          );
          var mappingResult = mappingToExists(oldCmptList, newCmptOptionList, mergeMode);
          setComponentTypeToKeyInfo(mappingResult, mainType, ComponentModel);
          option[mainType] = null;
          componentsMap.set(mainType, null);
          componentsCount.set(mainType, 0);
          var optionsByMainType = [];
          var cmptsByMainType = [];
          var cmptsCountByMainType = 0;
          var tooltipExists;
          var tooltipWarningLogged;
          each$5(mappingResult, function(resultItem, index2) {
            var componentModel = resultItem.existing;
            var newCmptOption = resultItem.newOption;
            if (!newCmptOption) {
              if (componentModel) {
                componentModel.mergeOption({}, this);
                componentModel.optionUpdated({}, false);
              }
            } else {
              var isSeriesType = mainType === "series";
              var ComponentModelClass = ComponentModel.getClass(
                mainType,
                resultItem.keyInfo.subType,
                !isSeriesType
                // Give a more detailed warn later if series don't exists
              );
              if (!ComponentModelClass) {
                if (define_process_env_default$C.NODE_ENV !== "production") {
                  var subType = resultItem.keyInfo.subType;
                  var seriesImportName = BUILTIN_CHARTS_MAP[subType];
                  if (!componetsMissingLogPrinted[subType]) {
                    componetsMissingLogPrinted[subType] = true;
                    if (seriesImportName) {
                      error("Series " + subType + " is used but not imported.\nimport { " + seriesImportName + " } from 'echarts/charts';\necharts.use([" + seriesImportName + "]);");
                    } else {
                      error("Unknown series " + subType);
                    }
                  }
                }
                return;
              }
              if (mainType === "tooltip") {
                if (tooltipExists) {
                  if (define_process_env_default$C.NODE_ENV !== "production") {
                    if (!tooltipWarningLogged) {
                      warn("Currently only one tooltip component is allowed.");
                      tooltipWarningLogged = true;
                    }
                  }
                  return;
                }
                tooltipExists = true;
              }
              if (componentModel && componentModel.constructor === ComponentModelClass) {
                componentModel.name = resultItem.keyInfo.name;
                componentModel.mergeOption(newCmptOption, this);
                componentModel.optionUpdated(newCmptOption, false);
              } else {
                var extraOpt = extend({
                  componentIndex: index2
                }, resultItem.keyInfo);
                componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt);
                extend(componentModel, extraOpt);
                if (resultItem.brandNew) {
                  componentModel.__requireNewView = true;
                }
                componentModel.init(newCmptOption, this, this);
                componentModel.optionUpdated(null, true);
              }
            }
            if (componentModel) {
              optionsByMainType.push(componentModel.option);
              cmptsByMainType.push(componentModel);
              cmptsCountByMainType++;
            } else {
              optionsByMainType.push(void 0);
              cmptsByMainType.push(void 0);
            }
          }, this);
          option[mainType] = optionsByMainType;
          componentsMap.set(mainType, cmptsByMainType);
          componentsCount.set(mainType, cmptsCountByMainType);
          if (mainType === "series") {
            reCreateSeriesIndices(this);
          }
        }
        if (!this._seriesIndices) {
          reCreateSeriesIndices(this);
        }
      };
      GlobalModel2.prototype.getOption = function() {
        var option = clone$2(this.option);
        each$5(option, function(optInMainType, mainType) {
          if (ComponentModel.hasClass(mainType)) {
            var opts = normalizeToArray(optInMainType);
            var realLen = opts.length;
            var metNonInner = false;
            for (var i = realLen - 1; i >= 0; i--) {
              if (opts[i] && !isComponentIdInternal(opts[i])) {
                metNonInner = true;
              } else {
                opts[i] = null;
                !metNonInner && realLen--;
              }
            }
            opts.length = realLen;
            option[mainType] = opts;
          }
        });
        delete option[OPTION_INNER_KEY];
        return option;
      };
      GlobalModel2.prototype.setTheme = function(theme2) {
        this._theme = new Model(theme2);
        this._resetOption("recreate", null);
      };
      GlobalModel2.prototype.getTheme = function() {
        return this._theme;
      };
      GlobalModel2.prototype.getLocaleModel = function() {
        return this._locale;
      };
      GlobalModel2.prototype.setUpdatePayload = function(payload) {
        this._payload = payload;
      };
      GlobalModel2.prototype.getUpdatePayload = function() {
        return this._payload;
      };
      GlobalModel2.prototype.getComponent = function(mainType, idx) {
        var list = this._componentsMap.get(mainType);
        if (list) {
          var cmpt = list[idx || 0];
          if (cmpt) {
            return cmpt;
          } else if (idx == null) {
            for (var i = 0; i < list.length; i++) {
              if (list[i]) {
                return list[i];
              }
            }
          }
        }
      };
      GlobalModel2.prototype.queryComponents = function(condition) {
        var mainType = condition.mainType;
        if (!mainType) {
          return [];
        }
        var index2 = condition.index;
        var id = condition.id;
        var name = condition.name;
        var cmpts = this._componentsMap.get(mainType);
        if (!cmpts || !cmpts.length) {
          return [];
        }
        var result;
        if (index2 != null) {
          result = [];
          each$5(normalizeToArray(index2), function(idx) {
            cmpts[idx] && result.push(cmpts[idx]);
          });
        } else if (id != null) {
          result = queryByIdOrName("id", id, cmpts);
        } else if (name != null) {
          result = queryByIdOrName("name", name, cmpts);
        } else {
          result = filter(cmpts, function(cmpt) {
            return !!cmpt;
          });
        }
        return filterBySubType(result, condition);
      };
      GlobalModel2.prototype.findComponents = function(condition) {
        var query = condition.query;
        var mainType = condition.mainType;
        var queryCond = getQueryCond(query);
        var result = queryCond ? this.queryComponents(queryCond) : filter(this._componentsMap.get(mainType), function(cmpt) {
          return !!cmpt;
        });
        return doFilter(filterBySubType(result, condition));
        function getQueryCond(q) {
          var indexAttr = mainType + "Index";
          var idAttr = mainType + "Id";
          var nameAttr = mainType + "Name";
          return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {
            mainType,
            // subType will be filtered finally.
            index: q[indexAttr],
            id: q[idAttr],
            name: q[nameAttr]
          } : null;
        }
        function doFilter(res) {
          return condition.filter ? filter(res, condition.filter) : res;
        }
      };
      GlobalModel2.prototype.eachComponent = function(mainType, cb, context) {
        var componentsMap = this._componentsMap;
        if (isFunction(mainType)) {
          var ctxForAll_1 = cb;
          var cbForAll_1 = mainType;
          componentsMap.each(function(cmpts2, componentType) {
            for (var i2 = 0; cmpts2 && i2 < cmpts2.length; i2++) {
              var cmpt2 = cmpts2[i2];
              cmpt2 && cbForAll_1.call(ctxForAll_1, componentType, cmpt2, cmpt2.componentIndex);
            }
          });
        } else {
          var cmpts = isString(mainType) ? componentsMap.get(mainType) : isObject$2(mainType) ? this.findComponents(mainType) : null;
          for (var i = 0; cmpts && i < cmpts.length; i++) {
            var cmpt = cmpts[i];
            cmpt && cb.call(context, cmpt, cmpt.componentIndex);
          }
        }
      };
      GlobalModel2.prototype.getSeriesByName = function(name) {
        var nameStr = convertOptionIdName(name, null);
        return filter(this._componentsMap.get("series"), function(oneSeries) {
          return !!oneSeries && nameStr != null && oneSeries.name === nameStr;
        });
      };
      GlobalModel2.prototype.getSeriesByIndex = function(seriesIndex) {
        return this._componentsMap.get("series")[seriesIndex];
      };
      GlobalModel2.prototype.getSeriesByType = function(subType) {
        return filter(this._componentsMap.get("series"), function(oneSeries) {
          return !!oneSeries && oneSeries.subType === subType;
        });
      };
      GlobalModel2.prototype.getSeries = function() {
        return filter(this._componentsMap.get("series"), function(oneSeries) {
          return !!oneSeries;
        });
      };
      GlobalModel2.prototype.getSeriesCount = function() {
        return this._componentsCount.get("series");
      };
      GlobalModel2.prototype.eachSeries = function(cb, context) {
        assertSeriesInitialized(this);
        each$5(this._seriesIndices, function(rawSeriesIndex) {
          var series = this._componentsMap.get("series")[rawSeriesIndex];
          cb.call(context, series, rawSeriesIndex);
        }, this);
      };
      GlobalModel2.prototype.eachRawSeries = function(cb, context) {
        each$5(this._componentsMap.get("series"), function(series) {
          series && cb.call(context, series, series.componentIndex);
        });
      };
      GlobalModel2.prototype.eachSeriesByType = function(subType, cb, context) {
        assertSeriesInitialized(this);
        each$5(this._seriesIndices, function(rawSeriesIndex) {
          var series = this._componentsMap.get("series")[rawSeriesIndex];
          if (series.subType === subType) {
            cb.call(context, series, rawSeriesIndex);
          }
        }, this);
      };
      GlobalModel2.prototype.eachRawSeriesByType = function(subType, cb, context) {
        return each$5(this.getSeriesByType(subType), cb, context);
      };
      GlobalModel2.prototype.isSeriesFiltered = function(seriesModel) {
        assertSeriesInitialized(this);
        return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;
      };
      GlobalModel2.prototype.getCurrentSeriesIndices = function() {
        return (this._seriesIndices || []).slice();
      };
      GlobalModel2.prototype.filterSeries = function(cb, context) {
        assertSeriesInitialized(this);
        var newSeriesIndices = [];
        each$5(this._seriesIndices, function(seriesRawIdx) {
          var series = this._componentsMap.get("series")[seriesRawIdx];
          cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx);
        }, this);
        this._seriesIndices = newSeriesIndices;
        this._seriesIndicesMap = createHashMap(newSeriesIndices);
      };
      GlobalModel2.prototype.restoreData = function(payload) {
        reCreateSeriesIndices(this);
        var componentsMap = this._componentsMap;
        var componentTypes = [];
        componentsMap.each(function(components, componentType) {
          if (ComponentModel.hasClass(componentType)) {
            componentTypes.push(componentType);
          }
        });
        ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function(componentType) {
          each$5(componentsMap.get(componentType), function(component) {
            if (component && (componentType !== "series" || !isNotTargetSeries(component, payload))) {
              component.restoreData();
            }
          });
        });
      };
      GlobalModel2.internalField = function() {
        reCreateSeriesIndices = function(ecModel) {
          var seriesIndices = ecModel._seriesIndices = [];
          each$5(ecModel._componentsMap.get("series"), function(series) {
            series && seriesIndices.push(series.componentIndex);
          });
          ecModel._seriesIndicesMap = createHashMap(seriesIndices);
        };
        assertSeriesInitialized = function(ecModel) {
          if (define_process_env_default$C.NODE_ENV !== "production") {
            if (!ecModel._seriesIndices) {
              throw new Error("Option should contains series.");
            }
          }
        };
        initBase = function(ecModel, baseOption) {
          ecModel.option = {};
          ecModel.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE;
          ecModel._componentsMap = createHashMap({
            series: []
          });
          ecModel._componentsCount = createHashMap();
          var airaOption = baseOption.aria;
          if (isObject$2(airaOption) && airaOption.enabled == null) {
            airaOption.enabled = true;
          }
          mergeTheme(baseOption, ecModel._theme.option);
          merge(baseOption, globalDefault, false);
          ecModel._mergeOption(baseOption, null);
        };
      }();
      return GlobalModel2;
    }(Model)
  );
  function isNotTargetSeries(seriesModel, payload) {
    if (payload) {
      var index2 = payload.seriesIndex;
      var id = payload.seriesId;
      var name_1 = payload.seriesName;
      return index2 != null && seriesModel.componentIndex !== index2 || id != null && seriesModel.id !== id || name_1 != null && seriesModel.name !== name_1;
    }
  }
  function mergeTheme(option, theme2) {
    var notMergeColorLayer = option.color && !option.colorLayer;
    each$5(theme2, function(themeItem, name) {
      if (name === "colorLayer" && notMergeColorLayer || name === "color" && option.color) {
        return;
      }
      if (!ComponentModel.hasClass(name)) {
        if (typeof themeItem === "object") {
          option[name] = !option[name] ? clone$2(themeItem) : merge(option[name], themeItem, false);
        } else {
          if (option[name] == null) {
            option[name] = themeItem;
          }
        }
      }
    });
  }
  function queryByIdOrName(attr, idOrName, cmpts) {
    if (isArray(idOrName)) {
      var keyMap_1 = createHashMap();
      each$5(idOrName, function(idOrNameItem) {
        if (idOrNameItem != null) {
          var idName = convertOptionIdName(idOrNameItem, null);
          idName != null && keyMap_1.set(idOrNameItem, true);
        }
      });
      return filter(cmpts, function(cmpt) {
        return cmpt && keyMap_1.get(cmpt[attr]);
      });
    } else {
      var idName_1 = convertOptionIdName(idOrName, null);
      return filter(cmpts, function(cmpt) {
        return cmpt && idName_1 != null && cmpt[attr] === idName_1;
      });
    }
  }
  function filterBySubType(components, condition) {
    return condition.hasOwnProperty("subType") ? filter(components, function(cmpt) {
      return cmpt && cmpt.subType === condition.subType;
    }) : components;
  }
  function normalizeSetOptionInput(opts) {
    var replaceMergeMainTypeMap = createHashMap();
    opts && each$5(normalizeToArray(opts.replaceMerge), function(mainType) {
      if (define_process_env_default$C.NODE_ENV !== "production") {
        assert(ComponentModel.hasClass(mainType), '"' + mainType + '" is not valid component main type in "replaceMerge"');
      }
      replaceMergeMainTypeMap.set(mainType, true);
    });
    return {
      replaceMergeMainTypeMap
    };
  }
  mixin(GlobalModel, PaletteMixin);
  var availableMethods = [
    "getDom",
    "getZr",
    "getWidth",
    "getHeight",
    "getDevicePixelRatio",
    "dispatchAction",
    "isSSR",
    "isDisposed",
    "on",
    "off",
    "getDataURL",
    "getConnectedDataURL",
    // 'getModel',
    "getOption",
    // 'getViewOfComponentModel',
    // 'getViewOfSeriesModel',
    "getId",
    "updateLabelLayout"
  ];
  var ExtensionAPI = (
    /** @class */
    /* @__PURE__ */ function() {
      function ExtensionAPI2(ecInstance) {
        each$5(availableMethods, function(methodName) {
          this[methodName] = bind$1(ecInstance[methodName], ecInstance);
        }, this);
      }
      return ExtensionAPI2;
    }()
  );
  var define_process_env_default$B = {};
  var QUERY_REG = /^(min|max)?(.+)$/;
  var OptionManager = (
    /** @class */
    function() {
      function OptionManager2(api) {
        this._timelineOptions = [];
        this._mediaList = [];
        this._currentMediaIndices = [];
        this._api = api;
      }
      OptionManager2.prototype.setOption = function(rawOption, optionPreprocessorFuncs2, opt) {
        if (rawOption) {
          each$5(normalizeToArray(rawOption.series), function(series) {
            series && series.data && isTypedArray(series.data) && setAsPrimitive(series.data);
          });
          each$5(normalizeToArray(rawOption.dataset), function(dataset) {
            dataset && dataset.source && isTypedArray(dataset.source) && setAsPrimitive(dataset.source);
          });
        }
        rawOption = clone$2(rawOption);
        var optionBackup = this._optionBackup;
        var newParsedOption = parseRawOption(rawOption, optionPreprocessorFuncs2, !optionBackup);
        this._newBaseOption = newParsedOption.baseOption;
        if (optionBackup) {
          if (newParsedOption.timelineOptions.length) {
            optionBackup.timelineOptions = newParsedOption.timelineOptions;
          }
          if (newParsedOption.mediaList.length) {
            optionBackup.mediaList = newParsedOption.mediaList;
          }
          if (newParsedOption.mediaDefault) {
            optionBackup.mediaDefault = newParsedOption.mediaDefault;
          }
        } else {
          this._optionBackup = newParsedOption;
        }
      };
      OptionManager2.prototype.mountOption = function(isRecreate) {
        var optionBackup = this._optionBackup;
        this._timelineOptions = optionBackup.timelineOptions;
        this._mediaList = optionBackup.mediaList;
        this._mediaDefault = optionBackup.mediaDefault;
        this._currentMediaIndices = [];
        return clone$2(isRecreate ? optionBackup.baseOption : this._newBaseOption);
      };
      OptionManager2.prototype.getTimelineOption = function(ecModel) {
        var option;
        var timelineOptions = this._timelineOptions;
        if (timelineOptions.length) {
          var timelineModel = ecModel.getComponent("timeline");
          if (timelineModel) {
            option = clone$2(
              // FIXME:TS as TimelineModel or quivlant interface
              timelineOptions[timelineModel.getCurrentIndex()]
            );
          }
        }
        return option;
      };
      OptionManager2.prototype.getMediaOption = function(ecModel) {
        var ecWidth = this._api.getWidth();
        var ecHeight = this._api.getHeight();
        var mediaList = this._mediaList;
        var mediaDefault = this._mediaDefault;
        var indices = [];
        var result = [];
        if (!mediaList.length && !mediaDefault) {
          return result;
        }
        for (var i = 0, len2 = mediaList.length; i < len2; i++) {
          if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
            indices.push(i);
          }
        }
        if (!indices.length && mediaDefault) {
          indices = [-1];
        }
        if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
          result = map$1(indices, function(index2) {
            return clone$2(index2 === -1 ? mediaDefault.option : mediaList[index2].option);
          });
        }
        this._currentMediaIndices = indices;
        return result;
      };
      return OptionManager2;
    }()
  );
  function parseRawOption(rawOption, optionPreprocessorFuncs2, isNew) {
    var mediaList = [];
    var mediaDefault;
    var baseOption;
    var declaredBaseOption = rawOption.baseOption;
    var timelineOnRoot = rawOption.timeline;
    var timelineOptionsOnRoot = rawOption.options;
    var mediaOnRoot = rawOption.media;
    var hasMedia = !!rawOption.media;
    var hasTimeline = !!(timelineOptionsOnRoot || timelineOnRoot || declaredBaseOption && declaredBaseOption.timeline);
    if (declaredBaseOption) {
      baseOption = declaredBaseOption;
      if (!baseOption.timeline) {
        baseOption.timeline = timelineOnRoot;
      }
    } else {
      if (hasTimeline || hasMedia) {
        rawOption.options = rawOption.media = null;
      }
      baseOption = rawOption;
    }
    if (hasMedia) {
      if (isArray(mediaOnRoot)) {
        each$5(mediaOnRoot, function(singleMedia) {
          if (define_process_env_default$B.NODE_ENV !== "production") {
            if (singleMedia && !singleMedia.option && isObject$2(singleMedia.query) && isObject$2(singleMedia.query.option)) {
              error("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }");
            }
          }
          if (singleMedia && singleMedia.option) {
            if (singleMedia.query) {
              mediaList.push(singleMedia);
            } else if (!mediaDefault) {
              mediaDefault = singleMedia;
            }
          }
        });
      } else {
        if (define_process_env_default$B.NODE_ENV !== "production") {
          error("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }");
        }
      }
    }
    doPreprocess(baseOption);
    each$5(timelineOptionsOnRoot, function(option) {
      return doPreprocess(option);
    });
    each$5(mediaList, function(media) {
      return doPreprocess(media.option);
    });
    function doPreprocess(option) {
      each$5(optionPreprocessorFuncs2, function(preProcess) {
        preProcess(option, isNew);
      });
    }
    return {
      baseOption,
      timelineOptions: timelineOptionsOnRoot || [],
      mediaDefault,
      mediaList
    };
  }
  function applyMediaQuery(query, ecWidth, ecHeight) {
    var realMap = {
      width: ecWidth,
      height: ecHeight,
      aspectratio: ecWidth / ecHeight
      // lower case for convenience.
    };
    var applicable = true;
    each$5(query, function(value, attr) {
      var matched = attr.match(QUERY_REG);
      if (!matched || !matched[1] || !matched[2]) {
        return;
      }
      var operator = matched[1];
      var realAttr = matched[2].toLowerCase();
      if (!compare(realMap[realAttr], value, operator)) {
        applicable = false;
      }
    });
    return applicable;
  }
  function compare(real, expect, operator) {
    if (operator === "min") {
      return real >= expect;
    } else if (operator === "max") {
      return real <= expect;
    } else {
      return real === expect;
    }
  }
  function indicesEquals(indices1, indices2) {
    return indices1.join(",") === indices2.join(",");
  }
  var define_process_env_default$A = {};
  var each$3 = each$5;
  var isObject$1 = isObject$2;
  var POSSIBLE_STYLES = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
  function compatEC2ItemStyle(opt) {
    var itemStyleOpt = opt && opt.itemStyle;
    if (!itemStyleOpt) {
      return;
    }
    for (var i = 0, len2 = POSSIBLE_STYLES.length; i < len2; i++) {
      var styleName = POSSIBLE_STYLES[i];
      var normalItemStyleOpt = itemStyleOpt.normal;
      var emphasisItemStyleOpt = itemStyleOpt.emphasis;
      if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
        if (define_process_env_default$A.NODE_ENV !== "production") {
          deprecateReplaceLog("itemStyle.normal." + styleName, styleName);
        }
        opt[styleName] = opt[styleName] || {};
        if (!opt[styleName].normal) {
          opt[styleName].normal = normalItemStyleOpt[styleName];
        } else {
          merge(opt[styleName].normal, normalItemStyleOpt[styleName]);
        }
        normalItemStyleOpt[styleName] = null;
      }
      if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
        if (define_process_env_default$A.NODE_ENV !== "production") {
          deprecateReplaceLog("itemStyle.emphasis." + styleName, "emphasis." + styleName);
        }
        opt[styleName] = opt[styleName] || {};
        if (!opt[styleName].emphasis) {
          opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
        } else {
          merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
        }
        emphasisItemStyleOpt[styleName] = null;
      }
    }
  }
  function convertNormalEmphasis(opt, optType, useExtend) {
    if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {
      var normalOpt = opt[optType].normal;
      var emphasisOpt = opt[optType].emphasis;
      if (normalOpt) {
        if (define_process_env_default$A.NODE_ENV !== "production") {
          deprecateLog("'normal' hierarchy in " + optType + " has been removed since 4.0. All style properties are configured in " + optType + " directly now.");
        }
        if (useExtend) {
          opt[optType].normal = opt[optType].emphasis = null;
          defaults(opt[optType], normalOpt);
        } else {
          opt[optType] = normalOpt;
        }
      }
      if (emphasisOpt) {
        if (define_process_env_default$A.NODE_ENV !== "production") {
          deprecateLog(optType + ".emphasis has been changed to emphasis." + optType + " since 4.0");
        }
        opt.emphasis = opt.emphasis || {};
        opt.emphasis[optType] = emphasisOpt;
        if (emphasisOpt.focus) {
          opt.emphasis.focus = emphasisOpt.focus;
        }
        if (emphasisOpt.blurScope) {
          opt.emphasis.blurScope = emphasisOpt.blurScope;
        }
      }
    }
  }
  function removeEC3NormalStatus(opt) {
    convertNormalEmphasis(opt, "itemStyle");
    convertNormalEmphasis(opt, "lineStyle");
    convertNormalEmphasis(opt, "areaStyle");
    convertNormalEmphasis(opt, "label");
    convertNormalEmphasis(opt, "labelLine");
    convertNormalEmphasis(opt, "upperLabel");
    convertNormalEmphasis(opt, "edgeLabel");
  }
  function compatTextStyle(opt, propName) {
    var labelOptSingle = isObject$1(opt) && opt[propName];
    var textStyle = isObject$1(labelOptSingle) && labelOptSingle.textStyle;
    if (textStyle) {
      if (define_process_env_default$A.NODE_ENV !== "production") {
        deprecateLog("textStyle hierarchy in " + propName + " has been removed since 4.0. All textStyle properties are configured in " + propName + " directly now.");
      }
      for (var i = 0, len2 = TEXT_STYLE_OPTIONS.length; i < len2; i++) {
        var textPropName = TEXT_STYLE_OPTIONS[i];
        if (textStyle.hasOwnProperty(textPropName)) {
          labelOptSingle[textPropName] = textStyle[textPropName];
        }
      }
    }
  }
  function compatEC3CommonStyles(opt) {
    if (opt) {
      removeEC3NormalStatus(opt);
      compatTextStyle(opt, "label");
      opt.emphasis && compatTextStyle(opt.emphasis, "label");
    }
  }
  function processSeries(seriesOpt) {
    if (!isObject$1(seriesOpt)) {
      return;
    }
    compatEC2ItemStyle(seriesOpt);
    removeEC3NormalStatus(seriesOpt);
    compatTextStyle(seriesOpt, "label");
    compatTextStyle(seriesOpt, "upperLabel");
    compatTextStyle(seriesOpt, "edgeLabel");
    if (seriesOpt.emphasis) {
      compatTextStyle(seriesOpt.emphasis, "label");
      compatTextStyle(seriesOpt.emphasis, "upperLabel");
      compatTextStyle(seriesOpt.emphasis, "edgeLabel");
    }
    var markPoint = seriesOpt.markPoint;
    if (markPoint) {
      compatEC2ItemStyle(markPoint);
      compatEC3CommonStyles(markPoint);
    }
    var markLine = seriesOpt.markLine;
    if (markLine) {
      compatEC2ItemStyle(markLine);
      compatEC3CommonStyles(markLine);
    }
    var markArea = seriesOpt.markArea;
    if (markArea) {
      compatEC3CommonStyles(markArea);
    }
    var data = seriesOpt.data;
    if (seriesOpt.type === "graph") {
      data = data || seriesOpt.nodes;
      var edgeData = seriesOpt.links || seriesOpt.edges;
      if (edgeData && !isTypedArray(edgeData)) {
        for (var i = 0; i < edgeData.length; i++) {
          compatEC3CommonStyles(edgeData[i]);
        }
      }
      each$5(seriesOpt.categories, function(opt) {
        removeEC3NormalStatus(opt);
      });
    }
    if (data && !isTypedArray(data)) {
      for (var i = 0; i < data.length; i++) {
        compatEC3CommonStyles(data[i]);
      }
    }
    markPoint = seriesOpt.markPoint;
    if (markPoint && markPoint.data) {
      var mpData = markPoint.data;
      for (var i = 0; i < mpData.length; i++) {
        compatEC3CommonStyles(mpData[i]);
      }
    }
    markLine = seriesOpt.markLine;
    if (markLine && markLine.data) {
      var mlData = markLine.data;
      for (var i = 0; i < mlData.length; i++) {
        if (isArray(mlData[i])) {
          compatEC3CommonStyles(mlData[i][0]);
          compatEC3CommonStyles(mlData[i][1]);
        } else {
          compatEC3CommonStyles(mlData[i]);
        }
      }
    }
    if (seriesOpt.type === "gauge") {
      compatTextStyle(seriesOpt, "axisLabel");
      compatTextStyle(seriesOpt, "title");
      compatTextStyle(seriesOpt, "detail");
    } else if (seriesOpt.type === "treemap") {
      convertNormalEmphasis(seriesOpt.breadcrumb, "itemStyle");
      each$5(seriesOpt.levels, function(opt) {
        removeEC3NormalStatus(opt);
      });
    } else if (seriesOpt.type === "tree") {
      removeEC3NormalStatus(seriesOpt.leaves);
    }
  }
  function toArr(o) {
    return isArray(o) ? o : o ? [o] : [];
  }
  function toObj(o) {
    return (isArray(o) ? o[0] : o) || {};
  }
  function globalCompatStyle(option, isTheme) {
    each$3(toArr(option.series), function(seriesOpt) {
      isObject$1(seriesOpt) && processSeries(seriesOpt);
    });
    var axes = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
    isTheme && axes.push("valueAxis", "categoryAxis", "logAxis", "timeAxis");
    each$3(axes, function(axisName) {
      each$3(toArr(option[axisName]), function(axisOpt) {
        if (axisOpt) {
          compatTextStyle(axisOpt, "axisLabel");
          compatTextStyle(axisOpt.axisPointer, "label");
        }
      });
    });
    each$3(toArr(option.parallel), function(parallelOpt) {
      var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
      compatTextStyle(parallelAxisDefault, "axisLabel");
      compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, "label");
    });
    each$3(toArr(option.calendar), function(calendarOpt) {
      convertNormalEmphasis(calendarOpt, "itemStyle");
      compatTextStyle(calendarOpt, "dayLabel");
      compatTextStyle(calendarOpt, "monthLabel");
      compatTextStyle(calendarOpt, "yearLabel");
    });
    each$3(toArr(option.radar), function(radarOpt) {
      compatTextStyle(radarOpt, "name");
      if (radarOpt.name && radarOpt.axisName == null) {
        radarOpt.axisName = radarOpt.name;
        delete radarOpt.name;
        if (define_process_env_default$A.NODE_ENV !== "production") {
          deprecateLog("name property in radar component has been changed to axisName");
        }
      }
      if (radarOpt.nameGap != null && radarOpt.axisNameGap == null) {
        radarOpt.axisNameGap = radarOpt.nameGap;
        delete radarOpt.nameGap;
        if (define_process_env_default$A.NODE_ENV !== "production") {
          deprecateLog("nameGap property in radar component has been changed to axisNameGap");
        }
      }
      if (define_process_env_default$A.NODE_ENV !== "production") {
        each$3(radarOpt.indicator, function(indicatorOpt) {
          if (indicatorOpt.text) {
            deprecateReplaceLog("text", "name", "radar.indicator");
          }
        });
      }
    });
    each$3(toArr(option.geo), function(geoOpt) {
      if (isObject$1(geoOpt)) {
        compatEC3CommonStyles(geoOpt);
        each$3(toArr(geoOpt.regions), function(regionObj) {
          compatEC3CommonStyles(regionObj);
        });
      }
    });
    each$3(toArr(option.timeline), function(timelineOpt) {
      compatEC3CommonStyles(timelineOpt);
      convertNormalEmphasis(timelineOpt, "label");
      convertNormalEmphasis(timelineOpt, "itemStyle");
      convertNormalEmphasis(timelineOpt, "controlStyle", true);
      var data = timelineOpt.data;
      isArray(data) && each$5(data, function(item) {
        if (isObject$2(item)) {
          convertNormalEmphasis(item, "label");
          convertNormalEmphasis(item, "itemStyle");
        }
      });
    });
    each$3(toArr(option.toolbox), function(toolboxOpt) {
      convertNormalEmphasis(toolboxOpt, "iconStyle");
      each$3(toolboxOpt.feature, function(featureOpt) {
        convertNormalEmphasis(featureOpt, "iconStyle");
      });
    });
    compatTextStyle(toObj(option.axisPointer), "label");
    compatTextStyle(toObj(option.tooltip).axisPointer, "label");
  }
  var define_process_env_default$z = {};
  function get(opt, path) {
    var pathArr = path.split(",");
    var obj = opt;
    for (var i = 0; i < pathArr.length; i++) {
      obj = obj && obj[pathArr[i]];
      if (obj == null) {
        break;
      }
    }
    return obj;
  }
  function set(opt, path, val, overwrite) {
    var pathArr = path.split(",");
    var obj = opt;
    var key2;
    var i = 0;
    for (; i < pathArr.length - 1; i++) {
      key2 = pathArr[i];
      if (obj[key2] == null) {
        obj[key2] = {};
      }
      obj = obj[key2];
    }
    if (obj[pathArr[i]] == null) {
      obj[pathArr[i]] = val;
    }
  }
  function compatLayoutProperties(option) {
    option && each$5(LAYOUT_PROPERTIES, function(prop) {
      if (prop[0] in option && !(prop[1] in option)) {
        option[prop[1]] = option[prop[0]];
      }
    });
  }
  var LAYOUT_PROPERTIES = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]];
  var COMPATITABLE_COMPONENTS = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"];
  var BAR_ITEM_STYLE_MAP = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
  function compatBarItemStyle(option) {
    var itemStyle = option && option.itemStyle;
    if (itemStyle) {
      for (var i = 0; i < BAR_ITEM_STYLE_MAP.length; i++) {
        var oldName = BAR_ITEM_STYLE_MAP[i][1];
        var newName = BAR_ITEM_STYLE_MAP[i][0];
        if (itemStyle[oldName] != null) {
          itemStyle[newName] = itemStyle[oldName];
          if (define_process_env_default$z.NODE_ENV !== "production") {
            deprecateReplaceLog(oldName, newName);
          }
        }
      }
    }
  }
  function compatPieLabel(option) {
    if (!option) {
      return;
    }
    if (option.alignTo === "edge" && option.margin != null && option.edgeDistance == null) {
      if (define_process_env_default$z.NODE_ENV !== "production") {
        deprecateReplaceLog("label.margin", "label.edgeDistance", "pie");
      }
      option.edgeDistance = option.margin;
    }
  }
  function compatSunburstState(option) {
    if (!option) {
      return;
    }
    if (option.downplay && !option.blur) {
      option.blur = option.downplay;
      if (define_process_env_default$z.NODE_ENV !== "production") {
        deprecateReplaceLog("downplay", "blur", "sunburst");
      }
    }
  }
  function compatGraphFocus(option) {
    if (!option) {
      return;
    }
    if (option.focusNodeAdjacency != null) {
      option.emphasis = option.emphasis || {};
      if (option.emphasis.focus == null) {
        if (define_process_env_default$z.NODE_ENV !== "production") {
          deprecateReplaceLog("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey");
        }
        option.emphasis.focus = "adjacency";
      }
    }
  }
  function traverseTree(data, cb) {
    if (data) {
      for (var i = 0; i < data.length; i++) {
        cb(data[i]);
        data[i] && traverseTree(data[i].children, cb);
      }
    }
  }
  function globalBackwardCompat(option, isTheme) {
    globalCompatStyle(option, isTheme);
    option.series = normalizeToArray(option.series);
    each$5(option.series, function(seriesOpt) {
      if (!isObject$2(seriesOpt)) {
        return;
      }
      var seriesType2 = seriesOpt.type;
      if (seriesType2 === "line") {
        if (seriesOpt.clipOverflow != null) {
          seriesOpt.clip = seriesOpt.clipOverflow;
          if (define_process_env_default$z.NODE_ENV !== "production") {
            deprecateReplaceLog("clipOverflow", "clip", "line");
          }
        }
      } else if (seriesType2 === "pie" || seriesType2 === "gauge") {
        if (seriesOpt.clockWise != null) {
          seriesOpt.clockwise = seriesOpt.clockWise;
          if (define_process_env_default$z.NODE_ENV !== "production") {
            deprecateReplaceLog("clockWise", "clockwise");
          }
        }
        compatPieLabel(seriesOpt.label);
        var data = seriesOpt.data;
        if (data && !isTypedArray(data)) {
          for (var i = 0; i < data.length; i++) {
            compatPieLabel(data[i]);
          }
        }
        if (seriesOpt.hoverOffset != null) {
          seriesOpt.emphasis = seriesOpt.emphasis || {};
          if (seriesOpt.emphasis.scaleSize = null) {
            if (define_process_env_default$z.NODE_ENV !== "production") {
              deprecateReplaceLog("hoverOffset", "emphasis.scaleSize");
            }
            seriesOpt.emphasis.scaleSize = seriesOpt.hoverOffset;
          }
        }
      } else if (seriesType2 === "gauge") {
        var pointerColor = get(seriesOpt, "pointer.color");
        pointerColor != null && set(seriesOpt, "itemStyle.color", pointerColor);
      } else if (seriesType2 === "bar") {
        compatBarItemStyle(seriesOpt);
        compatBarItemStyle(seriesOpt.backgroundStyle);
        compatBarItemStyle(seriesOpt.emphasis);
        var data = seriesOpt.data;
        if (data && !isTypedArray(data)) {
          for (var i = 0; i < data.length; i++) {
            if (typeof data[i] === "object") {
              compatBarItemStyle(data[i]);
              compatBarItemStyle(data[i] && data[i].emphasis);
            }
          }
        }
      } else if (seriesType2 === "sunburst") {
        var highlightPolicy = seriesOpt.highlightPolicy;
        if (highlightPolicy) {
          seriesOpt.emphasis = seriesOpt.emphasis || {};
          if (!seriesOpt.emphasis.focus) {
            seriesOpt.emphasis.focus = highlightPolicy;
            if (define_process_env_default$z.NODE_ENV !== "production") {
              deprecateReplaceLog("highlightPolicy", "emphasis.focus", "sunburst");
            }
          }
        }
        compatSunburstState(seriesOpt);
        traverseTree(seriesOpt.data, compatSunburstState);
      } else if (seriesType2 === "graph" || seriesType2 === "sankey") {
        compatGraphFocus(seriesOpt);
      } else if (seriesType2 === "map") {
        if (seriesOpt.mapType && !seriesOpt.map) {
          if (define_process_env_default$z.NODE_ENV !== "production") {
            deprecateReplaceLog("mapType", "map", "map");
          }
          seriesOpt.map = seriesOpt.mapType;
        }
        if (seriesOpt.mapLocation) {
          if (define_process_env_default$z.NODE_ENV !== "production") {
            deprecateLog("`mapLocation` is not used anymore.");
          }
          defaults(seriesOpt, seriesOpt.mapLocation);
        }
      }
      if (seriesOpt.hoverAnimation != null) {
        seriesOpt.emphasis = seriesOpt.emphasis || {};
        if (seriesOpt.emphasis && seriesOpt.emphasis.scale == null) {
          if (define_process_env_default$z.NODE_ENV !== "production") {
            deprecateReplaceLog("hoverAnimation", "emphasis.scale");
          }
          seriesOpt.emphasis.scale = seriesOpt.hoverAnimation;
        }
      }
      compatLayoutProperties(seriesOpt);
    });
    if (option.dataRange) {
      option.visualMap = option.dataRange;
    }
    each$5(COMPATITABLE_COMPONENTS, function(componentName) {
      var options = option[componentName];
      if (options) {
        if (!isArray(options)) {
          options = [options];
        }
        each$5(options, function(option2) {
          compatLayoutProperties(option2);
        });
      }
    });
  }
  function dataStack(ecModel) {
    var stackInfoMap = createHashMap();
    ecModel.eachSeries(function(seriesModel) {
      var stack = seriesModel.get("stack");
      if (stack) {
        var stackInfoList = stackInfoMap.get(stack) || stackInfoMap.set(stack, []);
        var data = seriesModel.getData();
        var stackInfo = {
          // Used for calculate axis extent automatically.
          // TODO: Type getCalculationInfo return more specific type?
          stackResultDimension: data.getCalculationInfo("stackResultDimension"),
          stackedOverDimension: data.getCalculationInfo("stackedOverDimension"),
          stackedDimension: data.getCalculationInfo("stackedDimension"),
          stackedByDimension: data.getCalculationInfo("stackedByDimension"),
          isStackedByIndex: data.getCalculationInfo("isStackedByIndex"),
          data,
          seriesModel
        };
        if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) {
          return;
        }
        stackInfoList.push(stackInfo);
      }
    });
    stackInfoMap.each(function(stackInfoList) {
      if (stackInfoList.length === 0) {
        return;
      }
      var firstSeries = stackInfoList[0].seriesModel;
      var stackOrder = firstSeries.get("stackOrder") || "seriesAsc";
      if (stackOrder === "seriesDesc") {
        stackInfoList.reverse();
      }
      each$5(stackInfoList, function(stackInfo, index2) {
        stackInfo.data.setCalculationInfo("stackedOnSeries", index2 > 0 ? stackInfoList[index2 - 1].seriesModel : null);
      });
      calculateStack(stackInfoList);
    });
  }
  function calculateStack(stackInfoList) {
    each$5(stackInfoList, function(targetStackInfo, idxInStack) {
      var resultVal = [];
      var resultNaN = [NaN, NaN];
      var dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension];
      var targetData = targetStackInfo.data;
      var isStackedByIndex = targetStackInfo.isStackedByIndex;
      var stackStrategy = targetStackInfo.seriesModel.get("stackStrategy") || "samesign";
      targetData.modify(dims, function(v0, v1, dataIndex) {
        var sum = targetData.get(targetStackInfo.stackedDimension, dataIndex);
        if (isNaN(sum)) {
          return resultNaN;
        }
        var byValue;
        var stackedDataRawIndex;
        if (isStackedByIndex) {
          stackedDataRawIndex = targetData.getRawIndex(dataIndex);
        } else {
          byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);
        }
        var stackedOver = NaN;
        for (var j = idxInStack - 1; j >= 0; j--) {
          var stackInfo = stackInfoList[j];
          if (!isStackedByIndex) {
            stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue);
          }
          if (stackedDataRawIndex >= 0) {
            var val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex);
            if (stackStrategy === "all" || stackStrategy === "positive" && val > 0 || stackStrategy === "negative" && val < 0 || stackStrategy === "samesign" && sum >= 0 && val > 0 || stackStrategy === "samesign" && sum <= 0 && val < 0) {
              sum = addSafe(sum, val);
              stackedOver = val;
              break;
            }
          }
        }
        resultVal[0] = sum;
        resultVal[1] = stackedOver;
        return resultVal;
      });
    });
  }
  var define_process_env_default$y = {};
  var SourceImpl = (
    /** @class */
    /* @__PURE__ */ function() {
      function SourceImpl2(fields) {
        this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []);
        this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN;
        this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN;
        this.startIndex = fields.startIndex || 0;
        this.dimensionsDetectedCount = fields.dimensionsDetectedCount;
        this.metaRawOption = fields.metaRawOption;
        var dimensionsDefine = this.dimensionsDefine = fields.dimensionsDefine;
        if (dimensionsDefine) {
          for (var i = 0; i < dimensionsDefine.length; i++) {
            var dim = dimensionsDefine[i];
            if (dim.type == null) {
              if (guessOrdinal(this, i) === BE_ORDINAL.Must) {
                dim.type = "ordinal";
              }
            }
          }
        }
      }
      return SourceImpl2;
    }()
  );
  function isSourceInstance(val) {
    return val instanceof SourceImpl;
  }
  function createSource(sourceData, thisMetaRawOption, sourceFormat) {
    sourceFormat = sourceFormat || detectSourceFormat(sourceData);
    var seriesLayoutBy = thisMetaRawOption.seriesLayoutBy;
    var determined = determineSourceDimensions(sourceData, sourceFormat, seriesLayoutBy, thisMetaRawOption.sourceHeader, thisMetaRawOption.dimensions);
    var source = new SourceImpl({
      data: sourceData,
      sourceFormat,
      seriesLayoutBy,
      dimensionsDefine: determined.dimensionsDefine,
      startIndex: determined.startIndex,
      dimensionsDetectedCount: determined.dimensionsDetectedCount,
      metaRawOption: clone$2(thisMetaRawOption)
    });
    return source;
  }
  function createSourceFromSeriesDataOption(data) {
    return new SourceImpl({
      data,
      sourceFormat: isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL
    });
  }
  function cloneSourceShallow(source) {
    return new SourceImpl({
      data: source.data,
      sourceFormat: source.sourceFormat,
      seriesLayoutBy: source.seriesLayoutBy,
      dimensionsDefine: clone$2(source.dimensionsDefine),
      startIndex: source.startIndex,
      dimensionsDetectedCount: source.dimensionsDetectedCount
    });
  }
  function detectSourceFormat(data) {
    var sourceFormat = SOURCE_FORMAT_UNKNOWN;
    if (isTypedArray(data)) {
      sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;
    } else if (isArray(data)) {
      if (data.length === 0) {
        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
      }
      for (var i = 0, len2 = data.length; i < len2; i++) {
        var item = data[i];
        if (item == null) {
          continue;
        } else if (isArray(item) || isTypedArray(item)) {
          sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
          break;
        } else if (isObject$2(item)) {
          sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;
          break;
        }
      }
    } else if (isObject$2(data)) {
      for (var key2 in data) {
        if (hasOwn(data, key2) && isArrayLike(data[key2])) {
          sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;
          break;
        }
      }
    }
    return sourceFormat;
  }
  function determineSourceDimensions(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {
    var dimensionsDetectedCount;
    var startIndex;
    if (!data) {
      return {
        dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
        startIndex,
        dimensionsDetectedCount
      };
    }
    if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
      var dataArrayRows = data;
      if (sourceHeader === "auto" || sourceHeader == null) {
        arrayRowsTravelFirst(function(val) {
          if (val != null && val !== "-") {
            if (isString(val)) {
              startIndex == null && (startIndex = 1);
            } else {
              startIndex = 0;
            }
          }
        }, seriesLayoutBy, dataArrayRows, 10);
      } else {
        startIndex = isNumber(sourceHeader) ? sourceHeader : sourceHeader ? 1 : 0;
      }
      if (!dimensionsDefine && startIndex === 1) {
        dimensionsDefine = [];
        arrayRowsTravelFirst(function(val, index2) {
          dimensionsDefine[index2] = val != null ? val + "" : "";
        }, seriesLayoutBy, dataArrayRows, Infinity);
      }
      dimensionsDetectedCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? dataArrayRows.length : dataArrayRows[0] ? dataArrayRows[0].length : null;
    } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
      if (!dimensionsDefine) {
        dimensionsDefine = objectRowsCollectDimensions(data);
      }
    } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
      if (!dimensionsDefine) {
        dimensionsDefine = [];
        each$5(data, function(colArr, key2) {
          dimensionsDefine.push(key2);
        });
      }
    } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
      var value0 = getDataItemValue(data[0]);
      dimensionsDetectedCount = isArray(value0) && value0.length || 1;
    } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
      if (define_process_env_default$y.NODE_ENV !== "production") {
        assert(!!dimensionsDefine, "dimensions must be given if data is TypedArray.");
      }
    }
    return {
      startIndex,
      dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
      dimensionsDetectedCount
    };
  }
  function objectRowsCollectDimensions(data) {
    var firstIndex = 0;
    var obj;
    while (firstIndex < data.length && !(obj = data[firstIndex++])) {
    }
    if (obj) {
      return keys(obj);
    }
  }
  function normalizeDimensionsOption(dimensionsDefine) {
    if (!dimensionsDefine) {
      return;
    }
    var nameMap = createHashMap();
    return map$1(dimensionsDefine, function(rawItem, index2) {
      rawItem = isObject$2(rawItem) ? rawItem : {
        name: rawItem
      };
      var item = {
        name: rawItem.name,
        displayName: rawItem.displayName,
        type: rawItem.type
      };
      if (item.name == null) {
        return item;
      }
      item.name += "";
      if (item.displayName == null) {
        item.displayName = item.name;
      }
      var exist = nameMap.get(item.name);
      if (!exist) {
        nameMap.set(item.name, {
          count: 1
        });
      } else {
        item.name += "-" + exist.count++;
      }
      return item;
    });
  }
  function arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {
    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
      for (var i = 0; i < data.length && i < maxLoop; i++) {
        cb(data[i] ? data[i][0] : null, i);
      }
    } else {
      var value0 = data[0] || [];
      for (var i = 0; i < value0.length && i < maxLoop; i++) {
        cb(value0[i], i);
      }
    }
  }
  function shouldRetrieveDataByName(source) {
    var sourceFormat = source.sourceFormat;
    return sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS;
  }
  var define_process_env_default$x = {};
  var _a, _b, _c, _d;
  var providerMethods;
  var mountMethods;
  var DefaultDataProvider = (
    /** @class */
    function() {
      function DefaultDataProvider2(sourceParam, dimSize) {
        var source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam;
        this._source = source;
        var data = this._data = source.data;
        var sourceFormat = source.sourceFormat;
        var seriesLayoutBy = source.seriesLayoutBy;
        if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
          if (define_process_env_default$x.NODE_ENV !== "production") {
            if (dimSize == null) {
              throw new Error("Typed array data must specify dimension size");
            }
          }
          this._offset = 0;
          this._dimSize = dimSize;
          this._data = data;
        }
        if (define_process_env_default$x.NODE_ENV !== "production") {
          var validator2 = rawSourceDataValidatorMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
          validator2 && validator2(data, source.dimensionsDefine);
        }
        mountMethods(this, data, source);
      }
      DefaultDataProvider2.prototype.getSource = function() {
        return this._source;
      };
      DefaultDataProvider2.prototype.count = function() {
        return 0;
      };
      DefaultDataProvider2.prototype.getItem = function(idx, out2) {
        return;
      };
      DefaultDataProvider2.prototype.appendData = function(newData) {
      };
      DefaultDataProvider2.prototype.clean = function() {
      };
      DefaultDataProvider2.protoInitialize = function() {
        var proto = DefaultDataProvider2.prototype;
        proto.pure = false;
        proto.persistent = true;
      }();
      DefaultDataProvider2.internalField = function() {
        var _a2;
        mountMethods = function(provider, data, source) {
          var sourceFormat = source.sourceFormat;
          var seriesLayoutBy = source.seriesLayoutBy;
          var startIndex = source.startIndex;
          var dimsDef = source.dimensionsDefine;
          var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];
          if (define_process_env_default$x.NODE_ENV !== "production") {
            assert(methods, "Invalide sourceFormat: " + sourceFormat);
          }
          extend(provider, methods);
          if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
            provider.getItem = getItemForTypedArray;
            provider.count = countForTypedArray;
            provider.fillStorage = fillStorageForTypedArray;
          } else {
            var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);
            provider.getItem = bind$1(rawItemGetter, null, data, startIndex, dimsDef);
            var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);
            provider.count = bind$1(rawCounter, null, data, startIndex, dimsDef);
          }
        };
        var getItemForTypedArray = function(idx, out2) {
          idx = idx - this._offset;
          out2 = out2 || [];
          var data = this._data;
          var dimSize = this._dimSize;
          var offset = dimSize * idx;
          for (var i = 0; i < dimSize; i++) {
            out2[i] = data[offset + i];
          }
          return out2;
        };
        var fillStorageForTypedArray = function(start2, end2, storage, extent) {
          var data = this._data;
          var dimSize = this._dimSize;
          for (var dim = 0; dim < dimSize; dim++) {
            var dimExtent = extent[dim];
            var min3 = dimExtent[0] == null ? Infinity : dimExtent[0];
            var max3 = dimExtent[1] == null ? -Infinity : dimExtent[1];
            var count = end2 - start2;
            var arr = storage[dim];
            for (var i = 0; i < count; i++) {
              var val = data[i * dimSize + dim];
              arr[start2 + i] = val;
              val < min3 && (min3 = val);
              val > max3 && (max3 = val);
            }
            dimExtent[0] = min3;
            dimExtent[1] = max3;
          }
        };
        var countForTypedArray = function() {
          return this._data ? this._data.length / this._dimSize : 0;
        };
        providerMethods = (_a2 = {}, _a2[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = {
          pure: true,
          appendData: appendDataSimply
        }, _a2[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = {
          pure: true,
          appendData: function() {
            throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
          }
        }, _a2[SOURCE_FORMAT_OBJECT_ROWS] = {
          pure: true,
          appendData: appendDataSimply
        }, _a2[SOURCE_FORMAT_KEYED_COLUMNS] = {
          pure: true,
          appendData: function(newData) {
            var data = this._data;
            each$5(newData, function(newCol, key2) {
              var oldCol = data[key2] || (data[key2] = []);
              for (var i = 0; i < (newCol || []).length; i++) {
                oldCol.push(newCol[i]);
              }
            });
          }
        }, _a2[SOURCE_FORMAT_ORIGINAL] = {
          appendData: appendDataSimply
        }, _a2[SOURCE_FORMAT_TYPED_ARRAY] = {
          persistent: false,
          pure: true,
          appendData: function(newData) {
            if (define_process_env_default$x.NODE_ENV !== "production") {
              assert(isTypedArray(newData), "Added data must be TypedArray if data in initialization is TypedArray");
            }
            this._data = newData;
          },
          // Clean self if data is already used.
          clean: function() {
            this._offset += this.count();
            this._data = null;
          }
        }, _a2);
        function appendDataSimply(newData) {
          for (var i = 0; i < newData.length; i++) {
            this._data.push(newData[i]);
          }
        }
      }();
      return DefaultDataProvider2;
    }()
  );
  var validateSimply = function(rawData) {
    if (!isArray(rawData)) {
      error("series.data or dataset.source must be an array.");
    }
  };
  var rawSourceDataValidatorMap = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = validateSimply, _a[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = validateSimply, _a[SOURCE_FORMAT_OBJECT_ROWS] = validateSimply, _a[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, dimsDef) {
    for (var i = 0; i < dimsDef.length; i++) {
      var dimName = dimsDef[i].name;
      if (dimName == null) {
        error("dimension name must not be null/undefined.");
      }
    }
  }, _a[SOURCE_FORMAT_ORIGINAL] = validateSimply, _a);
  var getItemSimply = function(rawData, startIndex, dimsDef, idx) {
    return rawData[idx];
  };
  var rawSourceItemGetterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(rawData, startIndex, dimsDef, idx) {
    return rawData[idx + startIndex];
  }, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(rawData, startIndex, dimsDef, idx, out2) {
    idx += startIndex;
    var item = out2 || [];
    var data = rawData;
    for (var i = 0; i < data.length; i++) {
      var row = data[i];
      item[i] = row ? row[idx] : null;
    }
    return item;
  }, _b[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, startIndex, dimsDef, idx, out2) {
    var item = out2 || [];
    for (var i = 0; i < dimsDef.length; i++) {
      var dimName = dimsDef[i].name;
      var col = dimName != null ? rawData[dimName] : null;
      item[i] = col ? col[idx] : null;
    }
    return item;
  }, _b[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _b);
  function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {
    var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
    if (define_process_env_default$x.NODE_ENV !== "production") {
      assert(method, 'Do not support get item on "' + sourceFormat + '", "' + seriesLayoutBy + '".');
    }
    return method;
  }
  var countSimply = function(rawData, startIndex, dimsDef) {
    return rawData.length;
  };
  var rawSourceDataCounterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(rawData, startIndex, dimsDef) {
    return Math.max(0, rawData.length - startIndex);
  }, _c[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(rawData, startIndex, dimsDef) {
    var row = rawData[0];
    return row ? Math.max(0, row.length - startIndex) : 0;
  }, _c[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _c[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, startIndex, dimsDef) {
    var dimName = dimsDef[0].name;
    var col = dimName != null ? rawData[dimName] : null;
    return col ? col.length : 0;
  }, _c[SOURCE_FORMAT_ORIGINAL] = countSimply, _c);
  function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {
    var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
    if (define_process_env_default$x.NODE_ENV !== "production") {
      assert(method, 'Do not support count on "' + sourceFormat + '", "' + seriesLayoutBy + '".');
    }
    return method;
  }
  var getRawValueSimply = function(dataItem, dimIndex, property) {
    return dataItem[dimIndex];
  };
  var rawSourceValueGetterMap = (_d = {}, _d[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _d[SOURCE_FORMAT_OBJECT_ROWS] = function(dataItem, dimIndex, property) {
    return dataItem[property];
  }, _d[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _d[SOURCE_FORMAT_ORIGINAL] = function(dataItem, dimIndex, property) {
    var value = getDataItemValue(dataItem);
    return !(value instanceof Array) ? value : value[dimIndex];
  }, _d[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _d);
  function getRawSourceValueGetter(sourceFormat) {
    var method = rawSourceValueGetterMap[sourceFormat];
    if (define_process_env_default$x.NODE_ENV !== "production") {
      assert(method, 'Do not support get value on "' + sourceFormat + '".');
    }
    return method;
  }
  function getMethodMapKey(sourceFormat, seriesLayoutBy) {
    return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + "_" + seriesLayoutBy : sourceFormat;
  }
  function retrieveRawValue(data, dataIndex, dim) {
    if (!data) {
      return;
    }
    var dataItem = data.getRawDataItem(dataIndex);
    if (dataItem == null) {
      return;
    }
    var store = data.getStore();
    var sourceFormat = store.getSource().sourceFormat;
    if (dim != null) {
      var dimIndex = data.getDimensionIndex(dim);
      var property = store.getDimensionProperty(dimIndex);
      return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property);
    } else {
      var result = dataItem;
      if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
        result = getDataItemValue(dataItem);
      }
      return result;
    }
  }
  var define_process_env_default$w = {};
  var DIMENSION_LABEL_REG = /\{@(.+?)\}/g;
  var DataFormatMixin = (
    /** @class */
    function() {
      function DataFormatMixin2() {
      }
      DataFormatMixin2.prototype.getDataParams = function(dataIndex, dataType) {
        var data = this.getData(dataType);
        var rawValue = this.getRawValue(dataIndex, dataType);
        var rawDataIndex = data.getRawIndex(dataIndex);
        var name = data.getName(dataIndex);
        var itemOpt = data.getRawDataItem(dataIndex);
        var style = data.getItemVisual(dataIndex, "style");
        var color2 = style && style[data.getItemVisual(dataIndex, "drawType") || "fill"];
        var borderColor = style && style.stroke;
        var mainType = this.mainType;
        var isSeries2 = mainType === "series";
        var userOutput = data.userOutput && data.userOutput.get();
        return {
          componentType: mainType,
          componentSubType: this.subType,
          componentIndex: this.componentIndex,
          seriesType: isSeries2 ? this.subType : null,
          seriesIndex: this.seriesIndex,
          seriesId: isSeries2 ? this.id : null,
          seriesName: isSeries2 ? this.name : null,
          name,
          dataIndex: rawDataIndex,
          data: itemOpt,
          dataType,
          value: rawValue,
          color: color2,
          borderColor,
          dimensionNames: userOutput ? userOutput.fullDimensions : null,
          encode: userOutput ? userOutput.encode : null,
          // Param name list for mapping `a`, `b`, `c`, `d`, `e`
          $vars: ["seriesName", "name", "value"]
        };
      };
      DataFormatMixin2.prototype.getFormattedLabel = function(dataIndex, status, dataType, labelDimIndex, formatter, extendParams) {
        status = status || "normal";
        var data = this.getData(dataType);
        var params = this.getDataParams(dataIndex, dataType);
        if (extendParams) {
          params.value = extendParams.interpolatedValue;
        }
        if (labelDimIndex != null && isArray(params.value)) {
          params.value = params.value[labelDimIndex];
        }
        if (!formatter) {
          var itemModel = data.getItemModel(dataIndex);
          formatter = itemModel.get(status === "normal" ? ["label", "formatter"] : [status, "label", "formatter"]);
        }
        if (isFunction(formatter)) {
          params.status = status;
          params.dimensionIndex = labelDimIndex;
          return formatter(params);
        } else if (isString(formatter)) {
          var str = formatTpl(formatter, params);
          return str.replace(DIMENSION_LABEL_REG, function(origin2, dimStr) {
            var len2 = dimStr.length;
            var dimLoose = dimStr;
            if (dimLoose.charAt(0) === "[" && dimLoose.charAt(len2 - 1) === "]") {
              dimLoose = +dimLoose.slice(1, len2 - 1);
              if (define_process_env_default$w.NODE_ENV !== "production") {
                if (isNaN(dimLoose)) {
                  error("Invalide label formatter: @" + dimStr + ", only support @[0], @[1], @[2], ...");
                }
              }
            }
            var val = retrieveRawValue(data, dataIndex, dimLoose);
            if (extendParams && isArray(extendParams.interpolatedValue)) {
              var dimIndex = data.getDimensionIndex(dimLoose);
              if (dimIndex >= 0) {
                val = extendParams.interpolatedValue[dimIndex];
              }
            }
            return val != null ? val + "" : "";
          });
        }
      };
      DataFormatMixin2.prototype.getRawValue = function(idx, dataType) {
        return retrieveRawValue(this.getData(dataType), idx);
      };
      DataFormatMixin2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
        return;
      };
      return DataFormatMixin2;
    }()
  );
  function normalizeTooltipFormatResult(result) {
    var markupText;
    var markupFragment;
    if (isObject$2(result)) {
      if (result.type) {
        markupFragment = result;
      } else {
        if (define_process_env_default$w.NODE_ENV !== "production") {
          console.warn("The return type of `formatTooltip` is not supported: " + makePrintable(result));
        }
      }
    } else {
      markupText = result;
    }
    return {
      text: markupText,
      // markers: markers || markersExisting,
      frag: markupFragment
    };
  }
  var define_process_env_default$v = {};
  function createTask(define) {
    return new Task(define);
  }
  var Task = (
    /** @class */
    function() {
      function Task2(define) {
        define = define || {};
        this._reset = define.reset;
        this._plan = define.plan;
        this._count = define.count;
        this._onDirty = define.onDirty;
        this._dirty = true;
      }
      Task2.prototype.perform = function(performArgs) {
        var upTask = this._upstream;
        var skip = performArgs && performArgs.skip;
        if (this._dirty && upTask) {
          var context = this.context;
          context.data = context.outputData = upTask.context.outputData;
        }
        if (this.__pipeline) {
          this.__pipeline.currentTask = this;
        }
        var planResult;
        if (this._plan && !skip) {
          planResult = this._plan(this.context);
        }
        var lastModBy = normalizeModBy(this._modBy);
        var lastModDataCount = this._modDataCount || 0;
        var modBy = normalizeModBy(performArgs && performArgs.modBy);
        var modDataCount = performArgs && performArgs.modDataCount || 0;
        if (lastModBy !== modBy || lastModDataCount !== modDataCount) {
          planResult = "reset";
        }
        function normalizeModBy(val) {
          !(val >= 1) && (val = 1);
          return val;
        }
        var forceFirstProgress;
        if (this._dirty || planResult === "reset") {
          this._dirty = false;
          forceFirstProgress = this._doReset(skip);
        }
        this._modBy = modBy;
        this._modDataCount = modDataCount;
        var step = performArgs && performArgs.step;
        if (upTask) {
          if (define_process_env_default$v.NODE_ENV !== "production") {
            assert(upTask._outputDueEnd != null);
          }
          this._dueEnd = upTask._outputDueEnd;
        } else {
          if (define_process_env_default$v.NODE_ENV !== "production") {
            assert(!this._progress || this._count);
          }
          this._dueEnd = this._count ? this._count(this.context) : Infinity;
        }
        if (this._progress) {
          var start2 = this._dueIndex;
          var end2 = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);
          if (!skip && (forceFirstProgress || start2 < end2)) {
            var progress = this._progress;
            if (isArray(progress)) {
              for (var i = 0; i < progress.length; i++) {
                this._doProgress(progress[i], start2, end2, modBy, modDataCount);
              }
            } else {
              this._doProgress(progress, start2, end2, modBy, modDataCount);
            }
          }
          this._dueIndex = end2;
          var outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end2;
          if (define_process_env_default$v.NODE_ENV !== "production") {
            assert(outputDueEnd >= this._outputDueEnd);
          }
          this._outputDueEnd = outputDueEnd;
        } else {
          this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
        }
        return this.unfinished();
      };
      Task2.prototype.dirty = function() {
        this._dirty = true;
        this._onDirty && this._onDirty(this.context);
      };
      Task2.prototype._doProgress = function(progress, start2, end2, modBy, modDataCount) {
        iterator.reset(start2, end2, modBy, modDataCount);
        this._callingProgress = progress;
        this._callingProgress({
          start: start2,
          end: end2,
          count: end2 - start2,
          next: iterator.next
        }, this.context);
      };
      Task2.prototype._doReset = function(skip) {
        this._dueIndex = this._outputDueEnd = this._dueEnd = 0;
        this._settedOutputEnd = null;
        var progress;
        var forceFirstProgress;
        if (!skip && this._reset) {
          progress = this._reset(this.context);
          if (progress && progress.progress) {
            forceFirstProgress = progress.forceFirstProgress;
            progress = progress.progress;
          }
          if (isArray(progress) && !progress.length) {
            progress = null;
          }
        }
        this._progress = progress;
        this._modBy = this._modDataCount = null;
        var downstream = this._downstream;
        downstream && downstream.dirty();
        return forceFirstProgress;
      };
      Task2.prototype.unfinished = function() {
        return this._progress && this._dueIndex < this._dueEnd;
      };
      Task2.prototype.pipe = function(downTask) {
        if (define_process_env_default$v.NODE_ENV !== "production") {
          assert(downTask && !downTask._disposed && downTask !== this);
        }
        if (this._downstream !== downTask || this._dirty) {
          this._downstream = downTask;
          downTask._upstream = this;
          downTask.dirty();
        }
      };
      Task2.prototype.dispose = function() {
        if (this._disposed) {
          return;
        }
        this._upstream && (this._upstream._downstream = null);
        this._downstream && (this._downstream._upstream = null);
        this._dirty = false;
        this._disposed = true;
      };
      Task2.prototype.getUpstream = function() {
        return this._upstream;
      };
      Task2.prototype.getDownstream = function() {
        return this._downstream;
      };
      Task2.prototype.setOutputEnd = function(end2) {
        this._outputDueEnd = this._settedOutputEnd = end2;
      };
      return Task2;
    }()
  );
  var iterator = /* @__PURE__ */ function() {
    var end2;
    var current;
    var modBy;
    var modDataCount;
    var winCount;
    var it = {
      reset: function(s, e2, sStep, sCount) {
        current = s;
        end2 = e2;
        modBy = sStep;
        modDataCount = sCount;
        winCount = Math.ceil(modDataCount / modBy);
        it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;
      }
    };
    return it;
    function sequentialNext() {
      return current < end2 ? current++ : null;
    }
    function modNext() {
      var dataIndex = current % winCount * modBy + Math.ceil(current / winCount);
      var result = current >= end2 ? null : dataIndex < modDataCount ? dataIndex : current;
      current++;
      return result;
    }
  }();
  function parseDataValue(value, opt) {
    var dimType = opt && opt.type;
    if (dimType === "ordinal") {
      return value;
    }
    if (dimType === "time" && !isNumber(value) && value != null && value !== "-") {
      value = +parseDate(value);
    }
    return value == null || value === "" ? NaN : Number(value);
  }
  createHashMap({
    "number": function(val) {
      return parseFloat(val);
    },
    "time": function(val) {
      return +parseDate(val);
    },
    "trim": function(val) {
      return isString(val) ? trim(val) : val;
    }
  });
  var SortOrderComparator = (
    /** @class */
    function() {
      function SortOrderComparator2(order, incomparable) {
        var isDesc = order === "desc";
        this._resultLT = isDesc ? 1 : -1;
        if (incomparable == null) {
          incomparable = isDesc ? "min" : "max";
        }
        this._incomparable = incomparable === "min" ? -Infinity : Infinity;
      }
      SortOrderComparator2.prototype.evaluate = function(lval, rval) {
        var lvalFloat = isNumber(lval) ? lval : numericToNumber(lval);
        var rvalFloat = isNumber(rval) ? rval : numericToNumber(rval);
        var lvalNotNumeric = isNaN(lvalFloat);
        var rvalNotNumeric = isNaN(rvalFloat);
        if (lvalNotNumeric) {
          lvalFloat = this._incomparable;
        }
        if (rvalNotNumeric) {
          rvalFloat = this._incomparable;
        }
        if (lvalNotNumeric && rvalNotNumeric) {
          var lvalIsStr = isString(lval);
          var rvalIsStr = isString(rval);
          if (lvalIsStr) {
            lvalFloat = rvalIsStr ? lval : 0;
          }
          if (rvalIsStr) {
            rvalFloat = lvalIsStr ? rval : 0;
          }
        }
        return lvalFloat < rvalFloat ? this._resultLT : lvalFloat > rvalFloat ? -this._resultLT : 0;
      };
      return SortOrderComparator2;
    }()
  );
  var define_process_env_default$u = {};
  var ExternalSource = (
    /** @class */
    function() {
      function ExternalSource2() {
      }
      ExternalSource2.prototype.getRawData = function() {
        throw new Error("not supported");
      };
      ExternalSource2.prototype.getRawDataItem = function(dataIndex) {
        throw new Error("not supported");
      };
      ExternalSource2.prototype.cloneRawData = function() {
        return;
      };
      ExternalSource2.prototype.getDimensionInfo = function(dim) {
        return;
      };
      ExternalSource2.prototype.cloneAllDimensionInfo = function() {
        return;
      };
      ExternalSource2.prototype.count = function() {
        return;
      };
      ExternalSource2.prototype.retrieveValue = function(dataIndex, dimIndex) {
        return;
      };
      ExternalSource2.prototype.retrieveValueFromItem = function(dataItem, dimIndex) {
        return;
      };
      ExternalSource2.prototype.convertValue = function(rawVal, dimInfo) {
        return parseDataValue(rawVal, dimInfo);
      };
      return ExternalSource2;
    }()
  );
  function createExternalSource(internalSource, externalTransform) {
    var extSource = new ExternalSource();
    var data = internalSource.data;
    var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;
    var sourceHeaderCount = internalSource.startIndex;
    var errMsg = "";
    if (internalSource.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN) {
      if (define_process_env_default$u.NODE_ENV !== "production") {
        errMsg = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.';
      }
      throwError(errMsg);
    }
    var dimensions = [];
    var dimsByName = {};
    var dimsDef = internalSource.dimensionsDefine;
    if (dimsDef) {
      each$5(dimsDef, function(dimDef, idx) {
        var name = dimDef.name;
        var dimDefExt = {
          index: idx,
          name,
          displayName: dimDef.displayName
        };
        dimensions.push(dimDefExt);
        if (name != null) {
          var errMsg_1 = "";
          if (hasOwn(dimsByName, name)) {
            if (define_process_env_default$u.NODE_ENV !== "production") {
              errMsg_1 = 'dimension name "' + name + '" duplicated.';
            }
            throwError(errMsg_1);
          }
          dimsByName[name] = dimDefExt;
        }
      });
    } else {
      for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {
        dimensions.push({
          index: i
        });
      }
    }
    var rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
    if (externalTransform.__isBuiltIn) {
      extSource.getRawDataItem = function(dataIndex) {
        return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
      };
      extSource.getRawData = bind$1(getRawData, null, internalSource);
    }
    extSource.cloneRawData = bind$1(cloneRawData, null, internalSource);
    var rawCounter = getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
    extSource.count = bind$1(rawCounter, null, data, sourceHeaderCount, dimensions);
    var rawValueGetter = getRawSourceValueGetter(sourceFormat);
    extSource.retrieveValue = function(dataIndex, dimIndex) {
      var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
      return retrieveValueFromItem(rawItem, dimIndex);
    };
    var retrieveValueFromItem = extSource.retrieveValueFromItem = function(dataItem, dimIndex) {
      if (dataItem == null) {
        return;
      }
      var dimDef = dimensions[dimIndex];
      if (dimDef) {
        return rawValueGetter(dataItem, dimIndex, dimDef.name);
      }
    };
    extSource.getDimensionInfo = bind$1(getDimensionInfo, null, dimensions, dimsByName);
    extSource.cloneAllDimensionInfo = bind$1(cloneAllDimensionInfo, null, dimensions);
    return extSource;
  }
  function getRawData(upstream) {
    var sourceFormat = upstream.sourceFormat;
    if (!isSupportedSourceFormat(sourceFormat)) {
      var errMsg = "";
      if (define_process_env_default$u.NODE_ENV !== "production") {
        errMsg = "`getRawData` is not supported in source format " + sourceFormat;
      }
      throwError(errMsg);
    }
    return upstream.data;
  }
  function cloneRawData(upstream) {
    var sourceFormat = upstream.sourceFormat;
    var data = upstream.data;
    if (!isSupportedSourceFormat(sourceFormat)) {
      var errMsg = "";
      if (define_process_env_default$u.NODE_ENV !== "production") {
        errMsg = "`cloneRawData` is not supported in source format " + sourceFormat;
      }
      throwError(errMsg);
    }
    if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
      var result = [];
      for (var i = 0, len2 = data.length; i < len2; i++) {
        result.push(data[i].slice());
      }
      return result;
    } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
      var result = [];
      for (var i = 0, len2 = data.length; i < len2; i++) {
        result.push(extend({}, data[i]));
      }
      return result;
    }
  }
  function getDimensionInfo(dimensions, dimsByName, dim) {
    if (dim == null) {
      return;
    }
    if (isNumber(dim) || !isNaN(dim) && !hasOwn(dimsByName, dim)) {
      return dimensions[dim];
    } else if (hasOwn(dimsByName, dim)) {
      return dimsByName[dim];
    }
  }
  function cloneAllDimensionInfo(dimensions) {
    return clone$2(dimensions);
  }
  var externalTransformMap = createHashMap();
  function registerExternalTransform(externalTransform) {
    externalTransform = clone$2(externalTransform);
    var type = externalTransform.type;
    var errMsg = "";
    if (!type) {
      if (define_process_env_default$u.NODE_ENV !== "production") {
        errMsg = "Must have a `type` when `registerTransform`.";
      }
      throwError(errMsg);
    }
    var typeParsed = type.split(":");
    if (typeParsed.length !== 2) {
      if (define_process_env_default$u.NODE_ENV !== "production") {
        errMsg = 'Name must include namespace like "ns:regression".';
      }
      throwError(errMsg);
    }
    var isBuiltIn = false;
    if (typeParsed[0] === "echarts") {
      type = typeParsed[1];
      isBuiltIn = true;
    }
    externalTransform.__isBuiltIn = isBuiltIn;
    externalTransformMap.set(type, externalTransform);
  }
  function applyDataTransform(rawTransOption, sourceList, infoForPrint) {
    var pipedTransOption = normalizeToArray(rawTransOption);
    var pipeLen = pipedTransOption.length;
    var errMsg = "";
    if (!pipeLen) {
      if (define_process_env_default$u.NODE_ENV !== "production") {
        errMsg = "If `transform` declared, it should at least contain one transform.";
      }
      throwError(errMsg);
    }
    for (var i = 0, len2 = pipeLen; i < len2; i++) {
      var transOption = pipedTransOption[i];
      sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i);
      if (i !== len2 - 1) {
        sourceList.length = Math.max(sourceList.length, 1);
      }
    }
    return sourceList;
  }
  function applySingleDataTransform(transOption, upSourceList, infoForPrint, pipeIndex) {
    var errMsg = "";
    if (!upSourceList.length) {
      if (define_process_env_default$u.NODE_ENV !== "production") {
        errMsg = "Must have at least one upstream dataset.";
      }
      throwError(errMsg);
    }
    if (!isObject$2(transOption)) {
      if (define_process_env_default$u.NODE_ENV !== "production") {
        errMsg = "transform declaration must be an object rather than " + typeof transOption + ".";
      }
      throwError(errMsg);
    }
    var transType = transOption.type;
    var externalTransform = externalTransformMap.get(transType);
    if (!externalTransform) {
      if (define_process_env_default$u.NODE_ENV !== "production") {
        errMsg = 'Can not find transform on type "' + transType + '".';
      }
      throwError(errMsg);
    }
    var extUpSourceList = map$1(upSourceList, function(upSource) {
      return createExternalSource(upSource, externalTransform);
    });
    var resultList = normalizeToArray(externalTransform.transform({
      upstream: extUpSourceList[0],
      upstreamList: extUpSourceList,
      config: clone$2(transOption.config)
    }));
    if (define_process_env_default$u.NODE_ENV !== "production") {
      if (transOption.print) {
        var printStrArr = map$1(resultList, function(extSource) {
          var pipeIndexStr = pipeIndex != null ? " === pipe index: " + pipeIndex : "";
          return ["=== dataset index: " + infoForPrint.datasetIndex + pipeIndexStr + " ===", "- transform result data:", makePrintable(extSource.data), "- transform result dimensions:", makePrintable(extSource.dimensions)].join("\n");
        }).join("\n");
        log(printStrArr);
      }
    }
    return map$1(resultList, function(result, resultIndex) {
      var errMsg2 = "";
      if (!isObject$2(result)) {
        if (define_process_env_default$u.NODE_ENV !== "production") {
          errMsg2 = "A transform should not return some empty results.";
        }
        throwError(errMsg2);
      }
      if (!result.data) {
        if (define_process_env_default$u.NODE_ENV !== "production") {
          errMsg2 = "Transform result data should be not be null or undefined";
        }
        throwError(errMsg2);
      }
      var sourceFormat = detectSourceFormat(result.data);
      if (!isSupportedSourceFormat(sourceFormat)) {
        if (define_process_env_default$u.NODE_ENV !== "production") {
          errMsg2 = "Transform result data should be array rows or object rows.";
        }
        throwError(errMsg2);
      }
      var resultMetaRawOption;
      var firstUpSource = upSourceList[0];
      if (firstUpSource && resultIndex === 0 && !result.dimensions) {
        var startIndex = firstUpSource.startIndex;
        if (startIndex) {
          result.data = firstUpSource.data.slice(0, startIndex).concat(result.data);
        }
        resultMetaRawOption = {
          seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
          sourceHeader: startIndex,
          dimensions: firstUpSource.metaRawOption.dimensions
        };
      } else {
        resultMetaRawOption = {
          seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
          sourceHeader: 0,
          dimensions: result.dimensions
        };
      }
      return createSource(result.data, resultMetaRawOption, null);
    });
  }
  function isSupportedSourceFormat(sourceFormat) {
    return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS;
  }
  var define_process_env_default$t = {};
  var UNDEFINED = "undefined";
  var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;
  var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;
  var CtorInt32Array$1 = typeof Int32Array === UNDEFINED ? Array : Int32Array;
  var CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;
  var dataCtors = {
    "float": CtorFloat64Array,
    "int": CtorInt32Array$1,
    // Ordinal data type can be string or int
    "ordinal": Array,
    "number": Array,
    "time": CtorFloat64Array
  };
  var defaultDimValueGetters;
  function getIndicesCtor(rawCount) {
    return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;
  }
  function getInitialExtent() {
    return [Infinity, -Infinity];
  }
  function cloneChunk(originalChunk) {
    var Ctor = originalChunk.constructor;
    return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);
  }
  function prepareStore(store, dimIdx, dimType, end2, append) {
    var DataCtor = dataCtors[dimType || "float"];
    if (append) {
      var oldStore = store[dimIdx];
      var oldLen = oldStore && oldStore.length;
      if (!(oldLen === end2)) {
        var newStore = new DataCtor(end2);
        for (var j = 0; j < oldLen; j++) {
          newStore[j] = oldStore[j];
        }
        store[dimIdx] = newStore;
      }
    } else {
      store[dimIdx] = new DataCtor(end2);
    }
  }
  var DataStore = (
    /** @class */
    function() {
      function DataStore2() {
        this._chunks = [];
        this._rawExtent = [];
        this._extent = [];
        this._count = 0;
        this._rawCount = 0;
        this._calcDimNameToIdx = createHashMap();
      }
      DataStore2.prototype.initData = function(provider, inputDimensions, dimValueGetter) {
        if (define_process_env_default$t.NODE_ENV !== "production") {
          assert(isFunction(provider.getItem) && isFunction(provider.count), "Invalid data provider.");
        }
        this._provider = provider;
        this._chunks = [];
        this._indices = null;
        this.getRawIndex = this._getRawIdxIdentity;
        var source = provider.getSource();
        var defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat];
        this._dimValueGetter = dimValueGetter || defaultGetter;
        this._rawExtent = [];
        var willRetrieveDataByName = shouldRetrieveDataByName(source);
        this._dimensions = map$1(inputDimensions, function(dim) {
          if (define_process_env_default$t.NODE_ENV !== "production") {
            if (willRetrieveDataByName) {
              assert(dim.property != null);
            }
          }
          return {
            // Only pick these two props. Not leak other properties like orderMeta.
            type: dim.type,
            property: dim.property
          };
        });
        this._initDataFromProvider(0, provider.count());
      };
      DataStore2.prototype.getProvider = function() {
        return this._provider;
      };
      DataStore2.prototype.getSource = function() {
        return this._provider.getSource();
      };
      DataStore2.prototype.ensureCalculationDimension = function(dimName, type) {
        var calcDimNameToIdx = this._calcDimNameToIdx;
        var dimensions = this._dimensions;
        var calcDimIdx = calcDimNameToIdx.get(dimName);
        if (calcDimIdx != null) {
          if (dimensions[calcDimIdx].type === type) {
            return calcDimIdx;
          }
        } else {
          calcDimIdx = dimensions.length;
        }
        dimensions[calcDimIdx] = {
          type
        };
        calcDimNameToIdx.set(dimName, calcDimIdx);
        this._chunks[calcDimIdx] = new dataCtors[type || "float"](this._rawCount);
        this._rawExtent[calcDimIdx] = getInitialExtent();
        return calcDimIdx;
      };
      DataStore2.prototype.collectOrdinalMeta = function(dimIdx, ordinalMeta) {
        var chunk = this._chunks[dimIdx];
        var dim = this._dimensions[dimIdx];
        var rawExtents = this._rawExtent;
        var offset = dim.ordinalOffset || 0;
        var len2 = chunk.length;
        if (offset === 0) {
          rawExtents[dimIdx] = getInitialExtent();
        }
        var dimRawExtent = rawExtents[dimIdx];
        for (var i = offset; i < len2; i++) {
          var val = chunk[i] = ordinalMeta.parseAndCollect(chunk[i]);
          if (!isNaN(val)) {
            dimRawExtent[0] = Math.min(val, dimRawExtent[0]);
            dimRawExtent[1] = Math.max(val, dimRawExtent[1]);
          }
        }
        dim.ordinalMeta = ordinalMeta;
        dim.ordinalOffset = len2;
        dim.type = "ordinal";
      };
      DataStore2.prototype.getOrdinalMeta = function(dimIdx) {
        var dimInfo = this._dimensions[dimIdx];
        var ordinalMeta = dimInfo.ordinalMeta;
        return ordinalMeta;
      };
      DataStore2.prototype.getDimensionProperty = function(dimIndex) {
        var item = this._dimensions[dimIndex];
        return item && item.property;
      };
      DataStore2.prototype.appendData = function(data) {
        if (define_process_env_default$t.NODE_ENV !== "production") {
          assert(!this._indices, "appendData can only be called on raw data.");
        }
        var provider = this._provider;
        var start2 = this.count();
        provider.appendData(data);
        var end2 = provider.count();
        if (!provider.persistent) {
          end2 += start2;
        }
        if (start2 < end2) {
          this._initDataFromProvider(start2, end2, true);
        }
        return [start2, end2];
      };
      DataStore2.prototype.appendValues = function(values, minFillLen) {
        var chunks = this._chunks;
        var dimensions = this._dimensions;
        var dimLen = dimensions.length;
        var rawExtent = this._rawExtent;
        var start2 = this.count();
        var end2 = start2 + Math.max(values.length, minFillLen || 0);
        for (var i = 0; i < dimLen; i++) {
          var dim = dimensions[i];
          prepareStore(chunks, i, dim.type, end2, true);
        }
        var emptyDataItem = [];
        for (var idx = start2; idx < end2; idx++) {
          var sourceIdx = idx - start2;
          for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {
            var dim = dimensions[dimIdx];
            var val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);
            chunks[dimIdx][idx] = val;
            var dimRawExtent = rawExtent[dimIdx];
            val < dimRawExtent[0] && (dimRawExtent[0] = val);
            val > dimRawExtent[1] && (dimRawExtent[1] = val);
          }
        }
        this._rawCount = this._count = end2;
        return {
          start: start2,
          end: end2
        };
      };
      DataStore2.prototype._initDataFromProvider = function(start2, end2, append) {
        var provider = this._provider;
        var chunks = this._chunks;
        var dimensions = this._dimensions;
        var dimLen = dimensions.length;
        var rawExtent = this._rawExtent;
        var dimNames = map$1(dimensions, function(dim2) {
          return dim2.property;
        });
        for (var i = 0; i < dimLen; i++) {
          var dim = dimensions[i];
          if (!rawExtent[i]) {
            rawExtent[i] = getInitialExtent();
          }
          prepareStore(chunks, i, dim.type, end2, append);
        }
        if (provider.fillStorage) {
          provider.fillStorage(start2, end2, chunks, rawExtent);
        } else {
          var dataItem = [];
          for (var idx = start2; idx < end2; idx++) {
            dataItem = provider.getItem(idx, dataItem);
            for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {
              var dimStorage = chunks[dimIdx];
              var val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);
              dimStorage[idx] = val;
              var dimRawExtent = rawExtent[dimIdx];
              val < dimRawExtent[0] && (dimRawExtent[0] = val);
              val > dimRawExtent[1] && (dimRawExtent[1] = val);
            }
          }
        }
        if (!provider.persistent && provider.clean) {
          provider.clean();
        }
        this._rawCount = this._count = end2;
        this._extent = [];
      };
      DataStore2.prototype.count = function() {
        return this._count;
      };
      DataStore2.prototype.get = function(dim, idx) {
        if (!(idx >= 0 && idx < this._count)) {
          return NaN;
        }
        var dimStore = this._chunks[dim];
        return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;
      };
      DataStore2.prototype.getValues = function(dimensions, idx) {
        var values = [];
        var dimArr = [];
        if (idx == null) {
          idx = dimensions;
          dimensions = [];
          for (var i = 0; i < this._dimensions.length; i++) {
            dimArr.push(i);
          }
        } else {
          dimArr = dimensions;
        }
        for (var i = 0, len2 = dimArr.length; i < len2; i++) {
          values.push(this.get(dimArr[i], idx));
        }
        return values;
      };
      DataStore2.prototype.getByRawIndex = function(dim, rawIdx) {
        if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {
          return NaN;
        }
        var dimStore = this._chunks[dim];
        return dimStore ? dimStore[rawIdx] : NaN;
      };
      DataStore2.prototype.getSum = function(dim) {
        var dimData = this._chunks[dim];
        var sum = 0;
        if (dimData) {
          for (var i = 0, len2 = this.count(); i < len2; i++) {
            var value = this.get(dim, i);
            if (!isNaN(value)) {
              sum += value;
            }
          }
        }
        return sum;
      };
      DataStore2.prototype.getMedian = function(dim) {
        var dimDataArray = [];
        this.each([dim], function(val) {
          if (!isNaN(val)) {
            dimDataArray.push(val);
          }
        });
        var sortedDimDataArray = dimDataArray.sort(function(a, b) {
          return a - b;
        });
        var len2 = this.count();
        return len2 === 0 ? 0 : len2 % 2 === 1 ? sortedDimDataArray[(len2 - 1) / 2] : (sortedDimDataArray[len2 / 2] + sortedDimDataArray[len2 / 2 - 1]) / 2;
      };
      DataStore2.prototype.indexOfRawIndex = function(rawIndex) {
        if (rawIndex >= this._rawCount || rawIndex < 0) {
          return -1;
        }
        if (!this._indices) {
          return rawIndex;
        }
        var indices = this._indices;
        var rawDataIndex = indices[rawIndex];
        if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {
          return rawIndex;
        }
        var left = 0;
        var right = this._count - 1;
        while (left <= right) {
          var mid = (left + right) / 2 | 0;
          if (indices[mid] < rawIndex) {
            left = mid + 1;
          } else if (indices[mid] > rawIndex) {
            right = mid - 1;
          } else {
            return mid;
          }
        }
        return -1;
      };
      DataStore2.prototype.getIndices = function() {
        var newIndices;
        var indices = this._indices;
        if (indices) {
          var Ctor = indices.constructor;
          var thisCount = this._count;
          if (Ctor === Array) {
            newIndices = new Ctor(thisCount);
            for (var i = 0; i < thisCount; i++) {
              newIndices[i] = indices[i];
            }
          } else {
            newIndices = new Ctor(indices.buffer, 0, thisCount);
          }
        } else {
          var Ctor = getIndicesCtor(this._rawCount);
          newIndices = new Ctor(this.count());
          for (var i = 0; i < newIndices.length; i++) {
            newIndices[i] = i;
          }
        }
        return newIndices;
      };
      DataStore2.prototype.filter = function(dims, cb) {
        if (!this._count) {
          return this;
        }
        var newStore = this.clone();
        var count = newStore.count();
        var Ctor = getIndicesCtor(newStore._rawCount);
        var newIndices = new Ctor(count);
        var value = [];
        var dimSize = dims.length;
        var offset = 0;
        var dim0 = dims[0];
        var chunks = newStore._chunks;
        for (var i = 0; i < count; i++) {
          var keep = void 0;
          var rawIdx = newStore.getRawIndex(i);
          if (dimSize === 0) {
            keep = cb(i);
          } else if (dimSize === 1) {
            var val = chunks[dim0][rawIdx];
            keep = cb(val, i);
          } else {
            var k = 0;
            for (; k < dimSize; k++) {
              value[k] = chunks[dims[k]][rawIdx];
            }
            value[k] = i;
            keep = cb.apply(null, value);
          }
          if (keep) {
            newIndices[offset++] = rawIdx;
          }
        }
        if (offset < count) {
          newStore._indices = newIndices;
        }
        newStore._count = offset;
        newStore._extent = [];
        newStore._updateGetRawIdx();
        return newStore;
      };
      DataStore2.prototype.selectRange = function(range) {
        var newStore = this.clone();
        var len2 = newStore._count;
        if (!len2) {
          return this;
        }
        var dims = keys(range);
        var dimSize = dims.length;
        if (!dimSize) {
          return this;
        }
        var originalCount = newStore.count();
        var Ctor = getIndicesCtor(newStore._rawCount);
        var newIndices = new Ctor(originalCount);
        var offset = 0;
        var dim0 = dims[0];
        var min3 = range[dim0][0];
        var max3 = range[dim0][1];
        var storeArr = newStore._chunks;
        var quickFinished = false;
        if (!newStore._indices) {
          var idx = 0;
          if (dimSize === 1) {
            var dimStorage = storeArr[dims[0]];
            for (var i = 0; i < len2; i++) {
              var val = dimStorage[i];
              if (val >= min3 && val <= max3 || isNaN(val)) {
                newIndices[offset++] = idx;
              }
              idx++;
            }
            quickFinished = true;
          } else if (dimSize === 2) {
            var dimStorage = storeArr[dims[0]];
            var dimStorage2 = storeArr[dims[1]];
            var min22 = range[dims[1]][0];
            var max22 = range[dims[1]][1];
            for (var i = 0; i < len2; i++) {
              var val = dimStorage[i];
              var val2 = dimStorage2[i];
              if ((val >= min3 && val <= max3 || isNaN(val)) && (val2 >= min22 && val2 <= max22 || isNaN(val2))) {
                newIndices[offset++] = idx;
              }
              idx++;
            }
            quickFinished = true;
          }
        }
        if (!quickFinished) {
          if (dimSize === 1) {
            for (var i = 0; i < originalCount; i++) {
              var rawIndex = newStore.getRawIndex(i);
              var val = storeArr[dims[0]][rawIndex];
              if (val >= min3 && val <= max3 || isNaN(val)) {
                newIndices[offset++] = rawIndex;
              }
            }
          } else {
            for (var i = 0; i < originalCount; i++) {
              var keep = true;
              var rawIndex = newStore.getRawIndex(i);
              for (var k = 0; k < dimSize; k++) {
                var dimk = dims[k];
                var val = storeArr[dimk][rawIndex];
                if (val < range[dimk][0] || val > range[dimk][1]) {
                  keep = false;
                }
              }
              if (keep) {
                newIndices[offset++] = newStore.getRawIndex(i);
              }
            }
          }
        }
        if (offset < originalCount) {
          newStore._indices = newIndices;
        }
        newStore._count = offset;
        newStore._extent = [];
        newStore._updateGetRawIdx();
        return newStore;
      };
      DataStore2.prototype.map = function(dims, cb) {
        var target = this.clone(dims);
        this._updateDims(target, dims, cb);
        return target;
      };
      DataStore2.prototype.modify = function(dims, cb) {
        this._updateDims(this, dims, cb);
      };
      DataStore2.prototype._updateDims = function(target, dims, cb) {
        var targetChunks = target._chunks;
        var tmpRetValue = [];
        var dimSize = dims.length;
        var dataCount = target.count();
        var values = [];
        var rawExtent = target._rawExtent;
        for (var i = 0; i < dims.length; i++) {
          rawExtent[dims[i]] = getInitialExtent();
        }
        for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {
          var rawIndex = target.getRawIndex(dataIndex);
          for (var k = 0; k < dimSize; k++) {
            values[k] = targetChunks[dims[k]][rawIndex];
          }
          values[dimSize] = dataIndex;
          var retValue = cb && cb.apply(null, values);
          if (retValue != null) {
            if (typeof retValue !== "object") {
              tmpRetValue[0] = retValue;
              retValue = tmpRetValue;
            }
            for (var i = 0; i < retValue.length; i++) {
              var dim = dims[i];
              var val = retValue[i];
              var rawExtentOnDim = rawExtent[dim];
              var dimStore = targetChunks[dim];
              if (dimStore) {
                dimStore[rawIndex] = val;
              }
              if (val < rawExtentOnDim[0]) {
                rawExtentOnDim[0] = val;
              }
              if (val > rawExtentOnDim[1]) {
                rawExtentOnDim[1] = val;
              }
            }
          }
        }
      };
      DataStore2.prototype.lttbDownSample = function(valueDimension, rate) {
        var target = this.clone([valueDimension], true);
        var targetStorage = target._chunks;
        var dimStore = targetStorage[valueDimension];
        var len2 = this.count();
        var sampledIndex = 0;
        var frameSize = Math.floor(1 / rate);
        var currentRawIndex = this.getRawIndex(0);
        var maxArea;
        var area;
        var nextRawIndex;
        var newIndices = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(len2 / frameSize) + 2) * 2, len2));
        newIndices[sampledIndex++] = currentRawIndex;
        for (var i = 1; i < len2 - 1; i += frameSize) {
          var nextFrameStart = Math.min(i + frameSize, len2 - 1);
          var nextFrameEnd = Math.min(i + frameSize * 2, len2);
          var avgX = (nextFrameEnd + nextFrameStart) / 2;
          var avgY = 0;
          for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {
            var rawIndex = this.getRawIndex(idx);
            var y = dimStore[rawIndex];
            if (isNaN(y)) {
              continue;
            }
            avgY += y;
          }
          avgY /= nextFrameEnd - nextFrameStart;
          var frameStart = i;
          var frameEnd = Math.min(i + frameSize, len2);
          var pointAX = i - 1;
          var pointAY = dimStore[currentRawIndex];
          maxArea = -1;
          nextRawIndex = frameStart;
          var firstNaNIndex = -1;
          var countNaN = 0;
          for (var idx = frameStart; idx < frameEnd; idx++) {
            var rawIndex = this.getRawIndex(idx);
            var y = dimStore[rawIndex];
            if (isNaN(y)) {
              countNaN++;
              if (firstNaNIndex < 0) {
                firstNaNIndex = rawIndex;
              }
              continue;
            }
            area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));
            if (area > maxArea) {
              maxArea = area;
              nextRawIndex = rawIndex;
            }
          }
          if (countNaN > 0 && countNaN < frameEnd - frameStart) {
            newIndices[sampledIndex++] = Math.min(firstNaNIndex, nextRawIndex);
            nextRawIndex = Math.max(firstNaNIndex, nextRawIndex);
          }
          newIndices[sampledIndex++] = nextRawIndex;
          currentRawIndex = nextRawIndex;
        }
        newIndices[sampledIndex++] = this.getRawIndex(len2 - 1);
        target._count = sampledIndex;
        target._indices = newIndices;
        target.getRawIndex = this._getRawIdx;
        return target;
      };
      DataStore2.prototype.minmaxDownSample = function(valueDimension, rate) {
        var target = this.clone([valueDimension], true);
        var targetStorage = target._chunks;
        var frameSize = Math.floor(1 / rate);
        var dimStore = targetStorage[valueDimension];
        var len2 = this.count();
        var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len2 / frameSize) * 2);
        var offset = 0;
        for (var i = 0; i < len2; i += frameSize) {
          var minIndex = i;
          var minValue = dimStore[this.getRawIndex(minIndex)];
          var maxIndex = i;
          var maxValue = dimStore[this.getRawIndex(maxIndex)];
          var thisFrameSize = frameSize;
          if (i + frameSize > len2) {
            thisFrameSize = len2 - i;
          }
          for (var k = 0; k < thisFrameSize; k++) {
            var rawIndex = this.getRawIndex(i + k);
            var value = dimStore[rawIndex];
            if (value < minValue) {
              minValue = value;
              minIndex = i + k;
            }
            if (value > maxValue) {
              maxValue = value;
              maxIndex = i + k;
            }
          }
          var rawMinIndex = this.getRawIndex(minIndex);
          var rawMaxIndex = this.getRawIndex(maxIndex);
          if (minIndex < maxIndex) {
            newIndices[offset++] = rawMinIndex;
            newIndices[offset++] = rawMaxIndex;
          } else {
            newIndices[offset++] = rawMaxIndex;
            newIndices[offset++] = rawMinIndex;
          }
        }
        target._count = offset;
        target._indices = newIndices;
        target._updateGetRawIdx();
        return target;
      };
      DataStore2.prototype.downSample = function(dimension, rate, sampleValue, sampleIndex) {
        var target = this.clone([dimension], true);
        var targetStorage = target._chunks;
        var frameValues = [];
        var frameSize = Math.floor(1 / rate);
        var dimStore = targetStorage[dimension];
        var len2 = this.count();
        var rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();
        var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len2 / frameSize));
        var offset = 0;
        for (var i = 0; i < len2; i += frameSize) {
          if (frameSize > len2 - i) {
            frameSize = len2 - i;
            frameValues.length = frameSize;
          }
          for (var k = 0; k < frameSize; k++) {
            var dataIdx = this.getRawIndex(i + k);
            frameValues[k] = dimStore[dataIdx];
          }
          var value = sampleValue(frameValues);
          var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len2 - 1));
          dimStore[sampleFrameIdx] = value;
          if (value < rawExtentOnDim[0]) {
            rawExtentOnDim[0] = value;
          }
          if (value > rawExtentOnDim[1]) {
            rawExtentOnDim[1] = value;
          }
          newIndices[offset++] = sampleFrameIdx;
        }
        target._count = offset;
        target._indices = newIndices;
        target._updateGetRawIdx();
        return target;
      };
      DataStore2.prototype.each = function(dims, cb) {
        if (!this._count) {
          return;
        }
        var dimSize = dims.length;
        var chunks = this._chunks;
        for (var i = 0, len2 = this.count(); i < len2; i++) {
          var rawIdx = this.getRawIndex(i);
          switch (dimSize) {
            case 0:
              cb(i);
              break;
            case 1:
              cb(chunks[dims[0]][rawIdx], i);
              break;
            case 2:
              cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i);
              break;
            default:
              var k = 0;
              var value = [];
              for (; k < dimSize; k++) {
                value[k] = chunks[dims[k]][rawIdx];
              }
              value[k] = i;
              cb.apply(null, value);
          }
        }
      };
      DataStore2.prototype.getDataExtent = function(dim) {
        var dimData = this._chunks[dim];
        var initialExtent = getInitialExtent();
        if (!dimData) {
          return initialExtent;
        }
        var currEnd = this.count();
        var useRaw = !this._indices;
        var dimExtent;
        if (useRaw) {
          return this._rawExtent[dim].slice();
        }
        dimExtent = this._extent[dim];
        if (dimExtent) {
          return dimExtent.slice();
        }
        dimExtent = initialExtent;
        var min3 = dimExtent[0];
        var max3 = dimExtent[1];
        for (var i = 0; i < currEnd; i++) {
          var rawIdx = this.getRawIndex(i);
          var value = dimData[rawIdx];
          value < min3 && (min3 = value);
          value > max3 && (max3 = value);
        }
        dimExtent = [min3, max3];
        this._extent[dim] = dimExtent;
        return dimExtent;
      };
      DataStore2.prototype.getRawDataItem = function(idx) {
        var rawIdx = this.getRawIndex(idx);
        if (!this._provider.persistent) {
          var val = [];
          var chunks = this._chunks;
          for (var i = 0; i < chunks.length; i++) {
            val.push(chunks[i][rawIdx]);
          }
          return val;
        } else {
          return this._provider.getItem(rawIdx);
        }
      };
      DataStore2.prototype.clone = function(clonedDims, ignoreIndices) {
        var target = new DataStore2();
        var chunks = this._chunks;
        var clonedDimsMap = clonedDims && reduce(clonedDims, function(obj, dimIdx) {
          obj[dimIdx] = true;
          return obj;
        }, {});
        if (clonedDimsMap) {
          for (var i = 0; i < chunks.length; i++) {
            target._chunks[i] = !clonedDimsMap[i] ? chunks[i] : cloneChunk(chunks[i]);
          }
        } else {
          target._chunks = chunks;
        }
        this._copyCommonProps(target);
        if (!ignoreIndices) {
          target._indices = this._cloneIndices();
        }
        target._updateGetRawIdx();
        return target;
      };
      DataStore2.prototype._copyCommonProps = function(target) {
        target._count = this._count;
        target._rawCount = this._rawCount;
        target._provider = this._provider;
        target._dimensions = this._dimensions;
        target._extent = clone$2(this._extent);
        target._rawExtent = clone$2(this._rawExtent);
      };
      DataStore2.prototype._cloneIndices = function() {
        if (this._indices) {
          var Ctor = this._indices.constructor;
          var indices = void 0;
          if (Ctor === Array) {
            var thisCount = this._indices.length;
            indices = new Ctor(thisCount);
            for (var i = 0; i < thisCount; i++) {
              indices[i] = this._indices[i];
            }
          } else {
            indices = new Ctor(this._indices);
          }
          return indices;
        }
        return null;
      };
      DataStore2.prototype._getRawIdxIdentity = function(idx) {
        return idx;
      };
      DataStore2.prototype._getRawIdx = function(idx) {
        if (idx < this._count && idx >= 0) {
          return this._indices[idx];
        }
        return -1;
      };
      DataStore2.prototype._updateGetRawIdx = function() {
        this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
      };
      DataStore2.internalField = function() {
        function getDimValueSimply(dataItem, property, dataIndex, dimIndex) {
          return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex]);
        }
        defaultDimValueGetters = {
          arrayRows: getDimValueSimply,
          objectRows: function(dataItem, property, dataIndex, dimIndex) {
            return parseDataValue(dataItem[property], this._dimensions[dimIndex]);
          },
          keyedColumns: getDimValueSimply,
          original: function(dataItem, property, dataIndex, dimIndex) {
            var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);
            return parseDataValue(value instanceof Array ? value[dimIndex] : value, this._dimensions[dimIndex]);
          },
          typedArray: function(dataItem, property, dataIndex, dimIndex) {
            return dataItem[dimIndex];
          }
        };
      }();
      return DataStore2;
    }()
  );
  var define_process_env_default$s = {};
  var SourceManager = (
    /** @class */
    function() {
      function SourceManager2(sourceHost) {
        this._sourceList = [];
        this._storeList = [];
        this._upstreamSignList = [];
        this._versionSignBase = 0;
        this._dirty = true;
        this._sourceHost = sourceHost;
      }
      SourceManager2.prototype.dirty = function() {
        this._setLocalSource([], []);
        this._storeList = [];
        this._dirty = true;
      };
      SourceManager2.prototype._setLocalSource = function(sourceList, upstreamSignList) {
        this._sourceList = sourceList;
        this._upstreamSignList = upstreamSignList;
        this._versionSignBase++;
        if (this._versionSignBase > 9e10) {
          this._versionSignBase = 0;
        }
      };
      SourceManager2.prototype._getVersionSign = function() {
        return this._sourceHost.uid + "_" + this._versionSignBase;
      };
      SourceManager2.prototype.prepareSource = function() {
        if (this._isDirty()) {
          this._createSource();
          this._dirty = false;
        }
      };
      SourceManager2.prototype._createSource = function() {
        this._setLocalSource([], []);
        var sourceHost = this._sourceHost;
        var upSourceMgrList = this._getUpstreamSourceManagers();
        var hasUpstream = !!upSourceMgrList.length;
        var resultSourceList;
        var upstreamSignList;
        if (isSeries(sourceHost)) {
          var seriesModel = sourceHost;
          var data = void 0;
          var sourceFormat = void 0;
          var upSource = void 0;
          if (hasUpstream) {
            var upSourceMgr = upSourceMgrList[0];
            upSourceMgr.prepareSource();
            upSource = upSourceMgr.getSource();
            data = upSource.data;
            sourceFormat = upSource.sourceFormat;
            upstreamSignList = [upSourceMgr._getVersionSign()];
          } else {
            data = seriesModel.get("data", true);
            sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;
            upstreamSignList = [];
          }
          var newMetaRawOption = this._getSourceMetaRawOption() || {};
          var upMetaRawOption = upSource && upSource.metaRawOption || {};
          var seriesLayoutBy = retrieve2(newMetaRawOption.seriesLayoutBy, upMetaRawOption.seriesLayoutBy) || null;
          var sourceHeader = retrieve2(newMetaRawOption.sourceHeader, upMetaRawOption.sourceHeader);
          var dimensions = retrieve2(newMetaRawOption.dimensions, upMetaRawOption.dimensions);
          var needsCreateSource = seriesLayoutBy !== upMetaRawOption.seriesLayoutBy || !!sourceHeader !== !!upMetaRawOption.sourceHeader || dimensions;
          resultSourceList = needsCreateSource ? [createSource(data, {
            seriesLayoutBy,
            sourceHeader,
            dimensions
          }, sourceFormat)] : [];
        } else {
          var datasetModel = sourceHost;
          if (hasUpstream) {
            var result = this._applyTransform(upSourceMgrList);
            resultSourceList = result.sourceList;
            upstreamSignList = result.upstreamSignList;
          } else {
            var sourceData = datasetModel.get("source", true);
            resultSourceList = [createSource(sourceData, this._getSourceMetaRawOption(), null)];
            upstreamSignList = [];
          }
        }
        if (define_process_env_default$s.NODE_ENV !== "production") {
          assert(resultSourceList && upstreamSignList);
        }
        this._setLocalSource(resultSourceList, upstreamSignList);
      };
      SourceManager2.prototype._applyTransform = function(upMgrList) {
        var datasetModel = this._sourceHost;
        var transformOption = datasetModel.get("transform", true);
        var fromTransformResult = datasetModel.get("fromTransformResult", true);
        if (define_process_env_default$s.NODE_ENV !== "production") {
          assert(fromTransformResult != null || transformOption != null);
        }
        if (fromTransformResult != null) {
          var errMsg = "";
          if (upMgrList.length !== 1) {
            if (define_process_env_default$s.NODE_ENV !== "production") {
              errMsg = "When using `fromTransformResult`, there should be only one upstream dataset";
            }
            doThrow(errMsg);
          }
        }
        var sourceList;
        var upSourceList = [];
        var upstreamSignList = [];
        each$5(upMgrList, function(upMgr) {
          upMgr.prepareSource();
          var upSource = upMgr.getSource(fromTransformResult || 0);
          var errMsg2 = "";
          if (fromTransformResult != null && !upSource) {
            if (define_process_env_default$s.NODE_ENV !== "production") {
              errMsg2 = "Can not retrieve result by `fromTransformResult`: " + fromTransformResult;
            }
            doThrow(errMsg2);
          }
          upSourceList.push(upSource);
          upstreamSignList.push(upMgr._getVersionSign());
        });
        if (transformOption) {
          sourceList = applyDataTransform(transformOption, upSourceList, {
            datasetIndex: datasetModel.componentIndex
          });
        } else if (fromTransformResult != null) {
          sourceList = [cloneSourceShallow(upSourceList[0])];
        }
        return {
          sourceList,
          upstreamSignList
        };
      };
      SourceManager2.prototype._isDirty = function() {
        if (this._dirty) {
          return true;
        }
        var upSourceMgrList = this._getUpstreamSourceManagers();
        for (var i = 0; i < upSourceMgrList.length; i++) {
          var upSrcMgr = upSourceMgrList[i];
          if (
            // Consider the case that there is ancestor diry, call it recursively.
            // The performance is probably not an issue because usually the chain is not long.
            upSrcMgr._isDirty() || this._upstreamSignList[i] !== upSrcMgr._getVersionSign()
          ) {
            return true;
          }
        }
      };
      SourceManager2.prototype.getSource = function(sourceIndex) {
        sourceIndex = sourceIndex || 0;
        var source = this._sourceList[sourceIndex];
        if (!source) {
          var upSourceMgrList = this._getUpstreamSourceManagers();
          return upSourceMgrList[0] && upSourceMgrList[0].getSource(sourceIndex);
        }
        return source;
      };
      SourceManager2.prototype.getSharedDataStore = function(seriesDimRequest) {
        if (define_process_env_default$s.NODE_ENV !== "production") {
          assert(isSeries(this._sourceHost), "Can only call getDataStore on series source manager.");
        }
        var schema = seriesDimRequest.makeStoreSchema();
        return this._innerGetDataStore(schema.dimensions, seriesDimRequest.source, schema.hash);
      };
      SourceManager2.prototype._innerGetDataStore = function(storeDims, seriesSource, sourceReadKey) {
        var sourceIndex = 0;
        var storeList = this._storeList;
        var cachedStoreMap = storeList[sourceIndex];
        if (!cachedStoreMap) {
          cachedStoreMap = storeList[sourceIndex] = {};
        }
        var cachedStore = cachedStoreMap[sourceReadKey];
        if (!cachedStore) {
          var upSourceMgr = this._getUpstreamSourceManagers()[0];
          if (isSeries(this._sourceHost) && upSourceMgr) {
            cachedStore = upSourceMgr._innerGetDataStore(storeDims, seriesSource, sourceReadKey);
          } else {
            cachedStore = new DataStore();
            cachedStore.initData(new DefaultDataProvider(seriesSource, storeDims.length), storeDims);
          }
          cachedStoreMap[sourceReadKey] = cachedStore;
        }
        return cachedStore;
      };
      SourceManager2.prototype._getUpstreamSourceManagers = function() {
        var sourceHost = this._sourceHost;
        if (isSeries(sourceHost)) {
          var datasetModel = querySeriesUpstreamDatasetModel(sourceHost);
          return !datasetModel ? [] : [datasetModel.getSourceManager()];
        } else {
          return map$1(queryDatasetUpstreamDatasetModels(sourceHost), function(datasetModel2) {
            return datasetModel2.getSourceManager();
          });
        }
      };
      SourceManager2.prototype._getSourceMetaRawOption = function() {
        var sourceHost = this._sourceHost;
        var seriesLayoutBy;
        var sourceHeader;
        var dimensions;
        if (isSeries(sourceHost)) {
          seriesLayoutBy = sourceHost.get("seriesLayoutBy", true);
          sourceHeader = sourceHost.get("sourceHeader", true);
          dimensions = sourceHost.get("dimensions", true);
        } else if (!this._getUpstreamSourceManagers().length) {
          var model = sourceHost;
          seriesLayoutBy = model.get("seriesLayoutBy", true);
          sourceHeader = model.get("sourceHeader", true);
          dimensions = model.get("dimensions", true);
        }
        return {
          seriesLayoutBy,
          sourceHeader,
          dimensions
        };
      };
      return SourceManager2;
    }()
  );
  function isSeries(sourceHost) {
    return sourceHost.mainType === "series";
  }
  function doThrow(errMsg) {
    throw new Error(errMsg);
  }
  var define_process_env_default$r = {};
  var TOOLTIP_LINE_HEIGHT_CSS = "line-height:1";
  function getTooltipLineHeight(textStyle) {
    var lineHeight = textStyle.lineHeight;
    if (lineHeight == null) {
      return TOOLTIP_LINE_HEIGHT_CSS;
    } else {
      return "line-height:" + encodeHTML(lineHeight + "") + "px";
    }
  }
  function getTooltipTextStyle(textStyle, renderMode) {
    var nameFontColor = textStyle.color || tokens.color.tertiary;
    var nameFontSize = textStyle.fontSize || 12;
    var nameFontWeight = textStyle.fontWeight || "400";
    var valueFontColor = textStyle.color || tokens.color.secondary;
    var valueFontSize = textStyle.fontSize || 14;
    var valueFontWeight = textStyle.fontWeight || "900";
    if (renderMode === "html") {
      return {
        // eslint-disable-next-line max-len
        nameStyle: "font-size:" + encodeHTML(nameFontSize + "") + "px;color:" + encodeHTML(nameFontColor) + ";font-weight:" + encodeHTML(nameFontWeight + ""),
        // eslint-disable-next-line max-len
        valueStyle: "font-size:" + encodeHTML(valueFontSize + "") + "px;color:" + encodeHTML(valueFontColor) + ";font-weight:" + encodeHTML(valueFontWeight + "")
      };
    } else {
      return {
        nameStyle: {
          fontSize: nameFontSize,
          fill: nameFontColor,
          fontWeight: nameFontWeight
        },
        valueStyle: {
          fontSize: valueFontSize,
          fill: valueFontColor,
          fontWeight: valueFontWeight
        }
      };
    }
  }
  var HTML_GAPS = [0, 10, 20, 30];
  var RICH_TEXT_GAPS = ["", "\n", "\n\n", "\n\n\n"];
  function createTooltipMarkup(type, option) {
    option.type = type;
    return option;
  }
  function isSectionFragment(frag) {
    return frag.type === "section";
  }
  function getBuilder(frag) {
    return isSectionFragment(frag) ? buildSection : buildNameValue;
  }
  function getBlockGapLevel(frag) {
    if (isSectionFragment(frag)) {
      var gapLevel_1 = 0;
      var subBlockLen = frag.blocks.length;
      var hasInnerGap_1 = subBlockLen > 1 || subBlockLen > 0 && !frag.noHeader;
      each$5(frag.blocks, function(subBlock) {
        var subGapLevel = getBlockGapLevel(subBlock);
        if (subGapLevel >= gapLevel_1) {
          gapLevel_1 = subGapLevel + +(hasInnerGap_1 && // 0 always can not be readable gap level.
          (!subGapLevel || isSectionFragment(subBlock) && !subBlock.noHeader));
        }
      });
      return gapLevel_1;
    }
    return 0;
  }
  function buildSection(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
    var noHeader = fragment.noHeader;
    var gaps = getGap(getBlockGapLevel(fragment));
    var subMarkupTextList = [];
    var subBlocks = fragment.blocks || [];
    assert(!subBlocks || isArray(subBlocks));
    subBlocks = subBlocks || [];
    var orderMode = ctx.orderMode;
    if (fragment.sortBlocks && orderMode) {
      subBlocks = subBlocks.slice();
      var orderMap = {
        valueAsc: "asc",
        valueDesc: "desc"
      };
      if (hasOwn(orderMap, orderMode)) {
        var comparator_1 = new SortOrderComparator(orderMap[orderMode], null);
        subBlocks.sort(function(a, b) {
          return comparator_1.evaluate(a.sortParam, b.sortParam);
        });
      } else if (orderMode === "seriesDesc") {
        subBlocks.reverse();
      }
    }
    each$5(subBlocks, function(subBlock, idx) {
      var valueFormatter = fragment.valueFormatter;
      var subMarkupText2 = getBuilder(subBlock)(
        // Inherit valueFormatter
        valueFormatter ? extend(extend({}, ctx), {
          valueFormatter
        }) : ctx,
        subBlock,
        idx > 0 ? gaps.html : 0,
        toolTipTextStyle
      );
      subMarkupText2 != null && subMarkupTextList.push(subMarkupText2);
    });
    var subMarkupText = ctx.renderMode === "richText" ? subMarkupTextList.join(gaps.richText) : wrapBlockHTML(toolTipTextStyle, subMarkupTextList.join(""), noHeader ? topMarginForOuterGap : gaps.html);
    if (noHeader) {
      return subMarkupText;
    }
    var displayableHeader = makeValueReadable(fragment.header, "ordinal", ctx.useUTC);
    var nameStyle = getTooltipTextStyle(toolTipTextStyle, ctx.renderMode).nameStyle;
    var tooltipLineHeight = getTooltipLineHeight(toolTipTextStyle);
    if (ctx.renderMode === "richText") {
      return wrapInlineNameRichText(ctx, displayableHeader, nameStyle) + gaps.richText + subMarkupText;
    } else {
      return wrapBlockHTML(toolTipTextStyle, '<div style="' + nameStyle + ";" + tooltipLineHeight + ';">' + encodeHTML(displayableHeader) + "</div>" + subMarkupText, topMarginForOuterGap);
    }
  }
  function buildNameValue(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
    var renderMode = ctx.renderMode;
    var noName = fragment.noName;
    var noValue = fragment.noValue;
    var noMarker = !fragment.markerType;
    var name = fragment.name;
    var useUTC = ctx.useUTC;
    var valueFormatter = fragment.valueFormatter || ctx.valueFormatter || function(value) {
      value = isArray(value) ? value : [value];
      return map$1(value, function(val, idx) {
        return makeValueReadable(val, isArray(valueTypeOption) ? valueTypeOption[idx] : valueTypeOption, useUTC);
      });
    };
    if (noName && noValue) {
      return;
    }
    var markerStr = noMarker ? "" : ctx.markupStyleCreator.makeTooltipMarker(fragment.markerType, fragment.markerColor || tokens.color.secondary, renderMode);
    var readableName = noName ? "" : makeValueReadable(name, "ordinal", useUTC);
    var valueTypeOption = fragment.valueType;
    var readableValueList = noValue ? [] : valueFormatter(fragment.value, fragment.dataIndex);
    var valueAlignRight = !noMarker || !noName;
    var valueCloseToMarker = !noMarker && noName;
    var _a2 = getTooltipTextStyle(toolTipTextStyle, renderMode), nameStyle = _a2.nameStyle, valueStyle = _a2.valueStyle;
    return renderMode === "richText" ? (noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameRichText(ctx, readableName, nameStyle)) + (noValue ? "" : wrapInlineValueRichText(ctx, readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)) : wrapBlockHTML(toolTipTextStyle, (noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameHTML(readableName, !noMarker, nameStyle)) + (noValue ? "" : wrapInlineValueHTML(readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)), topMarginForOuterGap);
  }
  function buildTooltipMarkup(fragment, markupStyleCreator, renderMode, orderMode, useUTC, toolTipTextStyle) {
    if (!fragment) {
      return;
    }
    var builder = getBuilder(fragment);
    var ctx = {
      useUTC,
      renderMode,
      orderMode,
      markupStyleCreator,
      valueFormatter: fragment.valueFormatter
    };
    return builder(ctx, fragment, 0, toolTipTextStyle);
  }
  function getGap(gapLevel) {
    return {
      html: HTML_GAPS[gapLevel],
      richText: RICH_TEXT_GAPS[gapLevel]
    };
  }
  function wrapBlockHTML(textStyle, encodedContent, topGap) {
    var clearfix = '<div style="clear:both"></div>';
    var marginCSS = "margin: " + topGap + "px 0 0";
    var tooltipLineHeight = getTooltipLineHeight(textStyle);
    return '<div style="' + marginCSS + ";" + tooltipLineHeight + ';">' + encodedContent + clearfix + "</div>";
  }
  function wrapInlineNameHTML(name, leftHasMarker, style) {
    var marginCss = leftHasMarker ? "margin-left:2px" : "";
    return '<span style="' + style + ";" + marginCss + '">' + encodeHTML(name) + "</span>";
  }
  function wrapInlineValueHTML(valueList, alignRight, valueCloseToMarker, style) {
    var paddingStr = valueCloseToMarker ? "10px" : "20px";
    var alignCSS = alignRight ? "float:right;margin-left:" + paddingStr : "";
    valueList = isArray(valueList) ? valueList : [valueList];
    return '<span style="' + alignCSS + ";" + style + '">' + map$1(valueList, function(value) {
      return encodeHTML(value);
    }).join("&nbsp;&nbsp;") + "</span>";
  }
  function wrapInlineNameRichText(ctx, name, style) {
    return ctx.markupStyleCreator.wrapRichTextStyle(name, style);
  }
  function wrapInlineValueRichText(ctx, values, alignRight, valueCloseToMarker, style) {
    var styles = [style];
    var paddingLeft = valueCloseToMarker ? 10 : 20;
    alignRight && styles.push({
      padding: [0, 0, 0, paddingLeft],
      align: "right"
    });
    return ctx.markupStyleCreator.wrapRichTextStyle(isArray(values) ? values.join("  ") : values, styles);
  }
  function retrieveVisualColorForTooltipMarker(series, dataIndex) {
    var style = series.getData().getItemVisual(dataIndex, "style");
    var color2 = style[series.visualDrawType];
    return convertToColorString(color2);
  }
  function getPaddingFromTooltipModel(model, renderMode) {
    var padding = model.get("padding");
    return padding != null ? padding : renderMode === "richText" ? [8, 10] : 10;
  }
  var TooltipMarkupStyleCreator = (
    /** @class */
    function() {
      function TooltipMarkupStyleCreator2() {
        this.richTextStyles = {};
        this._nextStyleNameId = getRandomIdBase();
      }
      TooltipMarkupStyleCreator2.prototype._generateStyleName = function() {
        return "__EC_aUTo_" + this._nextStyleNameId++;
      };
      TooltipMarkupStyleCreator2.prototype.makeTooltipMarker = function(markerType, colorStr, renderMode) {
        var markerId = renderMode === "richText" ? this._generateStyleName() : null;
        var marker = getTooltipMarker({
          color: colorStr,
          type: markerType,
          renderMode,
          markerId
        });
        if (isString(marker)) {
          return marker;
        } else {
          if (define_process_env_default$r.NODE_ENV !== "production") {
            assert(markerId);
          }
          this.richTextStyles[markerId] = marker.style;
          return marker.content;
        }
      };
      TooltipMarkupStyleCreator2.prototype.wrapRichTextStyle = function(text, styles) {
        var finalStl = {};
        if (isArray(styles)) {
          each$5(styles, function(stl) {
            return extend(finalStl, stl);
          });
        } else {
          extend(finalStl, styles);
        }
        var styleName = this._generateStyleName();
        this.richTextStyles[styleName] = finalStl;
        return "{" + styleName + "|" + text + "}";
      };
      return TooltipMarkupStyleCreator2;
    }()
  );
  function defaultSeriesFormatTooltip(opt) {
    var series = opt.series;
    var dataIndex = opt.dataIndex;
    var multipleSeries = opt.multipleSeries;
    var data = series.getData();
    var tooltipDims = data.mapDimensionsAll("defaultedTooltip");
    var tooltipDimLen = tooltipDims.length;
    var value = series.getRawValue(dataIndex);
    var isValueArr = isArray(value);
    var markerColor = retrieveVisualColorForTooltipMarker(series, dataIndex);
    var inlineValue;
    var inlineValueType;
    var subBlocks;
    var sortParam;
    if (tooltipDimLen > 1 || isValueArr && !tooltipDimLen) {
      var formatArrResult = formatTooltipArrayValue(value, series, dataIndex, tooltipDims, markerColor);
      inlineValue = formatArrResult.inlineValues;
      inlineValueType = formatArrResult.inlineValueTypes;
      subBlocks = formatArrResult.blocks;
      sortParam = formatArrResult.inlineValues[0];
    } else if (tooltipDimLen) {
      var dimInfo = data.getDimensionInfo(tooltipDims[0]);
      sortParam = inlineValue = retrieveRawValue(data, dataIndex, tooltipDims[0]);
      inlineValueType = dimInfo.type;
    } else {
      sortParam = inlineValue = isValueArr ? value[0] : value;
    }
    var seriesNameSpecified = isNameSpecified(series);
    var seriesName = seriesNameSpecified && series.name || "";
    var itemName = data.getName(dataIndex);
    var inlineName = multipleSeries ? seriesName : itemName;
    return createTooltipMarkup("section", {
      header: seriesName,
      // When series name is not specified, do not show a header line with only '-'.
      // This case always happens in tooltip.trigger: 'item'.
      noHeader: multipleSeries || !seriesNameSpecified,
      sortParam,
      blocks: [createTooltipMarkup("nameValue", {
        markerType: "item",
        markerColor,
        // Do not mix display seriesName and itemName in one tooltip,
        // which might confuses users.
        name: inlineName,
        // name dimension might be auto assigned, where the name might
        // be not readable. So we check trim here.
        noName: !trim(inlineName),
        value: inlineValue,
        valueType: inlineValueType,
        dataIndex
      })].concat(subBlocks || [])
    });
  }
  function formatTooltipArrayValue(value, series, dataIndex, tooltipDims, colorStr) {
    var data = series.getData();
    var isValueMultipleLine = reduce(value, function(isValueMultipleLine2, val, idx) {
      var dimItem = data.getDimensionInfo(idx);
      return isValueMultipleLine2 = isValueMultipleLine2 || dimItem && dimItem.tooltip !== false && dimItem.displayName != null;
    }, false);
    var inlineValues = [];
    var inlineValueTypes = [];
    var blocks = [];
    tooltipDims.length ? each$5(tooltipDims, function(dim) {
      setEachItem(retrieveRawValue(data, dataIndex, dim), dim);
    }) : each$5(value, setEachItem);
    function setEachItem(val, dim) {
      var dimInfo = data.getDimensionInfo(dim);
      if (!dimInfo || dimInfo.otherDims.tooltip === false) {
        return;
      }
      if (isValueMultipleLine) {
        blocks.push(createTooltipMarkup("nameValue", {
          markerType: "subItem",
          markerColor: colorStr,
          name: dimInfo.displayName,
          value: val,
          valueType: dimInfo.type
        }));
      } else {
        inlineValues.push(val);
        inlineValueTypes.push(dimInfo.type);
      }
    }
    return {
      inlineValues,
      inlineValueTypes,
      blocks
    };
  }
  var define_process_env_default$q = {};
  var inner$9 = makeInner();
  function getSelectionKey(data, dataIndex) {
    return data.getName(dataIndex) || data.getId(dataIndex);
  }
  var SERIES_UNIVERSAL_TRANSITION_PROP = "__universalTransitionEnabled";
  var SeriesModel = (
    /** @class */
    function(_super) {
      __extends(SeriesModel2, _super);
      function SeriesModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._selectedDataIndicesMap = {};
        return _this;
      }
      SeriesModel2.prototype.init = function(option, parentModel, ecModel) {
        this.seriesIndex = this.componentIndex;
        this.dataTask = createTask({
          count: dataTaskCount,
          reset: dataTaskReset
        });
        this.dataTask.context = {
          model: this
        };
        this.mergeDefaultAndTheme(option, ecModel);
        var sourceManager = inner$9(this).sourceManager = new SourceManager(this);
        sourceManager.prepareSource();
        var data = this.getInitialData(option, ecModel);
        wrapData(data, this);
        this.dataTask.context.data = data;
        if (define_process_env_default$q.NODE_ENV !== "production") {
          assert(data, "getInitialData returned invalid data.");
        }
        inner$9(this).dataBeforeProcessed = data;
        autoSeriesName(this);
        this._initSelectedMapFromData(data);
      };
      SeriesModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
        var layoutMode = fetchLayoutMode(this);
        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
        var themeSubType = this.subType;
        if (ComponentModel.hasClass(themeSubType)) {
          themeSubType += "Series";
        }
        merge(option, ecModel.getTheme().get(this.subType));
        merge(option, this.getDefaultOption());
        defaultEmphasis(option, "label", ["show"]);
        this.fillDataTextStyle(option.data);
        if (layoutMode) {
          mergeLayoutParam(option, inputPositionParams, layoutMode);
        }
      };
      SeriesModel2.prototype.mergeOption = function(newSeriesOption, ecModel) {
        newSeriesOption = merge(this.option, newSeriesOption, true);
        this.fillDataTextStyle(newSeriesOption.data);
        var layoutMode = fetchLayoutMode(this);
        if (layoutMode) {
          mergeLayoutParam(this.option, newSeriesOption, layoutMode);
        }
        var sourceManager = inner$9(this).sourceManager;
        sourceManager.dirty();
        sourceManager.prepareSource();
        var data = this.getInitialData(newSeriesOption, ecModel);
        wrapData(data, this);
        this.dataTask.dirty();
        this.dataTask.context.data = data;
        inner$9(this).dataBeforeProcessed = data;
        autoSeriesName(this);
        this._initSelectedMapFromData(data);
      };
      SeriesModel2.prototype.fillDataTextStyle = function(data) {
        if (data && !isTypedArray(data)) {
          var props = ["show"];
          for (var i = 0; i < data.length; i++) {
            if (data[i] && data[i].label) {
              defaultEmphasis(data[i], "label", props);
            }
          }
        }
      };
      SeriesModel2.prototype.getInitialData = function(option, ecModel) {
        return;
      };
      SeriesModel2.prototype.appendData = function(params) {
        var data = this.getRawData();
        data.appendData(params.data);
      };
      SeriesModel2.prototype.getData = function(dataType) {
        var task = getCurrentTask(this);
        if (task) {
          var data = task.context.data;
          return dataType == null || !data.getLinkedData ? data : data.getLinkedData(dataType);
        } else {
          return inner$9(this).data;
        }
      };
      SeriesModel2.prototype.getAllData = function() {
        var mainData = this.getData();
        return mainData && mainData.getLinkedDataAll ? mainData.getLinkedDataAll() : [{
          data: mainData
        }];
      };
      SeriesModel2.prototype.setData = function(data) {
        var task = getCurrentTask(this);
        if (task) {
          var context = task.context;
          context.outputData = data;
          if (task !== this.dataTask) {
            context.data = data;
          }
        }
        inner$9(this).data = data;
      };
      SeriesModel2.prototype.getEncode = function() {
        var encode2 = this.get("encode", true);
        if (encode2) {
          return createHashMap(encode2);
        }
      };
      SeriesModel2.prototype.getSourceManager = function() {
        return inner$9(this).sourceManager;
      };
      SeriesModel2.prototype.getSource = function() {
        return this.getSourceManager().getSource();
      };
      SeriesModel2.prototype.getRawData = function() {
        return inner$9(this).dataBeforeProcessed;
      };
      SeriesModel2.prototype.getColorBy = function() {
        var colorBy = this.get("colorBy");
        return colorBy || "series";
      };
      SeriesModel2.prototype.isColorBySeries = function() {
        return this.getColorBy() === "series";
      };
      SeriesModel2.prototype.getBaseAxis = function() {
        var coordSys = this.coordinateSystem;
        return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
      };
      SeriesModel2.prototype.indicesOfNearest = function(axisDim, dim, value, maxDistance) {
        var data = this.getData();
        var coordSys = this.coordinateSystem;
        var axis = coordSys && coordSys.getAxis(axisDim);
        if (!coordSys || !axis) {
          return [];
        }
        var targetCoord = axis.dataToCoord(value);
        if (maxDistance == null) {
          maxDistance = Infinity;
        }
        var nearestIndices = [];
        var minDist = Infinity;
        var minDiff = -1;
        var nearestIndicesLen = 0;
        data.each(dim, function(dimValue, idx) {
          var dataCoord = axis.dataToCoord(dimValue);
          var diff = targetCoord - dataCoord;
          var dist2 = Math.abs(diff);
          if (dist2 <= maxDistance) {
            if (dist2 < minDist || dist2 === minDist && diff >= 0 && minDiff < 0) {
              minDist = dist2;
              minDiff = diff;
              nearestIndicesLen = 0;
            }
            if (diff === minDiff) {
              nearestIndices[nearestIndicesLen++] = idx;
            }
          }
        });
        nearestIndices.length = nearestIndicesLen;
        return nearestIndices;
      };
      SeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
        return defaultSeriesFormatTooltip({
          series: this,
          dataIndex,
          multipleSeries
        });
      };
      SeriesModel2.prototype.isAnimationEnabled = function() {
        var ecModel = this.ecModel;
        if (env.node && !(ecModel && ecModel.ssr)) {
          return false;
        }
        var animationEnabled = this.getShallow("animation");
        if (animationEnabled) {
          if (this.getData().count() > this.getShallow("animationThreshold")) {
            animationEnabled = false;
          }
        }
        return !!animationEnabled;
      };
      SeriesModel2.prototype.restoreData = function() {
        this.dataTask.dirty();
      };
      SeriesModel2.prototype.getColorFromPalette = function(name, scope, requestColorNum) {
        var ecModel = this.ecModel;
        var color2 = PaletteMixin.prototype.getColorFromPalette.call(this, name, scope, requestColorNum);
        if (!color2) {
          color2 = ecModel.getColorFromPalette(name, scope, requestColorNum);
        }
        return color2;
      };
      SeriesModel2.prototype.coordDimToDataDim = function(coordDim) {
        return this.getRawData().mapDimensionsAll(coordDim);
      };
      SeriesModel2.prototype.getProgressive = function() {
        return this.get("progressive");
      };
      SeriesModel2.prototype.getProgressiveThreshold = function() {
        return this.get("progressiveThreshold");
      };
      SeriesModel2.prototype.select = function(innerDataIndices, dataType) {
        this._innerSelect(this.getData(dataType), innerDataIndices);
      };
      SeriesModel2.prototype.unselect = function(innerDataIndices, dataType) {
        var selectedMap = this.option.selectedMap;
        if (!selectedMap) {
          return;
        }
        var selectedMode = this.option.selectedMode;
        var data = this.getData(dataType);
        if (selectedMode === "series" || selectedMap === "all") {
          this.option.selectedMap = {};
          this._selectedDataIndicesMap = {};
          return;
        }
        for (var i = 0; i < innerDataIndices.length; i++) {
          var dataIndex = innerDataIndices[i];
          var nameOrId = getSelectionKey(data, dataIndex);
          selectedMap[nameOrId] = false;
          this._selectedDataIndicesMap[nameOrId] = -1;
        }
      };
      SeriesModel2.prototype.toggleSelect = function(innerDataIndices, dataType) {
        var tmpArr = [];
        for (var i = 0; i < innerDataIndices.length; i++) {
          tmpArr[0] = innerDataIndices[i];
          this.isSelected(innerDataIndices[i], dataType) ? this.unselect(tmpArr, dataType) : this.select(tmpArr, dataType);
        }
      };
      SeriesModel2.prototype.getSelectedDataIndices = function() {
        if (this.option.selectedMap === "all") {
          return [].slice.call(this.getData().getIndices());
        }
        var selectedDataIndicesMap = this._selectedDataIndicesMap;
        var nameOrIds = keys(selectedDataIndicesMap);
        var dataIndices = [];
        for (var i = 0; i < nameOrIds.length; i++) {
          var dataIndex = selectedDataIndicesMap[nameOrIds[i]];
          if (dataIndex >= 0) {
            dataIndices.push(dataIndex);
          }
        }
        return dataIndices;
      };
      SeriesModel2.prototype.isSelected = function(dataIndex, dataType) {
        var selectedMap = this.option.selectedMap;
        if (!selectedMap) {
          return false;
        }
        var data = this.getData(dataType);
        return (selectedMap === "all" || selectedMap[getSelectionKey(data, dataIndex)]) && !data.getItemModel(dataIndex).get(["select", "disabled"]);
      };
      SeriesModel2.prototype.isUniversalTransitionEnabled = function() {
        if (this[SERIES_UNIVERSAL_TRANSITION_PROP]) {
          return true;
        }
        var universalTransitionOpt = this.option.universalTransition;
        if (!universalTransitionOpt) {
          return false;
        }
        if (universalTransitionOpt === true) {
          return true;
        }
        return universalTransitionOpt && universalTransitionOpt.enabled;
      };
      SeriesModel2.prototype._innerSelect = function(data, innerDataIndices) {
        var _a2, _b2;
        var option = this.option;
        var selectedMode = option.selectedMode;
        var len2 = innerDataIndices.length;
        if (!selectedMode || !len2) {
          return;
        }
        if (selectedMode === "series") {
          option.selectedMap = "all";
        } else if (selectedMode === "multiple") {
          if (!isObject$2(option.selectedMap)) {
            option.selectedMap = {};
          }
          var selectedMap = option.selectedMap;
          for (var i = 0; i < len2; i++) {
            var dataIndex = innerDataIndices[i];
            var nameOrId = getSelectionKey(data, dataIndex);
            selectedMap[nameOrId] = true;
            this._selectedDataIndicesMap[nameOrId] = data.getRawIndex(dataIndex);
          }
        } else if (selectedMode === "single" || selectedMode === true) {
          var lastDataIndex = innerDataIndices[len2 - 1];
          var nameOrId = getSelectionKey(data, lastDataIndex);
          option.selectedMap = (_a2 = {}, _a2[nameOrId] = true, _a2);
          this._selectedDataIndicesMap = (_b2 = {}, _b2[nameOrId] = data.getRawIndex(lastDataIndex), _b2);
        }
      };
      SeriesModel2.prototype._initSelectedMapFromData = function(data) {
        if (this.option.selectedMap) {
          return;
        }
        var dataIndices = [];
        if (data.hasItemOption) {
          data.each(function(idx) {
            var rawItem = data.getRawDataItem(idx);
            if (rawItem && rawItem.selected) {
              dataIndices.push(idx);
            }
          });
        }
        if (dataIndices.length > 0) {
          this._innerSelect(data, dataIndices);
        }
      };
      SeriesModel2.registerClass = function(clz) {
        return ComponentModel.registerClass(clz);
      };
      SeriesModel2.protoInitialize = function() {
        var proto = SeriesModel2.prototype;
        proto.type = "series.__base__";
        proto.seriesIndex = 0;
        proto.ignoreStyleOnData = false;
        proto.hasSymbolVisual = false;
        proto.defaultSymbol = "circle";
        proto.visualStyleAccessPath = "itemStyle";
        proto.visualDrawType = "fill";
      }();
      return SeriesModel2;
    }(ComponentModel)
  );
  mixin(SeriesModel, DataFormatMixin);
  mixin(SeriesModel, PaletteMixin);
  mountExtend(SeriesModel, ComponentModel);
  function autoSeriesName(seriesModel) {
    var name = seriesModel.name;
    if (!isNameSpecified(seriesModel)) {
      seriesModel.name = getSeriesAutoName(seriesModel) || name;
    }
  }
  function getSeriesAutoName(seriesModel) {
    var data = seriesModel.getRawData();
    var dataDims = data.mapDimensionsAll("seriesName");
    var nameArr = [];
    each$5(dataDims, function(dataDim) {
      var dimInfo = data.getDimensionInfo(dataDim);
      dimInfo.displayName && nameArr.push(dimInfo.displayName);
    });
    return nameArr.join(" ");
  }
  function dataTaskCount(context) {
    return context.model.getRawData().count();
  }
  function dataTaskReset(context) {
    var seriesModel = context.model;
    seriesModel.setData(seriesModel.getRawData().cloneShallow());
    return dataTaskProgress;
  }
  function dataTaskProgress(param, context) {
    if (context.outputData && param.end > context.outputData.count()) {
      context.model.getRawData().cloneShallow(context.outputData);
    }
  }
  function wrapData(data, seriesModel) {
    each$5(concatArray(data.CHANGABLE_METHODS, data.DOWNSAMPLE_METHODS), function(methodName) {
      data.wrapMethod(methodName, curry$1(onDataChange, seriesModel));
    });
  }
  function onDataChange(seriesModel, newList) {
    var task = getCurrentTask(seriesModel);
    if (task) {
      task.setOutputEnd((newList || this).count());
    }
    return newList;
  }
  function getCurrentTask(seriesModel) {
    var scheduler = (seriesModel.ecModel || {}).scheduler;
    var pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);
    if (pipeline) {
      var task = pipeline.currentTask;
      if (task) {
        var agentStubMap = task.agentStubMap;
        if (agentStubMap) {
          task = agentStubMap.get(seriesModel.uid);
        }
      }
      return task;
    }
  }
  var ComponentView = (
    /** @class */
    function() {
      function ComponentView2() {
        this.group = new Group$2();
        this.uid = getUID("viewComponent");
      }
      ComponentView2.prototype.init = function(ecModel, api) {
      };
      ComponentView2.prototype.render = function(model, ecModel, api, payload) {
      };
      ComponentView2.prototype.dispose = function(ecModel, api) {
      };
      ComponentView2.prototype.updateView = function(model, ecModel, api, payload) {
      };
      ComponentView2.prototype.updateLayout = function(model, ecModel, api, payload) {
      };
      ComponentView2.prototype.updateVisual = function(model, ecModel, api, payload) {
      };
      ComponentView2.prototype.toggleBlurSeries = function(seriesModels, isBlur, ecModel) {
      };
      ComponentView2.prototype.eachRendered = function(cb) {
        var group = this.group;
        if (group) {
          group.traverse(cb);
        }
      };
      return ComponentView2;
    }()
  );
  enableClassExtend(ComponentView);
  enableClassManagement(ComponentView);
  function createRenderPlanner() {
    var inner2 = makeInner();
    return function(seriesModel) {
      var fields = inner2(seriesModel);
      var pipelineContext = seriesModel.pipelineContext;
      var originalLarge = !!fields.large;
      var originalProgressive = !!fields.progressiveRender;
      var large = fields.large = !!(pipelineContext && pipelineContext.large);
      var progressive = fields.progressiveRender = !!(pipelineContext && pipelineContext.progressiveRender);
      return !!(originalLarge !== large || originalProgressive !== progressive) && "reset";
    };
  }
  var define_process_env_default$p = {};
  var inner$8 = makeInner();
  var renderPlanner = createRenderPlanner();
  var ChartView = (
    /** @class */
    function() {
      function ChartView2() {
        this.group = new Group$2();
        this.uid = getUID("viewChart");
        this.renderTask = createTask({
          plan: renderTaskPlan,
          reset: renderTaskReset
        });
        this.renderTask.context = {
          view: this
        };
      }
      ChartView2.prototype.init = function(ecModel, api) {
      };
      ChartView2.prototype.render = function(seriesModel, ecModel, api, payload) {
        if (define_process_env_default$p.NODE_ENV !== "production") {
          throw new Error("render method must been implemented");
        }
      };
      ChartView2.prototype.highlight = function(seriesModel, ecModel, api, payload) {
        var data = seriesModel.getData(payload && payload.dataType);
        if (!data) {
          if (define_process_env_default$p.NODE_ENV !== "production") {
            error("Unknown dataType " + payload.dataType);
          }
          return;
        }
        toggleHighlight(data, payload, "emphasis");
      };
      ChartView2.prototype.downplay = function(seriesModel, ecModel, api, payload) {
        var data = seriesModel.getData(payload && payload.dataType);
        if (!data) {
          if (define_process_env_default$p.NODE_ENV !== "production") {
            error("Unknown dataType " + payload.dataType);
          }
          return;
        }
        toggleHighlight(data, payload, "normal");
      };
      ChartView2.prototype.remove = function(ecModel, api) {
        this.group.removeAll();
      };
      ChartView2.prototype.dispose = function(ecModel, api) {
      };
      ChartView2.prototype.updateView = function(seriesModel, ecModel, api, payload) {
        this.render(seriesModel, ecModel, api, payload);
      };
      ChartView2.prototype.updateLayout = function(seriesModel, ecModel, api, payload) {
        this.render(seriesModel, ecModel, api, payload);
      };
      ChartView2.prototype.updateVisual = function(seriesModel, ecModel, api, payload) {
        this.render(seriesModel, ecModel, api, payload);
      };
      ChartView2.prototype.eachRendered = function(cb) {
        traverseElements(this.group, cb);
      };
      ChartView2.markUpdateMethod = function(payload, methodName) {
        inner$8(payload).updateMethod = methodName;
      };
      ChartView2.protoInitialize = function() {
        var proto = ChartView2.prototype;
        proto.type = "chart";
      }();
      return ChartView2;
    }()
  );
  function elSetState(el, state, highlightDigit) {
    if (el && isHighDownDispatcher(el)) {
      (state === "emphasis" ? enterEmphasis : leaveEmphasis)(el, highlightDigit);
    }
  }
  function toggleHighlight(data, payload, state) {
    var dataIndex = queryDataIndex(data, payload);
    var highlightDigit = payload && payload.highlightKey != null ? getHighlightDigit(payload.highlightKey) : null;
    if (dataIndex != null) {
      each$5(normalizeToArray(dataIndex), function(dataIdx) {
        elSetState(data.getItemGraphicEl(dataIdx), state, highlightDigit);
      });
    } else {
      data.eachItemGraphicEl(function(el) {
        elSetState(el, state, highlightDigit);
      });
    }
  }
  enableClassExtend(ChartView, ["dispose"]);
  enableClassManagement(ChartView);
  function renderTaskPlan(context) {
    return renderPlanner(context.model);
  }
  function renderTaskReset(context) {
    var seriesModel = context.model;
    var ecModel = context.ecModel;
    var api = context.api;
    var payload = context.payload;
    var progressiveRender = seriesModel.pipelineContext.progressiveRender;
    var view = context.view;
    var updateMethod = payload && inner$8(payload).updateMethod;
    var methodName = progressiveRender ? "incrementalPrepareRender" : updateMethod && view[updateMethod] ? updateMethod : "render";
    if (methodName !== "render") {
      view[methodName](seriesModel, ecModel, api, payload);
    }
    return progressMethodMap[methodName];
  }
  var progressMethodMap = {
    incrementalPrepareRender: {
      progress: function(params, context) {
        context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload);
      }
    },
    render: {
      // Put view.render in `progress` to support appendData. But in this case
      // view.render should not be called in reset, otherwise it will be called
      // twise. Use `forceFirstProgress` to make sure that view.render is called
      // in any cases.
      forceFirstProgress: true,
      progress: function(params, context) {
        context.view.render(context.model, context.ecModel, context.api, context.payload);
      }
    }
  };
  var ORIGIN_METHOD = "\0__throttleOriginMethod";
  var RATE = "\0__throttleRate";
  var THROTTLE_TYPE = "\0__throttleType";
  function throttle(fn, delay, debounce) {
    var currCall;
    var lastCall = 0;
    var lastExec = 0;
    var timer = null;
    var diff;
    var scope;
    var args;
    var debounceNextCall;
    delay = delay || 0;
    function exec() {
      lastExec = (/* @__PURE__ */ new Date()).getTime();
      timer = null;
      fn.apply(scope, args || []);
    }
    var cb = function() {
      var cbArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        cbArgs[_i] = arguments[_i];
      }
      currCall = (/* @__PURE__ */ new Date()).getTime();
      scope = this;
      args = cbArgs;
      var thisDelay = debounceNextCall || delay;
      var thisDebounce = debounceNextCall || debounce;
      debounceNextCall = null;
      diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;
      clearTimeout(timer);
      if (thisDebounce) {
        timer = setTimeout(exec, thisDelay);
      } else {
        if (diff >= 0) {
          exec();
        } else {
          timer = setTimeout(exec, -diff);
        }
      }
      lastCall = currCall;
    };
    cb.clear = function() {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
    };
    cb.debounceNextCall = function(debounceDelay) {
      debounceNextCall = debounceDelay;
    };
    return cb;
  }
  function createOrUpdate(obj, fnAttr, rate, throttleType) {
    var fn = obj[fnAttr];
    if (!fn) {
      return;
    }
    var originFn = fn[ORIGIN_METHOD] || fn;
    var lastThrottleType = fn[THROTTLE_TYPE];
    var lastRate = fn[RATE];
    if (lastRate !== rate || lastThrottleType !== throttleType) {
      if (rate == null || !throttleType) {
        return obj[fnAttr] = originFn;
      }
      fn = obj[fnAttr] = throttle(originFn, rate, throttleType === "debounce");
      fn[ORIGIN_METHOD] = originFn;
      fn[THROTTLE_TYPE] = throttleType;
      fn[RATE] = rate;
    }
    return fn;
  }
  function clear(obj, fnAttr) {
    var fn = obj[fnAttr];
    if (fn && fn[ORIGIN_METHOD]) {
      fn.clear && fn.clear();
      obj[fnAttr] = fn[ORIGIN_METHOD];
    }
  }
  var inner$7 = makeInner();
  var defaultStyleMappers = {
    itemStyle: makeStyleMapper(ITEM_STYLE_KEY_MAP, true),
    lineStyle: makeStyleMapper(LINE_STYLE_KEY_MAP, true)
  };
  var defaultColorKey = {
    lineStyle: "stroke",
    itemStyle: "fill"
  };
  function getStyleMapper(seriesModel, stylePath) {
    var styleMapper = seriesModel.visualStyleMapper || defaultStyleMappers[stylePath];
    if (!styleMapper) {
      console.warn("Unknown style type '" + stylePath + "'.");
      return defaultStyleMappers.itemStyle;
    }
    return styleMapper;
  }
  function getDefaultColorKey(seriesModel, stylePath) {
    var colorKey = seriesModel.visualDrawType || defaultColorKey[stylePath];
    if (!colorKey) {
      console.warn("Unknown style type '" + stylePath + "'.");
      return "fill";
    }
    return colorKey;
  }
  var seriesStyleTask = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(seriesModel, ecModel) {
      var data = seriesModel.getData();
      var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
      var styleModel = seriesModel.getModel(stylePath);
      var getStyle2 = getStyleMapper(seriesModel, stylePath);
      var globalStyle = getStyle2(styleModel);
      var decalOption = styleModel.getShallow("decal");
      if (decalOption) {
        data.setVisual("decal", decalOption);
        decalOption.dirty = true;
      }
      var colorKey = getDefaultColorKey(seriesModel, stylePath);
      var color2 = globalStyle[colorKey];
      var colorCallback = isFunction(color2) ? color2 : null;
      var hasAutoColor = globalStyle.fill === "auto" || globalStyle.stroke === "auto";
      if (!globalStyle[colorKey] || colorCallback || hasAutoColor) {
        var colorPalette = seriesModel.getColorFromPalette(
          // TODO series count changed.
          seriesModel.name,
          null,
          ecModel.getSeriesCount()
        );
        if (!globalStyle[colorKey]) {
          globalStyle[colorKey] = colorPalette;
          data.setVisual("colorFromPalette", true);
        }
        globalStyle.fill = globalStyle.fill === "auto" || isFunction(globalStyle.fill) ? colorPalette : globalStyle.fill;
        globalStyle.stroke = globalStyle.stroke === "auto" || isFunction(globalStyle.stroke) ? colorPalette : globalStyle.stroke;
      }
      data.setVisual("style", globalStyle);
      data.setVisual("drawType", colorKey);
      if (!ecModel.isSeriesFiltered(seriesModel) && colorCallback) {
        data.setVisual("colorFromPalette", false);
        return {
          dataEach: function(data2, idx) {
            var dataParams = seriesModel.getDataParams(idx);
            var itemStyle = extend({}, globalStyle);
            itemStyle[colorKey] = colorCallback(dataParams);
            data2.setItemVisual(idx, "style", itemStyle);
          }
        };
      }
    }
  };
  var sharedModel = new Model();
  var dataStyleTask = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(seriesModel, ecModel) {
      if (seriesModel.ignoreStyleOnData || ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }
      var data = seriesModel.getData();
      var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
      var getStyle2 = getStyleMapper(seriesModel, stylePath);
      var colorKey = data.getVisual("drawType");
      return {
        dataEach: data.hasItemOption ? function(data2, idx) {
          var rawItem = data2.getRawDataItem(idx);
          if (rawItem && rawItem[stylePath]) {
            sharedModel.option = rawItem[stylePath];
            var style = getStyle2(sharedModel);
            var existsStyle = data2.ensureUniqueItemVisual(idx, "style");
            extend(existsStyle, style);
            if (sharedModel.option.decal) {
              data2.setItemVisual(idx, "decal", sharedModel.option.decal);
              sharedModel.option.decal.dirty = true;
            }
            if (colorKey in style) {
              data2.setItemVisual(idx, "colorFromPalette", false);
            }
          }
        } : null
      };
    }
  };
  var dataColorPaletteTask = {
    performRawSeries: true,
    overallReset: function(ecModel) {
      var paletteScopeGroupByType = createHashMap();
      ecModel.eachSeries(function(seriesModel) {
        var colorBy = seriesModel.getColorBy();
        if (seriesModel.isColorBySeries()) {
          return;
        }
        var key2 = seriesModel.type + "-" + colorBy;
        var colorScope = paletteScopeGroupByType.get(key2);
        if (!colorScope) {
          colorScope = {};
          paletteScopeGroupByType.set(key2, colorScope);
        }
        inner$7(seriesModel).scope = colorScope;
      });
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.isColorBySeries() || ecModel.isSeriesFiltered(seriesModel)) {
          return;
        }
        var dataAll = seriesModel.getRawData();
        var idxMap = {};
        var data = seriesModel.getData();
        var colorScope = inner$7(seriesModel).scope;
        var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
        var colorKey = getDefaultColorKey(seriesModel, stylePath);
        data.each(function(idx) {
          var rawIdx = data.getRawIndex(idx);
          idxMap[rawIdx] = idx;
        });
        dataAll.each(function(rawIdx) {
          var idx = idxMap[rawIdx];
          var fromPalette = data.getItemVisual(idx, "colorFromPalette");
          if (fromPalette) {
            var itemStyle = data.ensureUniqueItemVisual(idx, "style");
            var name_1 = dataAll.getName(rawIdx) || rawIdx + "";
            var dataCount = dataAll.count();
            itemStyle[colorKey] = seriesModel.getColorFromPalette(name_1, colorScope, dataCount);
          }
        });
      });
    }
  };
  var PI$1 = Math.PI;
  function defaultLoading(api, opts) {
    opts = opts || {};
    defaults(opts, {
      text: "loading",
      textColor: tokens.color.primary,
      fontSize: 12,
      fontWeight: "normal",
      fontStyle: "normal",
      fontFamily: "sans-serif",
      maskColor: "rgba(255,255,255,0.8)",
      showSpinner: true,
      color: tokens.color.theme[0],
      spinnerRadius: 10,
      lineWidth: 5,
      zlevel: 0
    });
    var group = new Group$2();
    var mask = new Rect$1({
      style: {
        fill: opts.maskColor
      },
      zlevel: opts.zlevel,
      z: 1e4
    });
    group.add(mask);
    var textContent = new ZRText({
      style: {
        text: opts.text,
        fill: opts.textColor,
        fontSize: opts.fontSize,
        fontWeight: opts.fontWeight,
        fontStyle: opts.fontStyle,
        fontFamily: opts.fontFamily
      },
      zlevel: opts.zlevel,
      z: 10001
    });
    var labelRect = new Rect$1({
      style: {
        fill: "none"
      },
      textContent,
      textConfig: {
        position: "right",
        distance: 10
      },
      zlevel: opts.zlevel,
      z: 10001
    });
    group.add(labelRect);
    var arc;
    if (opts.showSpinner) {
      arc = new Arc({
        shape: {
          startAngle: -PI$1 / 2,
          endAngle: -PI$1 / 2 + 0.1,
          r: opts.spinnerRadius
        },
        style: {
          stroke: opts.color,
          lineCap: "round",
          lineWidth: opts.lineWidth
        },
        zlevel: opts.zlevel,
        z: 10001
      });
      arc.animateShape(true).when(1e3, {
        endAngle: PI$1 * 3 / 2
      }).start("circularInOut");
      arc.animateShape(true).when(1e3, {
        startAngle: PI$1 * 3 / 2
      }).delay(300).start("circularInOut");
      group.add(arc);
    }
    group.resize = function() {
      var textWidth = textContent.getBoundingRect().width;
      var r = opts.showSpinner ? opts.spinnerRadius : 0;
      var cx = (api.getWidth() - r * 2 - (opts.showSpinner && textWidth ? 10 : 0) - textWidth) / 2 - (opts.showSpinner && textWidth ? 0 : 5 + textWidth / 2) + (opts.showSpinner ? 0 : textWidth / 2) + (textWidth ? 0 : r);
      var cy = api.getHeight() / 2;
      opts.showSpinner && arc.setShape({
        cx,
        cy
      });
      labelRect.setShape({
        x: cx - r,
        y: cy - r,
        width: r * 2,
        height: r * 2
      });
      mask.setShape({
        x: 0,
        y: 0,
        width: api.getWidth(),
        height: api.getHeight()
      });
    };
    group.resize();
    return group;
  }
  var define_process_env_default$o = {};
  var Scheduler = (
    /** @class */
    function() {
      function Scheduler2(ecInstance, api, dataProcessorHandlers, visualHandlers) {
        this._stageTaskMap = createHashMap();
        this.ecInstance = ecInstance;
        this.api = api;
        dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();
        visualHandlers = this._visualHandlers = visualHandlers.slice();
        this._allHandlers = dataProcessorHandlers.concat(visualHandlers);
      }
      Scheduler2.prototype.restoreData = function(ecModel, payload) {
        ecModel.restoreData(payload);
        this._stageTaskMap.each(function(taskRecord) {
          var overallTask = taskRecord.overallTask;
          overallTask && overallTask.dirty();
        });
      };
      Scheduler2.prototype.getPerformArgs = function(task, isBlock) {
        if (!task.__pipeline) {
          return;
        }
        var pipeline = this._pipelineMap.get(task.__pipeline.id);
        var pCtx = pipeline.context;
        var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;
        var step = incremental ? pipeline.step : null;
        var modDataCount = pCtx && pCtx.modDataCount;
        var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;
        return {
          step,
          modBy,
          modDataCount
        };
      };
      Scheduler2.prototype.getPipeline = function(pipelineId) {
        return this._pipelineMap.get(pipelineId);
      };
      Scheduler2.prototype.updateStreamModes = function(seriesModel, view) {
        var pipeline = this._pipelineMap.get(seriesModel.uid);
        var data = seriesModel.getData();
        var dataLen = data.count();
        var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;
        var large = seriesModel.get("large") && dataLen >= seriesModel.get("largeThreshold");
        var modDataCount = seriesModel.get("progressiveChunkMode") === "mod" ? dataLen : null;
        seriesModel.pipelineContext = pipeline.context = {
          progressiveRender,
          modDataCount,
          large
        };
      };
      Scheduler2.prototype.restorePipelines = function(ecModel) {
        var scheduler = this;
        var pipelineMap = scheduler._pipelineMap = createHashMap();
        ecModel.eachSeries(function(seriesModel) {
          var progressive = seriesModel.getProgressive();
          var pipelineId = seriesModel.uid;
          pipelineMap.set(pipelineId, {
            id: pipelineId,
            head: null,
            tail: null,
            threshold: seriesModel.getProgressiveThreshold(),
            progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),
            blockIndex: -1,
            step: Math.round(progressive || 700),
            count: 0
          });
          scheduler._pipe(seriesModel, seriesModel.dataTask);
        });
      };
      Scheduler2.prototype.prepareStageTasks = function() {
        var stageTaskMap = this._stageTaskMap;
        var ecModel = this.api.getModel();
        var api = this.api;
        each$5(this._allHandlers, function(handler) {
          var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {});
          var errMsg = "";
          if (define_process_env_default$o.NODE_ENV !== "production") {
            errMsg = '"reset" and "overallReset" must not be both specified.';
          }
          assert(!(handler.reset && handler.overallReset), errMsg);
          handler.reset && this._createSeriesStageTask(handler, record, ecModel, api);
          handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api);
        }, this);
      };
      Scheduler2.prototype.prepareView = function(view, model, ecModel, api) {
        var renderTask = view.renderTask;
        var context = renderTask.context;
        context.model = model;
        context.ecModel = ecModel;
        context.api = api;
        renderTask.__block = !view.incrementalPrepareRender;
        this._pipe(model, renderTask);
      };
      Scheduler2.prototype.performDataProcessorTasks = function(ecModel, payload) {
        this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, {
          block: true
        });
      };
      Scheduler2.prototype.performVisualTasks = function(ecModel, payload, opt) {
        this._performStageTasks(this._visualHandlers, ecModel, payload, opt);
      };
      Scheduler2.prototype._performStageTasks = function(stageHandlers, ecModel, payload, opt) {
        opt = opt || {};
        var unfinished = false;
        var scheduler = this;
        each$5(stageHandlers, function(stageHandler, idx) {
          if (opt.visualType && opt.visualType !== stageHandler.visualType) {
            return;
          }
          var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);
          var seriesTaskMap = stageHandlerRecord.seriesTaskMap;
          var overallTask = stageHandlerRecord.overallTask;
          if (overallTask) {
            var overallNeedDirty_1;
            var agentStubMap = overallTask.agentStubMap;
            agentStubMap.each(function(stub) {
              if (needSetDirty(opt, stub)) {
                stub.dirty();
                overallNeedDirty_1 = true;
              }
            });
            overallNeedDirty_1 && overallTask.dirty();
            scheduler.updatePayload(overallTask, payload);
            var performArgs_1 = scheduler.getPerformArgs(overallTask, opt.block);
            agentStubMap.each(function(stub) {
              stub.perform(performArgs_1);
            });
            if (overallTask.perform(performArgs_1)) {
              unfinished = true;
            }
          } else if (seriesTaskMap) {
            seriesTaskMap.each(function(task, pipelineId) {
              if (needSetDirty(opt, task)) {
                task.dirty();
              }
              var performArgs = scheduler.getPerformArgs(task, opt.block);
              performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);
              scheduler.updatePayload(task, payload);
              if (task.perform(performArgs)) {
                unfinished = true;
              }
            });
          }
        });
        function needSetDirty(opt2, task) {
          return opt2.setDirty && (!opt2.dirtyMap || opt2.dirtyMap.get(task.__pipeline.id));
        }
        this.unfinished = unfinished || this.unfinished;
      };
      Scheduler2.prototype.performSeriesTasks = function(ecModel) {
        var unfinished;
        ecModel.eachSeries(function(seriesModel) {
          unfinished = seriesModel.dataTask.perform() || unfinished;
        });
        this.unfinished = unfinished || this.unfinished;
      };
      Scheduler2.prototype.plan = function() {
        this._pipelineMap.each(function(pipeline) {
          var task = pipeline.tail;
          do {
            if (task.__block) {
              pipeline.blockIndex = task.__idxInPipeline;
              break;
            }
            task = task.getUpstream();
          } while (task);
        });
      };
      Scheduler2.prototype.updatePayload = function(task, payload) {
        payload !== "remain" && (task.context.payload = payload);
      };
      Scheduler2.prototype._createSeriesStageTask = function(stageHandler, stageHandlerRecord, ecModel, api) {
        var scheduler = this;
        var oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap;
        var newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = createHashMap();
        var seriesType2 = stageHandler.seriesType;
        var getTargetSeries = stageHandler.getTargetSeries;
        if (stageHandler.createOnAllSeries) {
          ecModel.eachRawSeries(create2);
        } else if (seriesType2) {
          ecModel.eachRawSeriesByType(seriesType2, create2);
        } else if (getTargetSeries) {
          getTargetSeries(ecModel, api).each(create2);
        }
        function create2(seriesModel) {
          var pipelineId = seriesModel.uid;
          var task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || createTask({
            plan: seriesTaskPlan,
            reset: seriesTaskReset,
            count: seriesTaskCount
          }));
          task.context = {
            model: seriesModel,
            ecModel,
            api,
            // PENDING: `useClearVisual` not used?
            useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,
            plan: stageHandler.plan,
            reset: stageHandler.reset,
            scheduler
          };
          scheduler._pipe(seriesModel, task);
        }
      };
      Scheduler2.prototype._createOverallStageTask = function(stageHandler, stageHandlerRecord, ecModel, api) {
        var scheduler = this;
        var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || createTask({
          reset: overallTaskReset
        });
        overallTask.context = {
          ecModel,
          api,
          overallReset: stageHandler.overallReset,
          scheduler
        };
        var oldAgentStubMap = overallTask.agentStubMap;
        var newAgentStubMap = overallTask.agentStubMap = createHashMap();
        var seriesType2 = stageHandler.seriesType;
        var getTargetSeries = stageHandler.getTargetSeries;
        var overallProgress = true;
        var shouldOverallTaskDirty = false;
        var errMsg = "";
        if (define_process_env_default$o.NODE_ENV !== "production") {
          errMsg = '"createOnAllSeries" is not supported for "overallReset", because it will block all streams.';
        }
        assert(!stageHandler.createOnAllSeries, errMsg);
        if (seriesType2) {
          ecModel.eachRawSeriesByType(seriesType2, createStub);
        } else if (getTargetSeries) {
          getTargetSeries(ecModel, api).each(createStub);
        } else {
          overallProgress = false;
          each$5(ecModel.getSeries(), createStub);
        }
        function createStub(seriesModel) {
          var pipelineId = seriesModel.uid;
          var stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || // When the result of `getTargetSeries` changed, the overallTask
          // should be set as dirty and re-performed.
          (shouldOverallTaskDirty = true, createTask({
            reset: stubReset,
            onDirty: stubOnDirty
          })));
          stub.context = {
            model: seriesModel,
            overallProgress
            // FIXME:TS never used, so comment it
            // modifyOutputEnd: modifyOutputEnd
          };
          stub.agent = overallTask;
          stub.__block = overallProgress;
          scheduler._pipe(seriesModel, stub);
        }
        if (shouldOverallTaskDirty) {
          overallTask.dirty();
        }
      };
      Scheduler2.prototype._pipe = function(seriesModel, task) {
        var pipelineId = seriesModel.uid;
        var pipeline = this._pipelineMap.get(pipelineId);
        !pipeline.head && (pipeline.head = task);
        pipeline.tail && pipeline.tail.pipe(task);
        pipeline.tail = task;
        task.__idxInPipeline = pipeline.count++;
        task.__pipeline = pipeline;
      };
      Scheduler2.wrapStageHandler = function(stageHandler, visualType) {
        if (isFunction(stageHandler)) {
          stageHandler = {
            overallReset: stageHandler,
            seriesType: detectSeriseType(stageHandler)
          };
        }
        stageHandler.uid = getUID("stageHandler");
        visualType && (stageHandler.visualType = visualType);
        return stageHandler;
      };
      return Scheduler2;
    }()
  );
  function overallTaskReset(context) {
    context.overallReset(context.ecModel, context.api, context.payload);
  }
  function stubReset(context) {
    return context.overallProgress && stubProgress;
  }
  function stubProgress() {
    this.agent.dirty();
    this.getDownstream().dirty();
  }
  function stubOnDirty() {
    this.agent && this.agent.dirty();
  }
  function seriesTaskPlan(context) {
    return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;
  }
  function seriesTaskReset(context) {
    if (context.useClearVisual) {
      context.data.clearAllVisual();
    }
    var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));
    return resetDefines.length > 1 ? map$1(resetDefines, function(v, idx) {
      return makeSeriesTaskProgress(idx);
    }) : singleSeriesTaskProgress;
  }
  var singleSeriesTaskProgress = makeSeriesTaskProgress(0);
  function makeSeriesTaskProgress(resetDefineIdx) {
    return function(params, context) {
      var data = context.data;
      var resetDefine = context.resetDefines[resetDefineIdx];
      if (resetDefine && resetDefine.dataEach) {
        for (var i = params.start; i < params.end; i++) {
          resetDefine.dataEach(data, i);
        }
      } else if (resetDefine && resetDefine.progress) {
        resetDefine.progress(params, data);
      }
    };
  }
  function seriesTaskCount(context) {
    return context.data.count();
  }
  function detectSeriseType(legacyFunc) {
    seriesType = null;
    try {
      legacyFunc(ecModelMock, apiMock);
    } catch (e2) {
    }
    return seriesType;
  }
  var ecModelMock = {};
  var apiMock = {};
  var seriesType;
  mockMethods(ecModelMock, GlobalModel);
  mockMethods(apiMock, ExtensionAPI);
  ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function(type) {
    seriesType = type;
  };
  ecModelMock.eachComponent = function(cond) {
    if (cond.mainType === "series" && cond.subType) {
      seriesType = cond.subType;
    }
  };
  function mockMethods(target, Clz) {
    for (var name_1 in Clz.prototype) {
      target[name_1] = noop;
    }
  }
  var color = tokens.darkColor;
  var backgroundColor = color.background;
  var axisCommon = function() {
    return {
      axisLine: {
        lineStyle: {
          color: color.axisLine
        }
      },
      splitLine: {
        lineStyle: {
          color: color.axisSplitLine
        }
      },
      splitArea: {
        areaStyle: {
          color: [color.backgroundTint, color.backgroundTransparent]
        }
      },
      minorSplitLine: {
        lineStyle: {
          color: color.axisMinorSplitLine
        }
      },
      axisLabel: {
        color: color.axisLabel
      },
      axisName: {}
    };
  };
  var matrixAxis = {
    label: {
      color: color.secondary
    },
    itemStyle: {
      borderColor: color.borderTint
    },
    dividerLineStyle: {
      color: color.border
    }
  };
  var theme = {
    darkMode: true,
    color: color.theme,
    backgroundColor,
    axisPointer: {
      lineStyle: {
        color: color.border
      },
      crossStyle: {
        color: color.borderShade
      },
      label: {
        color: color.tertiary
      }
    },
    legend: {
      textStyle: {
        color: color.secondary
      },
      pageTextStyle: {
        color: color.tertiary
      }
    },
    textStyle: {
      color: color.secondary
    },
    title: {
      textStyle: {
        color: color.primary
      },
      subtextStyle: {
        color: color.quaternary
      }
    },
    toolbox: {
      iconStyle: {
        borderColor: color.accent50
      }
    },
    tooltip: {
      backgroundColor: color.neutral20,
      defaultBorderColor: color.border,
      textStyle: {
        color: color.tertiary
      }
    },
    dataZoom: {
      borderColor: color.accent10,
      textStyle: {
        color: color.tertiary
      },
      brushStyle: {
        color: color.backgroundTint
      },
      handleStyle: {
        color: color.neutral00,
        borderColor: color.accent20
      },
      moveHandleStyle: {
        color: color.accent40
      },
      emphasis: {
        handleStyle: {
          borderColor: color.accent50
        }
      },
      dataBackground: {
        lineStyle: {
          color: color.accent30
        },
        areaStyle: {
          color: color.accent20
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: color.accent50
        },
        areaStyle: {
          color: color.accent30
        }
      }
    },
    visualMap: {
      textStyle: {
        color: color.secondary
      },
      handleStyle: {
        borderColor: color.neutral30
      }
    },
    timeline: {
      lineStyle: {
        color: color.accent10
      },
      label: {
        color: color.tertiary
      },
      controlStyle: {
        color: color.accent30,
        borderColor: color.accent30
      }
    },
    calendar: {
      itemStyle: {
        color: color.neutral00,
        borderColor: color.neutral20
      },
      dayLabel: {
        color: color.tertiary
      },
      monthLabel: {
        color: color.secondary
      },
      yearLabel: {
        color: color.secondary
      }
    },
    matrix: {
      x: matrixAxis,
      y: matrixAxis,
      backgroundColor: {
        borderColor: color.axisLine
      },
      body: {
        itemStyle: {
          borderColor: color.borderTint
        }
      }
    },
    timeAxis: axisCommon(),
    logAxis: axisCommon(),
    valueAxis: axisCommon(),
    categoryAxis: axisCommon(),
    line: {
      symbol: "circle"
    },
    graph: {
      color: color.theme
    },
    gauge: {
      title: {
        color: color.secondary
      },
      axisLine: {
        lineStyle: {
          color: [[1, color.neutral05]]
        }
      },
      axisLabel: {
        color: color.axisLabel
      },
      detail: {
        color: color.primary
      }
    },
    candlestick: {
      itemStyle: {
        color: "#f64e56",
        color0: "#54ea92",
        borderColor: "#f64e56",
        borderColor0: "#54ea92"
        // borderColor: '#ca2824',
        // borderColor0: '#09a443'
      }
    },
    funnel: {
      itemStyle: {
        borderColor: color.background
      }
    },
    radar: function() {
      var radar = axisCommon();
      radar.axisName = {
        color: color.axisLabel
      };
      radar.axisLine.lineStyle.color = color.neutral20;
      return radar;
    }(),
    treemap: {
      breadcrumb: {
        itemStyle: {
          color: color.neutral20,
          textStyle: {
            color: color.secondary
          }
        },
        emphasis: {
          itemStyle: {
            color: color.neutral30
          }
        }
      }
    },
    sunburst: {
      itemStyle: {
        borderColor: color.background
      }
    },
    map: {
      itemStyle: {
        borderColor: color.border,
        areaColor: color.neutral10
      },
      label: {
        color: color.tertiary
      },
      emphasis: {
        label: {
          color: color.primary
        },
        itemStyle: {
          areaColor: color.highlight
        }
      },
      select: {
        label: {
          color: color.primary
        },
        itemStyle: {
          areaColor: color.highlight
        }
      }
    },
    geo: {
      itemStyle: {
        borderColor: color.border,
        areaColor: color.neutral10
      },
      emphasis: {
        label: {
          color: color.primary
        },
        itemStyle: {
          areaColor: color.highlight
        }
      },
      select: {
        label: {
          color: color.primary
        },
        itemStyle: {
          color: color.highlight
        }
      }
    }
  };
  theme.categoryAxis.splitLine.show = false;
  var ECEventProcessor = (
    /** @class */
    function() {
      function ECEventProcessor2() {
      }
      ECEventProcessor2.prototype.normalizeQuery = function(query) {
        var cptQuery = {};
        var dataQuery = {};
        var otherQuery = {};
        if (isString(query)) {
          var condCptType = parseClassType(query);
          cptQuery.mainType = condCptType.main || null;
          cptQuery.subType = condCptType.sub || null;
        } else {
          var suffixes_1 = ["Index", "Name", "Id"];
          var dataKeys_1 = {
            name: 1,
            dataIndex: 1,
            dataType: 1
          };
          each$5(query, function(val, key2) {
            var reserved = false;
            for (var i = 0; i < suffixes_1.length; i++) {
              var propSuffix = suffixes_1[i];
              var suffixPos = key2.lastIndexOf(propSuffix);
              if (suffixPos > 0 && suffixPos === key2.length - propSuffix.length) {
                var mainType = key2.slice(0, suffixPos);
                if (mainType !== "data") {
                  cptQuery.mainType = mainType;
                  cptQuery[propSuffix.toLowerCase()] = val;
                  reserved = true;
                }
              }
            }
            if (dataKeys_1.hasOwnProperty(key2)) {
              dataQuery[key2] = val;
              reserved = true;
            }
            if (!reserved) {
              otherQuery[key2] = val;
            }
          });
        }
        return {
          cptQuery,
          dataQuery,
          otherQuery
        };
      };
      ECEventProcessor2.prototype.filter = function(eventType, query) {
        var eventInfo = this.eventInfo;
        if (!eventInfo) {
          return true;
        }
        var targetEl = eventInfo.targetEl;
        var packedEvent = eventInfo.packedEvent;
        var model = eventInfo.model;
        var view = eventInfo.view;
        if (!model || !view) {
          return true;
        }
        var cptQuery = query.cptQuery;
        var dataQuery = query.dataQuery;
        return check(cptQuery, model, "mainType") && check(cptQuery, model, "subType") && check(cptQuery, model, "index", "componentIndex") && check(cptQuery, model, "name") && check(cptQuery, model, "id") && check(dataQuery, packedEvent, "name") && check(dataQuery, packedEvent, "dataIndex") && check(dataQuery, packedEvent, "dataType") && (!view.filterForExposedEvent || view.filterForExposedEvent(eventType, query.otherQuery, targetEl, packedEvent));
        function check(query2, host, prop, propOnHost) {
          return query2[prop] == null || host[propOnHost || prop] === query2[prop];
        }
      };
      ECEventProcessor2.prototype.afterTrigger = function() {
        this.eventInfo = null;
      };
      return ECEventProcessor2;
    }()
  );
  var SYMBOL_PROPS_WITH_CB = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"];
  var SYMBOL_PROPS = SYMBOL_PROPS_WITH_CB.concat(["symbolKeepAspect"]);
  var seriesSymbolTask = {
    createOnAllSeries: true,
    // For legend.
    performRawSeries: true,
    reset: function(seriesModel, ecModel) {
      var data = seriesModel.getData();
      if (seriesModel.legendIcon) {
        data.setVisual("legendIcon", seriesModel.legendIcon);
      }
      if (!seriesModel.hasSymbolVisual) {
        return;
      }
      var symbolOptions = {};
      var symbolOptionsCb = {};
      var hasCallback = false;
      for (var i = 0; i < SYMBOL_PROPS_WITH_CB.length; i++) {
        var symbolPropName = SYMBOL_PROPS_WITH_CB[i];
        var val = seriesModel.get(symbolPropName);
        if (isFunction(val)) {
          hasCallback = true;
          symbolOptionsCb[symbolPropName] = val;
        } else {
          symbolOptions[symbolPropName] = val;
        }
      }
      symbolOptions.symbol = symbolOptions.symbol || seriesModel.defaultSymbol;
      data.setVisual(extend({
        legendIcon: seriesModel.legendIcon || symbolOptions.symbol,
        symbolKeepAspect: seriesModel.get("symbolKeepAspect")
      }, symbolOptions));
      if (ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }
      var symbolPropsCb = keys(symbolOptionsCb);
      function dataEach(data2, idx) {
        var rawValue = seriesModel.getRawValue(idx);
        var params = seriesModel.getDataParams(idx);
        for (var i2 = 0; i2 < symbolPropsCb.length; i2++) {
          var symbolPropName2 = symbolPropsCb[i2];
          data2.setItemVisual(idx, symbolPropName2, symbolOptionsCb[symbolPropName2](rawValue, params));
        }
      }
      return {
        dataEach: hasCallback ? dataEach : null
      };
    }
  };
  var dataSymbolTask = {
    createOnAllSeries: true,
    // For legend.
    performRawSeries: true,
    reset: function(seriesModel, ecModel) {
      if (!seriesModel.hasSymbolVisual) {
        return;
      }
      if (ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }
      var data = seriesModel.getData();
      function dataEach(data2, idx) {
        var itemModel = data2.getItemModel(idx);
        for (var i = 0; i < SYMBOL_PROPS.length; i++) {
          var symbolPropName = SYMBOL_PROPS[i];
          var val = itemModel.getShallow(symbolPropName, true);
          if (val != null) {
            data2.setItemVisual(idx, symbolPropName, val);
          }
        }
      }
      return {
        dataEach: data.hasItemOption ? dataEach : null
      };
    }
  };
  var define_process_env_default$n = {};
  function getItemVisualFromData(data, dataIndex, key2) {
    switch (key2) {
      case "color":
        var style = data.getItemVisual(dataIndex, "style");
        return style[data.getVisual("drawType")];
      case "opacity":
        return data.getItemVisual(dataIndex, "style").opacity;
      case "symbol":
      case "symbolSize":
      case "liftZ":
        return data.getItemVisual(dataIndex, key2);
      default:
        if (define_process_env_default$n.NODE_ENV !== "production") {
          console.warn("Unknown visual type " + key2);
        }
    }
  }
  function getVisualFromData(data, key2) {
    switch (key2) {
      case "color":
        var style = data.getVisual("style");
        return style[data.getVisual("drawType")];
      case "opacity":
        return data.getVisual("style").opacity;
      case "symbol":
      case "symbolSize":
      case "liftZ":
        return data.getVisual(key2);
      default:
        if (define_process_env_default$n.NODE_ENV !== "production") {
          console.warn("Unknown visual type " + key2);
        }
    }
  }
  var define_process_env_default$m = {};
  function handleSeriesLegacySelectEvents(type, eventPostfix, ecIns, ecModel, payload) {
    var legacyEventName = type + eventPostfix;
    if (!ecIns.isSilent(legacyEventName)) {
      if (define_process_env_default$m.NODE_ENV !== "production") {
        deprecateLog("event " + legacyEventName + " is deprecated.");
      }
      ecModel.eachComponent({
        mainType: "series",
        subType: "pie"
      }, function(seriesModel) {
        var seriesIndex = seriesModel.seriesIndex;
        var selectedMap = seriesModel.option.selectedMap;
        var selected = payload.selected;
        for (var i = 0; i < selected.length; i++) {
          if (selected[i].seriesIndex === seriesIndex) {
            var data = seriesModel.getData();
            var dataIndex = queryDataIndex(data, payload.fromActionPayload);
            ecIns.trigger(legacyEventName, {
              type: legacyEventName,
              seriesId: seriesModel.id,
              name: isArray(dataIndex) ? data.getName(dataIndex[0]) : data.getName(dataIndex),
              selected: isString(selectedMap) ? selectedMap : extend({}, selectedMap)
            });
          }
        }
      });
    }
  }
  function handleLegacySelectEvents(messageCenter, ecIns, api) {
    messageCenter.on("selectchanged", function(params) {
      var ecModel = api.getModel();
      if (params.isFromClick) {
        handleSeriesLegacySelectEvents("map", "selectchanged", ecIns, ecModel, params);
        handleSeriesLegacySelectEvents("pie", "selectchanged", ecIns, ecModel, params);
      } else if (params.fromAction === "select") {
        handleSeriesLegacySelectEvents("map", "selected", ecIns, ecModel, params);
        handleSeriesLegacySelectEvents("pie", "selected", ecIns, ecModel, params);
      } else if (params.fromAction === "unselect") {
        handleSeriesLegacySelectEvents("map", "unselected", ecIns, ecModel, params);
        handleSeriesLegacySelectEvents("pie", "unselected", ecIns, ecModel, params);
      }
    });
  }
  function findEventDispatcher(target, det, returnFirstMatch) {
    var found;
    while (target) {
      if (det(target)) {
        found = target;
        if (returnFirstMatch) {
          break;
        }
      }
      target = target.__hostTarget || target.parent;
    }
    return found;
  }
  var wmUniqueIndex = Math.round(Math.random() * 9);
  var supportDefineProperty = typeof Object.defineProperty === "function";
  var WeakMap = function() {
    function WeakMap2() {
      this._id = "__ec_inner_" + wmUniqueIndex++;
    }
    WeakMap2.prototype.get = function(key2) {
      return this._guard(key2)[this._id];
    };
    WeakMap2.prototype.set = function(key2, value) {
      var target = this._guard(key2);
      if (supportDefineProperty) {
        Object.defineProperty(target, this._id, {
          value,
          enumerable: false,
          configurable: true
        });
      } else {
        target[this._id] = value;
      }
      return this;
    };
    WeakMap2.prototype["delete"] = function(key2) {
      if (this.has(key2)) {
        delete this._guard(key2)[this._id];
        return true;
      }
      return false;
    };
    WeakMap2.prototype.has = function(key2) {
      return !!this._guard(key2)[this._id];
    };
    WeakMap2.prototype._guard = function(key2) {
      if (key2 !== Object(key2)) {
        throw TypeError("Value of WeakMap is not a non-null object.");
      }
      return key2;
    };
    return WeakMap2;
  }();
  var Triangle = Path.extend({
    type: "triangle",
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0
    },
    buildPath: function(path, shape) {
      var cx = shape.cx;
      var cy = shape.cy;
      var width = shape.width / 2;
      var height = shape.height / 2;
      path.moveTo(cx, cy - height);
      path.lineTo(cx + width, cy + height);
      path.lineTo(cx - width, cy + height);
      path.closePath();
    }
  });
  var Diamond = Path.extend({
    type: "diamond",
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0
    },
    buildPath: function(path, shape) {
      var cx = shape.cx;
      var cy = shape.cy;
      var width = shape.width / 2;
      var height = shape.height / 2;
      path.moveTo(cx, cy - height);
      path.lineTo(cx + width, cy);
      path.lineTo(cx, cy + height);
      path.lineTo(cx - width, cy);
      path.closePath();
    }
  });
  var Pin = Path.extend({
    type: "pin",
    shape: {
      // x, y on the cusp
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function(path, shape) {
      var x = shape.x;
      var y = shape.y;
      var w = shape.width / 5 * 3;
      var h = Math.max(w, shape.height);
      var r = w / 2;
      var dy = r * r / (h - r);
      var cy = y - h + r + dy;
      var angle = Math.asin(dy / r);
      var dx = Math.cos(angle) * r;
      var tanX = Math.sin(angle);
      var tanY = Math.cos(angle);
      var cpLen = r * 0.6;
      var cpLen2 = r * 0.7;
      path.moveTo(x - dx, cy + dy);
      path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);
      path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);
      path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);
      path.closePath();
    }
  });
  var Arrow = Path.extend({
    type: "arrow",
    shape: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function(ctx, shape) {
      var height = shape.height;
      var width = shape.width;
      var x = shape.x;
      var y = shape.y;
      var dx = width / 3 * 2;
      ctx.moveTo(x, y);
      ctx.lineTo(x + dx, y + height);
      ctx.lineTo(x, y + height / 4 * 3);
      ctx.lineTo(x - dx, y + height);
      ctx.lineTo(x, y);
      ctx.closePath();
    }
  });
  var symbolCtors = {
    line: Line,
    rect: Rect$1,
    roundRect: Rect$1,
    square: Rect$1,
    circle: Circle,
    diamond: Diamond,
    pin: Pin,
    arrow: Arrow,
    triangle: Triangle
  };
  var symbolShapeMakers = {
    line: function(x, y, w, h, shape) {
      shape.x1 = x;
      shape.y1 = y + h / 2;
      shape.x2 = x + w;
      shape.y2 = y + h / 2;
    },
    rect: function(x, y, w, h, shape) {
      shape.x = x;
      shape.y = y;
      shape.width = w;
      shape.height = h;
    },
    roundRect: function(x, y, w, h, shape) {
      shape.x = x;
      shape.y = y;
      shape.width = w;
      shape.height = h;
      shape.r = Math.min(w, h) / 4;
    },
    square: function(x, y, w, h, shape) {
      var size = Math.min(w, h);
      shape.x = x;
      shape.y = y;
      shape.width = size;
      shape.height = size;
    },
    circle: function(x, y, w, h, shape) {
      shape.cx = x + w / 2;
      shape.cy = y + h / 2;
      shape.r = Math.min(w, h) / 2;
    },
    diamond: function(x, y, w, h, shape) {
      shape.cx = x + w / 2;
      shape.cy = y + h / 2;
      shape.width = w;
      shape.height = h;
    },
    pin: function(x, y, w, h, shape) {
      shape.x = x + w / 2;
      shape.y = y + h / 2;
      shape.width = w;
      shape.height = h;
    },
    arrow: function(x, y, w, h, shape) {
      shape.x = x + w / 2;
      shape.y = y + h / 2;
      shape.width = w;
      shape.height = h;
    },
    triangle: function(x, y, w, h, shape) {
      shape.cx = x + w / 2;
      shape.cy = y + h / 2;
      shape.width = w;
      shape.height = h;
    }
  };
  var symbolBuildProxies = {};
  each$5(symbolCtors, function(Ctor, name) {
    symbolBuildProxies[name] = new Ctor();
  });
  var SymbolClz = Path.extend({
    type: "symbol",
    shape: {
      symbolType: "",
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    calculateTextPosition: function(out2, config, rect) {
      var res = calculateTextPosition(out2, config, rect);
      var shape = this.shape;
      if (shape && shape.symbolType === "pin" && config.position === "inside") {
        res.y = rect.y + rect.height * 0.4;
      }
      return res;
    },
    buildPath: function(ctx, shape, inBundle) {
      var symbolType = shape.symbolType;
      if (symbolType !== "none") {
        var proxySymbol = symbolBuildProxies[symbolType];
        if (!proxySymbol) {
          symbolType = "rect";
          proxySymbol = symbolBuildProxies[symbolType];
        }
        symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
        proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
      }
    }
  });
  function symbolPathSetColor(color2, innerColor2) {
    if (this.type !== "image") {
      var symbolStyle = this.style;
      if (this.__isEmptyBrush) {
        symbolStyle.stroke = color2;
        symbolStyle.fill = innerColor2 || tokens.color.neutral00;
        symbolStyle.lineWidth = 2;
      } else if (this.shape.symbolType === "line") {
        symbolStyle.stroke = color2;
      } else {
        symbolStyle.fill = color2;
      }
      this.markRedraw();
    }
  }
  function createSymbol(symbolType, x, y, w, h, color2, keepAspect) {
    var isEmpty = symbolType.indexOf("empty") === 0;
    if (isEmpty) {
      symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
    }
    var symbolPath;
    if (symbolType.indexOf("image://") === 0) {
      symbolPath = makeImage(symbolType.slice(8), new BoundingRect(x, y, w, h), keepAspect ? "center" : "cover");
    } else if (symbolType.indexOf("path://") === 0) {
      symbolPath = makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h), keepAspect ? "center" : "cover");
    } else {
      symbolPath = new SymbolClz({
        shape: {
          symbolType,
          x,
          y,
          width: w,
          height: h
        }
      });
    }
    symbolPath.__isEmptyBrush = isEmpty;
    symbolPath.setColor = symbolPathSetColor;
    if (color2) {
      symbolPath.setColor(color2);
    }
    return symbolPath;
  }
  function normalizeSymbolSize(symbolSize) {
    if (!isArray(symbolSize)) {
      symbolSize = [+symbolSize, +symbolSize];
    }
    return [symbolSize[0] || 0, symbolSize[1] || 0];
  }
  function normalizeSymbolOffset(symbolOffset, symbolSize) {
    if (symbolOffset == null) {
      return;
    }
    if (!isArray(symbolOffset)) {
      symbolOffset = [symbolOffset, symbolOffset];
    }
    return [parsePercent(symbolOffset[0], symbolSize[0]) || 0, parsePercent(retrieve2(symbolOffset[1], symbolOffset[0]), symbolSize[1]) || 0];
  }
  function isSafeNum(num) {
    return isFinite(num);
  }
  function createLinearGradient(ctx, obj, rect) {
    var x = obj.x == null ? 0 : obj.x;
    var x2 = obj.x2 == null ? 1 : obj.x2;
    var y = obj.y == null ? 0 : obj.y;
    var y2 = obj.y2 == null ? 0 : obj.y2;
    if (!obj.global) {
      x = x * rect.width + rect.x;
      x2 = x2 * rect.width + rect.x;
      y = y * rect.height + rect.y;
      y2 = y2 * rect.height + rect.y;
    }
    x = isSafeNum(x) ? x : 0;
    x2 = isSafeNum(x2) ? x2 : 1;
    y = isSafeNum(y) ? y : 0;
    y2 = isSafeNum(y2) ? y2 : 0;
    var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
    return canvasGradient;
  }
  function createRadialGradient(ctx, obj, rect) {
    var width = rect.width;
    var height = rect.height;
    var min3 = Math.min(width, height);
    var x = obj.x == null ? 0.5 : obj.x;
    var y = obj.y == null ? 0.5 : obj.y;
    var r = obj.r == null ? 0.5 : obj.r;
    if (!obj.global) {
      x = x * width + rect.x;
      y = y * height + rect.y;
      r = r * min3;
    }
    x = isSafeNum(x) ? x : 0.5;
    y = isSafeNum(y) ? y : 0.5;
    r = r >= 0 && isSafeNum(r) ? r : 0.5;
    var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
    return canvasGradient;
  }
  function getCanvasGradient(ctx, obj, rect) {
    var canvasGradient = obj.type === "radial" ? createRadialGradient(ctx, obj, rect) : createLinearGradient(ctx, obj, rect);
    var colorStops = obj.colorStops;
    for (var i = 0; i < colorStops.length; i++) {
      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
    }
    return canvasGradient;
  }
  function isClipPathChanged(clipPaths, prevClipPaths) {
    if (clipPaths === prevClipPaths || !clipPaths && !prevClipPaths) {
      return false;
    }
    if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
      return true;
    }
    for (var i = 0; i < clipPaths.length; i++) {
      if (clipPaths[i] !== prevClipPaths[i]) {
        return true;
      }
    }
    return false;
  }
  function parseInt10(val) {
    return parseInt(val, 10);
  }
  function getSize(root, whIdx, opts) {
    var wh = ["width", "height"][whIdx];
    var cwh = ["clientWidth", "clientHeight"][whIdx];
    var plt = ["paddingLeft", "paddingTop"][whIdx];
    var prb = ["paddingRight", "paddingBottom"][whIdx];
    if (opts[wh] != null && opts[wh] !== "auto") {
      return parseFloat(opts[wh]);
    }
    var stl = document.defaultView.getComputedStyle(root);
    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
  }
  function normalizeLineDash(lineType, lineWidth) {
    if (!lineType || lineType === "solid" || !(lineWidth > 0)) {
      return null;
    }
    return lineType === "dashed" ? [4 * lineWidth, 2 * lineWidth] : lineType === "dotted" ? [lineWidth] : isNumber(lineType) ? [lineType] : isArray(lineType) ? lineType : null;
  }
  function getLineDash(el) {
    var style = el.style;
    var lineDash = style.lineDash && style.lineWidth > 0 && normalizeLineDash(style.lineDash, style.lineWidth);
    var lineDashOffset = style.lineDashOffset;
    if (lineDash) {
      var lineScale_1 = style.strokeNoScale && el.getLineScale ? el.getLineScale() : 1;
      if (lineScale_1 && lineScale_1 !== 1) {
        lineDash = map$1(lineDash, function(rawVal) {
          return rawVal / lineScale_1;
        });
        lineDashOffset /= lineScale_1;
      }
    }
    return [lineDash, lineDashOffset];
  }
  var pathProxyForDraw = new PathProxy(true);
  function styleHasStroke(style) {
    var stroke = style.stroke;
    return !(stroke == null || stroke === "none" || !(style.lineWidth > 0));
  }
  function isValidStrokeFillStyle(strokeOrFill) {
    return typeof strokeOrFill === "string" && strokeOrFill !== "none";
  }
  function styleHasFill(style) {
    var fill = style.fill;
    return fill != null && fill !== "none";
  }
  function doFillPath(ctx, style) {
    if (style.fillOpacity != null && style.fillOpacity !== 1) {
      var originalGlobalAlpha = ctx.globalAlpha;
      ctx.globalAlpha = style.fillOpacity * style.opacity;
      ctx.fill();
      ctx.globalAlpha = originalGlobalAlpha;
    } else {
      ctx.fill();
    }
  }
  function doStrokePath(ctx, style) {
    if (style.strokeOpacity != null && style.strokeOpacity !== 1) {
      var originalGlobalAlpha = ctx.globalAlpha;
      ctx.globalAlpha = style.strokeOpacity * style.opacity;
      ctx.stroke();
      ctx.globalAlpha = originalGlobalAlpha;
    } else {
      ctx.stroke();
    }
  }
  function createCanvasPattern(ctx, pattern, el) {
    var image = createOrUpdateImage(pattern.image, pattern.__image, el);
    if (isImageReady(image)) {
      var canvasPattern = ctx.createPattern(image, pattern.repeat || "repeat");
      if (typeof DOMMatrix === "function" && canvasPattern && canvasPattern.setTransform) {
        var matrix = new DOMMatrix();
        matrix.translateSelf(pattern.x || 0, pattern.y || 0);
        matrix.rotateSelf(0, 0, (pattern.rotation || 0) * RADIAN_TO_DEGREE);
        matrix.scaleSelf(pattern.scaleX || 1, pattern.scaleY || 1);
        canvasPattern.setTransform(matrix);
      }
      return canvasPattern;
    }
  }
  function brushPath(ctx, el, style, inBatch) {
    var _a2;
    var hasStroke = styleHasStroke(style);
    var hasFill = styleHasFill(style);
    var strokePercent = style.strokePercent;
    var strokePart = strokePercent < 1;
    var firstDraw = !el.path;
    if ((!el.silent || strokePart) && firstDraw) {
      el.createPathProxy();
    }
    var path = el.path || pathProxyForDraw;
    var dirtyFlag = el.__dirty;
    if (!inBatch) {
      var fill = style.fill;
      var stroke = style.stroke;
      var hasFillGradient = hasFill && !!fill.colorStops;
      var hasStrokeGradient = hasStroke && !!stroke.colorStops;
      var hasFillPattern = hasFill && !!fill.image;
      var hasStrokePattern = hasStroke && !!stroke.image;
      var fillGradient = void 0;
      var strokeGradient = void 0;
      var fillPattern = void 0;
      var strokePattern = void 0;
      var rect = void 0;
      if (hasFillGradient || hasStrokeGradient) {
        rect = el.getBoundingRect();
      }
      if (hasFillGradient) {
        fillGradient = dirtyFlag ? getCanvasGradient(ctx, fill, rect) : el.__canvasFillGradient;
        el.__canvasFillGradient = fillGradient;
      }
      if (hasStrokeGradient) {
        strokeGradient = dirtyFlag ? getCanvasGradient(ctx, stroke, rect) : el.__canvasStrokeGradient;
        el.__canvasStrokeGradient = strokeGradient;
      }
      if (hasFillPattern) {
        fillPattern = dirtyFlag || !el.__canvasFillPattern ? createCanvasPattern(ctx, fill, el) : el.__canvasFillPattern;
        el.__canvasFillPattern = fillPattern;
      }
      if (hasStrokePattern) {
        strokePattern = dirtyFlag || !el.__canvasStrokePattern ? createCanvasPattern(ctx, stroke, el) : el.__canvasStrokePattern;
        el.__canvasStrokePattern = strokePattern;
      }
      if (hasFillGradient) {
        ctx.fillStyle = fillGradient;
      } else if (hasFillPattern) {
        if (fillPattern) {
          ctx.fillStyle = fillPattern;
        } else {
          hasFill = false;
        }
      }
      if (hasStrokeGradient) {
        ctx.strokeStyle = strokeGradient;
      } else if (hasStrokePattern) {
        if (strokePattern) {
          ctx.strokeStyle = strokePattern;
        } else {
          hasStroke = false;
        }
      }
    }
    var scale2 = el.getGlobalScale();
    path.setScale(scale2[0], scale2[1], el.segmentIgnoreThreshold);
    var lineDash;
    var lineDashOffset;
    if (ctx.setLineDash && style.lineDash) {
      _a2 = getLineDash(el), lineDash = _a2[0], lineDashOffset = _a2[1];
    }
    var needsRebuild = true;
    if (firstDraw || dirtyFlag & SHAPE_CHANGED_BIT) {
      path.setDPR(ctx.dpr);
      if (strokePart) {
        path.setContext(null);
      } else {
        path.setContext(ctx);
        needsRebuild = false;
      }
      path.reset();
      el.buildPath(path, el.shape, inBatch);
      path.toStatic();
      el.pathUpdated();
    }
    if (needsRebuild) {
      path.rebuildPath(ctx, strokePart ? strokePercent : 1);
    }
    if (lineDash) {
      ctx.setLineDash(lineDash);
      ctx.lineDashOffset = lineDashOffset;
    }
    if (!inBatch) {
      if (style.strokeFirst) {
        if (hasStroke) {
          doStrokePath(ctx, style);
        }
        if (hasFill) {
          doFillPath(ctx, style);
        }
      } else {
        if (hasFill) {
          doFillPath(ctx, style);
        }
        if (hasStroke) {
          doStrokePath(ctx, style);
        }
      }
    }
    if (lineDash) {
      ctx.setLineDash([]);
    }
  }
  function brushImage(ctx, el, style) {
    var image = el.__image = createOrUpdateImage(style.image, el.__image, el, el.onload);
    if (!image || !isImageReady(image)) {
      return;
    }
    var x = style.x || 0;
    var y = style.y || 0;
    var width = el.getWidth();
    var height = el.getHeight();
    var aspect = image.width / image.height;
    if (width == null && height != null) {
      width = height * aspect;
    } else if (height == null && width != null) {
      height = width / aspect;
    } else if (width == null && height == null) {
      width = image.width;
      height = image.height;
    }
    if (style.sWidth && style.sHeight) {
      var sx = style.sx || 0;
      var sy = style.sy || 0;
      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
    } else if (style.sx && style.sy) {
      var sx = style.sx;
      var sy = style.sy;
      var sWidth = width - sx;
      var sHeight = height - sy;
      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
    } else {
      ctx.drawImage(image, x, y, width, height);
    }
  }
  function brushText(ctx, el, style) {
    var _a2;
    var text = style.text;
    text != null && (text += "");
    if (text) {
      ctx.font = style.font || DEFAULT_FONT;
      ctx.textAlign = style.textAlign;
      ctx.textBaseline = style.textBaseline;
      var lineDash = void 0;
      var lineDashOffset = void 0;
      if (ctx.setLineDash && style.lineDash) {
        _a2 = getLineDash(el), lineDash = _a2[0], lineDashOffset = _a2[1];
      }
      if (lineDash) {
        ctx.setLineDash(lineDash);
        ctx.lineDashOffset = lineDashOffset;
      }
      if (style.strokeFirst) {
        if (styleHasStroke(style)) {
          ctx.strokeText(text, style.x, style.y);
        }
        if (styleHasFill(style)) {
          ctx.fillText(text, style.x, style.y);
        }
      } else {
        if (styleHasFill(style)) {
          ctx.fillText(text, style.x, style.y);
        }
        if (styleHasStroke(style)) {
          ctx.strokeText(text, style.x, style.y);
        }
      }
      if (lineDash) {
        ctx.setLineDash([]);
      }
    }
  }
  var SHADOW_NUMBER_PROPS = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"];
  var STROKE_PROPS = [
    ["lineCap", "butt"],
    ["lineJoin", "miter"],
    ["miterLimit", 10]
  ];
  function bindCommonProps(ctx, style, prevStyle, forceSetAll, scope) {
    var styleChanged = false;
    if (!forceSetAll) {
      prevStyle = prevStyle || {};
      if (style === prevStyle) {
        return false;
      }
    }
    if (forceSetAll || style.opacity !== prevStyle.opacity) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
      var opacity = Math.max(Math.min(style.opacity, 1), 0);
      ctx.globalAlpha = isNaN(opacity) ? DEFAULT_COMMON_STYLE.opacity : opacity;
    }
    if (forceSetAll || style.blend !== prevStyle.blend) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx.globalCompositeOperation = style.blend || DEFAULT_COMMON_STYLE.blend;
    }
    for (var i = 0; i < SHADOW_NUMBER_PROPS.length; i++) {
      var propName = SHADOW_NUMBER_PROPS[i];
      if (forceSetAll || style[propName] !== prevStyle[propName]) {
        if (!styleChanged) {
          flushPathDrawn(ctx, scope);
          styleChanged = true;
        }
        ctx[propName] = ctx.dpr * (style[propName] || 0);
      }
    }
    if (forceSetAll || style.shadowColor !== prevStyle.shadowColor) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx.shadowColor = style.shadowColor || DEFAULT_COMMON_STYLE.shadowColor;
    }
    return styleChanged;
  }
  function bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetAll, scope) {
    var style = getStyle(el, scope.inHover);
    var prevStyle = forceSetAll ? null : prevEl && getStyle(prevEl, scope.inHover) || {};
    if (style === prevStyle) {
      return false;
    }
    var styleChanged = bindCommonProps(ctx, style, prevStyle, forceSetAll, scope);
    if (forceSetAll || style.fill !== prevStyle.fill) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      isValidStrokeFillStyle(style.fill) && (ctx.fillStyle = style.fill);
    }
    if (forceSetAll || style.stroke !== prevStyle.stroke) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      isValidStrokeFillStyle(style.stroke) && (ctx.strokeStyle = style.stroke);
    }
    if (forceSetAll || style.opacity !== prevStyle.opacity) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
    }
    if (el.hasStroke()) {
      var lineWidth = style.lineWidth;
      var newLineWidth = lineWidth / (style.strokeNoScale && el.getLineScale ? el.getLineScale() : 1);
      if (ctx.lineWidth !== newLineWidth) {
        if (!styleChanged) {
          flushPathDrawn(ctx, scope);
          styleChanged = true;
        }
        ctx.lineWidth = newLineWidth;
      }
    }
    for (var i = 0; i < STROKE_PROPS.length; i++) {
      var prop = STROKE_PROPS[i];
      var propName = prop[0];
      if (forceSetAll || style[propName] !== prevStyle[propName]) {
        if (!styleChanged) {
          flushPathDrawn(ctx, scope);
          styleChanged = true;
        }
        ctx[propName] = style[propName] || prop[1];
      }
    }
    return styleChanged;
  }
  function bindImageStyle(ctx, el, prevEl, forceSetAll, scope) {
    return bindCommonProps(ctx, getStyle(el, scope.inHover), prevEl && getStyle(prevEl, scope.inHover), forceSetAll, scope);
  }
  function setContextTransform(ctx, el) {
    var m2 = el.transform;
    var dpr2 = ctx.dpr || 1;
    if (m2) {
      ctx.setTransform(dpr2 * m2[0], dpr2 * m2[1], dpr2 * m2[2], dpr2 * m2[3], dpr2 * m2[4], dpr2 * m2[5]);
    } else {
      ctx.setTransform(dpr2, 0, 0, dpr2, 0, 0);
    }
  }
  function updateClipStatus(clipPaths, ctx, scope) {
    var allClipped = false;
    for (var i = 0; i < clipPaths.length; i++) {
      var clipPath = clipPaths[i];
      allClipped = allClipped || clipPath.isZeroArea();
      setContextTransform(ctx, clipPath);
      ctx.beginPath();
      clipPath.buildPath(ctx, clipPath.shape);
      ctx.clip();
    }
    scope.allClipped = allClipped;
  }
  function isTransformChanged(m0, m1) {
    if (m0 && m1) {
      return m0[0] !== m1[0] || m0[1] !== m1[1] || m0[2] !== m1[2] || m0[3] !== m1[3] || m0[4] !== m1[4] || m0[5] !== m1[5];
    } else if (!m0 && !m1) {
      return false;
    }
    return true;
  }
  var DRAW_TYPE_PATH = 1;
  var DRAW_TYPE_IMAGE = 2;
  var DRAW_TYPE_TEXT = 3;
  var DRAW_TYPE_INCREMENTAL = 4;
  function canPathBatch(style) {
    var hasFill = styleHasFill(style);
    var hasStroke = styleHasStroke(style);
    return !(style.lineDash || !(+hasFill ^ +hasStroke) || hasFill && typeof style.fill !== "string" || hasStroke && typeof style.stroke !== "string" || style.strokePercent < 1 || style.strokeOpacity < 1 || style.fillOpacity < 1);
  }
  function flushPathDrawn(ctx, scope) {
    scope.batchFill && ctx.fill();
    scope.batchStroke && ctx.stroke();
    scope.batchFill = "";
    scope.batchStroke = "";
  }
  function getStyle(el, inHover) {
    return inHover ? el.__hoverStyle || el.style : el.style;
  }
  function brushSingle(ctx, el) {
    brush(ctx, el, { inHover: false, viewWidth: 0, viewHeight: 0 }, true);
  }
  function brush(ctx, el, scope, isLast) {
    var m2 = el.transform;
    if (!el.shouldBePainted(scope.viewWidth, scope.viewHeight, false, false)) {
      el.__dirty &= ~REDRAW_BIT;
      el.__isRendered = false;
      return;
    }
    var clipPaths = el.__clipPaths;
    var prevElClipPaths = scope.prevElClipPaths;
    var forceSetTransform = false;
    var forceSetStyle = false;
    if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {
      if (prevElClipPaths && prevElClipPaths.length) {
        flushPathDrawn(ctx, scope);
        ctx.restore();
        forceSetStyle = forceSetTransform = true;
        scope.prevElClipPaths = null;
        scope.allClipped = false;
        scope.prevEl = null;
      }
      if (clipPaths && clipPaths.length) {
        flushPathDrawn(ctx, scope);
        ctx.save();
        updateClipStatus(clipPaths, ctx, scope);
        forceSetTransform = true;
      }
      scope.prevElClipPaths = clipPaths;
    }
    if (scope.allClipped) {
      el.__isRendered = false;
      return;
    }
    el.beforeBrush && el.beforeBrush();
    el.innerBeforeBrush();
    var prevEl = scope.prevEl;
    if (!prevEl) {
      forceSetStyle = forceSetTransform = true;
    }
    var canBatchPath = el instanceof Path && el.autoBatch && canPathBatch(el.style);
    if (forceSetTransform || isTransformChanged(m2, prevEl.transform)) {
      flushPathDrawn(ctx, scope);
      setContextTransform(ctx, el);
    } else if (!canBatchPath) {
      flushPathDrawn(ctx, scope);
    }
    var style = getStyle(el, scope.inHover);
    if (el instanceof Path) {
      if (scope.lastDrawType !== DRAW_TYPE_PATH) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_PATH;
      }
      bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
      if (!canBatchPath || !scope.batchFill && !scope.batchStroke) {
        ctx.beginPath();
      }
      brushPath(ctx, el, style, canBatchPath);
      if (canBatchPath) {
        scope.batchFill = style.fill || "";
        scope.batchStroke = style.stroke || "";
      }
    } else {
      if (el instanceof TSpan) {
        if (scope.lastDrawType !== DRAW_TYPE_TEXT) {
          forceSetStyle = true;
          scope.lastDrawType = DRAW_TYPE_TEXT;
        }
        bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
        brushText(ctx, el, style);
      } else if (el instanceof ZRImage) {
        if (scope.lastDrawType !== DRAW_TYPE_IMAGE) {
          forceSetStyle = true;
          scope.lastDrawType = DRAW_TYPE_IMAGE;
        }
        bindImageStyle(ctx, el, prevEl, forceSetStyle, scope);
        brushImage(ctx, el, style);
      } else if (el.getTemporalDisplayables) {
        if (scope.lastDrawType !== DRAW_TYPE_INCREMENTAL) {
          forceSetStyle = true;
          scope.lastDrawType = DRAW_TYPE_INCREMENTAL;
        }
        brushIncremental(ctx, el, scope);
      }
    }
    if (canBatchPath && isLast) {
      flushPathDrawn(ctx, scope);
    }
    el.innerAfterBrush();
    el.afterBrush && el.afterBrush();
    scope.prevEl = el;
    el.__dirty = 0;
    el.__isRendered = true;
  }
  function brushIncremental(ctx, el, scope) {
    var displayables = el.getDisplayables();
    var temporalDisplayables = el.getTemporalDisplayables();
    ctx.save();
    var innerScope = {
      prevElClipPaths: null,
      prevEl: null,
      allClipped: false,
      viewWidth: scope.viewWidth,
      viewHeight: scope.viewHeight,
      inHover: scope.inHover
    };
    var i;
    var len2;
    for (i = el.getCursor(), len2 = displayables.length; i < len2; i++) {
      var displayable = displayables[i];
      displayable.beforeBrush && displayable.beforeBrush();
      displayable.innerBeforeBrush();
      brush(ctx, displayable, innerScope, i === len2 - 1);
      displayable.innerAfterBrush();
      displayable.afterBrush && displayable.afterBrush();
      innerScope.prevEl = displayable;
    }
    for (var i_1 = 0, len_1 = temporalDisplayables.length; i_1 < len_1; i_1++) {
      var displayable = temporalDisplayables[i_1];
      displayable.beforeBrush && displayable.beforeBrush();
      displayable.innerBeforeBrush();
      brush(ctx, displayable, innerScope, i_1 === len_1 - 1);
      displayable.innerAfterBrush();
      displayable.afterBrush && displayable.afterBrush();
      innerScope.prevEl = displayable;
    }
    el.clearTemporalDisplayables();
    el.notClear = true;
    ctx.restore();
  }
  var define_process_env_default$l = {};
  var decalMap = new WeakMap();
  var decalCache = new LRU(100);
  var decalKeys = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
  function createOrUpdatePatternFromDecal(decalObject, api) {
    if (decalObject === "none") {
      return null;
    }
    var dpr2 = api.getDevicePixelRatio();
    var zr = api.getZr();
    var isSVG = zr.painter.type === "svg";
    if (decalObject.dirty) {
      decalMap["delete"](decalObject);
    }
    var oldPattern = decalMap.get(decalObject);
    if (oldPattern) {
      return oldPattern;
    }
    var decalOpt = defaults(decalObject, {
      symbol: "rect",
      symbolSize: 1,
      symbolKeepAspect: true,
      color: "rgba(0, 0, 0, 0.2)",
      backgroundColor: null,
      dashArrayX: 5,
      dashArrayY: 5,
      rotation: 0,
      maxTileWidth: 512,
      maxTileHeight: 512
    });
    if (decalOpt.backgroundColor === "none") {
      decalOpt.backgroundColor = null;
    }
    var pattern = {
      repeat: "repeat"
    };
    setPatternnSource(pattern);
    pattern.rotation = decalOpt.rotation;
    pattern.scaleX = pattern.scaleY = isSVG ? 1 : 1 / dpr2;
    decalMap.set(decalObject, pattern);
    decalObject.dirty = false;
    return pattern;
    function setPatternnSource(pattern2) {
      var keys2 = [dpr2];
      var isValidKey = true;
      for (var i = 0; i < decalKeys.length; ++i) {
        var value = decalOpt[decalKeys[i]];
        if (value != null && !isArray(value) && !isString(value) && !isNumber(value) && typeof value !== "boolean") {
          isValidKey = false;
          break;
        }
        keys2.push(value);
      }
      var cacheKey;
      if (isValidKey) {
        cacheKey = keys2.join(",") + (isSVG ? "-svg" : "");
        var cache = decalCache.get(cacheKey);
        if (cache) {
          isSVG ? pattern2.svgElement = cache : pattern2.image = cache;
        }
      }
      var dashArrayX = normalizeDashArrayX(decalOpt.dashArrayX);
      var dashArrayY = normalizeDashArrayY(decalOpt.dashArrayY);
      var symbolArray = normalizeSymbolArray(decalOpt.symbol);
      var lineBlockLengthsX = getLineBlockLengthX(dashArrayX);
      var lineBlockLengthY = getLineBlockLengthY(dashArrayY);
      var canvas = !isSVG && platformApi.createCanvas();
      var svgRoot = isSVG && {
        tag: "g",
        attrs: {},
        key: "dcl",
        children: []
      };
      var pSize = getPatternSize();
      var ctx;
      if (canvas) {
        canvas.width = pSize.width * dpr2;
        canvas.height = pSize.height * dpr2;
        ctx = canvas.getContext("2d");
      }
      brushDecal();
      if (isValidKey) {
        decalCache.put(cacheKey, canvas || svgRoot);
      }
      pattern2.image = canvas;
      pattern2.svgElement = svgRoot;
      pattern2.svgWidth = pSize.width;
      pattern2.svgHeight = pSize.height;
      function getPatternSize() {
        var width = 1;
        for (var i2 = 0, xlen = lineBlockLengthsX.length; i2 < xlen; ++i2) {
          width = getLeastCommonMultiple(width, lineBlockLengthsX[i2]);
        }
        var symbolRepeats = 1;
        for (var i2 = 0, xlen = symbolArray.length; i2 < xlen; ++i2) {
          symbolRepeats = getLeastCommonMultiple(symbolRepeats, symbolArray[i2].length);
        }
        width *= symbolRepeats;
        var height = lineBlockLengthY * lineBlockLengthsX.length * symbolArray.length;
        if (define_process_env_default$l.NODE_ENV !== "production") {
          var warn2 = function(attrName) {
            console.warn("Calculated decal size is greater than " + attrName + " due to decal option settings so " + attrName + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + attrName + " to be larger to avoid incontinuity.");
          };
          if (width > decalOpt.maxTileWidth) {
            warn2("maxTileWidth");
          }
          if (height > decalOpt.maxTileHeight) {
            warn2("maxTileHeight");
          }
        }
        return {
          width: Math.max(1, Math.min(width, decalOpt.maxTileWidth)),
          height: Math.max(1, Math.min(height, decalOpt.maxTileHeight))
        };
      }
      function brushDecal() {
        if (ctx) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          if (decalOpt.backgroundColor) {
            ctx.fillStyle = decalOpt.backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }
        }
        var ySum = 0;
        for (var i2 = 0; i2 < dashArrayY.length; ++i2) {
          ySum += dashArrayY[i2];
        }
        if (ySum <= 0) {
          return;
        }
        var y = -lineBlockLengthY;
        var yId = 0;
        var yIdTotal = 0;
        var xId0 = 0;
        while (y < pSize.height) {
          if (yId % 2 === 0) {
            var symbolYId = yIdTotal / 2 % symbolArray.length;
            var x = 0;
            var xId1 = 0;
            var xId1Total = 0;
            while (x < pSize.width * 2) {
              var xSum = 0;
              for (var i2 = 0; i2 < dashArrayX[xId0].length; ++i2) {
                xSum += dashArrayX[xId0][i2];
              }
              if (xSum <= 0) {
                break;
              }
              if (xId1 % 2 === 0) {
                var size = (1 - decalOpt.symbolSize) * 0.5;
                var left = x + dashArrayX[xId0][xId1] * size;
                var top_1 = y + dashArrayY[yId] * size;
                var width = dashArrayX[xId0][xId1] * decalOpt.symbolSize;
                var height = dashArrayY[yId] * decalOpt.symbolSize;
                var symbolXId = xId1Total / 2 % symbolArray[symbolYId].length;
                brushSymbol(left, top_1, width, height, symbolArray[symbolYId][symbolXId]);
              }
              x += dashArrayX[xId0][xId1];
              ++xId1Total;
              ++xId1;
              if (xId1 === dashArrayX[xId0].length) {
                xId1 = 0;
              }
            }
            ++xId0;
            if (xId0 === dashArrayX.length) {
              xId0 = 0;
            }
          }
          y += dashArrayY[yId];
          ++yIdTotal;
          ++yId;
          if (yId === dashArrayY.length) {
            yId = 0;
          }
        }
        function brushSymbol(x2, y2, width2, height2, symbolType) {
          var scale2 = isSVG ? 1 : dpr2;
          var symbol = createSymbol(symbolType, x2 * scale2, y2 * scale2, width2 * scale2, height2 * scale2, decalOpt.color, decalOpt.symbolKeepAspect);
          if (isSVG) {
            var symbolVNode = zr.painter.renderOneToVNode(symbol);
            if (symbolVNode) {
              svgRoot.children.push(symbolVNode);
            }
          } else {
            brushSingle(ctx, symbol);
          }
        }
      }
    }
  }
  function normalizeSymbolArray(symbol) {
    if (!symbol || symbol.length === 0) {
      return [["rect"]];
    }
    if (isString(symbol)) {
      return [[symbol]];
    }
    var isAllString = true;
    for (var i = 0; i < symbol.length; ++i) {
      if (!isString(symbol[i])) {
        isAllString = false;
        break;
      }
    }
    if (isAllString) {
      return normalizeSymbolArray([symbol]);
    }
    var result = [];
    for (var i = 0; i < symbol.length; ++i) {
      if (isString(symbol[i])) {
        result.push([symbol[i]]);
      } else {
        result.push(symbol[i]);
      }
    }
    return result;
  }
  function normalizeDashArrayX(dash) {
    if (!dash || dash.length === 0) {
      return [[0, 0]];
    }
    if (isNumber(dash)) {
      var dashValue = Math.ceil(dash);
      return [[dashValue, dashValue]];
    }
    var isAllNumber = true;
    for (var i = 0; i < dash.length; ++i) {
      if (!isNumber(dash[i])) {
        isAllNumber = false;
        break;
      }
    }
    if (isAllNumber) {
      return normalizeDashArrayX([dash]);
    }
    var result = [];
    for (var i = 0; i < dash.length; ++i) {
      if (isNumber(dash[i])) {
        var dashValue = Math.ceil(dash[i]);
        result.push([dashValue, dashValue]);
      } else {
        var dashValue = map$1(dash[i], function(n) {
          return Math.ceil(n);
        });
        if (dashValue.length % 2 === 1) {
          result.push(dashValue.concat(dashValue));
        } else {
          result.push(dashValue);
        }
      }
    }
    return result;
  }
  function normalizeDashArrayY(dash) {
    if (!dash || typeof dash === "object" && dash.length === 0) {
      return [0, 0];
    }
    if (isNumber(dash)) {
      var dashValue_1 = Math.ceil(dash);
      return [dashValue_1, dashValue_1];
    }
    var dashValue = map$1(dash, function(n) {
      return Math.ceil(n);
    });
    return dash.length % 2 ? dashValue.concat(dashValue) : dashValue;
  }
  function getLineBlockLengthX(dash) {
    return map$1(dash, function(line) {
      return getLineBlockLengthY(line);
    });
  }
  function getLineBlockLengthY(dash) {
    var blockLength = 0;
    for (var i = 0; i < dash.length; ++i) {
      blockLength += dash[i];
    }
    if (dash.length % 2 === 1) {
      return blockLength * 2;
    }
    return blockLength;
  }
  function decalVisual(ecModel, api) {
    ecModel.eachRawSeries(function(seriesModel) {
      if (ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }
      var data = seriesModel.getData();
      if (data.hasItemVisual()) {
        data.each(function(idx) {
          var decal2 = data.getItemVisual(idx, "decal");
          if (decal2) {
            var itemStyle = data.ensureUniqueItemVisual(idx, "style");
            itemStyle.decal = createOrUpdatePatternFromDecal(decal2, api);
          }
        });
      }
      var decal = data.getVisual("decal");
      if (decal) {
        var style = data.getVisual("style");
        style.decal = createOrUpdatePatternFromDecal(decal, api);
      }
    });
  }
  var lifecycle = new Eventful();
  var define_process_env_default$k = {};
  var implsStore = {};
  function registerImpl(name, impl) {
    if (define_process_env_default$k.NODE_ENV !== "production") {
      if (implsStore[name]) {
        error("Already has an implementation of " + name + ".");
      }
    }
    implsStore[name] = impl;
  }
  function getImpl(name) {
    if (define_process_env_default$k.NODE_ENV !== "production") {
      if (!implsStore[name]) {
        error("Implementation of " + name + " doesn't exists.");
      }
    }
    return implsStore[name];
  }
  var define_process_env_default$j = {};
  var TEST_FRAME_REMAIN_TIME = 1;
  var PRIORITY_PROCESSOR_SERIES_FILTER = 800;
  var PRIORITY_PROCESSOR_DATASTACK = 900;
  var PRIORITY_PROCESSOR_FILTER = 1e3;
  var PRIORITY_PROCESSOR_DEFAULT = 2e3;
  var PRIORITY_PROCESSOR_STATISTIC = 5e3;
  var PRIORITY_VISUAL_LAYOUT = 1e3;
  var PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100;
  var PRIORITY_VISUAL_GLOBAL = 2e3;
  var PRIORITY_VISUAL_CHART = 3e3;
  var PRIORITY_VISUAL_COMPONENT = 4e3;
  var PRIORITY_VISUAL_CHART_DATA_CUSTOM = 4500;
  var PRIORITY_VISUAL_POST_CHART_LAYOUT = 4600;
  var PRIORITY_VISUAL_BRUSH = 5e3;
  var PRIORITY_VISUAL_ARIA = 6e3;
  var PRIORITY_VISUAL_DECAL = 7e3;
  var PRIORITY = {
    PROCESSOR: {
      FILTER: PRIORITY_PROCESSOR_FILTER,
      SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
      STATISTIC: PRIORITY_PROCESSOR_STATISTIC
    },
    VISUAL: {
      LAYOUT: PRIORITY_VISUAL_LAYOUT,
      PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
      GLOBAL: PRIORITY_VISUAL_GLOBAL,
      CHART: PRIORITY_VISUAL_CHART,
      POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
      COMPONENT: PRIORITY_VISUAL_COMPONENT,
      BRUSH: PRIORITY_VISUAL_BRUSH,
      CHART_ITEM: PRIORITY_VISUAL_CHART_DATA_CUSTOM,
      ARIA: PRIORITY_VISUAL_ARIA,
      DECAL: PRIORITY_VISUAL_DECAL
    }
  };
  var IN_MAIN_PROCESS_KEY = "__flagInMainProcess";
  var MAIN_PROCESS_VERSION_KEY = "__mainProcessVersion";
  var PENDING_UPDATE = "__pendingUpdate";
  var STATUS_NEEDS_UPDATE_KEY = "__needsUpdateStatus";
  var ACTION_REG = /^[a-zA-Z0-9_]+$/;
  var CONNECT_STATUS_KEY = "__connectUpdateStatus";
  var CONNECT_STATUS_PENDING = 0;
  var CONNECT_STATUS_UPDATING = 1;
  var CONNECT_STATUS_UPDATED = 2;
  function createRegisterEventWithLowercaseECharts(method) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.isDisposed()) {
        disposedWarning(this.id);
        return;
      }
      return toLowercaseNameAndCallEventful(this, method, args);
    };
  }
  function createRegisterEventWithLowercaseMessageCenter(method) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return toLowercaseNameAndCallEventful(this, method, args);
    };
  }
  function toLowercaseNameAndCallEventful(host, method, args) {
    args[0] = args[0] && args[0].toLowerCase();
    return Eventful.prototype[method].apply(host, args);
  }
  var MessageCenter = (
    /** @class */
    function(_super) {
      __extends(MessageCenter2, _super);
      function MessageCenter2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return MessageCenter2;
    }(Eventful)
  );
  var messageCenterProto = MessageCenter.prototype;
  messageCenterProto.on = createRegisterEventWithLowercaseMessageCenter("on");
  messageCenterProto.off = createRegisterEventWithLowercaseMessageCenter("off");
  var prepare;
  var prepareView;
  var updateDirectly;
  var updateMethods;
  var doConvertPixel;
  var updateStreamModes;
  var doDispatchAction;
  var flushPendingActions;
  var triggerUpdatedEvent;
  var bindRenderedEvent;
  var bindMouseEvent;
  var render;
  var renderComponents;
  var renderSeries;
  var createExtensionAPI;
  var enableConnect;
  var markStatusToUpdate;
  var applyChangedStates;
  var updateMainProcessVersion;
  var ECharts = (
    /** @class */
    function(_super) {
      __extends(ECharts2, _super);
      function ECharts2(dom, theme2, opts) {
        var _this = _super.call(this, new ECEventProcessor()) || this;
        _this._chartsViews = [];
        _this._chartsMap = {};
        _this._componentsViews = [];
        _this._componentsMap = {};
        _this._pendingActions = [];
        opts = opts || {};
        _this._dom = dom;
        var defaultRenderer = "canvas";
        var defaultCoarsePointer = "auto";
        var defaultUseDirtyRect = false;
        _this[MAIN_PROCESS_VERSION_KEY] = 1;
        if (define_process_env_default$j.NODE_ENV !== "production") {
          var root = (
            /* eslint-disable-next-line */
            env.hasGlobalWindow ? window : global
          );
          if (root) {
            defaultRenderer = retrieve2(root.__ECHARTS__DEFAULT__RENDERER__, defaultRenderer);
            defaultCoarsePointer = retrieve2(root.__ECHARTS__DEFAULT__COARSE_POINTER, defaultCoarsePointer);
            defaultUseDirtyRect = retrieve2(root.__ECHARTS__DEFAULT__USE_DIRTY_RECT__, defaultUseDirtyRect);
          }
        }
        if (opts.ssr) ;
        var zr = _this._zr = init$1(dom, {
          renderer: opts.renderer || defaultRenderer,
          devicePixelRatio: opts.devicePixelRatio,
          width: opts.width,
          height: opts.height,
          ssr: opts.ssr,
          useDirtyRect: retrieve2(opts.useDirtyRect, defaultUseDirtyRect),
          useCoarsePointer: retrieve2(opts.useCoarsePointer, defaultCoarsePointer),
          pointerSize: opts.pointerSize
        });
        _this._ssr = opts.ssr;
        _this._throttledZrFlush = throttle(bind$1(zr.flush, zr), 17);
        _this._updateTheme(theme2);
        _this._locale = createLocaleObject(opts.locale || SYSTEM_LANG);
        _this._coordSysMgr = new CoordinateSystemManager();
        var api = _this._api = createExtensionAPI(_this);
        function prioritySortFunc(a, b) {
          return a.__prio - b.__prio;
        }
        sort(visualFuncs, prioritySortFunc);
        sort(dataProcessorFuncs, prioritySortFunc);
        _this._scheduler = new Scheduler(_this, api, dataProcessorFuncs, visualFuncs);
        _this._messageCenter = new MessageCenter();
        _this._initEvents();
        _this.resize = bind$1(_this.resize, _this);
        zr.animation.on("frame", _this._onframe, _this);
        bindRenderedEvent(zr, _this);
        bindMouseEvent(zr, _this);
        setAsPrimitive(_this);
        return _this;
      }
      ECharts2.prototype._onframe = function() {
        if (this._disposed) {
          return;
        }
        applyChangedStates(this);
        var scheduler = this._scheduler;
        if (this[PENDING_UPDATE]) {
          var silent = this[PENDING_UPDATE].silent;
          this[IN_MAIN_PROCESS_KEY] = true;
          updateMainProcessVersion(this);
          try {
            prepare(this);
            updateMethods.update.call(this, null, this[PENDING_UPDATE].updateParams);
          } catch (e2) {
            this[IN_MAIN_PROCESS_KEY] = false;
            this[PENDING_UPDATE] = null;
            throw e2;
          }
          this._zr.flush();
          this[IN_MAIN_PROCESS_KEY] = false;
          this[PENDING_UPDATE] = null;
          flushPendingActions.call(this, silent);
          triggerUpdatedEvent.call(this, silent);
        } else if (scheduler.unfinished) {
          var remainTime = TEST_FRAME_REMAIN_TIME;
          var ecModel = this._model;
          var api = this._api;
          scheduler.unfinished = false;
          do {
            var startTime = +/* @__PURE__ */ new Date();
            scheduler.performSeriesTasks(ecModel);
            scheduler.performDataProcessorTasks(ecModel);
            updateStreamModes(this, ecModel);
            scheduler.performVisualTasks(ecModel);
            renderSeries(this, this._model, api, "remain", {});
            remainTime -= +/* @__PURE__ */ new Date() - startTime;
          } while (remainTime > 0 && scheduler.unfinished);
          if (!scheduler.unfinished) {
            this._zr.flush();
          }
        }
      };
      ECharts2.prototype.getDom = function() {
        return this._dom;
      };
      ECharts2.prototype.getId = function() {
        return this.id;
      };
      ECharts2.prototype.getZr = function() {
        return this._zr;
      };
      ECharts2.prototype.isSSR = function() {
        return this._ssr;
      };
      ECharts2.prototype.setOption = function(option, notMerge, lazyUpdate) {
        if (this[IN_MAIN_PROCESS_KEY]) {
          if (define_process_env_default$j.NODE_ENV !== "production") {
            error("`setOption` should not be called during main process.");
          }
          return;
        }
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        var silent;
        var replaceMerge;
        var transitionOpt;
        if (isObject$2(notMerge)) {
          lazyUpdate = notMerge.lazyUpdate;
          silent = notMerge.silent;
          replaceMerge = notMerge.replaceMerge;
          transitionOpt = notMerge.transition;
          notMerge = notMerge.notMerge;
        }
        this[IN_MAIN_PROCESS_KEY] = true;
        updateMainProcessVersion(this);
        if (!this._model || notMerge) {
          var optionManager = new OptionManager(this._api);
          var theme2 = this._theme;
          var ecModel = this._model = new GlobalModel();
          ecModel.scheduler = this._scheduler;
          ecModel.ssr = this._ssr;
          ecModel.init(null, null, null, theme2, this._locale, optionManager);
        }
        this._model.setOption(option, {
          replaceMerge
        }, optionPreprocessorFuncs);
        var updateParams = {
          seriesTransition: transitionOpt,
          optionChanged: true
        };
        if (lazyUpdate) {
          this[PENDING_UPDATE] = {
            silent,
            updateParams
          };
          this[IN_MAIN_PROCESS_KEY] = false;
          this.getZr().wakeUp();
        } else {
          try {
            prepare(this);
            updateMethods.update.call(this, null, updateParams);
          } catch (e2) {
            this[PENDING_UPDATE] = null;
            this[IN_MAIN_PROCESS_KEY] = false;
            throw e2;
          }
          if (!this._ssr) {
            this._zr.flush();
          }
          this[PENDING_UPDATE] = null;
          this[IN_MAIN_PROCESS_KEY] = false;
          flushPendingActions.call(this, silent);
          triggerUpdatedEvent.call(this, silent);
        }
      };
      ECharts2.prototype.setTheme = function(theme2, opts) {
        if (this[IN_MAIN_PROCESS_KEY]) {
          if (define_process_env_default$j.NODE_ENV !== "production") {
            error("`setTheme` should not be called during main process.");
          }
          return;
        }
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        var ecModel = this._model;
        if (!ecModel) {
          return;
        }
        var silent = opts && opts.silent;
        var updateParams = null;
        if (this[PENDING_UPDATE]) {
          if (silent == null) {
            silent = this[PENDING_UPDATE].silent;
          }
          updateParams = this[PENDING_UPDATE].updateParams;
          this[PENDING_UPDATE] = null;
        }
        this[IN_MAIN_PROCESS_KEY] = true;
        updateMainProcessVersion(this);
        try {
          this._updateTheme(theme2);
          ecModel.setTheme(this._theme);
          prepare(this);
          updateMethods.update.call(this, {
            type: "setTheme"
          }, updateParams);
        } catch (e2) {
          this[IN_MAIN_PROCESS_KEY] = false;
          throw e2;
        }
        this[IN_MAIN_PROCESS_KEY] = false;
        flushPendingActions.call(this, silent);
        triggerUpdatedEvent.call(this, silent);
      };
      ECharts2.prototype._updateTheme = function(theme2) {
        if (isString(theme2)) {
          theme2 = themeStorage[theme2];
        }
        if (theme2) {
          theme2 = clone$2(theme2);
          theme2 && globalBackwardCompat(theme2, true);
          this._theme = theme2;
        }
      };
      ECharts2.prototype.getModel = function() {
        return this._model;
      };
      ECharts2.prototype.getOption = function() {
        return this._model && this._model.getOption();
      };
      ECharts2.prototype.getWidth = function() {
        return this._zr.getWidth();
      };
      ECharts2.prototype.getHeight = function() {
        return this._zr.getHeight();
      };
      ECharts2.prototype.getDevicePixelRatio = function() {
        return this._zr.painter.dpr || env.hasGlobalWindow && window.devicePixelRatio || 1;
      };
      ECharts2.prototype.getRenderedCanvas = function(opts) {
        if (define_process_env_default$j.NODE_ENV !== "production") {
          deprecateReplaceLog("getRenderedCanvas", "renderToCanvas");
        }
        return this.renderToCanvas(opts);
      };
      ECharts2.prototype.renderToCanvas = function(opts) {
        opts = opts || {};
        var painter = this._zr.painter;
        if (define_process_env_default$j.NODE_ENV !== "production") {
          if (painter.type !== "canvas") {
            throw new Error("renderToCanvas can only be used in the canvas renderer.");
          }
        }
        return painter.getRenderedCanvas({
          backgroundColor: opts.backgroundColor || this._model.get("backgroundColor"),
          pixelRatio: opts.pixelRatio || this.getDevicePixelRatio()
        });
      };
      ECharts2.prototype.renderToSVGString = function(opts) {
        opts = opts || {};
        var painter = this._zr.painter;
        if (define_process_env_default$j.NODE_ENV !== "production") {
          if (painter.type !== "svg") {
            throw new Error("renderToSVGString can only be used in the svg renderer.");
          }
        }
        return painter.renderToString({
          useViewBox: opts.useViewBox
        });
      };
      ECharts2.prototype.getSvgDataURL = function() {
        var zr = this._zr;
        var list = zr.storage.getDisplayList();
        each$5(list, function(el) {
          el.stopAnimation(null, true);
        });
        return zr.painter.toDataURL();
      };
      ECharts2.prototype.getDataURL = function(opts) {
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        opts = opts || {};
        var excludeComponents = opts.excludeComponents;
        var ecModel = this._model;
        var excludesComponentViews = [];
        var self2 = this;
        each$5(excludeComponents, function(componentType) {
          ecModel.eachComponent({
            mainType: componentType
          }, function(component) {
            var view = self2._componentsMap[component.__viewId];
            if (!view.group.ignore) {
              excludesComponentViews.push(view);
              view.group.ignore = true;
            }
          });
        });
        var url = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(opts).toDataURL("image/" + (opts && opts.type || "png"));
        each$5(excludesComponentViews, function(view) {
          view.group.ignore = false;
        });
        return url;
      };
      ECharts2.prototype.getConnectedDataURL = function(opts) {
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        var isSvg = opts.type === "svg";
        var groupId = this.group;
        var mathMin2 = Math.min;
        var mathMax2 = Math.max;
        var MAX_NUMBER = Infinity;
        if (connectedGroups[groupId]) {
          var left_1 = MAX_NUMBER;
          var top_1 = MAX_NUMBER;
          var right_1 = -MAX_NUMBER;
          var bottom_1 = -MAX_NUMBER;
          var canvasList_1 = [];
          var dpr_1 = opts && opts.pixelRatio || this.getDevicePixelRatio();
          each$5(instances, function(chart, id) {
            if (chart.group === groupId) {
              var canvas = isSvg ? chart.getZr().painter.getSvgDom().innerHTML : chart.renderToCanvas(clone$2(opts));
              var boundingRect = chart.getDom().getBoundingClientRect();
              left_1 = mathMin2(boundingRect.left, left_1);
              top_1 = mathMin2(boundingRect.top, top_1);
              right_1 = mathMax2(boundingRect.right, right_1);
              bottom_1 = mathMax2(boundingRect.bottom, bottom_1);
              canvasList_1.push({
                dom: canvas,
                left: boundingRect.left,
                top: boundingRect.top
              });
            }
          });
          left_1 *= dpr_1;
          top_1 *= dpr_1;
          right_1 *= dpr_1;
          bottom_1 *= dpr_1;
          var width = right_1 - left_1;
          var height = bottom_1 - top_1;
          var targetCanvas = platformApi.createCanvas();
          var zr_1 = init$1(targetCanvas, {
            renderer: isSvg ? "svg" : "canvas"
          });
          zr_1.resize({
            width,
            height
          });
          if (isSvg) {
            var content_1 = "";
            each$5(canvasList_1, function(item) {
              var x = item.left - left_1;
              var y = item.top - top_1;
              content_1 += '<g transform="translate(' + x + "," + y + ')">' + item.dom + "</g>";
            });
            zr_1.painter.getSvgRoot().innerHTML = content_1;
            if (opts.connectedBackgroundColor) {
              zr_1.painter.setBackgroundColor(opts.connectedBackgroundColor);
            }
            zr_1.refreshImmediately();
            return zr_1.painter.toDataURL();
          } else {
            if (opts.connectedBackgroundColor) {
              zr_1.add(new Rect$1({
                shape: {
                  x: 0,
                  y: 0,
                  width,
                  height
                },
                style: {
                  fill: opts.connectedBackgroundColor
                }
              }));
            }
            each$5(canvasList_1, function(item) {
              var img = new ZRImage({
                style: {
                  x: item.left * dpr_1 - left_1,
                  y: item.top * dpr_1 - top_1,
                  image: item.dom
                }
              });
              zr_1.add(img);
            });
            zr_1.refreshImmediately();
            return targetCanvas.toDataURL("image/" + (opts && opts.type || "png"));
          }
        } else {
          return this.getDataURL(opts);
        }
      };
      ECharts2.prototype.convertToPixel = function(finder, value, opt) {
        return doConvertPixel(this, "convertToPixel", finder, value, opt);
      };
      ECharts2.prototype.convertToLayout = function(finder, value, opt) {
        return doConvertPixel(this, "convertToLayout", finder, value, opt);
      };
      ECharts2.prototype.convertFromPixel = function(finder, value, opt) {
        return doConvertPixel(this, "convertFromPixel", finder, value, opt);
      };
      ECharts2.prototype.containPixel = function(finder, value) {
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        var ecModel = this._model;
        var result;
        var findResult = parseFinder(ecModel, finder);
        each$5(findResult, function(models, key2) {
          key2.indexOf("Models") >= 0 && each$5(models, function(model) {
            var coordSys = model.coordinateSystem;
            if (coordSys && coordSys.containPoint) {
              result = result || !!coordSys.containPoint(value);
            } else if (key2 === "seriesModels") {
              var view = this._chartsMap[model.__viewId];
              if (view && view.containPoint) {
                result = result || view.containPoint(value, model);
              } else {
                if (define_process_env_default$j.NODE_ENV !== "production") {
                  warn(key2 + ": " + (view ? "The found component do not support containPoint." : "No view mapping to the found component."));
                }
              }
            } else {
              if (define_process_env_default$j.NODE_ENV !== "production") {
                warn(key2 + ": containPoint is not supported");
              }
            }
          }, this);
        }, this);
        return !!result;
      };
      ECharts2.prototype.getVisual = function(finder, visualType) {
        var ecModel = this._model;
        var parsedFinder = parseFinder(ecModel, finder, {
          defaultMainType: "series"
        });
        var seriesModel = parsedFinder.seriesModel;
        if (define_process_env_default$j.NODE_ENV !== "production") {
          if (!seriesModel) {
            warn("There is no specified series model");
          }
        }
        var data = seriesModel.getData();
        var dataIndexInside = parsedFinder.hasOwnProperty("dataIndexInside") ? parsedFinder.dataIndexInside : parsedFinder.hasOwnProperty("dataIndex") ? data.indexOfRawIndex(parsedFinder.dataIndex) : null;
        return dataIndexInside != null ? getItemVisualFromData(data, dataIndexInside, visualType) : getVisualFromData(data, visualType);
      };
      ECharts2.prototype.getViewOfComponentModel = function(componentModel) {
        return this._componentsMap[componentModel.__viewId];
      };
      ECharts2.prototype.getViewOfSeriesModel = function(seriesModel) {
        return this._chartsMap[seriesModel.__viewId];
      };
      ECharts2.prototype._initEvents = function() {
        var _this = this;
        each$5(MOUSE_EVENT_NAMES, function(eveName) {
          var handler = function(e2) {
            var ecModel = _this.getModel();
            var el = e2.target;
            var params;
            var isGlobalOut = eveName === "globalout";
            if (isGlobalOut) {
              params = {};
            } else {
              el && findEventDispatcher(el, function(parent) {
                var ecData = getECData(parent);
                if (ecData && ecData.dataIndex != null) {
                  var dataModel = ecData.dataModel || ecModel.getSeriesByIndex(ecData.seriesIndex);
                  params = dataModel && dataModel.getDataParams(ecData.dataIndex, ecData.dataType, el) || {};
                  return true;
                } else if (ecData.eventData) {
                  params = extend({}, ecData.eventData);
                  return true;
                }
              }, true);
            }
            if (params) {
              var componentType = params.componentType;
              var componentIndex = params.componentIndex;
              if (componentType === "markLine" || componentType === "markPoint" || componentType === "markArea") {
                componentType = "series";
                componentIndex = params.seriesIndex;
              }
              var model = componentType && componentIndex != null && ecModel.getComponent(componentType, componentIndex);
              var view = model && _this[model.mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId];
              if (define_process_env_default$j.NODE_ENV !== "production") {
                if (!isGlobalOut && !(model && view)) {
                  warn("model or view can not be found by params");
                }
              }
              params.event = e2;
              params.type = eveName;
              _this._$eventProcessor.eventInfo = {
                targetEl: el,
                packedEvent: params,
                model,
                view
              };
              _this.trigger(eveName, params);
            }
          };
          handler.zrEventfulCallAtLast = true;
          _this._zr.on(eveName, handler, _this);
        });
        var messageCenter = this._messageCenter;
        each$5(publicEventTypeMap, function(_, eventType) {
          messageCenter.on(eventType, function(event) {
            _this.trigger(eventType, event);
          });
        });
        handleLegacySelectEvents(messageCenter, this, this._api);
      };
      ECharts2.prototype.isDisposed = function() {
        return this._disposed;
      };
      ECharts2.prototype.clear = function() {
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        this.setOption({
          series: []
        }, true);
      };
      ECharts2.prototype.dispose = function() {
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        this._disposed = true;
        var dom = this.getDom();
        if (dom) {
          setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, "");
        }
        var chart = this;
        var api = chart._api;
        var ecModel = chart._model;
        each$5(chart._componentsViews, function(component) {
          component.dispose(ecModel, api);
        });
        each$5(chart._chartsViews, function(chart2) {
          chart2.dispose(ecModel, api);
        });
        chart._zr.dispose();
        chart._dom = chart._model = chart._chartsMap = chart._componentsMap = chart._chartsViews = chart._componentsViews = chart._scheduler = chart._api = chart._zr = chart._throttledZrFlush = chart._theme = chart._coordSysMgr = chart._messageCenter = null;
        delete instances[chart.id];
      };
      ECharts2.prototype.resize = function(opts) {
        if (this[IN_MAIN_PROCESS_KEY]) {
          if (define_process_env_default$j.NODE_ENV !== "production") {
            error("`resize` should not be called during main process.");
          }
          return;
        }
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        this._zr.resize(opts);
        var ecModel = this._model;
        this._loadingFX && this._loadingFX.resize();
        if (!ecModel) {
          return;
        }
        var needPrepare = ecModel.resetOption("media");
        var silent = opts && opts.silent;
        if (this[PENDING_UPDATE]) {
          if (silent == null) {
            silent = this[PENDING_UPDATE].silent;
          }
          needPrepare = true;
          this[PENDING_UPDATE] = null;
        }
        this[IN_MAIN_PROCESS_KEY] = true;
        updateMainProcessVersion(this);
        try {
          needPrepare && prepare(this);
          updateMethods.update.call(this, {
            type: "resize",
            animation: extend({
              // Disable animation
              duration: 0
            }, opts && opts.animation)
          });
        } catch (e2) {
          this[IN_MAIN_PROCESS_KEY] = false;
          throw e2;
        }
        this[IN_MAIN_PROCESS_KEY] = false;
        flushPendingActions.call(this, silent);
        triggerUpdatedEvent.call(this, silent);
      };
      ECharts2.prototype.showLoading = function(name, cfg) {
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        if (isObject$2(name)) {
          cfg = name;
          name = "";
        }
        name = name || "default";
        this.hideLoading();
        if (!loadingEffects[name]) {
          if (define_process_env_default$j.NODE_ENV !== "production") {
            warn("Loading effects " + name + " not exists.");
          }
          return;
        }
        var el = loadingEffects[name](this._api, cfg);
        var zr = this._zr;
        this._loadingFX = el;
        zr.add(el);
      };
      ECharts2.prototype.hideLoading = function() {
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        this._loadingFX && this._zr.remove(this._loadingFX);
        this._loadingFX = null;
      };
      ECharts2.prototype.makeActionFromEvent = function(eventObj) {
        var payload = extend({}, eventObj);
        payload.type = connectionEventRevertMap[eventObj.type];
        return payload;
      };
      ECharts2.prototype.dispatchAction = function(payload, opt) {
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        if (!isObject$2(opt)) {
          opt = {
            silent: !!opt
          };
        }
        if (!actions[payload.type]) {
          return;
        }
        if (!this._model) {
          return;
        }
        if (this[IN_MAIN_PROCESS_KEY]) {
          this._pendingActions.push(payload);
          return;
        }
        var silent = opt.silent;
        doDispatchAction.call(this, payload, silent);
        var flush = opt.flush;
        if (flush) {
          this._zr.flush();
        } else if (flush !== false && env.browser.weChat) {
          this._throttledZrFlush();
        }
        flushPendingActions.call(this, silent);
        triggerUpdatedEvent.call(this, silent);
      };
      ECharts2.prototype.updateLabelLayout = function() {
        lifecycle.trigger("series:layoutlabels", this._model, this._api, {
          // Not adding series labels.
          // TODO
          updatedSeries: []
        });
      };
      ECharts2.prototype.appendData = function(params) {
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        var seriesIndex = params.seriesIndex;
        var ecModel = this.getModel();
        var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
        if (define_process_env_default$j.NODE_ENV !== "production") {
          assert(params.data && seriesModel);
        }
        seriesModel.appendData(params);
        this._scheduler.unfinished = true;
        this.getZr().wakeUp();
      };
      ECharts2.internalField = function() {
        prepare = function(ecIns) {
          var scheduler = ecIns._scheduler;
          scheduler.restorePipelines(ecIns._model);
          scheduler.prepareStageTasks();
          prepareView(ecIns, true);
          prepareView(ecIns, false);
          scheduler.plan();
        };
        prepareView = function(ecIns, isComponent) {
          var ecModel = ecIns._model;
          var scheduler = ecIns._scheduler;
          var viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews;
          var viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap;
          var zr = ecIns._zr;
          var api = ecIns._api;
          for (var i = 0; i < viewList.length; i++) {
            viewList[i].__alive = false;
          }
          isComponent ? ecModel.eachComponent(function(componentType, model) {
            componentType !== "series" && doPrepare(model);
          }) : ecModel.eachSeries(doPrepare);
          function doPrepare(model) {
            var requireNewView = model.__requireNewView;
            model.__requireNewView = false;
            var viewId = "_ec_" + model.id + "_" + model.type;
            var view2 = !requireNewView && viewMap[viewId];
            if (!view2) {
              var classType = parseClassType(model.type);
              var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : (
                // FIXME:TS
                // (ChartView as ChartViewConstructor).getClass('series', classType.sub)
                // For backward compat, still support a chart type declared as only subType
                // like "liquidfill", but recommend "series.liquidfill"
                // But need a base class to make a type series.
                ChartView.getClass(classType.sub)
              );
              if (define_process_env_default$j.NODE_ENV !== "production") {
                assert(Clazz, classType.sub + " does not exist.");
              }
              view2 = new Clazz();
              view2.init(ecModel, api);
              viewMap[viewId] = view2;
              viewList.push(view2);
              zr.add(view2.group);
            }
            model.__viewId = view2.__id = viewId;
            view2.__alive = true;
            view2.__model = model;
            view2.group.__ecComponentInfo = {
              mainType: model.mainType,
              index: model.componentIndex
            };
            !isComponent && scheduler.prepareView(view2, model, ecModel, api);
          }
          for (var i = 0; i < viewList.length; ) {
            var view = viewList[i];
            if (!view.__alive) {
              !isComponent && view.renderTask.dispose();
              zr.remove(view.group);
              view.dispose(ecModel, api);
              viewList.splice(i, 1);
              if (viewMap[view.__id] === view) {
                delete viewMap[view.__id];
              }
              view.__id = view.group.__ecComponentInfo = null;
            } else {
              i++;
            }
          }
        };
        updateDirectly = function(ecIns, method, payload, mainType, subType) {
          var ecModel = ecIns._model;
          ecModel.setUpdatePayload(payload);
          if (!mainType) {
            each$5([].concat(ecIns._componentsViews).concat(ecIns._chartsViews), callView);
            return;
          }
          var query = {};
          query[mainType + "Id"] = payload[mainType + "Id"];
          query[mainType + "Index"] = payload[mainType + "Index"];
          query[mainType + "Name"] = payload[mainType + "Name"];
          var condition = {
            mainType,
            query
          };
          subType && (condition.subType = subType);
          var excludeSeriesId = payload.excludeSeriesId;
          var excludeSeriesIdMap;
          if (excludeSeriesId != null) {
            excludeSeriesIdMap = createHashMap();
            each$5(normalizeToArray(excludeSeriesId), function(id) {
              var modelId = convertOptionIdName(id, null);
              if (modelId != null) {
                excludeSeriesIdMap.set(modelId, true);
              }
            });
          }
          ecModel && ecModel.eachComponent(condition, function(model) {
            var isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) != null;
            if (isExcluded) {
              return;
            }
            if (isHighDownPayload(payload)) {
              if (model instanceof SeriesModel) {
                if (payload.type === HIGHLIGHT_ACTION_TYPE && !payload.notBlur && !model.get(["emphasis", "disabled"])) {
                  blurSeriesFromHighlightPayload(model, payload, ecIns._api);
                }
              } else {
                var _a2 = findComponentHighDownDispatchers(model.mainType, model.componentIndex, payload.name, ecIns._api), focusSelf = _a2.focusSelf, dispatchers = _a2.dispatchers;
                if (payload.type === HIGHLIGHT_ACTION_TYPE && focusSelf && !payload.notBlur) {
                  blurComponent(model.mainType, model.componentIndex, ecIns._api);
                }
                if (dispatchers) {
                  each$5(dispatchers, function(dispatcher) {
                    payload.type === HIGHLIGHT_ACTION_TYPE ? enterEmphasis(dispatcher) : leaveEmphasis(dispatcher);
                  });
                }
              }
            } else if (isSelectChangePayload(payload)) {
              if (model instanceof SeriesModel) {
                toggleSelectionFromPayload(model, payload, ecIns._api);
                updateSeriesElementSelection(model);
                markStatusToUpdate(ecIns);
              }
            }
          }, ecIns);
          ecModel && ecModel.eachComponent(condition, function(model) {
            var isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) != null;
            if (isExcluded) {
              return;
            }
            callView(ecIns[mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId]);
          }, ecIns);
          function callView(view) {
            view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
          }
        };
        updateMethods = {
          prepareAndUpdate: function(payload) {
            prepare(this);
            updateMethods.update.call(this, payload, payload && {
              // Needs to mark option changed if newOption is given.
              // It's from MagicType.
              // TODO If use a separate flag optionChanged in payload?
              optionChanged: payload.newOption != null
            });
          },
          update: function(payload, updateParams) {
            var ecModel = this._model;
            var api = this._api;
            var zr = this._zr;
            var coordSysMgr = this._coordSysMgr;
            var scheduler = this._scheduler;
            if (!ecModel) {
              return;
            }
            ecModel.setUpdatePayload(payload);
            scheduler.restoreData(ecModel, payload);
            scheduler.performSeriesTasks(ecModel);
            coordSysMgr.create(ecModel, api);
            scheduler.performDataProcessorTasks(ecModel, payload);
            updateStreamModes(this, ecModel);
            coordSysMgr.update(ecModel, api);
            clearColorPalette(ecModel);
            scheduler.performVisualTasks(ecModel, payload);
            var backgroundColor2 = ecModel.get("backgroundColor") || "transparent";
            zr.setBackgroundColor(backgroundColor2);
            var darkMode = ecModel.get("darkMode");
            if (darkMode != null && darkMode !== "auto") {
              zr.setDarkMode(darkMode);
            }
            render(this, ecModel, api, payload, updateParams);
            lifecycle.trigger("afterupdate", ecModel, api);
          },
          updateTransform: function(payload) {
            var _this = this;
            var ecModel = this._model;
            var api = this._api;
            if (!ecModel) {
              return;
            }
            ecModel.setUpdatePayload(payload);
            var componentDirtyList = [];
            ecModel.eachComponent(function(componentType, componentModel) {
              if (componentType === "series") {
                return;
              }
              var componentView = _this.getViewOfComponentModel(componentModel);
              if (componentView && componentView.__alive) {
                if (componentView.updateTransform) {
                  var result = componentView.updateTransform(componentModel, ecModel, api, payload);
                  result && result.update && componentDirtyList.push(componentView);
                } else {
                  componentDirtyList.push(componentView);
                }
              }
            });
            var seriesDirtyMap = createHashMap();
            ecModel.eachSeries(function(seriesModel) {
              var chartView = _this._chartsMap[seriesModel.__viewId];
              if (chartView.updateTransform) {
                var result = chartView.updateTransform(seriesModel, ecModel, api, payload);
                result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);
              } else {
                seriesDirtyMap.set(seriesModel.uid, 1);
              }
            });
            clearColorPalette(ecModel);
            this._scheduler.performVisualTasks(ecModel, payload, {
              setDirty: true,
              dirtyMap: seriesDirtyMap
            });
            renderSeries(this, ecModel, api, payload, {}, seriesDirtyMap);
            lifecycle.trigger("afterupdate", ecModel, api);
          },
          updateView: function(payload) {
            var ecModel = this._model;
            if (!ecModel) {
              return;
            }
            ecModel.setUpdatePayload(payload);
            ChartView.markUpdateMethod(payload, "updateView");
            clearColorPalette(ecModel);
            this._scheduler.performVisualTasks(ecModel, payload, {
              setDirty: true
            });
            render(this, ecModel, this._api, payload, {});
            lifecycle.trigger("afterupdate", ecModel, this._api);
          },
          updateVisual: function(payload) {
            var _this = this;
            var ecModel = this._model;
            if (!ecModel) {
              return;
            }
            ecModel.setUpdatePayload(payload);
            ecModel.eachSeries(function(seriesModel) {
              seriesModel.getData().clearAllVisual();
            });
            ChartView.markUpdateMethod(payload, "updateVisual");
            clearColorPalette(ecModel);
            this._scheduler.performVisualTasks(ecModel, payload, {
              visualType: "visual",
              setDirty: true
            });
            ecModel.eachComponent(function(componentType, componentModel) {
              if (componentType !== "series") {
                var componentView = _this.getViewOfComponentModel(componentModel);
                componentView && componentView.__alive && componentView.updateVisual(componentModel, ecModel, _this._api, payload);
              }
            });
            ecModel.eachSeries(function(seriesModel) {
              var chartView = _this._chartsMap[seriesModel.__viewId];
              chartView.updateVisual(seriesModel, ecModel, _this._api, payload);
            });
            lifecycle.trigger("afterupdate", ecModel, this._api);
          },
          updateLayout: function(payload) {
            updateMethods.update.call(this, payload);
          }
        };
        function doConvertPixelImpl(ecIns, methodName, finder, value, opt) {
          if (ecIns._disposed) {
            disposedWarning(ecIns.id);
            return;
          }
          var ecModel = ecIns._model;
          var coordSysList = ecIns._coordSysMgr.getCoordinateSystems();
          var result;
          var parsedFinder = parseFinder(ecModel, finder);
          for (var i = 0; i < coordSysList.length; i++) {
            var coordSys = coordSysList[i];
            if (coordSys[methodName] && (result = coordSys[methodName](ecModel, parsedFinder, value, opt)) != null) {
              return result;
            }
          }
          if (define_process_env_default$j.NODE_ENV !== "production") {
            warn("No coordinate system that supports " + methodName + " found by the given finder.");
          }
        }
        doConvertPixel = doConvertPixelImpl;
        updateStreamModes = function(ecIns, ecModel) {
          var chartsMap = ecIns._chartsMap;
          var scheduler = ecIns._scheduler;
          ecModel.eachSeries(function(seriesModel) {
            scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);
          });
        };
        doDispatchAction = function(payload, silent) {
          var _this = this;
          var ecModel = this.getModel();
          var payloadType = payload.type;
          var escapeConnect = payload.escapeConnect;
          var actionInfo = actions[payloadType];
          var cptTypeTmp = (actionInfo.update || "update").split(":");
          var updateMethod = cptTypeTmp.pop();
          var cptType = cptTypeTmp[0] != null && parseClassType(cptTypeTmp[0]);
          this[IN_MAIN_PROCESS_KEY] = true;
          updateMainProcessVersion(this);
          var payloads = [payload];
          var batched = false;
          if (payload.batch) {
            batched = true;
            payloads = map$1(payload.batch, function(item) {
              item = defaults(extend({}, item), payload);
              item.batch = null;
              return item;
            });
          }
          var eventObjBatch = [];
          var eventObj;
          var actionResultBatch = [];
          var nonRefinedEventType = actionInfo.nonRefinedEventType;
          var isSelectChange = isSelectChangePayload(payload);
          var isHighDown = isHighDownPayload(payload);
          if (isHighDown) {
            allLeaveBlur(this._api);
          }
          each$5(payloads, function(batchItem) {
            var actionResult = actionInfo.action(batchItem, ecModel, _this._api);
            if (actionInfo.refineEvent) {
              actionResultBatch.push(actionResult);
            } else {
              eventObj = actionResult;
            }
            eventObj = eventObj || extend({}, batchItem);
            eventObj.type = nonRefinedEventType;
            eventObjBatch.push(eventObj);
            if (isHighDown) {
              var _a2 = preParseFinder(payload), queryOptionMap = _a2.queryOptionMap, mainTypeSpecified = _a2.mainTypeSpecified;
              var componentMainType = mainTypeSpecified ? queryOptionMap.keys()[0] : "series";
              updateDirectly(_this, updateMethod, batchItem, componentMainType);
              markStatusToUpdate(_this);
            } else if (isSelectChange) {
              updateDirectly(_this, updateMethod, batchItem, "series");
              markStatusToUpdate(_this);
            } else if (cptType) {
              updateDirectly(_this, updateMethod, batchItem, cptType.main, cptType.sub);
            }
          });
          if (updateMethod !== "none" && !isHighDown && !isSelectChange && !cptType) {
            try {
              if (this[PENDING_UPDATE]) {
                prepare(this);
                updateMethods.update.call(this, payload);
                this[PENDING_UPDATE] = null;
              } else {
                updateMethods[updateMethod].call(this, payload);
              }
            } catch (e2) {
              this[IN_MAIN_PROCESS_KEY] = false;
              throw e2;
            }
          }
          if (batched) {
            eventObj = {
              type: nonRefinedEventType,
              escapeConnect,
              batch: eventObjBatch
            };
          } else {
            eventObj = eventObjBatch[0];
          }
          this[IN_MAIN_PROCESS_KEY] = false;
          if (!silent) {
            var refinedEvent = void 0;
            if (actionInfo.refineEvent) {
              var eventContent = actionInfo.refineEvent(actionResultBatch, payload, ecModel, this._api).eventContent;
              assert(isObject$2(eventContent));
              refinedEvent = defaults({
                type: actionInfo.refinedEventType
              }, eventContent);
              refinedEvent.fromAction = payload.type;
              refinedEvent.fromActionPayload = payload;
              refinedEvent.escapeConnect = true;
            }
            var messageCenter = this._messageCenter;
            messageCenter.trigger(eventObj.type, eventObj);
            if (refinedEvent) {
              messageCenter.trigger(refinedEvent.type, refinedEvent);
            }
          }
        };
        flushPendingActions = function(silent) {
          var pendingActions = this._pendingActions;
          while (pendingActions.length) {
            var payload = pendingActions.shift();
            doDispatchAction.call(this, payload, silent);
          }
        };
        triggerUpdatedEvent = function(silent) {
          !silent && this.trigger("updated");
        };
        bindRenderedEvent = function(zr, ecIns) {
          zr.on("rendered", function(params) {
            ecIns.trigger("rendered", params);
            if (
              // Although zr is dirty if initial animation is not finished
              // and this checking is called on frame, we also check
              // animation finished for robustness.
              zr.animation.isFinished() && !ecIns[PENDING_UPDATE] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length
            ) {
              ecIns.trigger("finished");
            }
          });
        };
        bindMouseEvent = function(zr, ecIns) {
          zr.on("mouseover", function(e2) {
            var el = e2.target;
            var dispatcher = findEventDispatcher(el, isHighDownDispatcher);
            if (dispatcher) {
              handleGlobalMouseOverForHighDown(dispatcher, e2, ecIns._api);
              markStatusToUpdate(ecIns);
            }
          }).on("mouseout", function(e2) {
            var el = e2.target;
            var dispatcher = findEventDispatcher(el, isHighDownDispatcher);
            if (dispatcher) {
              handleGlobalMouseOutForHighDown(dispatcher, e2, ecIns._api);
              markStatusToUpdate(ecIns);
            }
          }).on("click", function(e2) {
            var el = e2.target;
            var dispatcher = findEventDispatcher(el, function(target) {
              return getECData(target).dataIndex != null;
            }, true);
            if (dispatcher) {
              var actionType = dispatcher.selected ? "unselect" : "select";
              var ecData = getECData(dispatcher);
              ecIns._api.dispatchAction({
                type: actionType,
                dataType: ecData.dataType,
                dataIndexInside: ecData.dataIndex,
                seriesIndex: ecData.seriesIndex,
                isFromClick: true
              });
            }
          });
        };
        function clearColorPalette(ecModel) {
          ecModel.clearColorPalette();
          ecModel.eachSeries(function(seriesModel) {
            seriesModel.clearColorPalette();
          });
        }
        function allocateZlevels(ecModel) {
          var componentZLevels = [];
          var seriesZLevels = [];
          var hasSeparateZLevel = false;
          ecModel.eachComponent(function(componentType, componentModel) {
            var zlevel = componentModel.get("zlevel") || 0;
            var z = componentModel.get("z") || 0;
            var zlevelKey = componentModel.getZLevelKey();
            hasSeparateZLevel = hasSeparateZLevel || !!zlevelKey;
            (componentType === "series" ? seriesZLevels : componentZLevels).push({
              zlevel,
              z,
              idx: componentModel.componentIndex,
              type: componentType,
              key: zlevelKey
            });
          });
          if (hasSeparateZLevel) {
            var zLevels = componentZLevels.concat(seriesZLevels);
            var lastSeriesZLevel_1;
            var lastSeriesKey_1;
            sort(zLevels, function(a, b) {
              if (a.zlevel === b.zlevel) {
                return a.z - b.z;
              }
              return a.zlevel - b.zlevel;
            });
            each$5(zLevels, function(item) {
              var componentModel = ecModel.getComponent(item.type, item.idx);
              var zlevel = item.zlevel;
              var key2 = item.key;
              if (lastSeriesZLevel_1 != null) {
                zlevel = Math.max(lastSeriesZLevel_1, zlevel);
              }
              if (key2) {
                if (zlevel === lastSeriesZLevel_1 && key2 !== lastSeriesKey_1) {
                  zlevel++;
                }
                lastSeriesKey_1 = key2;
              } else if (lastSeriesKey_1) {
                if (zlevel === lastSeriesZLevel_1) {
                  zlevel++;
                }
                lastSeriesKey_1 = "";
              }
              lastSeriesZLevel_1 = zlevel;
              componentModel.setZLevel(zlevel);
            });
          }
        }
        render = function(ecIns, ecModel, api, payload, updateParams) {
          allocateZlevels(ecModel);
          renderComponents(ecIns, ecModel, api, payload, updateParams);
          each$5(ecIns._chartsViews, function(chart) {
            chart.__alive = false;
          });
          renderSeries(ecIns, ecModel, api, payload, updateParams);
          each$5(ecIns._chartsViews, function(chart) {
            if (!chart.__alive) {
              chart.remove(ecModel, api);
            }
          });
        };
        renderComponents = function(ecIns, ecModel, api, payload, updateParams, dirtyList) {
          each$5(dirtyList || ecIns._componentsViews, function(componentView) {
            var componentModel = componentView.__model;
            clearStates(componentModel, componentView);
            componentView.render(componentModel, ecModel, api, payload);
            updateZ(componentModel, componentView);
            updateStates(componentModel, componentView);
          });
        };
        renderSeries = function(ecIns, ecModel, api, payload, updateParams, dirtyMap) {
          var scheduler = ecIns._scheduler;
          updateParams = extend(updateParams || {}, {
            updatedSeries: ecModel.getSeries()
          });
          lifecycle.trigger("series:beforeupdate", ecModel, api, updateParams);
          var unfinished = false;
          ecModel.eachSeries(function(seriesModel) {
            var chartView = ecIns._chartsMap[seriesModel.__viewId];
            chartView.__alive = true;
            var renderTask = chartView.renderTask;
            scheduler.updatePayload(renderTask, payload);
            clearStates(seriesModel, chartView);
            if (dirtyMap && dirtyMap.get(seriesModel.uid)) {
              renderTask.dirty();
            }
            if (renderTask.perform(scheduler.getPerformArgs(renderTask))) {
              unfinished = true;
            }
            chartView.group.silent = !!seriesModel.get("silent");
            updateBlend(seriesModel, chartView);
            updateSeriesElementSelection(seriesModel);
          });
          scheduler.unfinished = unfinished || scheduler.unfinished;
          lifecycle.trigger("series:layoutlabels", ecModel, api, updateParams);
          lifecycle.trigger("series:transition", ecModel, api, updateParams);
          ecModel.eachSeries(function(seriesModel) {
            var chartView = ecIns._chartsMap[seriesModel.__viewId];
            updateZ(seriesModel, chartView);
            updateStates(seriesModel, chartView);
          });
          updateHoverLayerStatus(ecIns, ecModel);
          lifecycle.trigger("series:afterupdate", ecModel, api, updateParams);
        };
        markStatusToUpdate = function(ecIns) {
          ecIns[STATUS_NEEDS_UPDATE_KEY] = true;
          ecIns.getZr().wakeUp();
        };
        updateMainProcessVersion = function(ecIns) {
          ecIns[MAIN_PROCESS_VERSION_KEY] = (ecIns[MAIN_PROCESS_VERSION_KEY] + 1) % 1e3;
        };
        applyChangedStates = function(ecIns) {
          if (!ecIns[STATUS_NEEDS_UPDATE_KEY]) {
            return;
          }
          ecIns.getZr().storage.traverse(function(el) {
            if (isElementRemoved(el)) {
              return;
            }
            applyElementStates(el);
          });
          ecIns[STATUS_NEEDS_UPDATE_KEY] = false;
        };
        function applyElementStates(el) {
          var newStates = [];
          var oldStates = el.currentStates;
          for (var i = 0; i < oldStates.length; i++) {
            var stateName = oldStates[i];
            if (!(stateName === "emphasis" || stateName === "blur" || stateName === "select")) {
              newStates.push(stateName);
            }
          }
          if (el.selected && el.states.select) {
            newStates.push("select");
          }
          if (el.hoverState === HOVER_STATE_EMPHASIS && el.states.emphasis) {
            newStates.push("emphasis");
          } else if (el.hoverState === HOVER_STATE_BLUR && el.states.blur) {
            newStates.push("blur");
          }
          el.useStates(newStates);
        }
        function updateHoverLayerStatus(ecIns, ecModel) {
          var zr = ecIns._zr;
          var storage = zr.storage;
          var elCount = 0;
          storage.traverse(function(el) {
            if (!el.isGroup) {
              elCount++;
            }
          });
          if (elCount > ecModel.get("hoverLayerThreshold") && !env.node && !env.worker) {
            ecModel.eachSeries(function(seriesModel) {
              if (seriesModel.preventUsingHoverLayer) {
                return;
              }
              var chartView = ecIns._chartsMap[seriesModel.__viewId];
              if (chartView.__alive) {
                chartView.eachRendered(function(el) {
                  if (el.states.emphasis) {
                    el.states.emphasis.hoverLayer = true;
                  }
                });
              }
            });
          }
        }
        function updateBlend(seriesModel, chartView) {
          var blendMode = seriesModel.get("blendMode") || null;
          chartView.eachRendered(function(el) {
            if (!el.isGroup) {
              el.style.blend = blendMode;
            }
          });
        }
        function updateZ(model, view) {
          if (model.preventAutoZ) {
            return;
          }
          var zInfo = retrieveZInfo(model);
          view.eachRendered(function(el) {
            traverseUpdateZ(el, zInfo.z, zInfo.zlevel);
            return true;
          });
        }
        function clearStates(model, view) {
          view.eachRendered(function(el) {
            if (isElementRemoved(el)) {
              return;
            }
            var textContent = el.getTextContent();
            var textGuide = el.getTextGuideLine();
            if (el.stateTransition) {
              el.stateTransition = null;
            }
            if (textContent && textContent.stateTransition) {
              textContent.stateTransition = null;
            }
            if (textGuide && textGuide.stateTransition) {
              textGuide.stateTransition = null;
            }
            if (el.hasState()) {
              el.prevStates = el.currentStates;
              el.clearStates();
            } else if (el.prevStates) {
              el.prevStates = null;
            }
          });
        }
        function updateStates(model, view) {
          var stateAnimationModel = model.getModel("stateAnimation");
          var enableAnimation = model.isAnimationEnabled();
          var duration = stateAnimationModel.get("duration");
          var stateTransition = duration > 0 ? {
            duration,
            delay: stateAnimationModel.get("delay"),
            easing: stateAnimationModel.get("easing")
            // additive: stateAnimationModel.get('additive')
          } : null;
          view.eachRendered(function(el) {
            if (el.states && el.states.emphasis) {
              if (isElementRemoved(el)) {
                return;
              }
              if (el instanceof Path) {
                savePathStates(el);
              }
              if (el.__dirty) {
                var prevStates = el.prevStates;
                if (prevStates) {
                  el.useStates(prevStates);
                }
              }
              if (enableAnimation) {
                el.stateTransition = stateTransition;
                var textContent = el.getTextContent();
                var textGuide = el.getTextGuideLine();
                if (textContent) {
                  textContent.stateTransition = stateTransition;
                }
                if (textGuide) {
                  textGuide.stateTransition = stateTransition;
                }
              }
              if (el.__dirty) {
                applyElementStates(el);
              }
            }
          });
        }
        createExtensionAPI = function(ecIns) {
          return new /** @class */
          (function(_super2) {
            __extends(class_1, _super2);
            function class_1() {
              return _super2 !== null && _super2.apply(this, arguments) || this;
            }
            class_1.prototype.getCoordinateSystems = function() {
              return ecIns._coordSysMgr.getCoordinateSystems();
            };
            class_1.prototype.getComponentByElement = function(el) {
              while (el) {
                var modelInfo = el.__ecComponentInfo;
                if (modelInfo != null) {
                  return ecIns._model.getComponent(modelInfo.mainType, modelInfo.index);
                }
                el = el.parent;
              }
            };
            class_1.prototype.enterEmphasis = function(el, highlightDigit) {
              enterEmphasis(el, highlightDigit);
              markStatusToUpdate(ecIns);
            };
            class_1.prototype.leaveEmphasis = function(el, highlightDigit) {
              leaveEmphasis(el, highlightDigit);
              markStatusToUpdate(ecIns);
            };
            class_1.prototype.enterBlur = function(el) {
              enterBlur(el);
              markStatusToUpdate(ecIns);
            };
            class_1.prototype.leaveBlur = function(el) {
              leaveBlur(el);
              markStatusToUpdate(ecIns);
            };
            class_1.prototype.enterSelect = function(el) {
              enterSelect(el);
              markStatusToUpdate(ecIns);
            };
            class_1.prototype.leaveSelect = function(el) {
              leaveSelect(el);
              markStatusToUpdate(ecIns);
            };
            class_1.prototype.getModel = function() {
              return ecIns.getModel();
            };
            class_1.prototype.getViewOfComponentModel = function(componentModel) {
              return ecIns.getViewOfComponentModel(componentModel);
            };
            class_1.prototype.getViewOfSeriesModel = function(seriesModel) {
              return ecIns.getViewOfSeriesModel(seriesModel);
            };
            class_1.prototype.getMainProcessVersion = function() {
              return ecIns[MAIN_PROCESS_VERSION_KEY];
            };
            return class_1;
          }(ExtensionAPI))(ecIns);
        };
        enableConnect = function(chart) {
          function updateConnectedChartsStatus(charts, status) {
            for (var i = 0; i < charts.length; i++) {
              var otherChart = charts[i];
              otherChart[CONNECT_STATUS_KEY] = status;
            }
          }
          each$5(connectionEventRevertMap, function(_, eventType) {
            chart._messageCenter.on(eventType, function(event) {
              if (connectedGroups[chart.group] && chart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_PENDING) {
                if (event && event.escapeConnect) {
                  return;
                }
                var action_1 = chart.makeActionFromEvent(event);
                var otherCharts_1 = [];
                each$5(instances, function(otherChart) {
                  if (otherChart !== chart && otherChart.group === chart.group) {
                    otherCharts_1.push(otherChart);
                  }
                });
                updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_PENDING);
                each$5(otherCharts_1, function(otherChart) {
                  if (otherChart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_UPDATING) {
                    otherChart.dispatchAction(action_1);
                  }
                });
                updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_UPDATED);
              }
            });
          });
        };
      }();
      return ECharts2;
    }(Eventful)
  );
  var echartsProto = ECharts.prototype;
  echartsProto.on = createRegisterEventWithLowercaseECharts("on");
  echartsProto.off = createRegisterEventWithLowercaseECharts("off");
  echartsProto.one = function(eventName, cb, ctx) {
    var self2 = this;
    deprecateLog("ECharts#one is deprecated.");
    function wrapped() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      cb && cb.apply && cb.apply(this, args2);
      self2.off(eventName, wrapped);
    }
    this.on.call(this, eventName, wrapped, ctx);
  };
  var MOUSE_EVENT_NAMES = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
  function disposedWarning(id) {
    if (define_process_env_default$j.NODE_ENV !== "production") {
      warn("Instance " + id + " has been disposed");
    }
  }
  var actions = {};
  var connectionEventRevertMap = {};
  var publicEventTypeMap = {};
  var dataProcessorFuncs = [];
  var optionPreprocessorFuncs = [];
  var visualFuncs = [];
  var themeStorage = {};
  var loadingEffects = {};
  var instances = {};
  var connectedGroups = {};
  var idBase = +/* @__PURE__ */ new Date() - 0;
  var DOM_ATTRIBUTE_KEY = "_echarts_instance_";
  function init(dom, theme2, opts) {
    var isClient = !(opts && opts.ssr);
    if (isClient) {
      if (define_process_env_default$j.NODE_ENV !== "production") {
        if (!dom) {
          throw new Error("Initialize failed: invalid dom.");
        }
      }
      var existInstance = getInstanceByDom(dom);
      if (existInstance) {
        if (define_process_env_default$j.NODE_ENV !== "production") {
          warn("There is a chart instance already initialized on the dom.");
        }
        return existInstance;
      }
      if (define_process_env_default$j.NODE_ENV !== "production") {
        if (isDom(dom) && dom.nodeName.toUpperCase() !== "CANVAS" && (!dom.clientWidth && (!opts || opts.width == null) || !dom.clientHeight && (!opts || opts.height == null))) {
          warn("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload.");
        }
      }
    }
    var chart = new ECharts(dom, theme2, opts);
    chart.id = "ec_" + idBase++;
    instances[chart.id] = chart;
    isClient && setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id);
    enableConnect(chart);
    lifecycle.trigger("afterinit", chart);
    return chart;
  }
  function getInstanceByDom(dom) {
    return instances[getAttribute(dom, DOM_ATTRIBUTE_KEY)];
  }
  function registerTheme(name, theme2) {
    themeStorage[name] = theme2;
  }
  function registerPreprocessor(preprocessorFunc) {
    if (indexOf(optionPreprocessorFuncs, preprocessorFunc) < 0) {
      optionPreprocessorFuncs.push(preprocessorFunc);
    }
  }
  function registerProcessor(priority, processor) {
    normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_DEFAULT);
  }
  function registerPostInit(postInitFunc) {
    registerUpdateLifecycle("afterinit", postInitFunc);
  }
  function registerPostUpdate(postUpdateFunc) {
    registerUpdateLifecycle("afterupdate", postUpdateFunc);
  }
  function registerUpdateLifecycle(name, cb) {
    lifecycle.on(name, cb);
  }
  function registerAction(arg0, arg1, action) {
    var actionType;
    var publicEventType;
    var refineEvent;
    var update;
    var publishNonRefinedEvent;
    if (isFunction(arg1)) {
      action = arg1;
      arg1 = "";
    }
    if (isObject$2(arg0)) {
      actionType = arg0.type;
      publicEventType = arg0.event;
      update = arg0.update;
      publishNonRefinedEvent = arg0.publishNonRefinedEvent;
      if (!action) {
        action = arg0.action;
      }
      refineEvent = arg0.refineEvent;
    } else {
      actionType = arg0;
      publicEventType = arg1;
    }
    function createEventType(actionOrEventType) {
      return actionOrEventType.toLowerCase();
    }
    publicEventType = createEventType(publicEventType || actionType);
    var nonRefinedEventType = refineEvent ? createEventType(actionType) : publicEventType;
    if (actions[actionType]) {
      return;
    }
    assert(ACTION_REG.test(actionType) && ACTION_REG.test(publicEventType));
    if (refineEvent) {
      assert(publicEventType !== actionType);
    }
    actions[actionType] = {
      actionType,
      refinedEventType: publicEventType,
      nonRefinedEventType,
      update,
      action,
      refineEvent
    };
    publicEventTypeMap[publicEventType] = 1;
    if (refineEvent && publishNonRefinedEvent) {
      publicEventTypeMap[nonRefinedEventType] = 1;
    }
    if (define_process_env_default$j.NODE_ENV !== "production" && connectionEventRevertMap[nonRefinedEventType]) {
      error(nonRefinedEventType + ' must not be shared; use "refineEvent" if you intend to share an event name.');
    }
    connectionEventRevertMap[nonRefinedEventType] = actionType;
  }
  function registerCoordinateSystem(type, coordSysCreator) {
    CoordinateSystemManager.register(type, coordSysCreator);
  }
  function registerLayout(priority, layoutTask) {
    normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, "layout");
  }
  function registerVisual(priority, visualTask) {
    normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, "visual");
  }
  var registeredTasks = [];
  function normalizeRegister(targetList, priority, fn, defaultPriority, visualType) {
    if (isFunction(priority) || isObject$2(priority)) {
      fn = priority;
      priority = defaultPriority;
    }
    if (define_process_env_default$j.NODE_ENV !== "production") {
      if (isNaN(priority) || priority == null) {
        throw new Error("Illegal priority");
      }
      each$5(targetList, function(wrap) {
        assert(wrap.__raw !== fn);
      });
    }
    if (indexOf(registeredTasks, fn) >= 0) {
      return;
    }
    registeredTasks.push(fn);
    var stageHandler = Scheduler.wrapStageHandler(fn, visualType);
    stageHandler.__prio = priority;
    stageHandler.__raw = fn;
    targetList.push(stageHandler);
  }
  function registerLoading(name, loadingFx) {
    loadingEffects[name] = loadingFx;
  }
  function registerMap(mapName, geoJson, specialAreas) {
    var registerMap2 = getImpl("registerMap");
    registerMap2 && registerMap2(mapName, geoJson, specialAreas);
  }
  var registerTransform = registerExternalTransform;
  registerVisual(PRIORITY_VISUAL_GLOBAL, seriesStyleTask);
  registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataStyleTask);
  registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataColorPaletteTask);
  registerVisual(PRIORITY_VISUAL_GLOBAL, seriesSymbolTask);
  registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataSymbolTask);
  registerVisual(PRIORITY_VISUAL_DECAL, decalVisual);
  registerPreprocessor(globalBackwardCompat);
  registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack);
  registerLoading("default", defaultLoading);
  registerAction({
    type: HIGHLIGHT_ACTION_TYPE,
    event: HIGHLIGHT_ACTION_TYPE,
    update: HIGHLIGHT_ACTION_TYPE
  }, noop);
  registerAction({
    type: DOWNPLAY_ACTION_TYPE,
    event: DOWNPLAY_ACTION_TYPE,
    update: DOWNPLAY_ACTION_TYPE
  }, noop);
  registerAction({
    type: SELECT_ACTION_TYPE,
    event: SELECT_CHANGED_EVENT_TYPE,
    update: SELECT_ACTION_TYPE,
    action: noop,
    refineEvent: makeSelectChangedEvent,
    publishNonRefinedEvent: true
  });
  registerAction({
    type: UNSELECT_ACTION_TYPE,
    event: SELECT_CHANGED_EVENT_TYPE,
    update: UNSELECT_ACTION_TYPE,
    action: noop,
    refineEvent: makeSelectChangedEvent,
    publishNonRefinedEvent: true
  });
  registerAction({
    type: TOGGLE_SELECT_ACTION_TYPE,
    event: SELECT_CHANGED_EVENT_TYPE,
    update: TOGGLE_SELECT_ACTION_TYPE,
    action: noop,
    refineEvent: makeSelectChangedEvent,
    publishNonRefinedEvent: true
  });
  function makeSelectChangedEvent(actionResultBatch, payload, ecModel, api) {
    return {
      eventContent: {
        selected: getAllSelectedIndices(ecModel),
        isFromClick: payload.isFromClick || false
      }
    };
  }
  registerTheme("default", {});
  registerTheme("dark", theme);
  function dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {
    return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;
  }
  function defaultKeyGetter(item) {
    return item;
  }
  var DataDiffer = (
    /** @class */
    function() {
      function DataDiffer2(oldArr, newArr, oldKeyGetter, newKeyGetter, context, diffMode) {
        this._old = oldArr;
        this._new = newArr;
        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
        this._newKeyGetter = newKeyGetter || defaultKeyGetter;
        this.context = context;
        this._diffModeMultiple = diffMode === "multiple";
      }
      DataDiffer2.prototype.add = function(func) {
        this._add = func;
        return this;
      };
      DataDiffer2.prototype.update = function(func) {
        this._update = func;
        return this;
      };
      DataDiffer2.prototype.updateManyToOne = function(func) {
        this._updateManyToOne = func;
        return this;
      };
      DataDiffer2.prototype.updateOneToMany = function(func) {
        this._updateOneToMany = func;
        return this;
      };
      DataDiffer2.prototype.updateManyToMany = function(func) {
        this._updateManyToMany = func;
        return this;
      };
      DataDiffer2.prototype.remove = function(func) {
        this._remove = func;
        return this;
      };
      DataDiffer2.prototype.execute = function() {
        this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
      };
      DataDiffer2.prototype._executeOneToOne = function() {
        var oldArr = this._old;
        var newArr = this._new;
        var newDataIndexMap = {};
        var oldDataKeyArr = new Array(oldArr.length);
        var newDataKeyArr = new Array(newArr.length);
        this._initIndexMap(oldArr, null, oldDataKeyArr, "_oldKeyGetter");
        this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
        for (var i = 0; i < oldArr.length; i++) {
          var oldKey = oldDataKeyArr[i];
          var newIdxMapVal = newDataIndexMap[oldKey];
          var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
          if (newIdxMapValLen > 1) {
            var newIdx = newIdxMapVal.shift();
            if (newIdxMapVal.length === 1) {
              newDataIndexMap[oldKey] = newIdxMapVal[0];
            }
            this._update && this._update(newIdx, i);
          } else if (newIdxMapValLen === 1) {
            newDataIndexMap[oldKey] = null;
            this._update && this._update(newIdxMapVal, i);
          } else {
            this._remove && this._remove(i);
          }
        }
        this._performRestAdd(newDataKeyArr, newDataIndexMap);
      };
      DataDiffer2.prototype._executeMultiple = function() {
        var oldArr = this._old;
        var newArr = this._new;
        var oldDataIndexMap = {};
        var newDataIndexMap = {};
        var oldDataKeyArr = [];
        var newDataKeyArr = [];
        this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, "_oldKeyGetter");
        this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
        for (var i = 0; i < oldDataKeyArr.length; i++) {
          var oldKey = oldDataKeyArr[i];
          var oldIdxMapVal = oldDataIndexMap[oldKey];
          var newIdxMapVal = newDataIndexMap[oldKey];
          var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);
          var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
          if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {
            this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);
            newDataIndexMap[oldKey] = null;
          } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {
            this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);
            newDataIndexMap[oldKey] = null;
          } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {
            this._update && this._update(newIdxMapVal, oldIdxMapVal);
            newDataIndexMap[oldKey] = null;
          } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {
            this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);
            newDataIndexMap[oldKey] = null;
          } else if (oldIdxMapValLen > 1) {
            for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {
              this._remove && this._remove(oldIdxMapVal[i_1]);
            }
          } else {
            this._remove && this._remove(oldIdxMapVal);
          }
        }
        this._performRestAdd(newDataKeyArr, newDataIndexMap);
      };
      DataDiffer2.prototype._performRestAdd = function(newDataKeyArr, newDataIndexMap) {
        for (var i = 0; i < newDataKeyArr.length; i++) {
          var newKey = newDataKeyArr[i];
          var newIdxMapVal = newDataIndexMap[newKey];
          var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);
          if (idxMapValLen > 1) {
            for (var j = 0; j < idxMapValLen; j++) {
              this._add && this._add(newIdxMapVal[j]);
            }
          } else if (idxMapValLen === 1) {
            this._add && this._add(newIdxMapVal);
          }
          newDataIndexMap[newKey] = null;
        }
      };
      DataDiffer2.prototype._initIndexMap = function(arr, map2, keyArr, keyGetterName) {
        var cbModeMultiple = this._diffModeMultiple;
        for (var i = 0; i < arr.length; i++) {
          var key2 = "_ec_" + this[keyGetterName](arr[i], i);
          if (!cbModeMultiple) {
            keyArr[i] = key2;
          }
          if (!map2) {
            continue;
          }
          var idxMapVal = map2[key2];
          var idxMapValLen = dataIndexMapValueLength(idxMapVal);
          if (idxMapValLen === 0) {
            map2[key2] = i;
            if (cbModeMultiple) {
              keyArr.push(key2);
            }
          } else if (idxMapValLen === 1) {
            map2[key2] = [idxMapVal, i];
          } else {
            idxMapVal.push(i);
          }
        }
      };
      return DataDiffer2;
    }()
  );
  var define_process_env_default$i = {};
  var DimensionUserOuput = (
    /** @class */
    function() {
      function DimensionUserOuput2(encode2, dimRequest) {
        this._encode = encode2;
        this._schema = dimRequest;
      }
      DimensionUserOuput2.prototype.get = function() {
        return {
          // Do not generate full dimension name until fist used.
          fullDimensions: this._getFullDimensionNames(),
          encode: this._encode
        };
      };
      DimensionUserOuput2.prototype._getFullDimensionNames = function() {
        if (!this._cachedDimNames) {
          this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : [];
        }
        return this._cachedDimNames;
      };
      return DimensionUserOuput2;
    }()
  );
  function summarizeDimensions(data, schema) {
    var summary = {};
    var encode2 = summary.encode = {};
    var notExtraCoordDimMap = createHashMap();
    var defaultedLabel = [];
    var defaultedTooltip = [];
    var userOutputEncode = {};
    each$5(data.dimensions, function(dimName) {
      var dimItem = data.getDimensionInfo(dimName);
      var coordDim = dimItem.coordDim;
      if (coordDim) {
        if (define_process_env_default$i.NODE_ENV !== "production") {
          assert(VISUAL_DIMENSIONS.get(coordDim) == null);
        }
        var coordDimIndex = dimItem.coordDimIndex;
        getOrCreateEncodeArr(encode2, coordDim)[coordDimIndex] = dimName;
        if (!dimItem.isExtraCoord) {
          notExtraCoordDimMap.set(coordDim, 1);
          if (mayLabelDimType(dimItem.type)) {
            defaultedLabel[0] = dimName;
          }
          getOrCreateEncodeArr(userOutputEncode, coordDim)[coordDimIndex] = data.getDimensionIndex(dimItem.name);
        }
        if (dimItem.defaultTooltip) {
          defaultedTooltip.push(dimName);
        }
      }
      VISUAL_DIMENSIONS.each(function(v, otherDim) {
        var encodeArr = getOrCreateEncodeArr(encode2, otherDim);
        var dimIndex = dimItem.otherDims[otherDim];
        if (dimIndex != null && dimIndex !== false) {
          encodeArr[dimIndex] = dimItem.name;
        }
      });
    });
    var dataDimsOnCoord = [];
    var encodeFirstDimNotExtra = {};
    notExtraCoordDimMap.each(function(v, coordDim) {
      var dimArr = encode2[coordDim];
      encodeFirstDimNotExtra[coordDim] = dimArr[0];
      dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);
    });
    summary.dataDimsOnCoord = dataDimsOnCoord;
    summary.dataDimIndicesOnCoord = map$1(dataDimsOnCoord, function(dimName) {
      return data.getDimensionInfo(dimName).storeDimIndex;
    });
    summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;
    var encodeLabel = encode2.label;
    if (encodeLabel && encodeLabel.length) {
      defaultedLabel = encodeLabel.slice();
    }
    var encodeTooltip = encode2.tooltip;
    if (encodeTooltip && encodeTooltip.length) {
      defaultedTooltip = encodeTooltip.slice();
    } else if (!defaultedTooltip.length) {
      defaultedTooltip = defaultedLabel.slice();
    }
    encode2.defaultedLabel = defaultedLabel;
    encode2.defaultedTooltip = defaultedTooltip;
    summary.userOutput = new DimensionUserOuput(userOutputEncode, schema);
    return summary;
  }
  function getOrCreateEncodeArr(encode2, dim) {
    if (!encode2.hasOwnProperty(dim)) {
      encode2[dim] = [];
    }
    return encode2[dim];
  }
  function getDimensionTypeByAxis(axisType) {
    return axisType === "category" ? "ordinal" : axisType === "time" ? "time" : "float";
  }
  function mayLabelDimType(dimType) {
    return !(dimType === "ordinal" || dimType === "time");
  }
  var SeriesDimensionDefine = (
    /** @class */
    /* @__PURE__ */ function() {
      function SeriesDimensionDefine2(opt) {
        this.otherDims = {};
        if (opt != null) {
          extend(this, opt);
        }
      }
      return SeriesDimensionDefine2;
    }()
  );
  var inner$6 = makeInner();
  var dimTypeShort = {
    float: "f",
    int: "i",
    ordinal: "o",
    number: "n",
    time: "t"
  };
  var SeriesDataSchema = (
    /** @class */
    function() {
      function SeriesDataSchema2(opt) {
        this.dimensions = opt.dimensions;
        this._dimOmitted = opt.dimensionOmitted;
        this.source = opt.source;
        this._fullDimCount = opt.fullDimensionCount;
        this._updateDimOmitted(opt.dimensionOmitted);
      }
      SeriesDataSchema2.prototype.isDimensionOmitted = function() {
        return this._dimOmitted;
      };
      SeriesDataSchema2.prototype._updateDimOmitted = function(dimensionOmitted) {
        this._dimOmitted = dimensionOmitted;
        if (!dimensionOmitted) {
          return;
        }
        if (!this._dimNameMap) {
          this._dimNameMap = ensureSourceDimNameMap(this.source);
        }
      };
      SeriesDataSchema2.prototype.getSourceDimensionIndex = function(dimName) {
        return retrieve2(this._dimNameMap.get(dimName), -1);
      };
      SeriesDataSchema2.prototype.getSourceDimension = function(dimIndex) {
        var dimensionsDefine = this.source.dimensionsDefine;
        if (dimensionsDefine) {
          return dimensionsDefine[dimIndex];
        }
      };
      SeriesDataSchema2.prototype.makeStoreSchema = function() {
        var dimCount = this._fullDimCount;
        var willRetrieveDataByName = shouldRetrieveDataByName(this.source);
        var makeHashStrict = !shouldOmitUnusedDimensions(dimCount);
        var dimHash = "";
        var dims = [];
        for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < dimCount; fullDimIdx++) {
          var property = void 0;
          var type = void 0;
          var ordinalMeta = void 0;
          var seriesDimDef = this.dimensions[seriesDimIdx];
          if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
            property = willRetrieveDataByName ? seriesDimDef.name : null;
            type = seriesDimDef.type;
            ordinalMeta = seriesDimDef.ordinalMeta;
            seriesDimIdx++;
          } else {
            var sourceDimDef = this.getSourceDimension(fullDimIdx);
            if (sourceDimDef) {
              property = willRetrieveDataByName ? sourceDimDef.name : null;
              type = sourceDimDef.type;
            }
          }
          dims.push({
            property,
            type,
            ordinalMeta
          });
          if (willRetrieveDataByName && property != null && (!seriesDimDef || !seriesDimDef.isCalculationCoord)) {
            dimHash += makeHashStrict ? property.replace(/\`/g, "`1").replace(/\$/g, "`2") : property;
          }
          dimHash += "$";
          dimHash += dimTypeShort[type] || "f";
          if (ordinalMeta) {
            dimHash += ordinalMeta.uid;
          }
          dimHash += "$";
        }
        var source = this.source;
        var hash = [source.seriesLayoutBy, source.startIndex, dimHash].join("$$");
        return {
          dimensions: dims,
          hash
        };
      };
      SeriesDataSchema2.prototype.makeOutputDimensionNames = function() {
        var result = [];
        for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < this._fullDimCount; fullDimIdx++) {
          var name_1 = void 0;
          var seriesDimDef = this.dimensions[seriesDimIdx];
          if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
            if (!seriesDimDef.isCalculationCoord) {
              name_1 = seriesDimDef.name;
            }
            seriesDimIdx++;
          } else {
            var sourceDimDef = this.getSourceDimension(fullDimIdx);
            if (sourceDimDef) {
              name_1 = sourceDimDef.name;
            }
          }
          result.push(name_1);
        }
        return result;
      };
      SeriesDataSchema2.prototype.appendCalculationDimension = function(dimDef) {
        this.dimensions.push(dimDef);
        dimDef.isCalculationCoord = true;
        this._fullDimCount++;
        this._updateDimOmitted(true);
      };
      return SeriesDataSchema2;
    }()
  );
  function isSeriesDataSchema(schema) {
    return schema instanceof SeriesDataSchema;
  }
  function createDimNameMap(dimsDef) {
    var dataDimNameMap = createHashMap();
    for (var i = 0; i < (dimsDef || []).length; i++) {
      var dimDefItemRaw = dimsDef[i];
      var userDimName = isObject$2(dimDefItemRaw) ? dimDefItemRaw.name : dimDefItemRaw;
      if (userDimName != null && dataDimNameMap.get(userDimName) == null) {
        dataDimNameMap.set(userDimName, i);
      }
    }
    return dataDimNameMap;
  }
  function ensureSourceDimNameMap(source) {
    var innerSource = inner$6(source);
    return innerSource.dimNameMap || (innerSource.dimNameMap = createDimNameMap(source.dimensionsDefine));
  }
  function shouldOmitUnusedDimensions(dimCount) {
    return dimCount > 30;
  }
  var define_process_env_default$h = {};
  var isObject = isObject$2;
  var map = map$1;
  var CtorInt32Array = typeof Int32Array === "undefined" ? Array : Int32Array;
  var ID_PREFIX = "e\0\0";
  var INDEX_NOT_FOUND = -1;
  var TRANSFERABLE_PROPERTIES = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"];
  var CLONE_PROPERTIES = ["_approximateExtent"];
  var prepareInvertedIndex;
  var getId;
  var getIdNameFromStore;
  var normalizeDimensions;
  var transferProperties;
  var cloneListForMapAndSample;
  var makeIdFromName;
  var SeriesData = (
    /** @class */
    function() {
      function SeriesData2(dimensionsInput, hostModel) {
        this.type = "list";
        this._dimOmitted = false;
        this._nameList = [];
        this._idList = [];
        this._visual = {};
        this._layout = {};
        this._itemVisuals = [];
        this._itemLayouts = [];
        this._graphicEls = [];
        this._approximateExtent = {};
        this._calculationInfo = {};
        this.hasItemOption = false;
        this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "minmaxDownSample", "lttbDownSample", "map"];
        this.CHANGABLE_METHODS = ["filterSelf", "selectRange"];
        this.DOWNSAMPLE_METHODS = ["downSample", "minmaxDownSample", "lttbDownSample"];
        var dimensions;
        var assignStoreDimIdx = false;
        if (isSeriesDataSchema(dimensionsInput)) {
          dimensions = dimensionsInput.dimensions;
          this._dimOmitted = dimensionsInput.isDimensionOmitted();
          this._schema = dimensionsInput;
        } else {
          assignStoreDimIdx = true;
          dimensions = dimensionsInput;
        }
        dimensions = dimensions || ["x", "y"];
        var dimensionInfos = {};
        var dimensionNames = [];
        var invertedIndicesMap = {};
        var needsHasOwn = false;
        var emptyObj = {};
        for (var i = 0; i < dimensions.length; i++) {
          var dimInfoInput = dimensions[i];
          var dimensionInfo = isString(dimInfoInput) ? new SeriesDimensionDefine({
            name: dimInfoInput
          }) : !(dimInfoInput instanceof SeriesDimensionDefine) ? new SeriesDimensionDefine(dimInfoInput) : dimInfoInput;
          var dimensionName = dimensionInfo.name;
          dimensionInfo.type = dimensionInfo.type || "float";
          if (!dimensionInfo.coordDim) {
            dimensionInfo.coordDim = dimensionName;
            dimensionInfo.coordDimIndex = 0;
          }
          var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};
          dimensionNames.push(dimensionName);
          dimensionInfos[dimensionName] = dimensionInfo;
          if (emptyObj[dimensionName] != null) {
            needsHasOwn = true;
          }
          if (dimensionInfo.createInvertedIndices) {
            invertedIndicesMap[dimensionName] = [];
          }
          var dimIdx = i;
          if (isNumber(dimensionInfo.storeDimIndex)) {
            dimIdx = dimensionInfo.storeDimIndex;
          }
          if (otherDims.itemName === 0) {
            this._nameDimIdx = dimIdx;
          }
          if (otherDims.itemId === 0) {
            this._idDimIdx = dimIdx;
          }
          if (define_process_env_default$h.NODE_ENV !== "production") {
            assert(assignStoreDimIdx || dimensionInfo.storeDimIndex >= 0);
          }
          if (assignStoreDimIdx) {
            dimensionInfo.storeDimIndex = i;
          }
        }
        this.dimensions = dimensionNames;
        this._dimInfos = dimensionInfos;
        this._initGetDimensionInfo(needsHasOwn);
        this.hostModel = hostModel;
        this._invertedIndicesMap = invertedIndicesMap;
        if (this._dimOmitted) {
          var dimIdxToName_1 = this._dimIdxToName = createHashMap();
          each$5(dimensionNames, function(dimName) {
            dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName);
          });
        }
      }
      SeriesData2.prototype.getDimension = function(dim) {
        var dimIdx = this._recognizeDimIndex(dim);
        if (dimIdx == null) {
          return dim;
        }
        dimIdx = dim;
        if (!this._dimOmitted) {
          return this.dimensions[dimIdx];
        }
        var dimName = this._dimIdxToName.get(dimIdx);
        if (dimName != null) {
          return dimName;
        }
        var sourceDimDef = this._schema.getSourceDimension(dimIdx);
        if (sourceDimDef) {
          return sourceDimDef.name;
        }
      };
      SeriesData2.prototype.getDimensionIndex = function(dim) {
        var dimIdx = this._recognizeDimIndex(dim);
        if (dimIdx != null) {
          return dimIdx;
        }
        if (dim == null) {
          return -1;
        }
        var dimInfo = this._getDimInfo(dim);
        return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;
      };
      SeriesData2.prototype._recognizeDimIndex = function(dim) {
        if (isNumber(dim) || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {
          return +dim;
        }
      };
      SeriesData2.prototype._getStoreDimIndex = function(dim) {
        var dimIdx = this.getDimensionIndex(dim);
        if (define_process_env_default$h.NODE_ENV !== "production") {
          if (dimIdx == null) {
            throw new Error("Unknown dimension " + dim);
          }
        }
        return dimIdx;
      };
      SeriesData2.prototype.getDimensionInfo = function(dim) {
        return this._getDimInfo(this.getDimension(dim));
      };
      SeriesData2.prototype._initGetDimensionInfo = function(needsHasOwn) {
        var dimensionInfos = this._dimInfos;
        this._getDimInfo = needsHasOwn ? function(dimName) {
          return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : void 0;
        } : function(dimName) {
          return dimensionInfos[dimName];
        };
      };
      SeriesData2.prototype.getDimensionsOnCoord = function() {
        return this._dimSummary.dataDimsOnCoord.slice();
      };
      SeriesData2.prototype.mapDimension = function(coordDim, idx) {
        var dimensionsSummary = this._dimSummary;
        if (idx == null) {
          return dimensionsSummary.encodeFirstDimNotExtra[coordDim];
        }
        var dims = dimensionsSummary.encode[coordDim];
        return dims ? dims[idx] : null;
      };
      SeriesData2.prototype.mapDimensionsAll = function(coordDim) {
        var dimensionsSummary = this._dimSummary;
        var dims = dimensionsSummary.encode[coordDim];
        return (dims || []).slice();
      };
      SeriesData2.prototype.getStore = function() {
        return this._store;
      };
      SeriesData2.prototype.initData = function(data, nameList, dimValueGetter) {
        var _this = this;
        var store;
        if (data instanceof DataStore) {
          store = data;
        }
        if (!store) {
          var dimensions = this.dimensions;
          var provider = isSourceInstance(data) || isArrayLike(data) ? new DefaultDataProvider(data, dimensions.length) : data;
          store = new DataStore();
          var dimensionInfos = map(dimensions, function(dimName) {
            return {
              type: _this._dimInfos[dimName].type,
              property: dimName
            };
          });
          store.initData(provider, dimensionInfos, dimValueGetter);
        }
        this._store = store;
        this._nameList = (nameList || []).slice();
        this._idList = [];
        this._nameRepeatCount = {};
        this._doInit(0, store.count());
        this._dimSummary = summarizeDimensions(this, this._schema);
        this.userOutput = this._dimSummary.userOutput;
      };
      SeriesData2.prototype.appendData = function(data) {
        var range = this._store.appendData(data);
        this._doInit(range[0], range[1]);
      };
      SeriesData2.prototype.appendValues = function(values, names) {
        var _a2 = this._store.appendValues(values, names && names.length), start2 = _a2.start, end2 = _a2.end;
        var shouldMakeIdFromName = this._shouldMakeIdFromName();
        this._updateOrdinalMeta();
        if (names) {
          for (var idx = start2; idx < end2; idx++) {
            var sourceIdx = idx - start2;
            this._nameList[idx] = names[sourceIdx];
            if (shouldMakeIdFromName) {
              makeIdFromName(this, idx);
            }
          }
        }
      };
      SeriesData2.prototype._updateOrdinalMeta = function() {
        var store = this._store;
        var dimensions = this.dimensions;
        for (var i = 0; i < dimensions.length; i++) {
          var dimInfo = this._dimInfos[dimensions[i]];
          if (dimInfo.ordinalMeta) {
            store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);
          }
        }
      };
      SeriesData2.prototype._shouldMakeIdFromName = function() {
        var provider = this._store.getProvider();
        return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;
      };
      SeriesData2.prototype._doInit = function(start2, end2) {
        if (start2 >= end2) {
          return;
        }
        var store = this._store;
        var provider = store.getProvider();
        this._updateOrdinalMeta();
        var nameList = this._nameList;
        var idList = this._idList;
        var sourceFormat = provider.getSource().sourceFormat;
        var isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL;
        if (isFormatOriginal && !provider.pure) {
          var sharedDataItem = [];
          for (var idx = start2; idx < end2; idx++) {
            var dataItem = provider.getItem(idx, sharedDataItem);
            if (!this.hasItemOption && isDataItemOption(dataItem)) {
              this.hasItemOption = true;
            }
            if (dataItem) {
              var itemName = dataItem.name;
              if (nameList[idx] == null && itemName != null) {
                nameList[idx] = convertOptionIdName(itemName, null);
              }
              var itemId = dataItem.id;
              if (idList[idx] == null && itemId != null) {
                idList[idx] = convertOptionIdName(itemId, null);
              }
            }
          }
        }
        if (this._shouldMakeIdFromName()) {
          for (var idx = start2; idx < end2; idx++) {
            makeIdFromName(this, idx);
          }
        }
        prepareInvertedIndex(this);
      };
      SeriesData2.prototype.getApproximateExtent = function(dim) {
        return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));
      };
      SeriesData2.prototype.setApproximateExtent = function(extent, dim) {
        dim = this.getDimension(dim);
        this._approximateExtent[dim] = extent.slice();
      };
      SeriesData2.prototype.getCalculationInfo = function(key2) {
        return this._calculationInfo[key2];
      };
      SeriesData2.prototype.setCalculationInfo = function(key2, value) {
        isObject(key2) ? extend(this._calculationInfo, key2) : this._calculationInfo[key2] = value;
      };
      SeriesData2.prototype.getName = function(idx) {
        var rawIndex = this.getRawIndex(idx);
        var name = this._nameList[rawIndex];
        if (name == null && this._nameDimIdx != null) {
          name = getIdNameFromStore(this, this._nameDimIdx, rawIndex);
        }
        if (name == null) {
          name = "";
        }
        return name;
      };
      SeriesData2.prototype._getCategory = function(dimIdx, idx) {
        var ordinal = this._store.get(dimIdx, idx);
        var ordinalMeta = this._store.getOrdinalMeta(dimIdx);
        if (ordinalMeta) {
          return ordinalMeta.categories[ordinal];
        }
        return ordinal;
      };
      SeriesData2.prototype.getId = function(idx) {
        return getId(this, this.getRawIndex(idx));
      };
      SeriesData2.prototype.count = function() {
        return this._store.count();
      };
      SeriesData2.prototype.get = function(dim, idx) {
        var store = this._store;
        var dimInfo = this._dimInfos[dim];
        if (dimInfo) {
          return store.get(dimInfo.storeDimIndex, idx);
        }
      };
      SeriesData2.prototype.getByRawIndex = function(dim, rawIdx) {
        var store = this._store;
        var dimInfo = this._dimInfos[dim];
        if (dimInfo) {
          return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);
        }
      };
      SeriesData2.prototype.getIndices = function() {
        return this._store.getIndices();
      };
      SeriesData2.prototype.getDataExtent = function(dim) {
        return this._store.getDataExtent(this._getStoreDimIndex(dim));
      };
      SeriesData2.prototype.getSum = function(dim) {
        return this._store.getSum(this._getStoreDimIndex(dim));
      };
      SeriesData2.prototype.getMedian = function(dim) {
        return this._store.getMedian(this._getStoreDimIndex(dim));
      };
      SeriesData2.prototype.getValues = function(dimensions, idx) {
        var _this = this;
        var store = this._store;
        return isArray(dimensions) ? store.getValues(map(dimensions, function(dim) {
          return _this._getStoreDimIndex(dim);
        }), idx) : store.getValues(dimensions);
      };
      SeriesData2.prototype.hasValue = function(idx) {
        var dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;
        for (var i = 0, len2 = dataDimIndicesOnCoord.length; i < len2; i++) {
          if (isNaN(this._store.get(dataDimIndicesOnCoord[i], idx))) {
            return false;
          }
        }
        return true;
      };
      SeriesData2.prototype.indexOfName = function(name) {
        for (var i = 0, len2 = this._store.count(); i < len2; i++) {
          if (this.getName(i) === name) {
            return i;
          }
        }
        return -1;
      };
      SeriesData2.prototype.getRawIndex = function(idx) {
        return this._store.getRawIndex(idx);
      };
      SeriesData2.prototype.indexOfRawIndex = function(rawIndex) {
        return this._store.indexOfRawIndex(rawIndex);
      };
      SeriesData2.prototype.rawIndexOf = function(dim, value) {
        var invertedIndices = dim && this._invertedIndicesMap[dim];
        if (define_process_env_default$h.NODE_ENV !== "production") {
          if (!invertedIndices) {
            throw new Error("Do not supported yet");
          }
        }
        var rawIndex = invertedIndices && invertedIndices[value];
        if (rawIndex == null || isNaN(rawIndex)) {
          return INDEX_NOT_FOUND;
        }
        return rawIndex;
      };
      SeriesData2.prototype.each = function(dims, cb, ctx) {
        if (isFunction(dims)) {
          ctx = cb;
          cb = dims;
          dims = [];
        }
        var fCtx = ctx || this;
        var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);
        this._store.each(dimIndices, fCtx ? bind$1(cb, fCtx) : cb);
      };
      SeriesData2.prototype.filterSelf = function(dims, cb, ctx) {
        if (isFunction(dims)) {
          ctx = cb;
          cb = dims;
          dims = [];
        }
        var fCtx = ctx || this;
        var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);
        this._store = this._store.filter(dimIndices, fCtx ? bind$1(cb, fCtx) : cb);
        return this;
      };
      SeriesData2.prototype.selectRange = function(range) {
        var _this = this;
        var innerRange = {};
        var dims = keys(range);
        each$5(dims, function(dim) {
          var dimIdx = _this._getStoreDimIndex(dim);
          innerRange[dimIdx] = range[dim];
        });
        this._store = this._store.selectRange(innerRange);
        return this;
      };
      SeriesData2.prototype.mapArray = function(dims, cb, ctx) {
        if (isFunction(dims)) {
          ctx = cb;
          cb = dims;
          dims = [];
        }
        ctx = ctx || this;
        var result = [];
        this.each(dims, function() {
          result.push(cb && cb.apply(this, arguments));
        }, ctx);
        return result;
      };
      SeriesData2.prototype.map = function(dims, cb, ctx, ctxCompat) {
        var fCtx = ctx || ctxCompat || this;
        var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);
        var list = cloneListForMapAndSample(this);
        list._store = this._store.map(dimIndices, fCtx ? bind$1(cb, fCtx) : cb);
        return list;
      };
      SeriesData2.prototype.modify = function(dims, cb, ctx, ctxCompat) {
        var _this = this;
        var fCtx = ctx || ctxCompat || this;
        if (define_process_env_default$h.NODE_ENV !== "production") {
          each$5(normalizeDimensions(dims), function(dim) {
            var dimInfo = _this.getDimensionInfo(dim);
            if (!dimInfo.isCalculationCoord) {
              console.error("Danger: only stack dimension can be modified");
            }
          });
        }
        var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);
        this._store.modify(dimIndices, fCtx ? bind$1(cb, fCtx) : cb);
      };
      SeriesData2.prototype.downSample = function(dimension, rate, sampleValue, sampleIndex) {
        var list = cloneListForMapAndSample(this);
        list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);
        return list;
      };
      SeriesData2.prototype.minmaxDownSample = function(valueDimension, rate) {
        var list = cloneListForMapAndSample(this);
        list._store = this._store.minmaxDownSample(this._getStoreDimIndex(valueDimension), rate);
        return list;
      };
      SeriesData2.prototype.lttbDownSample = function(valueDimension, rate) {
        var list = cloneListForMapAndSample(this);
        list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);
        return list;
      };
      SeriesData2.prototype.getRawDataItem = function(idx) {
        return this._store.getRawDataItem(idx);
      };
      SeriesData2.prototype.getItemModel = function(idx) {
        var hostModel = this.hostModel;
        var dataItem = this.getRawDataItem(idx);
        return new Model(dataItem, hostModel, hostModel && hostModel.ecModel);
      };
      SeriesData2.prototype.diff = function(otherList) {
        var thisList = this;
        return new DataDiffer(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function(idx) {
          return getId(otherList, idx);
        }, function(idx) {
          return getId(thisList, idx);
        });
      };
      SeriesData2.prototype.getVisual = function(key2) {
        var visual = this._visual;
        return visual && visual[key2];
      };
      SeriesData2.prototype.setVisual = function(kvObj, val) {
        this._visual = this._visual || {};
        if (isObject(kvObj)) {
          extend(this._visual, kvObj);
        } else {
          this._visual[kvObj] = val;
        }
      };
      SeriesData2.prototype.getItemVisual = function(idx, key2) {
        var itemVisual = this._itemVisuals[idx];
        var val = itemVisual && itemVisual[key2];
        if (val == null) {
          return this.getVisual(key2);
        }
        return val;
      };
      SeriesData2.prototype.hasItemVisual = function() {
        return this._itemVisuals.length > 0;
      };
      SeriesData2.prototype.ensureUniqueItemVisual = function(idx, key2) {
        var itemVisuals = this._itemVisuals;
        var itemVisual = itemVisuals[idx];
        if (!itemVisual) {
          itemVisual = itemVisuals[idx] = {};
        }
        var val = itemVisual[key2];
        if (val == null) {
          val = this.getVisual(key2);
          if (isArray(val)) {
            val = val.slice();
          } else if (isObject(val)) {
            val = extend({}, val);
          }
          itemVisual[key2] = val;
        }
        return val;
      };
      SeriesData2.prototype.setItemVisual = function(idx, key2, value) {
        var itemVisual = this._itemVisuals[idx] || {};
        this._itemVisuals[idx] = itemVisual;
        if (isObject(key2)) {
          extend(itemVisual, key2);
        } else {
          itemVisual[key2] = value;
        }
      };
      SeriesData2.prototype.clearAllVisual = function() {
        this._visual = {};
        this._itemVisuals = [];
      };
      SeriesData2.prototype.setLayout = function(key2, val) {
        isObject(key2) ? extend(this._layout, key2) : this._layout[key2] = val;
      };
      SeriesData2.prototype.getLayout = function(key2) {
        return this._layout[key2];
      };
      SeriesData2.prototype.getItemLayout = function(idx) {
        return this._itemLayouts[idx];
      };
      SeriesData2.prototype.setItemLayout = function(idx, layout2, merge2) {
        this._itemLayouts[idx] = merge2 ? extend(this._itemLayouts[idx] || {}, layout2) : layout2;
      };
      SeriesData2.prototype.clearItemLayouts = function() {
        this._itemLayouts.length = 0;
      };
      SeriesData2.prototype.setItemGraphicEl = function(idx, el) {
        var seriesIndex = this.hostModel && this.hostModel.seriesIndex;
        setCommonECData(seriesIndex, this.dataType, idx, el);
        this._graphicEls[idx] = el;
      };
      SeriesData2.prototype.getItemGraphicEl = function(idx) {
        return this._graphicEls[idx];
      };
      SeriesData2.prototype.eachItemGraphicEl = function(cb, context) {
        each$5(this._graphicEls, function(el, idx) {
          if (el) {
            cb && cb.call(context, el, idx);
          }
        });
      };
      SeriesData2.prototype.cloneShallow = function(list) {
        if (!list) {
          list = new SeriesData2(this._schema ? this._schema : map(this.dimensions, this._getDimInfo, this), this.hostModel);
        }
        transferProperties(list, this);
        list._store = this._store;
        return list;
      };
      SeriesData2.prototype.wrapMethod = function(methodName, injectFunction) {
        var originalMethod = this[methodName];
        if (!isFunction(originalMethod)) {
          return;
        }
        this.__wrappedMethods = this.__wrappedMethods || [];
        this.__wrappedMethods.push(methodName);
        this[methodName] = function() {
          var res = originalMethod.apply(this, arguments);
          return injectFunction.apply(this, [res].concat(slice(arguments)));
        };
      };
      SeriesData2.internalField = function() {
        prepareInvertedIndex = function(data) {
          var invertedIndicesMap = data._invertedIndicesMap;
          each$5(invertedIndicesMap, function(invertedIndices, dim) {
            var dimInfo = data._dimInfos[dim];
            var ordinalMeta = dimInfo.ordinalMeta;
            var store = data._store;
            if (ordinalMeta) {
              invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length);
              for (var i = 0; i < invertedIndices.length; i++) {
                invertedIndices[i] = INDEX_NOT_FOUND;
              }
              for (var i = 0; i < store.count(); i++) {
                invertedIndices[store.get(dimInfo.storeDimIndex, i)] = i;
              }
            }
          });
        };
        getIdNameFromStore = function(data, dimIdx, idx) {
          return convertOptionIdName(data._getCategory(dimIdx, idx), null);
        };
        getId = function(data, rawIndex) {
          var id = data._idList[rawIndex];
          if (id == null && data._idDimIdx != null) {
            id = getIdNameFromStore(data, data._idDimIdx, rawIndex);
          }
          if (id == null) {
            id = ID_PREFIX + rawIndex;
          }
          return id;
        };
        normalizeDimensions = function(dimensions) {
          if (!isArray(dimensions)) {
            dimensions = dimensions != null ? [dimensions] : [];
          }
          return dimensions;
        };
        cloneListForMapAndSample = function(original) {
          var list = new SeriesData2(original._schema ? original._schema : map(original.dimensions, original._getDimInfo, original), original.hostModel);
          transferProperties(list, original);
          return list;
        };
        transferProperties = function(target, source) {
          each$5(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function(propName) {
            if (source.hasOwnProperty(propName)) {
              target[propName] = source[propName];
            }
          });
          target.__wrappedMethods = source.__wrappedMethods;
          each$5(CLONE_PROPERTIES, function(propName) {
            target[propName] = clone$2(source[propName]);
          });
          target._calculationInfo = extend({}, source._calculationInfo);
        };
        makeIdFromName = function(data, idx) {
          var nameList = data._nameList;
          var idList = data._idList;
          var nameDimIdx = data._nameDimIdx;
          var idDimIdx = data._idDimIdx;
          var name = nameList[idx];
          var id = idList[idx];
          if (name == null && nameDimIdx != null) {
            nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx);
          }
          if (id == null && idDimIdx != null) {
            idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);
          }
          if (id == null && name != null) {
            var nameRepeatCount = data._nameRepeatCount;
            var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;
            id = name;
            if (nmCnt > 1) {
              id += "__ec__" + nmCnt;
            }
            idList[idx] = id;
          }
        };
      }();
      return SeriesData2;
    }()
  );
  function prepareSeriesDataSchema(source, opt) {
    if (!isSourceInstance(source)) {
      source = createSourceFromSeriesDataOption(source);
    }
    opt = opt || {};
    var sysDims = opt.coordDimensions || [];
    var dimsDef = opt.dimensionsDefine || source.dimensionsDefine || [];
    var coordDimNameMap = createHashMap();
    var resultList = [];
    var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimensionsCount);
    var omitUnusedDimensions = opt.canOmitUnusedDimensions && shouldOmitUnusedDimensions(dimCount);
    var isUsingSourceDimensionsDef = dimsDef === source.dimensionsDefine;
    var dataDimNameMap = isUsingSourceDimensionsDef ? ensureSourceDimNameMap(source) : createDimNameMap(dimsDef);
    var encodeDef = opt.encodeDefine;
    if (!encodeDef && opt.encodeDefaulter) {
      encodeDef = opt.encodeDefaulter(source, dimCount);
    }
    var encodeDefMap = createHashMap(encodeDef);
    var indicesMap = new CtorInt32Array$1(dimCount);
    for (var i = 0; i < indicesMap.length; i++) {
      indicesMap[i] = -1;
    }
    function getResultItem(dimIdx) {
      var idx = indicesMap[dimIdx];
      if (idx < 0) {
        var dimDefItemRaw = dimsDef[dimIdx];
        var dimDefItem = isObject$2(dimDefItemRaw) ? dimDefItemRaw : {
          name: dimDefItemRaw
        };
        var resultItem2 = new SeriesDimensionDefine();
        var userDimName = dimDefItem.name;
        if (userDimName != null && dataDimNameMap.get(userDimName) != null) {
          resultItem2.name = resultItem2.displayName = userDimName;
        }
        dimDefItem.type != null && (resultItem2.type = dimDefItem.type);
        dimDefItem.displayName != null && (resultItem2.displayName = dimDefItem.displayName);
        var newIdx = resultList.length;
        indicesMap[dimIdx] = newIdx;
        resultItem2.storeDimIndex = dimIdx;
        resultList.push(resultItem2);
        return resultItem2;
      }
      return resultList[idx];
    }
    if (!omitUnusedDimensions) {
      for (var i = 0; i < dimCount; i++) {
        getResultItem(i);
      }
    }
    encodeDefMap.each(function(dataDimsRaw, coordDim2) {
      var dataDims = normalizeToArray(dataDimsRaw).slice();
      if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {
        encodeDefMap.set(coordDim2, false);
        return;
      }
      var validDataDims = encodeDefMap.set(coordDim2, []);
      each$5(dataDims, function(resultDimIdxOrName, idx) {
        var resultDimIdx2 = isString(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;
        if (resultDimIdx2 != null && resultDimIdx2 < dimCount) {
          validDataDims[idx] = resultDimIdx2;
          applyDim(getResultItem(resultDimIdx2), coordDim2, idx);
        }
      });
    });
    var availDimIdx = 0;
    each$5(sysDims, function(sysDimItemRaw) {
      var coordDim2;
      var sysDimItemDimsDef;
      var sysDimItemOtherDims;
      var sysDimItem;
      if (isString(sysDimItemRaw)) {
        coordDim2 = sysDimItemRaw;
        sysDimItem = {};
      } else {
        sysDimItem = sysDimItemRaw;
        coordDim2 = sysDimItem.name;
        var ordinalMeta = sysDimItem.ordinalMeta;
        sysDimItem.ordinalMeta = null;
        sysDimItem = extend({}, sysDimItem);
        sysDimItem.ordinalMeta = ordinalMeta;
        sysDimItemDimsDef = sysDimItem.dimsDef;
        sysDimItemOtherDims = sysDimItem.otherDims;
        sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
      }
      var dataDims = encodeDefMap.get(coordDim2);
      if (dataDims === false) {
        return;
      }
      dataDims = normalizeToArray(dataDims);
      if (!dataDims.length) {
        for (var i2 = 0; i2 < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i2++) {
          while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) {
            availDimIdx++;
          }
          availDimIdx < dimCount && dataDims.push(availDimIdx++);
        }
      }
      each$5(dataDims, function(resultDimIdx2, coordDimIndex) {
        var resultItem2 = getResultItem(resultDimIdx2);
        if (isUsingSourceDimensionsDef && sysDimItem.type != null) {
          resultItem2.type = sysDimItem.type;
        }
        applyDim(defaults(resultItem2, sysDimItem), coordDim2, coordDimIndex);
        if (resultItem2.name == null && sysDimItemDimsDef) {
          var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];
          !isObject$2(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {
            name: sysDimItemDimsDefItem
          });
          resultItem2.name = resultItem2.displayName = sysDimItemDimsDefItem.name;
          resultItem2.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;
        }
        sysDimItemOtherDims && defaults(resultItem2.otherDims, sysDimItemOtherDims);
      });
    });
    function applyDim(resultItem2, coordDim2, coordDimIndex) {
      if (VISUAL_DIMENSIONS.get(coordDim2) != null) {
        resultItem2.otherDims[coordDim2] = coordDimIndex;
      } else {
        resultItem2.coordDim = coordDim2;
        resultItem2.coordDimIndex = coordDimIndex;
        coordDimNameMap.set(coordDim2, true);
      }
    }
    var generateCoord = opt.generateCoord;
    var generateCoordCount = opt.generateCoordCount;
    var fromZero = generateCoordCount != null;
    generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;
    var extra = generateCoord || "value";
    function ifNoNameFillWithCoordName(resultItem2) {
      if (resultItem2.name == null) {
        resultItem2.name = resultItem2.coordDim;
      }
    }
    if (!omitUnusedDimensions) {
      for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {
        var resultItem = getResultItem(resultDimIdx);
        var coordDim = resultItem.coordDim;
        if (coordDim == null) {
          resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero);
          resultItem.coordDimIndex = 0;
          if (!generateCoord || generateCoordCount <= 0) {
            resultItem.isExtraCoord = true;
          }
          generateCoordCount--;
        }
        ifNoNameFillWithCoordName(resultItem);
        if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {
          resultItem.type = "ordinal";
        }
      }
    } else {
      each$5(resultList, function(resultItem2) {
        ifNoNameFillWithCoordName(resultItem2);
      });
      resultList.sort(function(item0, item1) {
        return item0.storeDimIndex - item1.storeDimIndex;
      });
    }
    removeDuplication(resultList);
    return new SeriesDataSchema({
      source,
      dimensions: resultList,
      fullDimensionCount: dimCount,
      dimensionOmitted: omitUnusedDimensions
    });
  }
  function removeDuplication(result) {
    var duplicationMap = createHashMap();
    for (var i = 0; i < result.length; i++) {
      var dim = result[i];
      var dimOriginalName = dim.name;
      var count = duplicationMap.get(dimOriginalName) || 0;
      if (count > 0) {
        dim.name = dimOriginalName + (count - 1);
      }
      count++;
      duplicationMap.set(dimOriginalName, count);
    }
  }
  function getDimCount(source, sysDims, dimsDef, optDimCount) {
    var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);
    each$5(sysDims, function(sysDimItem) {
      var sysDimItemDimsDef;
      if (isObject$2(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {
        dimCount = Math.max(dimCount, sysDimItemDimsDef.length);
      }
    });
    return dimCount;
  }
  function genCoordDimName(name, map2, fromZero) {
    if (fromZero || map2.hasKey(name)) {
      var i = 0;
      while (map2.hasKey(name + i)) {
        i++;
      }
      name += i;
    }
    map2.set(name, true);
    return name;
  }
  var define_process_env_default$g = {};
  var CoordSysInfo = (
    /** @class */
    /* @__PURE__ */ function() {
      function CoordSysInfo2(coordSysName) {
        this.coordSysDims = [];
        this.axisMap = createHashMap();
        this.categoryAxisMap = createHashMap();
        this.coordSysName = coordSysName;
      }
      return CoordSysInfo2;
    }()
  );
  function getCoordSysInfoBySeries(seriesModel) {
    var coordSysName = seriesModel.get("coordinateSystem");
    var result = new CoordSysInfo(coordSysName);
    var fetch2 = fetchers[coordSysName];
    if (fetch2) {
      fetch2(seriesModel, result, result.axisMap, result.categoryAxisMap);
      return result;
    }
  }
  var fetchers = {
    cartesian2d: function(seriesModel, result, axisMap, categoryAxisMap) {
      var xAxisModel = seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
      var yAxisModel = seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
      if (define_process_env_default$g.NODE_ENV !== "production") {
        if (!xAxisModel) {
          throw new Error('xAxis "' + retrieve(seriesModel.get("xAxisIndex"), seriesModel.get("xAxisId"), 0) + '" not found');
        }
        if (!yAxisModel) {
          throw new Error('yAxis "' + retrieve(seriesModel.get("xAxisIndex"), seriesModel.get("yAxisId"), 0) + '" not found');
        }
      }
      result.coordSysDims = ["x", "y"];
      axisMap.set("x", xAxisModel);
      axisMap.set("y", yAxisModel);
      if (isCategory(xAxisModel)) {
        categoryAxisMap.set("x", xAxisModel);
        result.firstCategoryDimIndex = 0;
      }
      if (isCategory(yAxisModel)) {
        categoryAxisMap.set("y", yAxisModel);
        result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
      }
    },
    singleAxis: function(seriesModel, result, axisMap, categoryAxisMap) {
      var singleAxisModel = seriesModel.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
      if (define_process_env_default$g.NODE_ENV !== "production") {
        if (!singleAxisModel) {
          throw new Error("singleAxis should be specified.");
        }
      }
      result.coordSysDims = ["single"];
      axisMap.set("single", singleAxisModel);
      if (isCategory(singleAxisModel)) {
        categoryAxisMap.set("single", singleAxisModel);
        result.firstCategoryDimIndex = 0;
      }
    },
    polar: function(seriesModel, result, axisMap, categoryAxisMap) {
      var polarModel = seriesModel.getReferringComponents("polar", SINGLE_REFERRING).models[0];
      var radiusAxisModel = polarModel.findAxisModel("radiusAxis");
      var angleAxisModel = polarModel.findAxisModel("angleAxis");
      if (define_process_env_default$g.NODE_ENV !== "production") {
        if (!angleAxisModel) {
          throw new Error("angleAxis option not found");
        }
        if (!radiusAxisModel) {
          throw new Error("radiusAxis option not found");
        }
      }
      result.coordSysDims = ["radius", "angle"];
      axisMap.set("radius", radiusAxisModel);
      axisMap.set("angle", angleAxisModel);
      if (isCategory(radiusAxisModel)) {
        categoryAxisMap.set("radius", radiusAxisModel);
        result.firstCategoryDimIndex = 0;
      }
      if (isCategory(angleAxisModel)) {
        categoryAxisMap.set("angle", angleAxisModel);
        result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
      }
    },
    geo: function(seriesModel, result, axisMap, categoryAxisMap) {
      result.coordSysDims = ["lng", "lat"];
    },
    parallel: function(seriesModel, result, axisMap, categoryAxisMap) {
      var ecModel = seriesModel.ecModel;
      var parallelModel = ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
      var coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();
      each$5(parallelModel.parallelAxisIndex, function(axisIndex, index2) {
        var axisModel = ecModel.getComponent("parallelAxis", axisIndex);
        var axisDim = coordSysDims[index2];
        axisMap.set(axisDim, axisModel);
        if (isCategory(axisModel)) {
          categoryAxisMap.set(axisDim, axisModel);
          if (result.firstCategoryDimIndex == null) {
            result.firstCategoryDimIndex = index2;
          }
        }
      });
    },
    matrix: function(seriesModel, result, axisMap, categoryAxisMap) {
      var matrixModel = seriesModel.getReferringComponents("matrix", SINGLE_REFERRING).models[0];
      if (define_process_env_default$g.NODE_ENV !== "production") {
        if (!matrixModel) {
          throw new Error("matrix coordinate system should be specified.");
        }
      }
      result.coordSysDims = ["x", "y"];
      var xModel = matrixModel.getDimensionModel("x");
      var yModel = matrixModel.getDimensionModel("y");
      axisMap.set("x", xModel);
      axisMap.set("y", yModel);
      categoryAxisMap.set("x", xModel);
      categoryAxisMap.set("y", yModel);
    }
  };
  function isCategory(axisModel) {
    return axisModel.get("type") === "category";
  }
  function enableDataStack(seriesModel, dimensionsInput, opt) {
    opt = opt || {};
    var byIndex = opt.byIndex;
    var stackedCoordDimension = opt.stackedCoordDimension;
    var dimensionDefineList;
    var schema;
    var store;
    if (isLegacyDimensionsInput(dimensionsInput)) {
      dimensionDefineList = dimensionsInput;
    } else {
      schema = dimensionsInput.schema;
      dimensionDefineList = schema.dimensions;
      store = dimensionsInput.store;
    }
    var mayStack = !!(seriesModel && seriesModel.get("stack"));
    var stackedByDimInfo;
    var stackedDimInfo;
    var stackResultDimension;
    var stackedOverDimension;
    each$5(dimensionDefineList, function(dimensionInfo, index2) {
      if (isString(dimensionInfo)) {
        dimensionDefineList[index2] = dimensionInfo = {
          name: dimensionInfo
        };
      }
      if (mayStack && !dimensionInfo.isExtraCoord) {
        if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {
          stackedByDimInfo = dimensionInfo;
        }
        if (!stackedDimInfo && dimensionInfo.type !== "ordinal" && dimensionInfo.type !== "time" && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {
          stackedDimInfo = dimensionInfo;
        }
      }
    });
    if (stackedDimInfo && !byIndex && !stackedByDimInfo) {
      byIndex = true;
    }
    if (stackedDimInfo) {
      stackResultDimension = "__\0ecstackresult_" + seriesModel.id;
      stackedOverDimension = "__\0ecstackedover_" + seriesModel.id;
      if (stackedByDimInfo) {
        stackedByDimInfo.createInvertedIndices = true;
      }
      var stackedDimCoordDim_1 = stackedDimInfo.coordDim;
      var stackedDimType = stackedDimInfo.type;
      var stackedDimCoordIndex_1 = 0;
      each$5(dimensionDefineList, function(dimensionInfo) {
        if (dimensionInfo.coordDim === stackedDimCoordDim_1) {
          stackedDimCoordIndex_1++;
        }
      });
      var stackedOverDimensionDefine = {
        name: stackResultDimension,
        coordDim: stackedDimCoordDim_1,
        coordDimIndex: stackedDimCoordIndex_1,
        type: stackedDimType,
        isExtraCoord: true,
        isCalculationCoord: true,
        storeDimIndex: dimensionDefineList.length
      };
      var stackResultDimensionDefine = {
        name: stackedOverDimension,
        // This dimension contains stack base (generally, 0), so do not set it as
        // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
        coordDim: stackedOverDimension,
        coordDimIndex: stackedDimCoordIndex_1 + 1,
        type: stackedDimType,
        isExtraCoord: true,
        isCalculationCoord: true,
        storeDimIndex: dimensionDefineList.length + 1
      };
      if (schema) {
        if (store) {
          stackedOverDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackedOverDimension, stackedDimType);
          stackResultDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackResultDimension, stackedDimType);
        }
        schema.appendCalculationDimension(stackedOverDimensionDefine);
        schema.appendCalculationDimension(stackResultDimensionDefine);
      } else {
        dimensionDefineList.push(stackedOverDimensionDefine);
        dimensionDefineList.push(stackResultDimensionDefine);
      }
    }
    return {
      stackedDimension: stackedDimInfo && stackedDimInfo.name,
      stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,
      isStackedByIndex: byIndex,
      stackedOverDimension,
      stackResultDimension
    };
  }
  function isLegacyDimensionsInput(dimensionsInput) {
    return !isSeriesDataSchema(dimensionsInput.schema);
  }
  function isDimensionStacked(data, stackedDim) {
    return !!stackedDim && stackedDim === data.getCalculationInfo("stackedDimension");
  }
  function getStackedDimension(data, targetDim) {
    return isDimensionStacked(data, targetDim) ? data.getCalculationInfo("stackResultDimension") : targetDim;
  }
  function getCoordSysDimDefs(seriesModel, coordSysInfo) {
    var coordSysName = seriesModel.get("coordinateSystem");
    var registeredCoordSys = CoordinateSystemManager.get(coordSysName);
    var coordSysDimDefs;
    if (coordSysInfo && coordSysInfo.coordSysDims) {
      coordSysDimDefs = map$1(coordSysInfo.coordSysDims, function(dim) {
        var dimInfo = {
          name: dim
        };
        var axisModel = coordSysInfo.axisMap.get(dim);
        if (axisModel) {
          var axisType = axisModel.get("type");
          dimInfo.type = getDimensionTypeByAxis(axisType);
        }
        return dimInfo;
      });
    }
    if (!coordSysDimDefs) {
      coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ["x", "y"];
    }
    return coordSysDimDefs;
  }
  function injectOrdinalMeta(dimInfoList, createInvertedIndices, coordSysInfo) {
    var firstCategoryDimIndex;
    var hasNameEncode;
    coordSysInfo && each$5(dimInfoList, function(dimInfo, dimIndex) {
      var coordDim = dimInfo.coordDim;
      var categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);
      if (categoryAxisModel) {
        if (firstCategoryDimIndex == null) {
          firstCategoryDimIndex = dimIndex;
        }
        dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();
        if (createInvertedIndices) {
          dimInfo.createInvertedIndices = true;
        }
      }
      if (dimInfo.otherDims.itemName != null) {
        hasNameEncode = true;
      }
    });
    if (!hasNameEncode && firstCategoryDimIndex != null) {
      dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;
    }
    return firstCategoryDimIndex;
  }
  function createSeriesData(sourceRaw, seriesModel, opt) {
    opt = opt || {};
    var sourceManager = seriesModel.getSourceManager();
    var source;
    var isOriginalSource = false;
    {
      source = sourceManager.getSource();
      isOriginalSource = source.sourceFormat === SOURCE_FORMAT_ORIGINAL;
    }
    var coordSysInfo = getCoordSysInfoBySeries(seriesModel);
    var coordSysDimDefs = getCoordSysDimDefs(seriesModel, coordSysInfo);
    var useEncodeDefaulter = opt.useEncodeDefaulter;
    var encodeDefaulter = isFunction(useEncodeDefaulter) ? useEncodeDefaulter : useEncodeDefaulter ? curry$1(makeSeriesEncodeForAxisCoordSys, coordSysDimDefs, seriesModel) : null;
    var createDimensionOptions = {
      coordDimensions: coordSysDimDefs,
      generateCoord: opt.generateCoord,
      encodeDefine: seriesModel.getEncode(),
      encodeDefaulter,
      canOmitUnusedDimensions: !isOriginalSource
    };
    var schema = prepareSeriesDataSchema(source, createDimensionOptions);
    var firstCategoryDimIndex = injectOrdinalMeta(schema.dimensions, opt.createInvertedIndices, coordSysInfo);
    var store = !isOriginalSource ? sourceManager.getSharedDataStore(schema) : null;
    var stackCalculationInfo = enableDataStack(seriesModel, {
      schema,
      store
    });
    var data = new SeriesData(schema, seriesModel);
    data.setCalculationInfo(stackCalculationInfo);
    var dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function(itemOpt, dimName, dataIndex, dimIndex) {
      return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);
    } : null;
    data.hasItemOption = false;
    data.initData(
      // Try to reuse the data store in sourceManager if using dataset.
      isOriginalSource ? source : store,
      null,
      dimValueGetter
    );
    return data;
  }
  function isNeedCompleteOrdinalData(source) {
    if (source.sourceFormat === SOURCE_FORMAT_ORIGINAL) {
      var sampleItem = firstDataNotNull(source.data || []);
      return !isArray(getDataItemValue(sampleItem));
    }
  }
  function firstDataNotNull(arr) {
    var i = 0;
    while (i < arr.length && arr[i] == null) {
      i++;
    }
    return arr[i];
  }
  function isValueNice(val) {
    var exp10 = Math.pow(10, quantityExponent(Math.abs(val)));
    var f = Math.abs(val / exp10);
    return f === 0 || f === 1 || f === 2 || f === 3 || f === 5;
  }
  function isIntervalOrLogScale(scale2) {
    return scale2.type === "interval" || scale2.type === "log";
  }
  function intervalScaleNiceTicks(extent, spanWithBreaks, splitNumber, minInterval, maxInterval) {
    var result = {};
    var interval = result.interval = nice(spanWithBreaks / splitNumber);
    if (minInterval != null && interval < minInterval) {
      interval = result.interval = minInterval;
    }
    if (maxInterval != null && interval > maxInterval) {
      interval = result.interval = maxInterval;
    }
    var precision = result.intervalPrecision = getIntervalPrecision(interval);
    var niceTickExtent = result.niceTickExtent = [round$1(Math.ceil(extent[0] / interval) * interval, precision), round$1(Math.floor(extent[1] / interval) * interval, precision)];
    fixExtent(niceTickExtent, extent);
    return result;
  }
  function increaseInterval(interval) {
    var exp10 = Math.pow(10, quantityExponent(interval));
    var f = interval / exp10;
    if (!f) {
      f = 1;
    } else if (f === 2) {
      f = 3;
    } else if (f === 3) {
      f = 5;
    } else {
      f *= 2;
    }
    return round$1(f * exp10);
  }
  function getIntervalPrecision(interval) {
    return getPrecision(interval) + 2;
  }
  function clamp(niceTickExtent, idx, extent) {
    niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);
  }
  function fixExtent(niceTickExtent, extent) {
    !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);
    !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);
    clamp(niceTickExtent, 0, extent);
    clamp(niceTickExtent, 1, extent);
    if (niceTickExtent[0] > niceTickExtent[1]) {
      niceTickExtent[0] = niceTickExtent[1];
    }
  }
  function contain(val, extent) {
    return val >= extent[0] && val <= extent[1];
  }
  var ScaleCalculator = (
    /** @class */
    function() {
      function ScaleCalculator2() {
        this.normalize = normalize;
        this.scale = scale;
      }
      ScaleCalculator2.prototype.updateMethods = function(brkCtx) {
        if (brkCtx.hasBreaks()) {
          this.normalize = bind$1(brkCtx.normalize, brkCtx);
          this.scale = bind$1(brkCtx.scale, brkCtx);
        } else {
          this.normalize = normalize;
          this.scale = scale;
        }
      };
      return ScaleCalculator2;
    }()
  );
  function normalize(val, extent) {
    if (extent[1] === extent[0]) {
      return 0.5;
    }
    return (val - extent[0]) / (extent[1] - extent[0]);
  }
  function scale(val, extent) {
    return val * (extent[1] - extent[0]) + extent[0];
  }
  function logTransform(base2, extent, noClampNegative) {
    var loggedBase = Math.log(base2);
    return [
      // log(negative) is NaN, so safe guard here.
      // PENDING: But even getting a -Infinity still does not make sense in extent.
      //  Just keep it as is, getting a NaN to make some previous cases works by coincidence.
      Math.log(noClampNegative ? extent[0] : Math.max(0, extent[0])) / loggedBase,
      Math.log(noClampNegative ? extent[1] : Math.max(0, extent[1])) / loggedBase
    ];
  }
  var Scale = (
    /** @class */
    function() {
      function Scale2(setting) {
        this._calculator = new ScaleCalculator();
        this._setting = setting || {};
        this._extent = [Infinity, -Infinity];
      }
      Scale2.prototype.getSetting = function(name) {
        return this._setting[name];
      };
      Scale2.prototype._innerUnionExtent = function(other) {
        var extent = this._extent;
        this._innerSetExtent(other[0] < extent[0] ? other[0] : extent[0], other[1] > extent[1] ? other[1] : extent[1]);
      };
      Scale2.prototype.unionExtentFromData = function(data, dim) {
        this._innerUnionExtent(data.getApproximateExtent(dim));
      };
      Scale2.prototype.getExtent = function() {
        return this._extent.slice();
      };
      Scale2.prototype.setExtent = function(start2, end2) {
        this._innerSetExtent(start2, end2);
      };
      Scale2.prototype._innerSetExtent = function(start2, end2) {
        var thisExtent = this._extent;
        if (!isNaN(start2)) {
          thisExtent[0] = start2;
        }
        if (!isNaN(end2)) {
          thisExtent[1] = end2;
        }
        this._brkCtx && this._brkCtx.update(thisExtent);
      };
      Scale2.prototype.setBreaksFromOption = function(breakOptionList) {
      };
      Scale2.prototype._innerSetBreak = function(parsed) {
        if (this._brkCtx) {
          this._brkCtx.setBreaks(parsed);
          this._calculator.updateMethods(this._brkCtx);
          this._brkCtx.update(this._extent);
        }
      };
      Scale2.prototype._innerGetBreaks = function() {
        return this._brkCtx ? this._brkCtx.breaks : [];
      };
      Scale2.prototype.hasBreaks = function() {
        return this._brkCtx ? this._brkCtx.hasBreaks() : false;
      };
      Scale2.prototype._getExtentSpanWithBreaks = function() {
        return this._brkCtx && this._brkCtx.hasBreaks() ? this._brkCtx.getExtentSpan() : this._extent[1] - this._extent[0];
      };
      Scale2.prototype.isInExtentRange = function(value) {
        return this._extent[0] <= value && this._extent[1] >= value;
      };
      Scale2.prototype.isBlank = function() {
        return this._isBlank;
      };
      Scale2.prototype.setBlank = function(isBlank) {
        this._isBlank = isBlank;
      };
      return Scale2;
    }()
  );
  enableClassManagement(Scale);
  var uidBase = 0;
  var OrdinalMeta = (
    /** @class */
    function() {
      function OrdinalMeta2(opt) {
        this.categories = opt.categories || [];
        this._needCollect = opt.needCollect;
        this._deduplication = opt.deduplication;
        this.uid = ++uidBase;
        this._onCollect = opt.onCollect;
      }
      OrdinalMeta2.createByAxisModel = function(axisModel) {
        var option = axisModel.option;
        var data = option.data;
        var categories = data && map$1(data, getName);
        return new OrdinalMeta2({
          categories,
          needCollect: !categories,
          // deduplication is default in axis.
          deduplication: option.dedplication !== false
        });
      };
      OrdinalMeta2.prototype.getOrdinal = function(category) {
        return this._getOrCreateMap().get(category);
      };
      OrdinalMeta2.prototype.parseAndCollect = function(category) {
        var index2;
        var needCollect = this._needCollect;
        if (!isString(category) && !needCollect) {
          return category;
        }
        if (needCollect && !this._deduplication) {
          index2 = this.categories.length;
          this.categories[index2] = category;
          this._onCollect && this._onCollect(category, index2);
          return index2;
        }
        var map2 = this._getOrCreateMap();
        index2 = map2.get(category);
        if (index2 == null) {
          if (needCollect) {
            index2 = this.categories.length;
            this.categories[index2] = category;
            map2.set(category, index2);
            this._onCollect && this._onCollect(category, index2);
          } else {
            index2 = NaN;
          }
        }
        return index2;
      };
      OrdinalMeta2.prototype._getOrCreateMap = function() {
        return this._map || (this._map = createHashMap(this.categories));
      };
      return OrdinalMeta2;
    }()
  );
  function getName(obj) {
    if (isObject$2(obj) && obj.value != null) {
      return obj.value;
    } else {
      return obj + "";
    }
  }
  var OrdinalScale = (
    /** @class */
    function(_super) {
      __extends(OrdinalScale2, _super);
      function OrdinalScale2(setting) {
        var _this = _super.call(this, setting) || this;
        _this.type = "ordinal";
        var ordinalMeta = _this.getSetting("ordinalMeta");
        if (!ordinalMeta) {
          ordinalMeta = new OrdinalMeta({});
        }
        if (isArray(ordinalMeta)) {
          ordinalMeta = new OrdinalMeta({
            categories: map$1(ordinalMeta, function(item) {
              return isObject$2(item) ? item.value : item;
            })
          });
        }
        _this._ordinalMeta = ordinalMeta;
        _this._extent = _this.getSetting("extent") || [0, ordinalMeta.categories.length - 1];
        return _this;
      }
      OrdinalScale2.prototype.parse = function(val) {
        if (val == null) {
          return NaN;
        }
        return isString(val) ? this._ordinalMeta.getOrdinal(val) : Math.round(val);
      };
      OrdinalScale2.prototype.contain = function(val) {
        return contain(val, this._extent) && val >= 0 && val < this._ordinalMeta.categories.length;
      };
      OrdinalScale2.prototype.normalize = function(val) {
        val = this._getTickNumber(val);
        return this._calculator.normalize(val, this._extent);
      };
      OrdinalScale2.prototype.scale = function(val) {
        val = Math.round(this._calculator.scale(val, this._extent));
        return this.getRawOrdinalNumber(val);
      };
      OrdinalScale2.prototype.getTicks = function() {
        var ticks = [];
        var extent = this._extent;
        var rank = extent[0];
        while (rank <= extent[1]) {
          ticks.push({
            value: rank
          });
          rank++;
        }
        return ticks;
      };
      OrdinalScale2.prototype.getMinorTicks = function(splitNumber) {
        return;
      };
      OrdinalScale2.prototype.setSortInfo = function(info) {
        if (info == null) {
          this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
          return;
        }
        var infoOrdinalNumbers = info.ordinalNumbers;
        var ordinalsByTick = this._ordinalNumbersByTick = [];
        var ticksByOrdinal = this._ticksByOrdinalNumber = [];
        var tickNum = 0;
        var allCategoryLen = this._ordinalMeta.categories.length;
        for (var len2 = Math.min(allCategoryLen, infoOrdinalNumbers.length); tickNum < len2; ++tickNum) {
          var ordinalNumber = infoOrdinalNumbers[tickNum];
          ordinalsByTick[tickNum] = ordinalNumber;
          ticksByOrdinal[ordinalNumber] = tickNum;
        }
        var unusedOrdinal = 0;
        for (; tickNum < allCategoryLen; ++tickNum) {
          while (ticksByOrdinal[unusedOrdinal] != null) {
            unusedOrdinal++;
          }
          ordinalsByTick.push(unusedOrdinal);
          ticksByOrdinal[unusedOrdinal] = tickNum;
        }
      };
      OrdinalScale2.prototype._getTickNumber = function(ordinal) {
        var ticksByOrdinalNumber = this._ticksByOrdinalNumber;
        return ticksByOrdinalNumber && ordinal >= 0 && ordinal < ticksByOrdinalNumber.length ? ticksByOrdinalNumber[ordinal] : ordinal;
      };
      OrdinalScale2.prototype.getRawOrdinalNumber = function(tickNumber) {
        var ordinalNumbersByTick = this._ordinalNumbersByTick;
        return ordinalNumbersByTick && tickNumber >= 0 && tickNumber < ordinalNumbersByTick.length ? ordinalNumbersByTick[tickNumber] : tickNumber;
      };
      OrdinalScale2.prototype.getLabel = function(tick) {
        if (!this.isBlank()) {
          var ordinalNumber = this.getRawOrdinalNumber(tick.value);
          var cateogry = this._ordinalMeta.categories[ordinalNumber];
          return cateogry == null ? "" : cateogry + "";
        }
      };
      OrdinalScale2.prototype.count = function() {
        return this._extent[1] - this._extent[0] + 1;
      };
      OrdinalScale2.prototype.isInExtentRange = function(value) {
        value = this._getTickNumber(value);
        return this._extent[0] <= value && this._extent[1] >= value;
      };
      OrdinalScale2.prototype.getOrdinalMeta = function() {
        return this._ordinalMeta;
      };
      OrdinalScale2.prototype.calcNiceTicks = function() {
      };
      OrdinalScale2.prototype.calcNiceExtent = function() {
      };
      OrdinalScale2.type = "ordinal";
      return OrdinalScale2;
    }(Scale)
  );
  Scale.registerClass(OrdinalScale);
  var roundNumber = round$1;
  var IntervalScale = (
    /** @class */
    function(_super) {
      __extends(IntervalScale2, _super);
      function IntervalScale2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "interval";
        _this._interval = 0;
        _this._intervalPrecision = 2;
        return _this;
      }
      IntervalScale2.prototype.parse = function(val) {
        return val == null || val === "" ? NaN : Number(val);
      };
      IntervalScale2.prototype.contain = function(val) {
        return contain(val, this._extent);
      };
      IntervalScale2.prototype.normalize = function(val) {
        return this._calculator.normalize(val, this._extent);
      };
      IntervalScale2.prototype.scale = function(val) {
        return this._calculator.scale(val, this._extent);
      };
      IntervalScale2.prototype.getInterval = function() {
        return this._interval;
      };
      IntervalScale2.prototype.setInterval = function(interval) {
        this._interval = interval;
        this._niceExtent = this._extent.slice();
        this._intervalPrecision = getIntervalPrecision(interval);
      };
      IntervalScale2.prototype.getTicks = function(opt) {
        opt = opt || {};
        var interval = this._interval;
        var extent = this._extent;
        var niceTickExtent = this._niceExtent;
        var intervalPrecision = this._intervalPrecision;
        var scaleBreakHelper = getScaleBreakHelper();
        var ticks = [];
        if (!interval) {
          return ticks;
        }
        if (opt.breakTicks === "only_break" && scaleBreakHelper) ;
        var safeLimit = 1e4;
        if (extent[0] < niceTickExtent[0]) {
          if (opt.expandToNicedExtent) {
            ticks.push({
              value: roundNumber(niceTickExtent[0] - interval, intervalPrecision)
            });
          } else {
            ticks.push({
              value: extent[0]
            });
          }
        }
        var estimateNiceMultiple = function(tickVal, targetTick) {
          return Math.round((targetTick - tickVal) / interval);
        };
        var tick = niceTickExtent[0];
        while (tick <= niceTickExtent[1]) {
          ticks.push({
            value: tick
          });
          tick = roundNumber(tick + interval, intervalPrecision);
          if (this._brkCtx) {
            var moreMultiple = this._brkCtx.calcNiceTickMultiple(tick, estimateNiceMultiple);
            if (moreMultiple >= 0) {
              tick = roundNumber(tick + moreMultiple * interval, intervalPrecision);
            }
          }
          if (ticks.length > 0 && tick === ticks[ticks.length - 1].value) {
            break;
          }
          if (ticks.length > safeLimit) {
            return [];
          }
        }
        var lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];
        if (extent[1] > lastNiceTick) {
          if (opt.expandToNicedExtent) {
            ticks.push({
              value: roundNumber(lastNiceTick + interval, intervalPrecision)
            });
          } else {
            ticks.push({
              value: extent[1]
            });
          }
        }
        if (opt.breakTicks !== "none" && scaleBreakHelper) ;
        return ticks;
      };
      IntervalScale2.prototype.getMinorTicks = function(splitNumber) {
        var ticks = this.getTicks({
          expandToNicedExtent: true
        });
        var minorTicks = [];
        var extent = this.getExtent();
        for (var i = 1; i < ticks.length; i++) {
          var nextTick = ticks[i];
          var prevTick = ticks[i - 1];
          if (prevTick["break"] || nextTick["break"]) {
            continue;
          }
          var count = 0;
          var minorTicksGroup = [];
          var interval = nextTick.value - prevTick.value;
          var minorInterval = interval / splitNumber;
          var minorIntervalPrecision = getIntervalPrecision(minorInterval);
          while (count < splitNumber - 1) {
            var minorTick = roundNumber(prevTick.value + (count + 1) * minorInterval, minorIntervalPrecision);
            if (minorTick > extent[0] && minorTick < extent[1]) {
              minorTicksGroup.push(minorTick);
            }
            count++;
          }
          var scaleBreakHelper = getScaleBreakHelper();
          scaleBreakHelper && scaleBreakHelper.pruneTicksByBreak("auto", minorTicksGroup, this._getNonTransBreaks(), function(value) {
            return value;
          }, this._interval, extent);
          minorTicks.push(minorTicksGroup);
        }
        return minorTicks;
      };
      IntervalScale2.prototype._getNonTransBreaks = function() {
        return this._brkCtx ? this._brkCtx.breaks : [];
      };
      IntervalScale2.prototype.getLabel = function(data, opt) {
        if (data == null) {
          return "";
        }
        var precision = opt && opt.precision;
        if (precision == null) {
          precision = getPrecision(data.value) || 0;
        } else if (precision === "auto") {
          precision = this._intervalPrecision;
        }
        var dataNum = roundNumber(data.value, precision, true);
        return addCommas(dataNum);
      };
      IntervalScale2.prototype.calcNiceTicks = function(splitNumber, minInterval, maxInterval) {
        splitNumber = splitNumber || 5;
        var extent = this._extent.slice();
        var span = this._getExtentSpanWithBreaks();
        if (!isFinite(span)) {
          return;
        }
        if (span < 0) {
          span = -span;
          extent.reverse();
          this._innerSetExtent(extent[0], extent[1]);
          extent = this._extent.slice();
        }
        var result = intervalScaleNiceTicks(extent, span, splitNumber, minInterval, maxInterval);
        this._intervalPrecision = result.intervalPrecision;
        this._interval = result.interval;
        this._niceExtent = result.niceTickExtent;
      };
      IntervalScale2.prototype.calcNiceExtent = function(opt) {
        var extent = this._extent.slice();
        if (extent[0] === extent[1]) {
          if (extent[0] !== 0) {
            var expandSize = Math.abs(extent[0]);
            if (!opt.fixMax) {
              extent[1] += expandSize / 2;
              extent[0] -= expandSize / 2;
            } else {
              extent[0] -= expandSize / 2;
            }
          } else {
            extent[1] = 1;
          }
        }
        var span = extent[1] - extent[0];
        if (!isFinite(span)) {
          extent[0] = 0;
          extent[1] = 1;
        }
        this._innerSetExtent(extent[0], extent[1]);
        extent = this._extent.slice();
        this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
        var interval = this._interval;
        var intervalPrecition = this._intervalPrecision;
        if (!opt.fixMin) {
          extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval, intervalPrecition);
        }
        if (!opt.fixMax) {
          extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval, intervalPrecition);
        }
        this._innerSetExtent(extent[0], extent[1]);
      };
      IntervalScale2.prototype.setNiceExtent = function(min3, max3) {
        this._niceExtent = [min3, max3];
      };
      IntervalScale2.type = "interval";
      return IntervalScale2;
    }(Scale)
  );
  Scale.registerClass(IntervalScale);
  var supportFloat32Array = typeof Float32Array !== "undefined";
  var Float32ArrayCtor = !supportFloat32Array ? Array : Float32Array;
  function createFloat32Array(arg) {
    if (isArray(arg)) {
      return supportFloat32Array ? new Float32Array(arg) : arg;
    }
    return new Float32ArrayCtor(arg);
  }
  var STACK_PREFIX = "__ec_stack_";
  function getSeriesStackId(seriesModel) {
    return seriesModel.get("stack") || STACK_PREFIX + seriesModel.seriesIndex;
  }
  function getAxisKey(axis) {
    return axis.dim + axis.index;
  }
  function prepareLayoutBarSeries(seriesType2, ecModel) {
    var seriesModels = [];
    ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
      if (isOnCartesian(seriesModel)) {
        seriesModels.push(seriesModel);
      }
    });
    return seriesModels;
  }
  function getValueAxesMinGaps(barSeries) {
    var axisValues = {};
    each$5(barSeries, function(seriesModel) {
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      if (baseAxis.type !== "time" && baseAxis.type !== "value") {
        return;
      }
      var data = seriesModel.getData();
      var key3 = baseAxis.dim + "_" + baseAxis.index;
      var dimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
      var store = data.getStore();
      for (var i = 0, cnt = store.count(); i < cnt; ++i) {
        var value = store.get(dimIdx, i);
        if (!axisValues[key3]) {
          axisValues[key3] = [value];
        } else {
          axisValues[key3].push(value);
        }
      }
    });
    var axisMinGaps = {};
    for (var key2 in axisValues) {
      if (axisValues.hasOwnProperty(key2)) {
        var valuesInAxis = axisValues[key2];
        if (valuesInAxis) {
          valuesInAxis.sort(function(a, b) {
            return a - b;
          });
          var min3 = null;
          for (var j = 1; j < valuesInAxis.length; ++j) {
            var delta = valuesInAxis[j] - valuesInAxis[j - 1];
            if (delta > 0) {
              min3 = min3 === null ? delta : Math.min(min3, delta);
            }
          }
          axisMinGaps[key2] = min3;
        }
      }
    }
    return axisMinGaps;
  }
  function makeColumnLayout(barSeries) {
    var axisMinGaps = getValueAxesMinGaps(barSeries);
    var seriesInfoList = [];
    each$5(barSeries, function(seriesModel) {
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      var axisExtent = baseAxis.getExtent();
      var bandWidth;
      if (baseAxis.type === "category") {
        bandWidth = baseAxis.getBandWidth();
      } else if (baseAxis.type === "value" || baseAxis.type === "time") {
        var key2 = baseAxis.dim + "_" + baseAxis.index;
        var minGap = axisMinGaps[key2];
        var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);
        var scale2 = baseAxis.scale.getExtent();
        var scaleSpan = Math.abs(scale2[1] - scale2[0]);
        bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan;
      } else {
        var data = seriesModel.getData();
        bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
      }
      var barWidth = parsePercent(seriesModel.get("barWidth"), bandWidth);
      var barMaxWidth = parsePercent(seriesModel.get("barMaxWidth"), bandWidth);
      var barMinWidth = parsePercent(
        // barMinWidth by default is 0.5 / 1 in cartesian. Because in value axis,
        // the auto-calculated bar width might be less than 0.5 / 1.
        seriesModel.get("barMinWidth") || (isInLargeMode(seriesModel) ? 0.5 : 1),
        bandWidth
      );
      var barGap = seriesModel.get("barGap");
      var barCategoryGap = seriesModel.get("barCategoryGap");
      var defaultBarGap = seriesModel.get("defaultBarGap");
      seriesInfoList.push({
        bandWidth,
        barWidth,
        barMaxWidth,
        barMinWidth,
        barGap,
        barCategoryGap,
        defaultBarGap,
        axisKey: getAxisKey(baseAxis),
        stackId: getSeriesStackId(seriesModel)
      });
    });
    return doCalBarWidthAndOffset(seriesInfoList);
  }
  function doCalBarWidthAndOffset(seriesInfoList) {
    var columnsMap = {};
    each$5(seriesInfoList, function(seriesInfo, idx) {
      var axisKey = seriesInfo.axisKey;
      var bandWidth = seriesInfo.bandWidth;
      var columnsOnAxis = columnsMap[axisKey] || {
        bandWidth,
        remainedWidth: bandWidth,
        autoWidthCount: 0,
        categoryGap: null,
        gap: seriesInfo.defaultBarGap || 0,
        stacks: {}
      };
      var stacks = columnsOnAxis.stacks;
      columnsMap[axisKey] = columnsOnAxis;
      var stackId = seriesInfo.stackId;
      if (!stacks[stackId]) {
        columnsOnAxis.autoWidthCount++;
      }
      stacks[stackId] = stacks[stackId] || {
        width: 0,
        maxWidth: 0
      };
      var barWidth = seriesInfo.barWidth;
      if (barWidth && !stacks[stackId].width) {
        stacks[stackId].width = barWidth;
        barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
        columnsOnAxis.remainedWidth -= barWidth;
      }
      var barMaxWidth = seriesInfo.barMaxWidth;
      barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
      var barMinWidth = seriesInfo.barMinWidth;
      barMinWidth && (stacks[stackId].minWidth = barMinWidth);
      var barGap = seriesInfo.barGap;
      barGap != null && (columnsOnAxis.gap = barGap);
      var barCategoryGap = seriesInfo.barCategoryGap;
      barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
    });
    var result = {};
    each$5(columnsMap, function(columnsOnAxis, coordSysName) {
      result[coordSysName] = {};
      var stacks = columnsOnAxis.stacks;
      var bandWidth = columnsOnAxis.bandWidth;
      var categoryGapPercent = columnsOnAxis.categoryGap;
      if (categoryGapPercent == null) {
        var columnCount = keys(stacks).length;
        categoryGapPercent = Math.max(35 - columnCount * 4, 15) + "%";
      }
      var categoryGap = parsePercent(categoryGapPercent, bandWidth);
      var barGapPercent = parsePercent(columnsOnAxis.gap, 1);
      var remainedWidth = columnsOnAxis.remainedWidth;
      var autoWidthCount = columnsOnAxis.autoWidthCount;
      var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
      autoWidth = Math.max(autoWidth, 0);
      each$5(stacks, function(column) {
        var maxWidth = column.maxWidth;
        var minWidth = column.minWidth;
        if (!column.width) {
          var finalWidth = autoWidth;
          if (maxWidth && maxWidth < finalWidth) {
            finalWidth = Math.min(maxWidth, remainedWidth);
          }
          if (minWidth && minWidth > finalWidth) {
            finalWidth = minWidth;
          }
          if (finalWidth !== autoWidth) {
            column.width = finalWidth;
            remainedWidth -= finalWidth + barGapPercent * finalWidth;
            autoWidthCount--;
          }
        } else {
          var finalWidth = column.width;
          if (maxWidth) {
            finalWidth = Math.min(finalWidth, maxWidth);
          }
          if (minWidth) {
            finalWidth = Math.max(finalWidth, minWidth);
          }
          column.width = finalWidth;
          remainedWidth -= finalWidth + barGapPercent * finalWidth;
          autoWidthCount--;
        }
      });
      autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
      autoWidth = Math.max(autoWidth, 0);
      var widthSum = 0;
      var lastColumn;
      each$5(stacks, function(column, idx) {
        if (!column.width) {
          column.width = autoWidth;
        }
        lastColumn = column;
        widthSum += column.width * (1 + barGapPercent);
      });
      if (lastColumn) {
        widthSum -= lastColumn.width * barGapPercent;
      }
      var offset = -widthSum / 2;
      each$5(stacks, function(column, stackId) {
        result[coordSysName][stackId] = result[coordSysName][stackId] || {
          bandWidth,
          offset,
          width: column.width
        };
        offset += column.width * (1 + barGapPercent);
      });
    });
    return result;
  }
  function retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {
    if (barWidthAndOffset && axis) {
      var result = barWidthAndOffset[getAxisKey(axis)];
      return result;
    }
  }
  function isOnCartesian(seriesModel) {
    return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "cartesian2d";
  }
  function isInLargeMode(seriesModel) {
    return seriesModel.pipelineContext && seriesModel.pipelineContext.large;
  }
  var define_process_env_default$f = {};
  var bisect = function(a, x, lo, hi) {
    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (a[mid][1] < x) {
        lo = mid + 1;
      } else {
        hi = mid;
      }
    }
    return lo;
  };
  var TimeScale = (
    /** @class */
    function(_super) {
      __extends(TimeScale2, _super);
      function TimeScale2(settings) {
        var _this = _super.call(this, settings) || this;
        _this.type = "time";
        return _this;
      }
      TimeScale2.prototype.getLabel = function(tick) {
        var useUTC = this.getSetting("useUTC");
        return format(tick.value, fullLeveledFormatter[getDefaultFormatPrecisionOfInterval(getPrimaryTimeUnit(this._minLevelUnit))] || fullLeveledFormatter.second, useUTC, this.getSetting("locale"));
      };
      TimeScale2.prototype.getFormattedLabel = function(tick, idx, labelFormatter) {
        var isUTC = this.getSetting("useUTC");
        var lang = this.getSetting("locale");
        return leveledFormat(tick, idx, labelFormatter, lang, isUTC);
      };
      TimeScale2.prototype.getTicks = function(opt) {
        var interval = this._interval;
        var extent = this._extent;
        var ticks = [];
        if (!interval) {
          return ticks;
        }
        var useUTC = this.getSetting("useUTC");
        var extent0Unit = getUnitFromValue(extent[1], useUTC);
        ticks.push({
          value: extent[0],
          time: {
            level: 0,
            upperTimeUnit: extent0Unit,
            lowerTimeUnit: extent0Unit
          }
        });
        var innerTicks = getIntervalTicks(this._minLevelUnit, this._approxInterval, useUTC, extent, this._getExtentSpanWithBreaks(), this._brkCtx);
        ticks = ticks.concat(innerTicks);
        var extent1Unit = getUnitFromValue(extent[1], useUTC);
        ticks.push({
          value: extent[1],
          time: {
            level: 0,
            upperTimeUnit: extent1Unit,
            lowerTimeUnit: extent1Unit
          }
        });
        this.getSetting("useUTC");
        var upperUnitIndex = primaryTimeUnits.length - 1;
        var maxLevel = 0;
        each$5(ticks, function(tick) {
          upperUnitIndex = Math.min(upperUnitIndex, indexOf(primaryTimeUnits, tick.time.upperTimeUnit));
          maxLevel = Math.max(maxLevel, tick.time.level);
        });
        return ticks;
      };
      TimeScale2.prototype.calcNiceExtent = function(opt) {
        var extent = this.getExtent();
        if (extent[0] === extent[1]) {
          extent[0] -= ONE_DAY;
          extent[1] += ONE_DAY;
        }
        if (extent[1] === -Infinity && extent[0] === Infinity) {
          var d = /* @__PURE__ */ new Date();
          extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());
          extent[0] = extent[1] - ONE_DAY;
        }
        this._innerSetExtent(extent[0], extent[1]);
        this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
      };
      TimeScale2.prototype.calcNiceTicks = function(approxTickNum, minInterval, maxInterval) {
        approxTickNum = approxTickNum || 10;
        var span = this._getExtentSpanWithBreaks();
        this._approxInterval = span / approxTickNum;
        if (minInterval != null && this._approxInterval < minInterval) {
          this._approxInterval = minInterval;
        }
        if (maxInterval != null && this._approxInterval > maxInterval) {
          this._approxInterval = maxInterval;
        }
        var scaleIntervalsLen = scaleIntervals.length;
        var idx = Math.min(bisect(scaleIntervals, this._approxInterval, 0, scaleIntervalsLen), scaleIntervalsLen - 1);
        this._interval = scaleIntervals[idx][1];
        this._intervalPrecision = getIntervalPrecision(this._interval);
        this._minLevelUnit = scaleIntervals[Math.max(idx - 1, 0)][0];
      };
      TimeScale2.prototype.parse = function(val) {
        return isNumber(val) ? val : +parseDate(val);
      };
      TimeScale2.prototype.contain = function(val) {
        return contain(val, this._extent);
      };
      TimeScale2.prototype.normalize = function(val) {
        return this._calculator.normalize(val, this._extent);
      };
      TimeScale2.prototype.scale = function(val) {
        return this._calculator.scale(val, this._extent);
      };
      TimeScale2.type = "time";
      return TimeScale2;
    }(IntervalScale)
  );
  var scaleIntervals = [
    // Format                           interval
    ["second", ONE_SECOND],
    ["minute", ONE_MINUTE],
    ["hour", ONE_HOUR],
    ["quarter-day", ONE_HOUR * 6],
    ["half-day", ONE_HOUR * 12],
    ["day", ONE_DAY * 1.2],
    ["half-week", ONE_DAY * 3.5],
    ["week", ONE_DAY * 7],
    ["month", ONE_DAY * 31],
    ["quarter", ONE_DAY * 95],
    ["half-year", ONE_YEAR / 2],
    ["year", ONE_YEAR]
    // 1Y
  ];
  function isPrimaryUnitValueAndGreaterSame(unit, valueA, valueB, isUTC) {
    return roundTime(new Date(valueA), unit, isUTC).getTime() === roundTime(new Date(valueB), unit, isUTC).getTime();
  }
  function getDateInterval(approxInterval, daysInMonth) {
    approxInterval /= ONE_DAY;
    return approxInterval > 16 ? 16 : approxInterval > 7.5 ? 7 : approxInterval > 3.5 ? 4 : approxInterval > 1.5 ? 2 : 1;
  }
  function getMonthInterval(approxInterval) {
    var APPROX_ONE_MONTH = 30 * ONE_DAY;
    approxInterval /= APPROX_ONE_MONTH;
    return approxInterval > 6 ? 6 : approxInterval > 3 ? 3 : approxInterval > 2 ? 2 : 1;
  }
  function getHourInterval(approxInterval) {
    approxInterval /= ONE_HOUR;
    return approxInterval > 12 ? 12 : approxInterval > 6 ? 6 : approxInterval > 3.5 ? 4 : approxInterval > 2 ? 2 : 1;
  }
  function getMinutesAndSecondsInterval(approxInterval, isMinutes) {
    approxInterval /= isMinutes ? ONE_MINUTE : ONE_SECOND;
    return approxInterval > 30 ? 30 : approxInterval > 20 ? 20 : approxInterval > 15 ? 15 : approxInterval > 10 ? 10 : approxInterval > 5 ? 5 : approxInterval > 2 ? 2 : 1;
  }
  function getMillisecondsInterval(approxInterval) {
    return nice(approxInterval);
  }
  function getFirstTimestampOfUnit(timestamp, unitName, isUTC) {
    var upperUnitIdx = Math.max(0, indexOf(primaryTimeUnits, unitName) - 1);
    return roundTime(new Date(timestamp), primaryTimeUnits[upperUnitIdx], isUTC).getTime();
  }
  function createEstimateNiceMultiple(setMethodName, dateMethodInterval) {
    var tmpDate = /* @__PURE__ */ new Date(0);
    tmpDate[setMethodName](1);
    var tmpTime = tmpDate.getTime();
    tmpDate[setMethodName](1 + dateMethodInterval);
    var approxTimeInterval = tmpDate.getTime() - tmpTime;
    return function(tickVal, targetValue) {
      return Math.max(0, Math.round((targetValue - tickVal) / approxTimeInterval));
    };
  }
  function getIntervalTicks(bottomUnitName, approxInterval, isUTC, extent, extentSpanWithBreaks, brkCtx) {
    var safeLimit = 1e4;
    var unitNames = timeUnits;
    var iter = 0;
    function addTicksInSpan(interval, minTimestamp, maxTimestamp, getMethodName, setMethodName, isDate2, out2) {
      var estimateNiceMultiple = createEstimateNiceMultiple(setMethodName, interval);
      var dateTime = minTimestamp;
      var date = new Date(dateTime);
      while (dateTime < maxTimestamp && dateTime <= extent[1]) {
        out2.push({
          value: dateTime
        });
        if (iter++ > safeLimit) {
          if (define_process_env_default$f.NODE_ENV !== "production") {
            warn("Exceed safe limit in time scale.");
          }
          break;
        }
        date[setMethodName](date[getMethodName]() + interval);
        dateTime = date.getTime();
        if (brkCtx) {
          var moreMultiple = brkCtx.calcNiceTickMultiple(dateTime, estimateNiceMultiple);
          if (moreMultiple > 0) {
            date[setMethodName](date[getMethodName]() + moreMultiple * interval);
            dateTime = date.getTime();
          }
        }
      }
      out2.push({
        value: dateTime,
        notAdd: true
      });
    }
    function addLevelTicks(unitName, lastLevelTicks, levelTicks2) {
      var newAddedTicks = [];
      var isFirstLevel = !lastLevelTicks.length;
      if (isPrimaryUnitValueAndGreaterSame(getPrimaryTimeUnit(unitName), extent[0], extent[1], isUTC)) {
        return;
      }
      if (isFirstLevel) {
        lastLevelTicks = [{
          value: getFirstTimestampOfUnit(extent[0], unitName, isUTC)
        }, {
          value: extent[1]
        }];
      }
      for (var i2 = 0; i2 < lastLevelTicks.length - 1; i2++) {
        var startTick = lastLevelTicks[i2].value;
        var endTick = lastLevelTicks[i2 + 1].value;
        if (startTick === endTick) {
          continue;
        }
        var interval = void 0;
        var getterName = void 0;
        var setterName = void 0;
        var isDate2 = false;
        switch (unitName) {
          case "year":
            interval = Math.max(1, Math.round(approxInterval / ONE_DAY / 365));
            getterName = fullYearGetterName(isUTC);
            setterName = fullYearSetterName(isUTC);
            break;
          case "half-year":
          case "quarter":
          case "month":
            interval = getMonthInterval(approxInterval);
            getterName = monthGetterName(isUTC);
            setterName = monthSetterName(isUTC);
            break;
          case "week":
          case "half-week":
          case "day":
            interval = getDateInterval(approxInterval);
            getterName = dateGetterName(isUTC);
            setterName = dateSetterName(isUTC);
            isDate2 = true;
            break;
          case "half-day":
          case "quarter-day":
          case "hour":
            interval = getHourInterval(approxInterval);
            getterName = hoursGetterName(isUTC);
            setterName = hoursSetterName(isUTC);
            break;
          case "minute":
            interval = getMinutesAndSecondsInterval(approxInterval, true);
            getterName = minutesGetterName(isUTC);
            setterName = minutesSetterName(isUTC);
            break;
          case "second":
            interval = getMinutesAndSecondsInterval(approxInterval, false);
            getterName = secondsGetterName(isUTC);
            setterName = secondsSetterName(isUTC);
            break;
          case "millisecond":
            interval = getMillisecondsInterval(approxInterval);
            getterName = millisecondsGetterName(isUTC);
            setterName = millisecondsSetterName(isUTC);
            break;
        }
        if (endTick >= extent[0] && startTick <= extent[1]) {
          addTicksInSpan(interval, startTick, endTick, getterName, setterName, isDate2, newAddedTicks);
        }
        if (unitName === "year" && levelTicks2.length > 1 && i2 === 0) {
          levelTicks2.unshift({
            value: levelTicks2[0].value - interval
          });
        }
      }
      for (var i2 = 0; i2 < newAddedTicks.length; i2++) {
        levelTicks2.push(newAddedTicks[i2]);
      }
    }
    var levelsTicks = [];
    var currentLevelTicks = [];
    var tickCount = 0;
    var lastLevelTickCount = 0;
    for (var i = 0; i < unitNames.length; ++i) {
      var primaryTimeUnit = getPrimaryTimeUnit(unitNames[i]);
      if (!isPrimaryTimeUnit(unitNames[i])) {
        continue;
      }
      addLevelTicks(unitNames[i], levelsTicks[levelsTicks.length - 1] || [], currentLevelTicks);
      var nextPrimaryTimeUnit = unitNames[i + 1] ? getPrimaryTimeUnit(unitNames[i + 1]) : null;
      if (primaryTimeUnit !== nextPrimaryTimeUnit) {
        if (currentLevelTicks.length) {
          lastLevelTickCount = tickCount;
          currentLevelTicks.sort(function(a, b) {
            return a.value - b.value;
          });
          var levelTicksRemoveDuplicated = [];
          for (var i_1 = 0; i_1 < currentLevelTicks.length; ++i_1) {
            var tickValue = currentLevelTicks[i_1].value;
            if (i_1 === 0 || currentLevelTicks[i_1 - 1].value !== tickValue) {
              levelTicksRemoveDuplicated.push(currentLevelTicks[i_1]);
              if (tickValue >= extent[0] && tickValue <= extent[1]) {
                tickCount++;
              }
            }
          }
          var targetTickNum = extentSpanWithBreaks / approxInterval;
          if (tickCount > targetTickNum * 1.5 && lastLevelTickCount > targetTickNum / 1.5) {
            break;
          }
          levelsTicks.push(levelTicksRemoveDuplicated);
          if (tickCount > targetTickNum || bottomUnitName === unitNames[i]) {
            break;
          }
        }
        currentLevelTicks = [];
      }
    }
    var levelsTicksInExtent = filter(map$1(levelsTicks, function(levelTicks2) {
      return filter(levelTicks2, function(tick) {
        return tick.value >= extent[0] && tick.value <= extent[1] && !tick.notAdd;
      });
    }), function(levelTicks2) {
      return levelTicks2.length > 0;
    });
    var ticks = [];
    var maxLevel = levelsTicksInExtent.length - 1;
    for (var i = 0; i < levelsTicksInExtent.length; ++i) {
      var levelTicks = levelsTicksInExtent[i];
      for (var k = 0; k < levelTicks.length; ++k) {
        var unit = getUnitFromValue(levelTicks[k].value, isUTC);
        ticks.push({
          value: levelTicks[k].value,
          time: {
            level: maxLevel - i,
            upperTimeUnit: unit,
            lowerTimeUnit: unit
          }
        });
      }
    }
    ticks.sort(function(a, b) {
      return a.value - b.value;
    });
    var result = [];
    for (var i = 0; i < ticks.length; ++i) {
      if (i === 0 || ticks[i].value !== ticks[i - 1].value) {
        result.push(ticks[i]);
      }
    }
    return result;
  }
  Scale.registerClass(TimeScale);
  var fixRound = round$1;
  var mathFloor = Math.floor;
  var mathCeil = Math.ceil;
  var mathPow = Math.pow;
  var mathLog = Math.log;
  var LogScale = (
    /** @class */
    function(_super) {
      __extends(LogScale2, _super);
      function LogScale2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "log";
        _this.base = 10;
        _this._originalScale = new IntervalScale();
        return _this;
      }
      LogScale2.prototype.getTicks = function(opt) {
        opt = opt || {};
        var extent = this._extent.slice();
        var originalExtent = this._originalScale.getExtent();
        var ticks = _super.prototype.getTicks.call(this, opt);
        var base2 = this.base;
        this._originalScale._innerGetBreaks();
        return map$1(ticks, function(tick) {
          var val = tick.value;
          var roundingCriterion = null;
          var powVal = mathPow(base2, val);
          if (val === extent[0] && this._fixMin) {
            roundingCriterion = originalExtent[0];
          } else if (val === extent[1] && this._fixMax) {
            roundingCriterion = originalExtent[1];
          }
          var vBreak;
          if (roundingCriterion != null) {
            powVal = fixRoundingError(powVal, roundingCriterion);
          }
          return {
            value: powVal,
            "break": vBreak
          };
        }, this);
      };
      LogScale2.prototype._getNonTransBreaks = function() {
        return this._originalScale._innerGetBreaks();
      };
      LogScale2.prototype.setExtent = function(start2, end2) {
        this._originalScale.setExtent(start2, end2);
        var loggedExtent = logTransform(this.base, [start2, end2]);
        _super.prototype.setExtent.call(this, loggedExtent[0], loggedExtent[1]);
      };
      LogScale2.prototype.getExtent = function() {
        var base2 = this.base;
        var extent = _super.prototype.getExtent.call(this);
        extent[0] = mathPow(base2, extent[0]);
        extent[1] = mathPow(base2, extent[1]);
        var originalExtent = this._originalScale.getExtent();
        this._fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));
        this._fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));
        return extent;
      };
      LogScale2.prototype.unionExtentFromData = function(data, dim) {
        this._originalScale.unionExtentFromData(data, dim);
        var loggedOther = logTransform(this.base, data.getApproximateExtent(dim), true);
        this._innerUnionExtent(loggedOther);
      };
      LogScale2.prototype.calcNiceTicks = function(approxTickNum) {
        approxTickNum = approxTickNum || 10;
        var extent = this._extent.slice();
        var span = this._getExtentSpanWithBreaks();
        if (!isFinite(span) || span <= 0) {
          return;
        }
        var interval = quantity(span);
        var err = approxTickNum / span * interval;
        if (err <= 0.5) {
          interval *= 10;
        }
        while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
          interval *= 10;
        }
        var niceExtent = [fixRound(mathCeil(extent[0] / interval) * interval), fixRound(mathFloor(extent[1] / interval) * interval)];
        this._interval = interval;
        this._intervalPrecision = getIntervalPrecision(interval);
        this._niceExtent = niceExtent;
      };
      LogScale2.prototype.calcNiceExtent = function(opt) {
        _super.prototype.calcNiceExtent.call(this, opt);
        this._fixMin = opt.fixMin;
        this._fixMax = opt.fixMax;
      };
      LogScale2.prototype.contain = function(val) {
        val = mathLog(val) / mathLog(this.base);
        return _super.prototype.contain.call(this, val);
      };
      LogScale2.prototype.normalize = function(val) {
        val = mathLog(val) / mathLog(this.base);
        return _super.prototype.normalize.call(this, val);
      };
      LogScale2.prototype.scale = function(val) {
        val = _super.prototype.scale.call(this, val);
        return mathPow(this.base, val);
      };
      LogScale2.prototype.setBreaksFromOption = function(breakOptionList) {
        {
          return;
        }
      };
      LogScale2.type = "log";
      return LogScale2;
    }(IntervalScale)
  );
  function fixRoundingError(val, originalVal) {
    return fixRound(val, getPrecision(originalVal));
  }
  Scale.registerClass(LogScale);
  var define_process_env_default$e = {};
  var ScaleRawExtentInfo = (
    /** @class */
    function() {
      function ScaleRawExtentInfo2(scale2, model, originalExtent) {
        this._prepareParams(scale2, model, originalExtent);
      }
      ScaleRawExtentInfo2.prototype._prepareParams = function(scale2, model, dataExtent) {
        if (dataExtent[1] < dataExtent[0]) {
          dataExtent = [NaN, NaN];
        }
        this._dataMin = dataExtent[0];
        this._dataMax = dataExtent[1];
        var isOrdinal = this._isOrdinal = scale2.type === "ordinal";
        this._needCrossZero = scale2.type === "interval" && model.getNeedCrossZero && model.getNeedCrossZero();
        var axisMinValue = model.get("min", true);
        if (axisMinValue == null) {
          axisMinValue = model.get("startValue", true);
        }
        var modelMinRaw = this._modelMinRaw = axisMinValue;
        if (isFunction(modelMinRaw)) {
          this._modelMinNum = parseAxisModelMinMax(scale2, modelMinRaw({
            min: dataExtent[0],
            max: dataExtent[1]
          }));
        } else if (modelMinRaw !== "dataMin") {
          this._modelMinNum = parseAxisModelMinMax(scale2, modelMinRaw);
        }
        var modelMaxRaw = this._modelMaxRaw = model.get("max", true);
        if (isFunction(modelMaxRaw)) {
          this._modelMaxNum = parseAxisModelMinMax(scale2, modelMaxRaw({
            min: dataExtent[0],
            max: dataExtent[1]
          }));
        } else if (modelMaxRaw !== "dataMax") {
          this._modelMaxNum = parseAxisModelMinMax(scale2, modelMaxRaw);
        }
        if (isOrdinal) {
          this._axisDataLen = model.getCategories().length;
        } else {
          var boundaryGap = model.get("boundaryGap");
          var boundaryGapArr = isArray(boundaryGap) ? boundaryGap : [boundaryGap || 0, boundaryGap || 0];
          if (typeof boundaryGapArr[0] === "boolean" || typeof boundaryGapArr[1] === "boolean") {
            if (define_process_env_default$e.NODE_ENV !== "production") {
              console.warn('Boolean type for boundaryGap is only allowed for ordinal axis. Please use string in percentage instead, e.g., "20%". Currently, boundaryGap is set to be 0.');
            }
            this._boundaryGapInner = [0, 0];
          } else {
            this._boundaryGapInner = [parsePercent$1(boundaryGapArr[0], 1), parsePercent$1(boundaryGapArr[1], 1)];
          }
        }
      };
      ScaleRawExtentInfo2.prototype.calculate = function() {
        var isOrdinal = this._isOrdinal;
        var dataMin = this._dataMin;
        var dataMax = this._dataMax;
        var axisDataLen = this._axisDataLen;
        var boundaryGapInner = this._boundaryGapInner;
        var span = !isOrdinal ? dataMax - dataMin || Math.abs(dataMin) : null;
        var min3 = this._modelMinRaw === "dataMin" ? dataMin : this._modelMinNum;
        var max3 = this._modelMaxRaw === "dataMax" ? dataMax : this._modelMaxNum;
        var minFixed = min3 != null;
        var maxFixed = max3 != null;
        if (min3 == null) {
          min3 = isOrdinal ? axisDataLen ? 0 : NaN : dataMin - boundaryGapInner[0] * span;
        }
        if (max3 == null) {
          max3 = isOrdinal ? axisDataLen ? axisDataLen - 1 : NaN : dataMax + boundaryGapInner[1] * span;
        }
        (min3 == null || !isFinite(min3)) && (min3 = NaN);
        (max3 == null || !isFinite(max3)) && (max3 = NaN);
        var isBlank = eqNaN(min3) || eqNaN(max3) || isOrdinal && !axisDataLen;
        if (this._needCrossZero) {
          if (min3 > 0 && max3 > 0 && !minFixed) {
            min3 = 0;
          }
          if (min3 < 0 && max3 < 0 && !maxFixed) {
            max3 = 0;
          }
        }
        var determinedMin = this._determinedMin;
        var determinedMax = this._determinedMax;
        if (determinedMin != null) {
          min3 = determinedMin;
          minFixed = true;
        }
        if (determinedMax != null) {
          max3 = determinedMax;
          maxFixed = true;
        }
        return {
          min: min3,
          max: max3,
          minFixed,
          maxFixed,
          isBlank
        };
      };
      ScaleRawExtentInfo2.prototype.modifyDataMinMax = function(minMaxName, val) {
        if (define_process_env_default$e.NODE_ENV !== "production") {
          assert(!this.frozen);
        }
        this[DATA_MIN_MAX_ATTR[minMaxName]] = val;
      };
      ScaleRawExtentInfo2.prototype.setDeterminedMinMax = function(minMaxName, val) {
        var attr = DETERMINED_MIN_MAX_ATTR[minMaxName];
        if (define_process_env_default$e.NODE_ENV !== "production") {
          assert(!this.frozen && this[attr] == null);
        }
        this[attr] = val;
      };
      ScaleRawExtentInfo2.prototype.freeze = function() {
        this.frozen = true;
      };
      return ScaleRawExtentInfo2;
    }()
  );
  var DETERMINED_MIN_MAX_ATTR = {
    min: "_determinedMin",
    max: "_determinedMax"
  };
  var DATA_MIN_MAX_ATTR = {
    min: "_dataMin",
    max: "_dataMax"
  };
  function ensureScaleRawExtentInfo(scale2, model, originalExtent) {
    var rawExtentInfo = scale2.rawExtentInfo;
    if (rawExtentInfo) {
      return rawExtentInfo;
    }
    rawExtentInfo = new ScaleRawExtentInfo(scale2, model, originalExtent);
    scale2.rawExtentInfo = rawExtentInfo;
    return rawExtentInfo;
  }
  function parseAxisModelMinMax(scale2, minMax) {
    return minMax == null ? null : eqNaN(minMax) ? NaN : scale2.parse(minMax);
  }
  var define_process_env_default$d = {};
  function getScaleExtent(scale2, model) {
    var scaleType = scale2.type;
    var rawExtentResult = ensureScaleRawExtentInfo(scale2, model, scale2.getExtent()).calculate();
    scale2.setBlank(rawExtentResult.isBlank);
    var min3 = rawExtentResult.min;
    var max3 = rawExtentResult.max;
    var ecModel = model.ecModel;
    if (ecModel && scaleType === "time") {
      var barSeriesModels = prepareLayoutBarSeries("bar", ecModel);
      var isBaseAxisAndHasBarSeries_1 = false;
      each$5(barSeriesModels, function(seriesModel) {
        isBaseAxisAndHasBarSeries_1 = isBaseAxisAndHasBarSeries_1 || seriesModel.getBaseAxis() === model.axis;
      });
      if (isBaseAxisAndHasBarSeries_1) {
        var barWidthAndOffset = makeColumnLayout(barSeriesModels);
        var adjustedScale = adjustScaleForOverflow(min3, max3, model, barWidthAndOffset);
        min3 = adjustedScale.min;
        max3 = adjustedScale.max;
      }
    }
    return {
      extent: [min3, max3],
      // "fix" means "fixed", the value should not be
      // changed in the subsequent steps.
      fixMin: rawExtentResult.minFixed,
      fixMax: rawExtentResult.maxFixed
    };
  }
  function adjustScaleForOverflow(min3, max3, model, barWidthAndOffset) {
    var axisExtent = model.axis.getExtent();
    var axisLength = Math.abs(axisExtent[1] - axisExtent[0]);
    var barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);
    if (barsOnCurrentAxis === void 0) {
      return {
        min: min3,
        max: max3
      };
    }
    var minOverflow = Infinity;
    each$5(barsOnCurrentAxis, function(item) {
      minOverflow = Math.min(item.offset, minOverflow);
    });
    var maxOverflow = -Infinity;
    each$5(barsOnCurrentAxis, function(item) {
      maxOverflow = Math.max(item.offset + item.width, maxOverflow);
    });
    minOverflow = Math.abs(minOverflow);
    maxOverflow = Math.abs(maxOverflow);
    var totalOverFlow = minOverflow + maxOverflow;
    var oldRange = max3 - min3;
    var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;
    var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;
    max3 += overflowBuffer * (maxOverflow / totalOverFlow);
    min3 -= overflowBuffer * (minOverflow / totalOverFlow);
    return {
      min: min3,
      max: max3
    };
  }
  function niceScaleExtent(scale2, inModel) {
    var model = inModel;
    var extentInfo = getScaleExtent(scale2, model);
    var extent = extentInfo.extent;
    var splitNumber = model.get("splitNumber");
    if (scale2 instanceof LogScale) {
      scale2.base = model.get("logBase");
    }
    var scaleType = scale2.type;
    var interval = model.get("interval");
    var isIntervalOrTime = scaleType === "interval" || scaleType === "time";
    scale2.setBreaksFromOption(retrieveAxisBreaksOption(model));
    scale2.setExtent(extent[0], extent[1]);
    scale2.calcNiceExtent({
      splitNumber,
      fixMin: extentInfo.fixMin,
      fixMax: extentInfo.fixMax,
      minInterval: isIntervalOrTime ? model.get("minInterval") : null,
      maxInterval: isIntervalOrTime ? model.get("maxInterval") : null
    });
    if (interval != null) {
      scale2.setInterval && scale2.setInterval(interval);
    }
  }
  function createScaleByModel(model, axisType) {
    axisType = axisType || model.get("type");
    if (axisType) {
      switch (axisType) {
        case "category":
          return new OrdinalScale({
            ordinalMeta: model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(),
            extent: [Infinity, -Infinity]
          });
        case "time":
          return new TimeScale({
            locale: model.ecModel.getLocaleModel(),
            useUTC: model.ecModel.get("useUTC")
          });
        default:
          return new (Scale.getClass(axisType) || IntervalScale)();
      }
    }
  }
  function ifAxisCrossZero(axis) {
    var dataExtent = axis.scale.getExtent();
    var min3 = dataExtent[0];
    var max3 = dataExtent[1];
    return !(min3 > 0 && max3 > 0 || min3 < 0 && max3 < 0);
  }
  function makeLabelFormatter(axis) {
    var labelFormatter = axis.getLabelModel().get("formatter");
    if (axis.type === "time") {
      var parsed_1 = parseTimeAxisLabelFormatter(labelFormatter);
      return function(tick, idx) {
        return axis.scale.getFormattedLabel(tick, idx, parsed_1);
      };
    } else if (isString(labelFormatter)) {
      return function(tick) {
        var label = axis.scale.getLabel(tick);
        var text = labelFormatter.replace("{value}", label != null ? label : "");
        return text;
      };
    } else if (isFunction(labelFormatter)) {
      if (axis.type === "category") {
        return function(tick, idx) {
          return labelFormatter(
            getAxisRawValue(axis, tick),
            tick.value - axis.scale.getExtent()[0],
            null
            // Using `null` just for backward compat.
          );
        };
      }
      var scaleBreakHelper_1 = getScaleBreakHelper();
      return function(tick, idx) {
        var extra = null;
        if (scaleBreakHelper_1) {
          extra = scaleBreakHelper_1.makeAxisLabelFormatterParamBreak(extra, tick["break"]);
        }
        return labelFormatter(getAxisRawValue(axis, tick), idx, extra);
      };
    } else {
      return function(tick) {
        return axis.scale.getLabel(tick);
      };
    }
  }
  function getAxisRawValue(axis, tick) {
    return axis.type === "category" ? axis.scale.getLabel(tick) : tick.value;
  }
  function getOptionCategoryInterval(model) {
    var interval = model.get("interval");
    return interval == null ? "auto" : interval;
  }
  function shouldShowAllLabels(axis) {
    return axis.type === "category" && getOptionCategoryInterval(axis.getLabelModel()) === 0;
  }
  function getDataDimensionsOnAxis(data, axisDim) {
    var dataDimMap = {};
    each$5(data.mapDimensionsAll(axisDim), function(dataDim) {
      dataDimMap[getStackedDimension(data, dataDim)] = true;
    });
    return keys(dataDimMap);
  }
  function unionAxisExtentFromData(dataExtent, data, axisDim) {
    if (data) {
      each$5(getDataDimensionsOnAxis(data, axisDim), function(dim) {
        var seriesExtent = data.getApproximateExtent(dim);
        seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);
        seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);
      });
    }
  }
  function isNameLocationCenter(nameLocation) {
    return nameLocation === "middle" || nameLocation === "center";
  }
  function shouldAxisShow(axisModel) {
    return axisModel.getShallow("show");
  }
  function retrieveAxisBreaksOption(model) {
    var option = model.get("breaks", true);
    if (option != null) {
      {
        if (define_process_env_default$d.NODE_ENV !== "production") {
          error('Must `import {AxisBreak} from "echarts/features.js"; use(AxisBreak);` first if using breaks option.');
        }
        return void 0;
      }
    }
  }
  var AxisModelCommonMixin = (
    /** @class */
    function() {
      function AxisModelCommonMixin2() {
      }
      AxisModelCommonMixin2.prototype.getNeedCrossZero = function() {
        var option = this.option;
        return !option.scale;
      };
      AxisModelCommonMixin2.prototype.getCoordSysModel = function() {
        return;
      };
      return AxisModelCommonMixin2;
    }()
  );
  var extensions = [];
  var extensionRegisters = {
    registerPreprocessor,
    registerProcessor,
    registerPostInit,
    registerPostUpdate,
    registerUpdateLifecycle,
    registerAction,
    registerCoordinateSystem,
    registerLayout,
    registerVisual,
    registerTransform,
    registerLoading,
    registerMap,
    registerImpl,
    PRIORITY,
    ComponentModel,
    ComponentView,
    SeriesModel,
    ChartView,
    // TODO Use ComponentModel and SeriesModel instead of Constructor
    registerComponentModel: function(ComponentModelClass) {
      ComponentModel.registerClass(ComponentModelClass);
    },
    registerComponentView: function(ComponentViewClass) {
      ComponentView.registerClass(ComponentViewClass);
    },
    registerSeriesModel: function(SeriesModelClass) {
      SeriesModel.registerClass(SeriesModelClass);
    },
    registerChartView: function(ChartViewClass) {
      ChartView.registerClass(ChartViewClass);
    },
    registerCustomSeries: function(seriesType2, renderItem) {
    },
    registerSubTypeDefaulter: function(componentType, defaulter) {
      ComponentModel.registerSubTypeDefaulter(componentType, defaulter);
    },
    registerPainter: function(painterType, PainterCtor) {
      registerPainter(painterType, PainterCtor);
    }
  };
  function use(ext) {
    if (isArray(ext)) {
      each$5(ext, function(singleExt) {
        use(singleExt);
      });
      return;
    }
    if (indexOf(extensions, ext) >= 0) {
      return;
    }
    extensions.push(ext);
    if (isFunction(ext)) {
      ext = {
        install: ext
      };
    }
    ext.install(extensionRegisters);
  }
  var modelInner = makeInner();
  var axisInner = makeInner();
  var AxisTickLabelComputingKind = {
    estimate: 1,
    determine: 2
  };
  function createAxisLabelsComputingContext(kind) {
    return {
      out: {
        noPxChangeTryDetermine: []
      },
      kind
    };
  }
  function tickValuesToNumbers(axis, values) {
    var nums = map$1(values, function(val) {
      return axis.scale.parse(val);
    });
    if (axis.type === "time" && nums.length > 0) {
      nums.sort();
      nums.unshift(nums[0]);
      nums.push(nums[nums.length - 1]);
    }
    return nums;
  }
  function createAxisLabels(axis, ctx) {
    var custom = axis.getLabelModel().get("customValues");
    if (custom) {
      var labelFormatter_1 = makeLabelFormatter(axis);
      var extent_1 = axis.scale.getExtent();
      var tickNumbers = tickValuesToNumbers(axis, custom);
      var ticks = filter(tickNumbers, function(val) {
        return val >= extent_1[0] && val <= extent_1[1];
      });
      return {
        labels: map$1(ticks, function(numval) {
          var tick = {
            value: numval
          };
          return {
            formattedLabel: labelFormatter_1(tick),
            rawLabel: axis.scale.getLabel(tick),
            tickValue: numval,
            time: void 0,
            "break": void 0
          };
        })
      };
    }
    return axis.type === "category" ? makeCategoryLabels(axis, ctx) : makeRealNumberLabels(axis);
  }
  function createAxisTicks(axis, tickModel, opt) {
    var custom = axis.getTickModel().get("customValues");
    if (custom) {
      var extent_2 = axis.scale.getExtent();
      var tickNumbers = tickValuesToNumbers(axis, custom);
      return {
        ticks: filter(tickNumbers, function(val) {
          return val >= extent_2[0] && val <= extent_2[1];
        })
      };
    }
    return axis.type === "category" ? makeCategoryTicks(axis, tickModel) : {
      ticks: map$1(axis.scale.getTicks(opt), function(tick) {
        return tick.value;
      })
    };
  }
  function makeCategoryLabels(axis, ctx) {
    var labelModel = axis.getLabelModel();
    var result = makeCategoryLabelsActually(axis, labelModel, ctx);
    return !labelModel.get("show") || axis.scale.isBlank() ? {
      labels: []
    } : result;
  }
  function makeCategoryLabelsActually(axis, labelModel, ctx) {
    var labelsCache = ensureCategoryLabelCache(axis);
    var optionLabelInterval = getOptionCategoryInterval(labelModel);
    var isEstimate = ctx.kind === AxisTickLabelComputingKind.estimate;
    if (!isEstimate) {
      var result_1 = axisCacheGet(labelsCache, optionLabelInterval);
      if (result_1) {
        return result_1;
      }
    }
    var labels;
    var numericLabelInterval;
    if (isFunction(optionLabelInterval)) {
      labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);
    } else {
      numericLabelInterval = optionLabelInterval === "auto" ? makeAutoCategoryInterval(axis, ctx) : optionLabelInterval;
      labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);
    }
    var result = {
      labels,
      labelCategoryInterval: numericLabelInterval
    };
    if (!isEstimate) {
      axisCacheSet(labelsCache, optionLabelInterval, result);
    } else {
      ctx.out.noPxChangeTryDetermine.push(function() {
        axisCacheSet(labelsCache, optionLabelInterval, result);
        return true;
      });
    }
    return result;
  }
  function makeCategoryTicks(axis, tickModel) {
    var ticksCache = ensureCategoryTickCache(axis);
    var optionTickInterval = getOptionCategoryInterval(tickModel);
    var result = axisCacheGet(ticksCache, optionTickInterval);
    if (result) {
      return result;
    }
    var ticks;
    var tickCategoryInterval;
    if (!tickModel.get("show") || axis.scale.isBlank()) {
      ticks = [];
    }
    if (isFunction(optionTickInterval)) {
      ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);
    } else if (optionTickInterval === "auto") {
      var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel(), createAxisLabelsComputingContext(AxisTickLabelComputingKind.determine));
      tickCategoryInterval = labelsResult.labelCategoryInterval;
      ticks = map$1(labelsResult.labels, function(labelItem) {
        return labelItem.tickValue;
      });
    } else {
      tickCategoryInterval = optionTickInterval;
      ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);
    }
    return axisCacheSet(ticksCache, optionTickInterval, {
      ticks,
      tickCategoryInterval
    });
  }
  function makeRealNumberLabels(axis) {
    var ticks = axis.scale.getTicks();
    var labelFormatter = makeLabelFormatter(axis);
    return {
      labels: map$1(ticks, function(tick, idx) {
        return {
          formattedLabel: labelFormatter(tick, idx),
          rawLabel: axis.scale.getLabel(tick),
          tickValue: tick.value,
          time: tick.time,
          "break": tick["break"]
        };
      })
    };
  }
  var ensureCategoryTickCache = initAxisCacheMethod("axisTick");
  var ensureCategoryLabelCache = initAxisCacheMethod("axisLabel");
  function initAxisCacheMethod(prop) {
    return function ensureCache(axis) {
      return axisInner(axis)[prop] || (axisInner(axis)[prop] = {
        list: []
      });
    };
  }
  function axisCacheGet(cache, key2) {
    for (var i = 0; i < cache.list.length; i++) {
      if (cache.list[i].key === key2) {
        return cache.list[i].value;
      }
    }
  }
  function axisCacheSet(cache, key2, value) {
    cache.list.push({
      key: key2,
      value
    });
    return value;
  }
  function makeAutoCategoryInterval(axis, ctx) {
    if (ctx.kind === AxisTickLabelComputingKind.estimate) {
      var result_2 = axis.calculateCategoryInterval(ctx);
      ctx.out.noPxChangeTryDetermine.push(function() {
        axisInner(axis).autoInterval = result_2;
        return true;
      });
      return result_2;
    }
    var result = axisInner(axis).autoInterval;
    return result != null ? result : axisInner(axis).autoInterval = axis.calculateCategoryInterval(ctx);
  }
  function calculateCategoryInterval(axis, ctx) {
    var kind = ctx.kind;
    var params = fetchAutoCategoryIntervalCalculationParams(axis);
    var labelFormatter = makeLabelFormatter(axis);
    var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;
    var ordinalScale = axis.scale;
    var ordinalExtent = ordinalScale.getExtent();
    var tickCount = ordinalScale.count();
    if (ordinalExtent[1] - ordinalExtent[0] < 1) {
      return 0;
    }
    var step = 1;
    var maxCount = 40;
    if (tickCount > maxCount) {
      step = Math.max(1, Math.floor(tickCount / maxCount));
    }
    var tickValue = ordinalExtent[0];
    var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
    var unitW = Math.abs(unitSpan * Math.cos(rotation));
    var unitH = Math.abs(unitSpan * Math.sin(rotation));
    var maxW = 0;
    var maxH = 0;
    for (; tickValue <= ordinalExtent[1]; tickValue += step) {
      var width = 0;
      var height = 0;
      var rect = getBoundingRect(labelFormatter({
        value: tickValue
      }), params.font, "center", "top");
      width = rect.width * 1.3;
      height = rect.height * 1.3;
      maxW = Math.max(maxW, width, 7);
      maxH = Math.max(maxH, height, 7);
    }
    var dw = maxW / unitW;
    var dh = maxH / unitH;
    isNaN(dw) && (dw = Infinity);
    isNaN(dh) && (dh = Infinity);
    var interval = Math.max(0, Math.floor(Math.min(dw, dh)));
    if (kind === AxisTickLabelComputingKind.estimate) {
      ctx.out.noPxChangeTryDetermine.push(bind$1(calculateCategoryIntervalTryDetermine, null, axis, interval, tickCount));
      return interval;
    }
    var lastInterval = calculateCategoryIntervalDealCache(axis, interval, tickCount);
    return lastInterval != null ? lastInterval : interval;
  }
  function calculateCategoryIntervalTryDetermine(axis, interval, tickCount) {
    return calculateCategoryIntervalDealCache(axis, interval, tickCount) == null;
  }
  function calculateCategoryIntervalDealCache(axis, interval, tickCount) {
    var cache = modelInner(axis.model);
    var axisExtent = axis.getExtent();
    var lastAutoInterval = cache.lastAutoInterval;
    var lastTickCount = cache.lastTickCount;
    if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval && cache.axisExtent0 === axisExtent[0] && cache.axisExtent1 === axisExtent[1]) {
      return lastAutoInterval;
    } else {
      cache.lastTickCount = tickCount;
      cache.lastAutoInterval = interval;
      cache.axisExtent0 = axisExtent[0];
      cache.axisExtent1 = axisExtent[1];
    }
  }
  function fetchAutoCategoryIntervalCalculationParams(axis) {
    var labelModel = axis.getLabelModel();
    return {
      axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,
      labelRotate: labelModel.get("rotate") || 0,
      font: labelModel.getFont()
    };
  }
  function makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {
    var labelFormatter = makeLabelFormatter(axis);
    var ordinalScale = axis.scale;
    var ordinalExtent = ordinalScale.getExtent();
    var labelModel = axis.getLabelModel();
    var result = [];
    var step = Math.max((categoryInterval || 0) + 1, 1);
    var startTick = ordinalExtent[0];
    var tickCount = ordinalScale.count();
    if (startTick !== 0 && step > 1 && tickCount / step > 2) {
      startTick = Math.round(Math.ceil(startTick / step) * step);
    }
    var showAllLabel = shouldShowAllLabels(axis);
    var includeMinLabel = labelModel.get("showMinLabel") || showAllLabel;
    var includeMaxLabel = labelModel.get("showMaxLabel") || showAllLabel;
    if (includeMinLabel && startTick !== ordinalExtent[0]) {
      addItem(ordinalExtent[0]);
    }
    var tickValue = startTick;
    for (; tickValue <= ordinalExtent[1]; tickValue += step) {
      addItem(tickValue);
    }
    if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {
      addItem(ordinalExtent[1]);
    }
    function addItem(tickValue2) {
      var tickObj = {
        value: tickValue2
      };
      result.push(onlyTick ? tickValue2 : {
        formattedLabel: labelFormatter(tickObj),
        rawLabel: ordinalScale.getLabel(tickObj),
        tickValue: tickValue2,
        time: void 0,
        "break": void 0
      });
    }
    return result;
  }
  function makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {
    var ordinalScale = axis.scale;
    var labelFormatter = makeLabelFormatter(axis);
    var result = [];
    each$5(ordinalScale.getTicks(), function(tick) {
      var rawLabel = ordinalScale.getLabel(tick);
      var tickValue = tick.value;
      if (categoryInterval(tick.value, rawLabel)) {
        result.push(onlyTick ? tickValue : {
          formattedLabel: labelFormatter(tick),
          rawLabel,
          tickValue,
          time: void 0,
          "break": void 0
        });
      }
    });
    return result;
  }
  var NORMALIZED_EXTENT = [0, 1];
  var Axis = (
    /** @class */
    function() {
      function Axis2(dim, scale2, extent) {
        this.onBand = false;
        this.inverse = false;
        this.dim = dim;
        this.scale = scale2;
        this._extent = extent || [0, 0];
      }
      Axis2.prototype.contain = function(coord) {
        var extent = this._extent;
        var min3 = Math.min(extent[0], extent[1]);
        var max3 = Math.max(extent[0], extent[1]);
        return coord >= min3 && coord <= max3;
      };
      Axis2.prototype.containData = function(data) {
        return this.scale.contain(this.scale.parse(data));
      };
      Axis2.prototype.getExtent = function() {
        return this._extent.slice();
      };
      Axis2.prototype.getPixelPrecision = function(dataExtent) {
        return getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
      };
      Axis2.prototype.setExtent = function(start2, end2) {
        var extent = this._extent;
        extent[0] = start2;
        extent[1] = end2;
      };
      Axis2.prototype.dataToCoord = function(data, clamp2) {
        var extent = this._extent;
        var scale2 = this.scale;
        data = scale2.normalize(scale2.parse(data));
        if (this.onBand && scale2.type === "ordinal") {
          extent = extent.slice();
          fixExtentWithBands(extent, scale2.count());
        }
        return linearMap(data, NORMALIZED_EXTENT, extent, clamp2);
      };
      Axis2.prototype.coordToData = function(coord, clamp2) {
        var extent = this._extent;
        var scale2 = this.scale;
        if (this.onBand && scale2.type === "ordinal") {
          extent = extent.slice();
          fixExtentWithBands(extent, scale2.count());
        }
        var t = linearMap(coord, extent, NORMALIZED_EXTENT, clamp2);
        return this.scale.scale(t);
      };
      Axis2.prototype.pointToData = function(point, clamp2) {
        return;
      };
      Axis2.prototype.getTicksCoords = function(opt) {
        opt = opt || {};
        var tickModel = opt.tickModel || this.getTickModel();
        var result = createAxisTicks(this, tickModel, {
          breakTicks: opt.breakTicks,
          pruneByBreak: opt.pruneByBreak
        });
        var ticks = result.ticks;
        var ticksCoords = map$1(ticks, function(tickVal) {
          return {
            coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(tickVal) : tickVal),
            tickValue: tickVal
          };
        }, this);
        var alignWithLabel = tickModel.get("alignWithLabel");
        fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);
        return ticksCoords;
      };
      Axis2.prototype.getMinorTicksCoords = function() {
        if (this.scale.type === "ordinal") {
          return [];
        }
        var minorTickModel = this.model.getModel("minorTick");
        var splitNumber = minorTickModel.get("splitNumber");
        if (!(splitNumber > 0 && splitNumber < 100)) {
          splitNumber = 5;
        }
        var minorTicks = this.scale.getMinorTicks(splitNumber);
        var minorTicksCoords = map$1(minorTicks, function(minorTicksGroup) {
          return map$1(minorTicksGroup, function(minorTick) {
            return {
              coord: this.dataToCoord(minorTick),
              tickValue: minorTick
            };
          }, this);
        }, this);
        return minorTicksCoords;
      };
      Axis2.prototype.getViewLabels = function(ctx) {
        ctx = ctx || createAxisLabelsComputingContext(AxisTickLabelComputingKind.determine);
        return createAxisLabels(this, ctx).labels;
      };
      Axis2.prototype.getLabelModel = function() {
        return this.model.getModel("axisLabel");
      };
      Axis2.prototype.getTickModel = function() {
        return this.model.getModel("axisTick");
      };
      Axis2.prototype.getBandWidth = function() {
        var axisExtent = this._extent;
        var dataExtent = this.scale.getExtent();
        var len2 = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);
        len2 === 0 && (len2 = 1);
        var size = Math.abs(axisExtent[1] - axisExtent[0]);
        return Math.abs(size) / len2;
      };
      Axis2.prototype.calculateCategoryInterval = function(ctx) {
        ctx = ctx || createAxisLabelsComputingContext(AxisTickLabelComputingKind.determine);
        return calculateCategoryInterval(this, ctx);
      };
      return Axis2;
    }()
  );
  function fixExtentWithBands(extent, nTick) {
    var size = extent[1] - extent[0];
    var len2 = nTick;
    var margin = size / len2 / 2;
    extent[0] += margin;
    extent[1] -= margin;
  }
  function fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp2) {
    var ticksLen = ticksCoords.length;
    if (!axis.onBand || alignWithLabel || !ticksLen) {
      return;
    }
    var axisExtent = axis.getExtent();
    var last;
    var diffSize;
    if (ticksLen === 1) {
      ticksCoords[0].coord = axisExtent[0];
      ticksCoords[0].onBand = true;
      last = ticksCoords[1] = {
        coord: axisExtent[1],
        tickValue: ticksCoords[0].tickValue,
        onBand: true
      };
    } else {
      var crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;
      var shift_1 = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;
      each$5(ticksCoords, function(ticksItem) {
        ticksItem.coord -= shift_1 / 2;
        ticksItem.onBand = true;
      });
      var dataExtent = axis.scale.getExtent();
      diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;
      last = {
        coord: ticksCoords[ticksLen - 1].coord + shift_1 * diffSize,
        tickValue: dataExtent[1] + 1,
        onBand: true
      };
      ticksCoords.push(last);
    }
    var inverse = axisExtent[0] > axisExtent[1];
    if (littleThan(ticksCoords[0].coord, axisExtent[0])) {
      clamp2 ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();
    }
    if (clamp2 && littleThan(axisExtent[0], ticksCoords[0].coord)) {
      ticksCoords.unshift({
        coord: axisExtent[0],
        onBand: true
      });
    }
    if (littleThan(axisExtent[1], last.coord)) {
      clamp2 ? last.coord = axisExtent[1] : ticksCoords.pop();
    }
    if (clamp2 && littleThan(last.coord, axisExtent[1])) {
      ticksCoords.push({
        coord: axisExtent[1],
        onBand: true
      });
    }
    function littleThan(a, b) {
      a = round$1(a);
      b = round$1(b);
      return inverse ? a > b : a < b;
    }
  }
  var LABEL_LAYOUT_BASE_PROPS = ["label", "labelLine", "layoutOption", "priority", "defaultAttr", "marginForce", "minMarginForce", "marginDefault", "suggestIgnore"];
  var LABEL_LAYOUT_DIRTY_BIT_OTHERS = 1;
  var LABEL_LAYOUT_DIRTY_BIT_OBB = 2;
  var LABEL_LAYOUT_DIRTY_ALL = LABEL_LAYOUT_DIRTY_BIT_OTHERS | LABEL_LAYOUT_DIRTY_BIT_OBB;
  function setLabelLayoutDirty(labelGeometry, dirtyOrClear, dirtyBits) {
    dirtyBits = dirtyBits || LABEL_LAYOUT_DIRTY_ALL;
    dirtyOrClear ? labelGeometry.dirty |= dirtyBits : labelGeometry.dirty &= ~dirtyBits;
  }
  function isLabelLayoutDirty(labelGeometry, dirtyBits) {
    dirtyBits = dirtyBits || LABEL_LAYOUT_DIRTY_ALL;
    return labelGeometry.dirty == null || !!(labelGeometry.dirty & dirtyBits);
  }
  function ensureLabelLayoutWithGeometry(labelLayout) {
    if (!labelLayout) {
      return;
    }
    if (isLabelLayoutDirty(labelLayout)) {
      computeLabelGeometry(labelLayout, labelLayout.label, labelLayout);
    }
    return labelLayout;
  }
  function computeLabelGeometry(out2, label, opt) {
    var rawTransform = label.getComputedTransform();
    out2.transform = ensureCopyTransform(out2.transform, rawTransform);
    var outLocalRect = out2.localRect = ensureCopyRect(out2.localRect, label.getBoundingRect());
    var labelStyleExt = label.style;
    var margin = labelStyleExt.margin;
    var marginForce = opt && opt.marginForce;
    var minMarginForce = opt && opt.minMarginForce;
    var marginDefault = opt && opt.marginDefault;
    var marginType = labelStyleExt.__marginType;
    if (marginType == null && marginDefault) {
      margin = marginDefault;
      marginType = LabelMarginType.textMargin;
    }
    for (var i = 0; i < 4; i++) {
      _tmpLabelMargin[i] = marginType === LabelMarginType.minMargin && minMarginForce && minMarginForce[i] != null ? minMarginForce[i] : marginForce && marginForce[i] != null ? marginForce[i] : margin ? margin[i] : 0;
    }
    if (marginType === LabelMarginType.textMargin) {
      expandOrShrinkRect(outLocalRect, _tmpLabelMargin, false, false);
    }
    var outGlobalRect = out2.rect = ensureCopyRect(out2.rect, outLocalRect);
    if (rawTransform) {
      outGlobalRect.applyTransform(rawTransform);
    }
    if (marginType === LabelMarginType.minMargin) {
      expandOrShrinkRect(outGlobalRect, _tmpLabelMargin, false, false);
    }
    out2.axisAligned = isBoundingRectAxisAligned(rawTransform);
    (out2.label = out2.label || {}).ignore = label.ignore;
    setLabelLayoutDirty(out2, false);
    setLabelLayoutDirty(out2, true, LABEL_LAYOUT_DIRTY_BIT_OBB);
    return out2;
  }
  var _tmpLabelMargin = [0, 0, 0, 0];
  function computeLabelGeometry2(out2, rawLocalRect, rawTransform) {
    out2.transform = ensureCopyTransform(out2.transform, rawTransform);
    out2.localRect = ensureCopyRect(out2.localRect, rawLocalRect);
    out2.rect = ensureCopyRect(out2.rect, rawLocalRect);
    if (rawTransform) {
      out2.rect.applyTransform(rawTransform);
    }
    out2.axisAligned = isBoundingRectAxisAligned(rawTransform);
    out2.obb = void 0;
    (out2.label = out2.label || {}).ignore = false;
    return out2;
  }
  function labelLayoutApplyTranslation(labelLayout, offset) {
    if (!labelLayout) {
      return;
    }
    labelLayout.label.x += offset.x;
    labelLayout.label.y += offset.y;
    labelLayout.label.markRedraw();
    var transform = labelLayout.transform;
    if (transform) {
      transform[4] += offset.x;
      transform[5] += offset.y;
    }
    var globalRect = labelLayout.rect;
    if (globalRect) {
      globalRect.x += offset.x;
      globalRect.y += offset.y;
    }
    var obb = labelLayout.obb;
    if (obb) {
      obb.fromBoundingRect(labelLayout.localRect, transform);
    }
  }
  function newLabelLayoutWithGeometry(newBaseWithDefaults, source) {
    for (var i = 0; i < LABEL_LAYOUT_BASE_PROPS.length; i++) {
      var prop = LABEL_LAYOUT_BASE_PROPS[i];
      if (newBaseWithDefaults[prop] == null) {
        newBaseWithDefaults[prop] = source[prop];
      }
    }
    return ensureLabelLayoutWithGeometry(newBaseWithDefaults);
  }
  function ensureOBB(labelGeometry) {
    var obb = labelGeometry.obb;
    if (!obb || isLabelLayoutDirty(labelGeometry, LABEL_LAYOUT_DIRTY_BIT_OBB)) {
      labelGeometry.obb = obb = obb || new OrientedBoundingRect();
      obb.fromBoundingRect(labelGeometry.localRect, labelGeometry.transform);
      setLabelLayoutDirty(labelGeometry, false, LABEL_LAYOUT_DIRTY_BIT_OBB);
    }
    return obb;
  }
  function hideOverlap(labelList) {
    var displayedLabels = [];
    labelList.sort(function(a, b) {
      return (b.suggestIgnore ? 1 : 0) - (a.suggestIgnore ? 1 : 0) || b.priority - a.priority;
    });
    function hideEl(el) {
      if (!el.ignore) {
        var emphasisState = el.ensureState("emphasis");
        if (emphasisState.ignore == null) {
          emphasisState.ignore = false;
        }
      }
      el.ignore = true;
    }
    for (var i = 0; i < labelList.length; i++) {
      var labelItem = ensureLabelLayoutWithGeometry(labelList[i]);
      if (labelItem.label.ignore) {
        continue;
      }
      var label = labelItem.label;
      var labelLine = labelItem.labelLine;
      var overlapped = false;
      for (var j = 0; j < displayedLabels.length; j++) {
        if (labelIntersect(labelItem, displayedLabels[j], null, {
          touchThreshold: 0.05
        })) {
          overlapped = true;
          break;
        }
      }
      if (overlapped) {
        hideEl(label);
        labelLine && hideEl(labelLine);
      } else {
        displayedLabels.push(labelItem);
      }
    }
  }
  function labelIntersect(baseLayoutInfo, targetLayoutInfo, mtv, intersectOpt) {
    if (!baseLayoutInfo || !targetLayoutInfo) {
      return false;
    }
    if (baseLayoutInfo.label && baseLayoutInfo.label.ignore || targetLayoutInfo.label && targetLayoutInfo.label.ignore) {
      return false;
    }
    if (!baseLayoutInfo.rect.intersect(targetLayoutInfo.rect, mtv, intersectOpt)) {
      return false;
    }
    if (baseLayoutInfo.axisAligned && targetLayoutInfo.axisAligned) {
      return true;
    }
    return ensureOBB(baseLayoutInfo).intersect(ensureOBB(targetLayoutInfo), mtv, intersectOpt);
  }
  function createDom(id, painter, dpr2) {
    var newDom = platformApi.createCanvas();
    var width = painter.getWidth();
    var height = painter.getHeight();
    var newDomStyle = newDom.style;
    if (newDomStyle) {
      newDomStyle.position = "absolute";
      newDomStyle.left = "0";
      newDomStyle.top = "0";
      newDomStyle.width = width + "px";
      newDomStyle.height = height + "px";
      newDom.setAttribute("data-zr-dom-id", id);
    }
    newDom.width = width * dpr2;
    newDom.height = height * dpr2;
    return newDom;
  }
  var Layer = function(_super) {
    __extends(Layer2, _super);
    function Layer2(id, painter, dpr2) {
      var _this = _super.call(this) || this;
      _this.motionBlur = false;
      _this.lastFrameAlpha = 0.7;
      _this.dpr = 1;
      _this.virtual = false;
      _this.config = {};
      _this.incremental = false;
      _this.zlevel = 0;
      _this.maxRepaintRectCount = 5;
      _this.__dirty = true;
      _this.__firstTimePaint = true;
      _this.__used = false;
      _this.__drawIndex = 0;
      _this.__startIndex = 0;
      _this.__endIndex = 0;
      _this.__prevStartIndex = null;
      _this.__prevEndIndex = null;
      var dom;
      dpr2 = dpr2 || devicePixelRatio;
      if (typeof id === "string") {
        dom = createDom(id, painter, dpr2);
      } else if (isObject$2(id)) {
        dom = id;
        id = dom.id;
      }
      _this.id = id;
      _this.dom = dom;
      var domStyle = dom.style;
      if (domStyle) {
        disableUserSelect(dom);
        dom.onselectstart = function() {
          return false;
        };
        domStyle.padding = "0";
        domStyle.margin = "0";
        domStyle.borderWidth = "0";
      }
      _this.painter = painter;
      _this.dpr = dpr2;
      return _this;
    }
    Layer2.prototype.getElementCount = function() {
      return this.__endIndex - this.__startIndex;
    };
    Layer2.prototype.afterBrush = function() {
      this.__prevStartIndex = this.__startIndex;
      this.__prevEndIndex = this.__endIndex;
    };
    Layer2.prototype.initContext = function() {
      this.ctx = this.dom.getContext("2d");
      this.ctx.dpr = this.dpr;
    };
    Layer2.prototype.setUnpainted = function() {
      this.__firstTimePaint = true;
    };
    Layer2.prototype.createBackBuffer = function() {
      var dpr2 = this.dpr;
      this.domBack = createDom("back-" + this.id, this.painter, dpr2);
      this.ctxBack = this.domBack.getContext("2d");
      if (dpr2 !== 1) {
        this.ctxBack.scale(dpr2, dpr2);
      }
    };
    Layer2.prototype.createRepaintRects = function(displayList, prevList, viewWidth, viewHeight) {
      if (this.__firstTimePaint) {
        this.__firstTimePaint = false;
        return null;
      }
      var mergedRepaintRects = [];
      var maxRepaintRectCount = this.maxRepaintRectCount;
      var full = false;
      var pendingRect = new BoundingRect(0, 0, 0, 0);
      function addRectToMergePool(rect) {
        if (!rect.isFinite() || rect.isZero()) {
          return;
        }
        if (mergedRepaintRects.length === 0) {
          var boundingRect = new BoundingRect(0, 0, 0, 0);
          boundingRect.copy(rect);
          mergedRepaintRects.push(boundingRect);
        } else {
          var isMerged = false;
          var minDeltaArea = Infinity;
          var bestRectToMergeIdx = 0;
          for (var i2 = 0; i2 < mergedRepaintRects.length; ++i2) {
            var mergedRect = mergedRepaintRects[i2];
            if (mergedRect.intersect(rect)) {
              var pendingRect_1 = new BoundingRect(0, 0, 0, 0);
              pendingRect_1.copy(mergedRect);
              pendingRect_1.union(rect);
              mergedRepaintRects[i2] = pendingRect_1;
              isMerged = true;
              break;
            } else if (full) {
              pendingRect.copy(rect);
              pendingRect.union(mergedRect);
              var aArea = rect.width * rect.height;
              var bArea = mergedRect.width * mergedRect.height;
              var pendingArea = pendingRect.width * pendingRect.height;
              var deltaArea = pendingArea - aArea - bArea;
              if (deltaArea < minDeltaArea) {
                minDeltaArea = deltaArea;
                bestRectToMergeIdx = i2;
              }
            }
          }
          if (full) {
            mergedRepaintRects[bestRectToMergeIdx].union(rect);
            isMerged = true;
          }
          if (!isMerged) {
            var boundingRect = new BoundingRect(0, 0, 0, 0);
            boundingRect.copy(rect);
            mergedRepaintRects.push(boundingRect);
          }
          if (!full) {
            full = mergedRepaintRects.length >= maxRepaintRectCount;
          }
        }
      }
      for (var i = this.__startIndex; i < this.__endIndex; ++i) {
        var el = displayList[i];
        if (el) {
          var shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true);
          var prevRect = el.__isRendered && (el.__dirty & REDRAW_BIT || !shouldPaint) ? el.getPrevPaintRect() : null;
          if (prevRect) {
            addRectToMergePool(prevRect);
          }
          var curRect = shouldPaint && (el.__dirty & REDRAW_BIT || !el.__isRendered) ? el.getPaintRect() : null;
          if (curRect) {
            addRectToMergePool(curRect);
          }
        }
      }
      for (var i = this.__prevStartIndex; i < this.__prevEndIndex; ++i) {
        var el = prevList[i];
        var shouldPaint = el && el.shouldBePainted(viewWidth, viewHeight, true, true);
        if (el && (!shouldPaint || !el.__zr) && el.__isRendered) {
          var prevRect = el.getPrevPaintRect();
          if (prevRect) {
            addRectToMergePool(prevRect);
          }
        }
      }
      var hasIntersections;
      do {
        hasIntersections = false;
        for (var i = 0; i < mergedRepaintRects.length; ) {
          if (mergedRepaintRects[i].isZero()) {
            mergedRepaintRects.splice(i, 1);
            continue;
          }
          for (var j = i + 1; j < mergedRepaintRects.length; ) {
            if (mergedRepaintRects[i].intersect(mergedRepaintRects[j])) {
              hasIntersections = true;
              mergedRepaintRects[i].union(mergedRepaintRects[j]);
              mergedRepaintRects.splice(j, 1);
            } else {
              j++;
            }
          }
          i++;
        }
      } while (hasIntersections);
      this._paintRects = mergedRepaintRects;
      return mergedRepaintRects;
    };
    Layer2.prototype.debugGetPaintRects = function() {
      return (this._paintRects || []).slice();
    };
    Layer2.prototype.resize = function(width, height) {
      var dpr2 = this.dpr;
      var dom = this.dom;
      var domStyle = dom.style;
      var domBack = this.domBack;
      if (domStyle) {
        domStyle.width = width + "px";
        domStyle.height = height + "px";
      }
      dom.width = width * dpr2;
      dom.height = height * dpr2;
      if (domBack) {
        domBack.width = width * dpr2;
        domBack.height = height * dpr2;
        if (dpr2 !== 1) {
          this.ctxBack.scale(dpr2, dpr2);
        }
      }
    };
    Layer2.prototype.clear = function(clearAll, clearColor, repaintRects) {
      var dom = this.dom;
      var ctx = this.ctx;
      var width = dom.width;
      var height = dom.height;
      clearColor = clearColor || this.clearColor;
      var haveMotionBLur = this.motionBlur && !clearAll;
      var lastFrameAlpha = this.lastFrameAlpha;
      var dpr2 = this.dpr;
      var self2 = this;
      if (haveMotionBLur) {
        if (!this.domBack) {
          this.createBackBuffer();
        }
        this.ctxBack.globalCompositeOperation = "copy";
        this.ctxBack.drawImage(dom, 0, 0, width / dpr2, height / dpr2);
      }
      var domBack = this.domBack;
      function doClear(x, y, width2, height2) {
        ctx.clearRect(x, y, width2, height2);
        if (clearColor && clearColor !== "transparent") {
          var clearColorGradientOrPattern = void 0;
          if (isGradientObject(clearColor)) {
            var shouldCache = clearColor.global || clearColor.__width === width2 && clearColor.__height === height2;
            clearColorGradientOrPattern = shouldCache && clearColor.__canvasGradient || getCanvasGradient(ctx, clearColor, {
              x: 0,
              y: 0,
              width: width2,
              height: height2
            });
            clearColor.__canvasGradient = clearColorGradientOrPattern;
            clearColor.__width = width2;
            clearColor.__height = height2;
          } else if (isImagePatternObject(clearColor)) {
            clearColor.scaleX = clearColor.scaleX || dpr2;
            clearColor.scaleY = clearColor.scaleY || dpr2;
            clearColorGradientOrPattern = createCanvasPattern(ctx, clearColor, {
              dirty: function() {
                self2.setUnpainted();
                self2.painter.refresh();
              }
            });
          }
          ctx.save();
          ctx.fillStyle = clearColorGradientOrPattern || clearColor;
          ctx.fillRect(x, y, width2, height2);
          ctx.restore();
        }
        if (haveMotionBLur) {
          ctx.save();
          ctx.globalAlpha = lastFrameAlpha;
          ctx.drawImage(domBack, x, y, width2, height2);
          ctx.restore();
        }
      }
      if (!repaintRects || haveMotionBLur) {
        doClear(0, 0, width, height);
      } else if (repaintRects.length) {
        each$5(repaintRects, function(rect) {
          doClear(rect.x * dpr2, rect.y * dpr2, rect.width * dpr2, rect.height * dpr2);
        });
      }
    };
    return Layer2;
  }(Eventful);
  var define_process_env_default$c = {};
  var HOVER_LAYER_ZLEVEL = 1e5;
  var CANVAS_ZLEVEL = 314159;
  var EL_AFTER_INCREMENTAL_INC = 0.01;
  var INCREMENTAL_INC = 1e-3;
  function isLayerValid(layer) {
    if (!layer) {
      return false;
    }
    if (layer.__builtin__) {
      return true;
    }
    if (typeof layer.resize !== "function" || typeof layer.refresh !== "function") {
      return false;
    }
    return true;
  }
  function createRoot(width, height) {
    var domRoot = document.createElement("div");
    domRoot.style.cssText = [
      "position:relative",
      "width:" + width + "px",
      "height:" + height + "px",
      "padding:0",
      "margin:0",
      "border-width:0"
    ].join(";") + ";";
    return domRoot;
  }
  var CanvasPainter = function() {
    function CanvasPainter2(root, storage, opts, id) {
      this.type = "canvas";
      this._zlevelList = [];
      this._prevDisplayList = [];
      this._layers = {};
      this._layerConfig = {};
      this._needsManuallyCompositing = false;
      this.type = "canvas";
      var singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === "CANVAS";
      this._opts = opts = extend({}, opts || {});
      this.dpr = opts.devicePixelRatio || devicePixelRatio;
      this._singleCanvas = singleCanvas;
      this.root = root;
      var rootStyle = root.style;
      if (rootStyle) {
        disableUserSelect(root);
        root.innerHTML = "";
      }
      this.storage = storage;
      var zlevelList = this._zlevelList;
      this._prevDisplayList = [];
      var layers = this._layers;
      if (!singleCanvas) {
        this._width = getSize(root, 0, opts);
        this._height = getSize(root, 1, opts);
        var domRoot = this._domRoot = createRoot(this._width, this._height);
        root.appendChild(domRoot);
      } else {
        var rootCanvas = root;
        var width = rootCanvas.width;
        var height = rootCanvas.height;
        if (opts.width != null) {
          width = opts.width;
        }
        if (opts.height != null) {
          height = opts.height;
        }
        this.dpr = opts.devicePixelRatio || 1;
        rootCanvas.width = width * this.dpr;
        rootCanvas.height = height * this.dpr;
        this._width = width;
        this._height = height;
        var mainLayer = new Layer(rootCanvas, this, this.dpr);
        mainLayer.__builtin__ = true;
        mainLayer.initContext();
        layers[CANVAS_ZLEVEL] = mainLayer;
        mainLayer.zlevel = CANVAS_ZLEVEL;
        zlevelList.push(CANVAS_ZLEVEL);
        this._domRoot = root;
      }
    }
    CanvasPainter2.prototype.getType = function() {
      return "canvas";
    };
    CanvasPainter2.prototype.isSingleCanvas = function() {
      return this._singleCanvas;
    };
    CanvasPainter2.prototype.getViewportRoot = function() {
      return this._domRoot;
    };
    CanvasPainter2.prototype.getViewportRootOffset = function() {
      var viewportRoot = this.getViewportRoot();
      if (viewportRoot) {
        return {
          offsetLeft: viewportRoot.offsetLeft || 0,
          offsetTop: viewportRoot.offsetTop || 0
        };
      }
    };
    CanvasPainter2.prototype.refresh = function(paintAll) {
      var list = this.storage.getDisplayList(true);
      var prevList = this._prevDisplayList;
      var zlevelList = this._zlevelList;
      this._redrawId = Math.random();
      this._paintList(list, prevList, paintAll, this._redrawId);
      for (var i = 0; i < zlevelList.length; i++) {
        var z = zlevelList[i];
        var layer = this._layers[z];
        if (!layer.__builtin__ && layer.refresh) {
          var clearColor = i === 0 ? this._backgroundColor : null;
          layer.refresh(clearColor);
        }
      }
      if (this._opts.useDirtyRect) {
        this._prevDisplayList = list.slice();
      }
      return this;
    };
    CanvasPainter2.prototype.refreshHover = function() {
      this._paintHoverList(this.storage.getDisplayList(false));
    };
    CanvasPainter2.prototype._paintHoverList = function(list) {
      var len2 = list.length;
      var hoverLayer = this._hoverlayer;
      hoverLayer && hoverLayer.clear();
      if (!len2) {
        return;
      }
      var scope = {
        inHover: true,
        viewWidth: this._width,
        viewHeight: this._height
      };
      var ctx;
      for (var i = 0; i < len2; i++) {
        var el = list[i];
        if (el.__inHover) {
          if (!hoverLayer) {
            hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);
          }
          if (!ctx) {
            ctx = hoverLayer.ctx;
            ctx.save();
          }
          brush(ctx, el, scope, i === len2 - 1);
        }
      }
      if (ctx) {
        ctx.restore();
      }
    };
    CanvasPainter2.prototype.getHoverLayer = function() {
      return this.getLayer(HOVER_LAYER_ZLEVEL);
    };
    CanvasPainter2.prototype.paintOne = function(ctx, el) {
      brushSingle(ctx, el);
    };
    CanvasPainter2.prototype._paintList = function(list, prevList, paintAll, redrawId) {
      if (this._redrawId !== redrawId) {
        return;
      }
      paintAll = paintAll || false;
      this._updateLayerStatus(list);
      var _a2 = this._doPaintList(list, prevList, paintAll), finished = _a2.finished, needsRefreshHover = _a2.needsRefreshHover;
      if (this._needsManuallyCompositing) {
        this._compositeManually();
      }
      if (needsRefreshHover) {
        this._paintHoverList(list);
      }
      if (!finished) {
        var self_1 = this;
        requestAnimationFrame(function() {
          self_1._paintList(list, prevList, paintAll, redrawId);
        });
      } else {
        this.eachLayer(function(layer) {
          layer.afterBrush && layer.afterBrush();
        });
      }
    };
    CanvasPainter2.prototype._compositeManually = function() {
      var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;
      var width = this._domRoot.width;
      var height = this._domRoot.height;
      ctx.clearRect(0, 0, width, height);
      this.eachBuiltinLayer(function(layer) {
        if (layer.virtual) {
          ctx.drawImage(layer.dom, 0, 0, width, height);
        }
      });
    };
    CanvasPainter2.prototype._doPaintList = function(list, prevList, paintAll) {
      var _this = this;
      var layerList = [];
      var useDirtyRect = this._opts.useDirtyRect;
      for (var zi = 0; zi < this._zlevelList.length; zi++) {
        var zlevel = this._zlevelList[zi];
        var layer = this._layers[zlevel];
        if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {
          layerList.push(layer);
        }
      }
      var finished = true;
      var needsRefreshHover = false;
      var _loop_1 = function(k2) {
        var layer2 = layerList[k2];
        var ctx = layer2.ctx;
        var repaintRects = useDirtyRect && layer2.createRepaintRects(list, prevList, this_1._width, this_1._height);
        var start2 = paintAll ? layer2.__startIndex : layer2.__drawIndex;
        var useTimer = !paintAll && layer2.incremental && Date.now;
        var startTime = useTimer && Date.now();
        var clearColor = layer2.zlevel === this_1._zlevelList[0] ? this_1._backgroundColor : null;
        if (layer2.__startIndex === layer2.__endIndex) {
          layer2.clear(false, clearColor, repaintRects);
        } else if (start2 === layer2.__startIndex) {
          var firstEl = list[start2];
          if (!firstEl.incremental || !firstEl.notClear || paintAll) {
            layer2.clear(false, clearColor, repaintRects);
          }
        }
        if (start2 === -1) {
          console.error("For some unknown reason. drawIndex is -1");
          start2 = layer2.__startIndex;
        }
        var i;
        var repaint = function(repaintRect) {
          var scope = {
            inHover: false,
            allClipped: false,
            prevEl: null,
            viewWidth: _this._width,
            viewHeight: _this._height
          };
          for (i = start2; i < layer2.__endIndex; i++) {
            var el = list[i];
            if (el.__inHover) {
              needsRefreshHover = true;
            }
            _this._doPaintEl(el, layer2, useDirtyRect, repaintRect, scope, i === layer2.__endIndex - 1);
            if (useTimer) {
              var dTime = Date.now() - startTime;
              if (dTime > 15) {
                break;
              }
            }
          }
          if (scope.prevElClipPaths) {
            ctx.restore();
          }
        };
        if (repaintRects) {
          if (repaintRects.length === 0) {
            i = layer2.__endIndex;
          } else {
            var dpr2 = this_1.dpr;
            for (var r = 0; r < repaintRects.length; ++r) {
              var rect = repaintRects[r];
              ctx.save();
              ctx.beginPath();
              ctx.rect(rect.x * dpr2, rect.y * dpr2, rect.width * dpr2, rect.height * dpr2);
              ctx.clip();
              repaint(rect);
              ctx.restore();
            }
          }
        } else {
          ctx.save();
          repaint();
          ctx.restore();
        }
        layer2.__drawIndex = i;
        if (layer2.__drawIndex < layer2.__endIndex) {
          finished = false;
        }
      };
      var this_1 = this;
      for (var k = 0; k < layerList.length; k++) {
        _loop_1(k);
      }
      if (env.wxa) {
        each$5(this._layers, function(layer2) {
          if (layer2 && layer2.ctx && layer2.ctx.draw) {
            layer2.ctx.draw();
          }
        });
      }
      return {
        finished,
        needsRefreshHover
      };
    };
    CanvasPainter2.prototype._doPaintEl = function(el, currentLayer, useDirtyRect, repaintRect, scope, isLast) {
      var ctx = currentLayer.ctx;
      if (useDirtyRect) {
        var paintRect = el.getPaintRect();
        if (!repaintRect || paintRect && paintRect.intersect(repaintRect)) {
          brush(ctx, el, scope, isLast);
          el.setPrevPaintRect(paintRect);
        }
      } else {
        brush(ctx, el, scope, isLast);
      }
    };
    CanvasPainter2.prototype.getLayer = function(zlevel, virtual) {
      if (this._singleCanvas && !this._needsManuallyCompositing) {
        zlevel = CANVAS_ZLEVEL;
      }
      var layer = this._layers[zlevel];
      if (!layer) {
        layer = new Layer("zr_" + zlevel, this, this.dpr);
        layer.zlevel = zlevel;
        layer.__builtin__ = true;
        if (this._layerConfig[zlevel]) {
          merge(layer, this._layerConfig[zlevel], true);
        } else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {
          merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);
        }
        if (virtual) {
          layer.virtual = virtual;
        }
        this.insertLayer(zlevel, layer);
        layer.initContext();
      }
      return layer;
    };
    CanvasPainter2.prototype.insertLayer = function(zlevel, layer) {
      var layersMap = this._layers;
      var zlevelList = this._zlevelList;
      var len2 = zlevelList.length;
      var domRoot = this._domRoot;
      var prevLayer = null;
      var i = -1;
      if (layersMap[zlevel]) {
        if (define_process_env_default$c.NODE_ENV !== "production") {
          logError("ZLevel " + zlevel + " has been used already");
        }
        return;
      }
      if (!isLayerValid(layer)) {
        if (define_process_env_default$c.NODE_ENV !== "production") {
          logError("Layer of zlevel " + zlevel + " is not valid");
        }
        return;
      }
      if (len2 > 0 && zlevel > zlevelList[0]) {
        for (i = 0; i < len2 - 1; i++) {
          if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
            break;
          }
        }
        prevLayer = layersMap[zlevelList[i]];
      }
      zlevelList.splice(i + 1, 0, zlevel);
      layersMap[zlevel] = layer;
      if (!layer.virtual) {
        if (prevLayer) {
          var prevDom = prevLayer.dom;
          if (prevDom.nextSibling) {
            domRoot.insertBefore(layer.dom, prevDom.nextSibling);
          } else {
            domRoot.appendChild(layer.dom);
          }
        } else {
          if (domRoot.firstChild) {
            domRoot.insertBefore(layer.dom, domRoot.firstChild);
          } else {
            domRoot.appendChild(layer.dom);
          }
        }
      }
      layer.painter || (layer.painter = this);
    };
    CanvasPainter2.prototype.eachLayer = function(cb, context) {
      var zlevelList = this._zlevelList;
      for (var i = 0; i < zlevelList.length; i++) {
        var z = zlevelList[i];
        cb.call(context, this._layers[z], z);
      }
    };
    CanvasPainter2.prototype.eachBuiltinLayer = function(cb, context) {
      var zlevelList = this._zlevelList;
      for (var i = 0; i < zlevelList.length; i++) {
        var z = zlevelList[i];
        var layer = this._layers[z];
        if (layer.__builtin__) {
          cb.call(context, layer, z);
        }
      }
    };
    CanvasPainter2.prototype.eachOtherLayer = function(cb, context) {
      var zlevelList = this._zlevelList;
      for (var i = 0; i < zlevelList.length; i++) {
        var z = zlevelList[i];
        var layer = this._layers[z];
        if (!layer.__builtin__) {
          cb.call(context, layer, z);
        }
      }
    };
    CanvasPainter2.prototype.getLayers = function() {
      return this._layers;
    };
    CanvasPainter2.prototype._updateLayerStatus = function(list) {
      this.eachBuiltinLayer(function(layer2, z) {
        layer2.__dirty = layer2.__used = false;
      });
      function updatePrevLayer(idx) {
        if (prevLayer) {
          if (prevLayer.__endIndex !== idx) {
            prevLayer.__dirty = true;
          }
          prevLayer.__endIndex = idx;
        }
      }
      if (this._singleCanvas) {
        for (var i_1 = 1; i_1 < list.length; i_1++) {
          var el = list[i_1];
          if (el.zlevel !== list[i_1 - 1].zlevel || el.incremental) {
            this._needsManuallyCompositing = true;
            break;
          }
        }
      }
      var prevLayer = null;
      var incrementalLayerCount = 0;
      var prevZlevel;
      var i;
      for (i = 0; i < list.length; i++) {
        var el = list[i];
        var zlevel = el.zlevel;
        var layer = void 0;
        if (prevZlevel !== zlevel) {
          prevZlevel = zlevel;
          incrementalLayerCount = 0;
        }
        if (el.incremental) {
          layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);
          layer.incremental = true;
          incrementalLayerCount = 1;
        } else {
          layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);
        }
        if (!layer.__builtin__) {
          logError("ZLevel " + zlevel + " has been used by unkown layer " + layer.id);
        }
        if (layer !== prevLayer) {
          layer.__used = true;
          if (layer.__startIndex !== i) {
            layer.__dirty = true;
          }
          layer.__startIndex = i;
          if (!layer.incremental) {
            layer.__drawIndex = i;
          } else {
            layer.__drawIndex = -1;
          }
          updatePrevLayer(i);
          prevLayer = layer;
        }
        if (el.__dirty & REDRAW_BIT && !el.__inHover) {
          layer.__dirty = true;
          if (layer.incremental && layer.__drawIndex < 0) {
            layer.__drawIndex = i;
          }
        }
      }
      updatePrevLayer(i);
      this.eachBuiltinLayer(function(layer2, z) {
        if (!layer2.__used && layer2.getElementCount() > 0) {
          layer2.__dirty = true;
          layer2.__startIndex = layer2.__endIndex = layer2.__drawIndex = 0;
        }
        if (layer2.__dirty && layer2.__drawIndex < 0) {
          layer2.__drawIndex = layer2.__startIndex;
        }
      });
    };
    CanvasPainter2.prototype.clear = function() {
      this.eachBuiltinLayer(this._clearLayer);
      return this;
    };
    CanvasPainter2.prototype._clearLayer = function(layer) {
      layer.clear();
    };
    CanvasPainter2.prototype.setBackgroundColor = function(backgroundColor2) {
      this._backgroundColor = backgroundColor2;
      each$5(this._layers, function(layer) {
        layer.setUnpainted();
      });
    };
    CanvasPainter2.prototype.configLayer = function(zlevel, config) {
      if (config) {
        var layerConfig = this._layerConfig;
        if (!layerConfig[zlevel]) {
          layerConfig[zlevel] = config;
        } else {
          merge(layerConfig[zlevel], config, true);
        }
        for (var i = 0; i < this._zlevelList.length; i++) {
          var _zlevel = this._zlevelList[i];
          if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {
            var layer = this._layers[_zlevel];
            merge(layer, layerConfig[zlevel], true);
          }
        }
      }
    };
    CanvasPainter2.prototype.delLayer = function(zlevel) {
      var layers = this._layers;
      var zlevelList = this._zlevelList;
      var layer = layers[zlevel];
      if (!layer) {
        return;
      }
      layer.dom.parentNode.removeChild(layer.dom);
      delete layers[zlevel];
      zlevelList.splice(indexOf(zlevelList, zlevel), 1);
    };
    CanvasPainter2.prototype.resize = function(width, height) {
      if (!this._domRoot.style) {
        if (width == null || height == null) {
          return;
        }
        this._width = width;
        this._height = height;
        this.getLayer(CANVAS_ZLEVEL).resize(width, height);
      } else {
        var domRoot = this._domRoot;
        domRoot.style.display = "none";
        var opts = this._opts;
        var root = this.root;
        width != null && (opts.width = width);
        height != null && (opts.height = height);
        width = getSize(root, 0, opts);
        height = getSize(root, 1, opts);
        domRoot.style.display = "";
        if (this._width !== width || height !== this._height) {
          domRoot.style.width = width + "px";
          domRoot.style.height = height + "px";
          for (var id in this._layers) {
            if (this._layers.hasOwnProperty(id)) {
              this._layers[id].resize(width, height);
            }
          }
          this.refresh(true);
        }
        this._width = width;
        this._height = height;
      }
      return this;
    };
    CanvasPainter2.prototype.clearLayer = function(zlevel) {
      var layer = this._layers[zlevel];
      if (layer) {
        layer.clear();
      }
    };
    CanvasPainter2.prototype.dispose = function() {
      this.root.innerHTML = "";
      this.root = this.storage = this._domRoot = this._layers = null;
    };
    CanvasPainter2.prototype.getRenderedCanvas = function(opts) {
      opts = opts || {};
      if (this._singleCanvas && !this._compositeManually) {
        return this._layers[CANVAS_ZLEVEL].dom;
      }
      var imageLayer = new Layer("image", this, opts.pixelRatio || this.dpr);
      imageLayer.initContext();
      imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);
      var ctx = imageLayer.ctx;
      if (opts.pixelRatio <= this.dpr) {
        this.refresh();
        var width_1 = imageLayer.dom.width;
        var height_1 = imageLayer.dom.height;
        this.eachLayer(function(layer) {
          if (layer.__builtin__) {
            ctx.drawImage(layer.dom, 0, 0, width_1, height_1);
          } else if (layer.renderToCanvas) {
            ctx.save();
            layer.renderToCanvas(ctx);
            ctx.restore();
          }
        });
      } else {
        var scope = {
          inHover: false,
          viewWidth: this._width,
          viewHeight: this._height
        };
        var displayList = this.storage.getDisplayList(true);
        for (var i = 0, len2 = displayList.length; i < len2; i++) {
          var el = displayList[i];
          brush(ctx, el, scope, i === len2 - 1);
        }
      }
      return imageLayer.dom;
    };
    CanvasPainter2.prototype.getWidth = function() {
      return this._width;
    };
    CanvasPainter2.prototype.getHeight = function() {
      return this._height;
    };
    return CanvasPainter2;
  }();
  function install$d(registers) {
    registers.registerPainter("canvas", CanvasPainter);
  }
  var define_process_env_default$b = {};
  var LineSeriesModel = (
    /** @class */
    function(_super) {
      __extends(LineSeriesModel2, _super);
      function LineSeriesModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = LineSeriesModel2.type;
        _this.hasSymbolVisual = true;
        return _this;
      }
      LineSeriesModel2.prototype.getInitialData = function(option) {
        if (define_process_env_default$b.NODE_ENV !== "production") {
          var coordSys = option.coordinateSystem;
          if (coordSys !== "polar" && coordSys !== "cartesian2d") {
            throw new Error("Line not support coordinateSystem besides cartesian and polar");
          }
        }
        return createSeriesData(null, this, {
          useEncodeDefaulter: true
        });
      };
      LineSeriesModel2.prototype.getLegendIcon = function(opt) {
        var group = new Group$2();
        var line = createSymbol("line", 0, opt.itemHeight / 2, opt.itemWidth, 0, opt.lineStyle.stroke, false);
        group.add(line);
        line.setStyle(opt.lineStyle);
        var visualType = this.getData().getVisual("symbol");
        var visualRotate = this.getData().getVisual("symbolRotate");
        var symbolType = visualType === "none" ? "circle" : visualType;
        var size = opt.itemHeight * 0.8;
        var symbol = createSymbol(symbolType, (opt.itemWidth - size) / 2, (opt.itemHeight - size) / 2, size, size, opt.itemStyle.fill);
        group.add(symbol);
        symbol.setStyle(opt.itemStyle);
        var symbolRotate = opt.iconRotate === "inherit" ? visualRotate : opt.iconRotate || 0;
        symbol.rotation = symbolRotate * Math.PI / 180;
        symbol.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);
        if (symbolType.indexOf("empty") > -1) {
          symbol.style.stroke = symbol.style.fill;
          symbol.style.fill = tokens.color.neutral00;
          symbol.style.lineWidth = 2;
        }
        return group;
      };
      LineSeriesModel2.type = "series.line";
      LineSeriesModel2.dependencies = ["grid", "polar"];
      LineSeriesModel2.defaultOption = {
        // zlevel: 0,
        z: 3,
        coordinateSystem: "cartesian2d",
        legendHoverLink: true,
        clip: true,
        label: {
          position: "top"
        },
        // itemStyle: {
        // },
        endLabel: {
          show: false,
          valueAnimation: true,
          distance: 8
        },
        lineStyle: {
          width: 2,
          type: "solid"
        },
        emphasis: {
          scale: true
        },
        // areaStyle: {
        // origin of areaStyle. Valid values:
        // `'auto'/null/undefined`: from axisLine to data
        // `'start'`: from min to data
        // `'end'`: from data to max
        // origin: 'auto'
        // },
        // false, 'start', 'end', 'middle'
        step: false,
        // Disabled if step is true
        smooth: false,
        smoothMonotone: null,
        symbol: "emptyCircle",
        symbolSize: 6,
        symbolRotate: null,
        showSymbol: true,
        // `false`: follow the label interval strategy.
        // `true`: show all symbols.
        // `'auto'`: If possible, show all symbols, otherwise
        //           follow the label interval strategy.
        showAllSymbol: "auto",
        // Whether to connect break point.
        connectNulls: false,
        // Sampling for large data. Can be: 'average', 'max', 'min', 'sum', 'lttb'.
        sampling: "none",
        animationEasing: "linear",
        // Disable progressive
        progressive: 0,
        hoverLayerThreshold: Infinity,
        universalTransition: {
          divideShape: "clone"
        },
        triggerLineEvent: false
      };
      return LineSeriesModel2;
    }(SeriesModel)
  );
  function getDefaultLabel(data, dataIndex) {
    var labelDims = data.mapDimensionsAll("defaultedLabel");
    var len2 = labelDims.length;
    if (len2 === 1) {
      var rawVal = retrieveRawValue(data, dataIndex, labelDims[0]);
      return rawVal != null ? rawVal + "" : null;
    } else if (len2) {
      var vals = [];
      for (var i = 0; i < labelDims.length; i++) {
        vals.push(retrieveRawValue(data, dataIndex, labelDims[i]));
      }
      return vals.join(" ");
    }
  }
  function getDefaultInterpolatedLabel(data, interpolatedValue) {
    var labelDims = data.mapDimensionsAll("defaultedLabel");
    if (!isArray(interpolatedValue)) {
      return interpolatedValue + "";
    }
    var vals = [];
    for (var i = 0; i < labelDims.length; i++) {
      var dimIndex = data.getDimensionIndex(labelDims[i]);
      if (dimIndex >= 0) {
        vals.push(interpolatedValue[dimIndex]);
      }
    }
    return vals.join(" ");
  }
  var Symbol$1 = (
    /** @class */
    function(_super) {
      __extends(Symbol2, _super);
      function Symbol2(data, idx, seriesScope, opts) {
        var _this = _super.call(this) || this;
        _this.updateData(data, idx, seriesScope, opts);
        return _this;
      }
      Symbol2.prototype._createSymbol = function(symbolType, data, idx, symbolSize, z2, keepAspect) {
        this.removeAll();
        var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, null, keepAspect);
        symbolPath.attr({
          z2: retrieve2(z2, 100),
          culling: true,
          scaleX: symbolSize[0] / 2,
          scaleY: symbolSize[1] / 2
        });
        symbolPath.drift = driftSymbol;
        this._symbolType = symbolType;
        this.add(symbolPath);
      };
      Symbol2.prototype.stopSymbolAnimation = function(toLastFrame) {
        this.childAt(0).stopAnimation(null, toLastFrame);
      };
      Symbol2.prototype.getSymbolType = function() {
        return this._symbolType;
      };
      Symbol2.prototype.getSymbolPath = function() {
        return this.childAt(0);
      };
      Symbol2.prototype.highlight = function() {
        enterEmphasis(this.childAt(0));
      };
      Symbol2.prototype.downplay = function() {
        leaveEmphasis(this.childAt(0));
      };
      Symbol2.prototype.setZ = function(zlevel, z) {
        var symbolPath = this.childAt(0);
        symbolPath.zlevel = zlevel;
        symbolPath.z = z;
      };
      Symbol2.prototype.setDraggable = function(draggable, hasCursorOption) {
        var symbolPath = this.childAt(0);
        symbolPath.draggable = draggable;
        symbolPath.cursor = !hasCursorOption && draggable ? "move" : symbolPath.cursor;
      };
      Symbol2.prototype.updateData = function(data, idx, seriesScope, opts) {
        this.silent = false;
        var symbolType = data.getItemVisual(idx, "symbol") || "circle";
        var seriesModel = data.hostModel;
        var symbolSize = Symbol2.getSymbolSize(data, idx);
        var z2 = Symbol2.getSymbolZ2(data, idx);
        var isInit = symbolType !== this._symbolType;
        var disableAnimation = opts && opts.disableAnimation;
        if (isInit) {
          var keepAspect = data.getItemVisual(idx, "symbolKeepAspect");
          this._createSymbol(symbolType, data, idx, symbolSize, z2, keepAspect);
        } else {
          var symbolPath = this.childAt(0);
          symbolPath.silent = false;
          var target = {
            scaleX: symbolSize[0] / 2,
            scaleY: symbolSize[1] / 2
          };
          disableAnimation ? symbolPath.attr(target) : updateProps$1(symbolPath, target, seriesModel, idx);
          saveOldStyle(symbolPath);
        }
        this._updateCommon(data, idx, symbolSize, seriesScope, opts);
        if (isInit) {
          var symbolPath = this.childAt(0);
          if (!disableAnimation) {
            var target = {
              scaleX: this._sizeX,
              scaleY: this._sizeY,
              style: {
                // Always fadeIn. Because it has fadeOut animation when symbol is removed..
                opacity: symbolPath.style.opacity
              }
            };
            symbolPath.scaleX = symbolPath.scaleY = 0;
            symbolPath.style.opacity = 0;
            initProps(symbolPath, target, seriesModel, idx);
          }
        }
        if (disableAnimation) {
          this.childAt(0).stopAnimation("leave");
        }
      };
      Symbol2.prototype._updateCommon = function(data, idx, symbolSize, seriesScope, opts) {
        var symbolPath = this.childAt(0);
        var seriesModel = data.hostModel;
        var emphasisItemStyle;
        var blurItemStyle;
        var selectItemStyle;
        var focus;
        var blurScope;
        var emphasisDisabled;
        var labelStatesModels;
        var hoverScale;
        var cursorStyle;
        if (seriesScope) {
          emphasisItemStyle = seriesScope.emphasisItemStyle;
          blurItemStyle = seriesScope.blurItemStyle;
          selectItemStyle = seriesScope.selectItemStyle;
          focus = seriesScope.focus;
          blurScope = seriesScope.blurScope;
          labelStatesModels = seriesScope.labelStatesModels;
          hoverScale = seriesScope.hoverScale;
          cursorStyle = seriesScope.cursorStyle;
          emphasisDisabled = seriesScope.emphasisDisabled;
        }
        if (!seriesScope || data.hasItemOption) {
          var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx);
          var emphasisModel = itemModel.getModel("emphasis");
          emphasisItemStyle = emphasisModel.getModel("itemStyle").getItemStyle();
          selectItemStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
          blurItemStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
          focus = emphasisModel.get("focus");
          blurScope = emphasisModel.get("blurScope");
          emphasisDisabled = emphasisModel.get("disabled");
          labelStatesModels = getLabelStatesModels(itemModel);
          hoverScale = emphasisModel.getShallow("scale");
          cursorStyle = itemModel.getShallow("cursor");
        }
        var symbolRotate = data.getItemVisual(idx, "symbolRotate");
        symbolPath.attr("rotation", (symbolRotate || 0) * Math.PI / 180 || 0);
        var symbolOffset = normalizeSymbolOffset(data.getItemVisual(idx, "symbolOffset"), symbolSize);
        if (symbolOffset) {
          symbolPath.x = symbolOffset[0];
          symbolPath.y = symbolOffset[1];
        }
        cursorStyle && symbolPath.attr("cursor", cursorStyle);
        var symbolStyle = data.getItemVisual(idx, "style");
        var visualColor = symbolStyle.fill;
        if (symbolPath instanceof ZRImage) {
          var pathStyle = symbolPath.style;
          symbolPath.useStyle(extend({
            // TODO other properties like x, y ?
            image: pathStyle.image,
            x: pathStyle.x,
            y: pathStyle.y,
            width: pathStyle.width,
            height: pathStyle.height
          }, symbolStyle));
        } else {
          if (symbolPath.__isEmptyBrush) {
            symbolPath.useStyle(extend({}, symbolStyle));
          } else {
            symbolPath.useStyle(symbolStyle);
          }
          symbolPath.style.decal = null;
          symbolPath.setColor(visualColor, opts && opts.symbolInnerColor);
          symbolPath.style.strokeNoScale = true;
        }
        var liftZ = data.getItemVisual(idx, "liftZ");
        var z2Origin = this._z2;
        if (liftZ != null) {
          if (z2Origin == null) {
            this._z2 = symbolPath.z2;
            symbolPath.z2 += liftZ;
          }
        } else if (z2Origin != null) {
          symbolPath.z2 = z2Origin;
          this._z2 = null;
        }
        var useNameLabel = opts && opts.useNameLabel;
        setLabelStyle(symbolPath, labelStatesModels, {
          labelFetcher: seriesModel,
          labelDataIndex: idx,
          defaultText: getLabelDefaultText,
          inheritColor: visualColor,
          defaultOpacity: symbolStyle.opacity
        });
        function getLabelDefaultText(idx2) {
          return useNameLabel ? data.getName(idx2) : getDefaultLabel(data, idx2);
        }
        this._sizeX = symbolSize[0] / 2;
        this._sizeY = symbolSize[1] / 2;
        var emphasisState = symbolPath.ensureState("emphasis");
        emphasisState.style = emphasisItemStyle;
        symbolPath.ensureState("select").style = selectItemStyle;
        symbolPath.ensureState("blur").style = blurItemStyle;
        var scaleRatio = hoverScale == null || hoverScale === true ? Math.max(1.1, 3 / this._sizeY) : isFinite(hoverScale) && hoverScale > 0 ? +hoverScale : 1;
        emphasisState.scaleX = this._sizeX * scaleRatio;
        emphasisState.scaleY = this._sizeY * scaleRatio;
        this.setSymbolScale(1);
        toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
      };
      Symbol2.prototype.setSymbolScale = function(scale2) {
        this.scaleX = this.scaleY = scale2;
      };
      Symbol2.prototype.fadeOut = function(cb, seriesModel, opt) {
        var symbolPath = this.childAt(0);
        var dataIndex = getECData(this).dataIndex;
        var animationOpt = opt && opt.animation;
        this.silent = symbolPath.silent = true;
        if (opt && opt.fadeLabel) {
          var textContent = symbolPath.getTextContent();
          if (textContent) {
            removeElement(textContent, {
              style: {
                opacity: 0
              }
            }, seriesModel, {
              dataIndex,
              removeOpt: animationOpt,
              cb: function() {
                symbolPath.removeTextContent();
              }
            });
          }
        } else {
          symbolPath.removeTextContent();
        }
        removeElement(symbolPath, {
          style: {
            opacity: 0
          },
          scaleX: 0,
          scaleY: 0
        }, seriesModel, {
          dataIndex,
          cb,
          removeOpt: animationOpt
        });
      };
      Symbol2.getSymbolSize = function(data, idx) {
        return normalizeSymbolSize(data.getItemVisual(idx, "symbolSize"));
      };
      Symbol2.getSymbolZ2 = function(data, idx) {
        return data.getItemVisual(idx, "z2");
      };
      return Symbol2;
    }(Group$2)
  );
  function driftSymbol(dx, dy) {
    this.parent.drift(dx, dy);
  }
  function symbolNeedsDraw(data, point, idx, opt) {
    return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, "symbol") !== "none";
  }
  function normalizeUpdateOpt(opt) {
    if (opt != null && !isObject$2(opt)) {
      opt = {
        isIgnore: opt
      };
    }
    return opt || {};
  }
  function makeSeriesScope(data) {
    var seriesModel = data.hostModel;
    var emphasisModel = seriesModel.getModel("emphasis");
    return {
      emphasisItemStyle: emphasisModel.getModel("itemStyle").getItemStyle(),
      blurItemStyle: seriesModel.getModel(["blur", "itemStyle"]).getItemStyle(),
      selectItemStyle: seriesModel.getModel(["select", "itemStyle"]).getItemStyle(),
      focus: emphasisModel.get("focus"),
      blurScope: emphasisModel.get("blurScope"),
      emphasisDisabled: emphasisModel.get("disabled"),
      hoverScale: emphasisModel.get("scale"),
      labelStatesModels: getLabelStatesModels(seriesModel),
      cursorStyle: seriesModel.get("cursor")
    };
  }
  var SymbolDraw = (
    /** @class */
    function() {
      function SymbolDraw2(SymbolCtor) {
        this.group = new Group$2();
        this._SymbolCtor = SymbolCtor || Symbol$1;
      }
      SymbolDraw2.prototype.updateData = function(data, opt) {
        this._progressiveEls = null;
        opt = normalizeUpdateOpt(opt);
        var group = this.group;
        var seriesModel = data.hostModel;
        var oldData = this._data;
        var SymbolCtor = this._SymbolCtor;
        var disableAnimation = opt.disableAnimation;
        var seriesScope = makeSeriesScope(data);
        var symbolUpdateOpt = {
          disableAnimation
        };
        var getSymbolPoint = opt.getSymbolPoint || function(idx) {
          return data.getItemLayout(idx);
        };
        if (!oldData) {
          group.removeAll();
        }
        data.diff(oldData).add(function(newIdx) {
          var point = getSymbolPoint(newIdx);
          if (symbolNeedsDraw(data, point, newIdx, opt)) {
            var symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
            symbolEl.setPosition(point);
            data.setItemGraphicEl(newIdx, symbolEl);
            group.add(symbolEl);
          }
        }).update(function(newIdx, oldIdx) {
          var symbolEl = oldData.getItemGraphicEl(oldIdx);
          var point = getSymbolPoint(newIdx);
          if (!symbolNeedsDraw(data, point, newIdx, opt)) {
            group.remove(symbolEl);
            return;
          }
          var newSymbolType = data.getItemVisual(newIdx, "symbol") || "circle";
          var oldSymbolType = symbolEl && symbolEl.getSymbolType && symbolEl.getSymbolType();
          if (!symbolEl || oldSymbolType && oldSymbolType !== newSymbolType) {
            group.remove(symbolEl);
            symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
            symbolEl.setPosition(point);
          } else {
            symbolEl.updateData(data, newIdx, seriesScope, symbolUpdateOpt);
            var target = {
              x: point[0],
              y: point[1]
            };
            disableAnimation ? symbolEl.attr(target) : updateProps$1(symbolEl, target, seriesModel);
          }
          group.add(symbolEl);
          data.setItemGraphicEl(newIdx, symbolEl);
        }).remove(function(oldIdx) {
          var el = oldData.getItemGraphicEl(oldIdx);
          el && el.fadeOut(function() {
            group.remove(el);
          }, seriesModel);
        }).execute();
        this._getSymbolPoint = getSymbolPoint;
        this._data = data;
      };
      SymbolDraw2.prototype.updateLayout = function() {
        var _this = this;
        var data = this._data;
        if (data) {
          data.eachItemGraphicEl(function(el, idx) {
            var point = _this._getSymbolPoint(idx);
            el.setPosition(point);
            el.markRedraw();
          });
        }
      };
      SymbolDraw2.prototype.incrementalPrepareUpdate = function(data) {
        this._seriesScope = makeSeriesScope(data);
        this._data = null;
        this.group.removeAll();
      };
      SymbolDraw2.prototype.incrementalUpdate = function(taskParams, data, opt) {
        this._progressiveEls = [];
        opt = normalizeUpdateOpt(opt);
        function updateIncrementalAndHover(el2) {
          if (!el2.isGroup) {
            el2.incremental = true;
            el2.ensureState("emphasis").hoverLayer = true;
          }
        }
        for (var idx = taskParams.start; idx < taskParams.end; idx++) {
          var point = data.getItemLayout(idx);
          if (symbolNeedsDraw(data, point, idx, opt)) {
            var el = new this._SymbolCtor(data, idx, this._seriesScope);
            el.traverse(updateIncrementalAndHover);
            el.setPosition(point);
            this.group.add(el);
            data.setItemGraphicEl(idx, el);
            this._progressiveEls.push(el);
          }
        }
      };
      SymbolDraw2.prototype.eachRendered = function(cb) {
        traverseElements(this._progressiveEls || this.group, cb);
      };
      SymbolDraw2.prototype.remove = function(enableAnimation) {
        var group = this.group;
        var data = this._data;
        if (data && enableAnimation) {
          data.eachItemGraphicEl(function(el) {
            el.fadeOut(function() {
              group.remove(el);
            }, data.hostModel);
          });
        } else {
          group.removeAll();
        }
      };
      return SymbolDraw2;
    }()
  );
  function prepareDataCoordInfo(coordSys, data, valueOrigin) {
    var baseAxis = coordSys.getBaseAxis();
    var valueAxis2 = coordSys.getOtherAxis(baseAxis);
    var valueStart = getValueStart(valueAxis2, valueOrigin);
    var baseAxisDim = baseAxis.dim;
    var valueAxisDim = valueAxis2.dim;
    var valueDim = data.mapDimension(valueAxisDim);
    var baseDim = data.mapDimension(baseAxisDim);
    var baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
    var dims = map$1(coordSys.dimensions, function(coordDim) {
      return data.mapDimension(coordDim);
    });
    var stacked = false;
    var stackResultDim = data.getCalculationInfo("stackResultDimension");
    if (isDimensionStacked(
      data,
      dims[0]
      /* , dims[1] */
    )) {
      stacked = true;
      dims[0] = stackResultDim;
    }
    if (isDimensionStacked(
      data,
      dims[1]
      /* , dims[0] */
    )) {
      stacked = true;
      dims[1] = stackResultDim;
    }
    return {
      dataDimsForPoint: dims,
      valueStart,
      valueAxisDim,
      baseAxisDim,
      stacked: !!stacked,
      valueDim,
      baseDim,
      baseDataOffset,
      stackedOverDimension: data.getCalculationInfo("stackedOverDimension")
    };
  }
  function getValueStart(valueAxis2, valueOrigin) {
    var valueStart = 0;
    var extent = valueAxis2.scale.getExtent();
    if (valueOrigin === "start") {
      valueStart = extent[0];
    } else if (valueOrigin === "end") {
      valueStart = extent[1];
    } else if (isNumber(valueOrigin) && !isNaN(valueOrigin)) {
      valueStart = valueOrigin;
    } else {
      if (extent[0] > 0) {
        valueStart = extent[0];
      } else if (extent[1] < 0) {
        valueStart = extent[1];
      }
    }
    return valueStart;
  }
  function getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {
    var value = NaN;
    if (dataCoordInfo.stacked) {
      value = data.get(data.getCalculationInfo("stackedOverDimension"), idx);
    }
    if (isNaN(value)) {
      value = dataCoordInfo.valueStart;
    }
    var baseDataOffset = dataCoordInfo.baseDataOffset;
    var stackedData = [];
    stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);
    stackedData[1 - baseDataOffset] = value;
    return coordSys.dataToPoint(stackedData);
  }
  function diffData(oldData, newData) {
    var diffResult = [];
    newData.diff(oldData).add(function(idx) {
      diffResult.push({
        cmd: "+",
        idx
      });
    }).update(function(newIdx, oldIdx) {
      diffResult.push({
        cmd: "=",
        idx: oldIdx,
        idx1: newIdx
      });
    }).remove(function(idx) {
      diffResult.push({
        cmd: "-",
        idx
      });
    }).execute();
    return diffResult;
  }
  function lineAnimationDiff(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
    var diff = diffData(oldData, newData);
    var currPoints = [];
    var nextPoints = [];
    var currStackedPoints = [];
    var nextStackedPoints = [];
    var status = [];
    var sortedIndices = [];
    var rawIndices = [];
    var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);
    var oldPoints = oldData.getLayout("points") || [];
    var newPoints = newData.getLayout("points") || [];
    for (var i = 0; i < diff.length; i++) {
      var diffItem = diff[i];
      var pointAdded = true;
      var oldIdx2 = void 0;
      var newIdx2 = void 0;
      switch (diffItem.cmd) {
        case "=":
          oldIdx2 = diffItem.idx * 2;
          newIdx2 = diffItem.idx1 * 2;
          var currentX = oldPoints[oldIdx2];
          var currentY = oldPoints[oldIdx2 + 1];
          var nextX = newPoints[newIdx2];
          var nextY = newPoints[newIdx2 + 1];
          if (isNaN(currentX) || isNaN(currentY)) {
            currentX = nextX;
            currentY = nextY;
          }
          currPoints.push(currentX, currentY);
          nextPoints.push(nextX, nextY);
          currStackedPoints.push(oldStackedOnPoints[oldIdx2], oldStackedOnPoints[oldIdx2 + 1]);
          nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
          rawIndices.push(newData.getRawIndex(diffItem.idx1));
          break;
        case "+":
          var newIdx = diffItem.idx;
          var newDataDimsForPoint = newDataOldCoordInfo.dataDimsForPoint;
          var oldPt = oldCoordSys.dataToPoint([newData.get(newDataDimsForPoint[0], newIdx), newData.get(newDataDimsForPoint[1], newIdx)]);
          newIdx2 = newIdx * 2;
          currPoints.push(oldPt[0], oldPt[1]);
          nextPoints.push(newPoints[newIdx2], newPoints[newIdx2 + 1]);
          var stackedOnPoint = getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, newIdx);
          currStackedPoints.push(stackedOnPoint[0], stackedOnPoint[1]);
          nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
          rawIndices.push(newData.getRawIndex(newIdx));
          break;
        case "-":
          pointAdded = false;
      }
      if (pointAdded) {
        status.push(diffItem);
        sortedIndices.push(sortedIndices.length);
      }
    }
    sortedIndices.sort(function(a, b) {
      return rawIndices[a] - rawIndices[b];
    });
    var len2 = currPoints.length;
    var sortedCurrPoints = createFloat32Array(len2);
    var sortedNextPoints = createFloat32Array(len2);
    var sortedCurrStackedPoints = createFloat32Array(len2);
    var sortedNextStackedPoints = createFloat32Array(len2);
    var sortedStatus = [];
    for (var i = 0; i < sortedIndices.length; i++) {
      var idx = sortedIndices[i];
      var i2 = i * 2;
      var idx2 = idx * 2;
      sortedCurrPoints[i2] = currPoints[idx2];
      sortedCurrPoints[i2 + 1] = currPoints[idx2 + 1];
      sortedNextPoints[i2] = nextPoints[idx2];
      sortedNextPoints[i2 + 1] = nextPoints[idx2 + 1];
      sortedCurrStackedPoints[i2] = currStackedPoints[idx2];
      sortedCurrStackedPoints[i2 + 1] = currStackedPoints[idx2 + 1];
      sortedNextStackedPoints[i2] = nextStackedPoints[idx2];
      sortedNextStackedPoints[i2 + 1] = nextStackedPoints[idx2 + 1];
      sortedStatus[i] = status[idx];
    }
    return {
      current: sortedCurrPoints,
      next: sortedNextPoints,
      stackedOnCurrent: sortedCurrStackedPoints,
      stackedOnNext: sortedNextStackedPoints,
      status: sortedStatus
    };
  }
  var mathMin = Math.min;
  var mathMax = Math.max;
  function isPointNull$1(x, y) {
    return isNaN(x) || isNaN(y);
  }
  function drawSegment(ctx, points2, start2, segLen, allLen, dir, smooth, smoothMonotone, connectNulls) {
    var prevX;
    var prevY;
    var cpx0;
    var cpy0;
    var cpx1;
    var cpy1;
    var idx = start2;
    var k = 0;
    for (; k < segLen; k++) {
      var x = points2[idx * 2];
      var y = points2[idx * 2 + 1];
      if (idx >= allLen || idx < 0) {
        break;
      }
      if (isPointNull$1(x, y)) {
        if (connectNulls) {
          idx += dir;
          continue;
        }
        break;
      }
      if (idx === start2) {
        ctx[dir > 0 ? "moveTo" : "lineTo"](x, y);
        cpx0 = x;
        cpy0 = y;
      } else {
        var dx = x - prevX;
        var dy = y - prevY;
        if (dx * dx + dy * dy < 0.5) {
          idx += dir;
          continue;
        }
        if (smooth > 0) {
          var nextIdx = idx + dir;
          var nextX = points2[nextIdx * 2];
          var nextY = points2[nextIdx * 2 + 1];
          while (nextX === x && nextY === y && k < segLen) {
            k++;
            nextIdx += dir;
            idx += dir;
            nextX = points2[nextIdx * 2];
            nextY = points2[nextIdx * 2 + 1];
            x = points2[idx * 2];
            y = points2[idx * 2 + 1];
            dx = x - prevX;
            dy = y - prevY;
          }
          var tmpK = k + 1;
          if (connectNulls) {
            while (isPointNull$1(nextX, nextY) && tmpK < segLen) {
              tmpK++;
              nextIdx += dir;
              nextX = points2[nextIdx * 2];
              nextY = points2[nextIdx * 2 + 1];
            }
          }
          var ratioNextSeg = 0.5;
          var vx = 0;
          var vy = 0;
          var nextCpx0 = void 0;
          var nextCpy0 = void 0;
          if (tmpK >= segLen || isPointNull$1(nextX, nextY)) {
            cpx1 = x;
            cpy1 = y;
          } else {
            vx = nextX - prevX;
            vy = nextY - prevY;
            var dx0 = x - prevX;
            var dx1 = nextX - x;
            var dy0 = y - prevY;
            var dy1 = nextY - y;
            var lenPrevSeg = void 0;
            var lenNextSeg = void 0;
            if (smoothMonotone === "x") {
              lenPrevSeg = Math.abs(dx0);
              lenNextSeg = Math.abs(dx1);
              var dir_1 = vx > 0 ? 1 : -1;
              cpx1 = x - dir_1 * lenPrevSeg * smooth;
              cpy1 = y;
              nextCpx0 = x + dir_1 * lenNextSeg * smooth;
              nextCpy0 = y;
            } else if (smoothMonotone === "y") {
              lenPrevSeg = Math.abs(dy0);
              lenNextSeg = Math.abs(dy1);
              var dir_2 = vy > 0 ? 1 : -1;
              cpx1 = x;
              cpy1 = y - dir_2 * lenPrevSeg * smooth;
              nextCpx0 = x;
              nextCpy0 = y + dir_2 * lenNextSeg * smooth;
            } else {
              lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);
              lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1);
              ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
              cpx1 = x - vx * smooth * (1 - ratioNextSeg);
              cpy1 = y - vy * smooth * (1 - ratioNextSeg);
              nextCpx0 = x + vx * smooth * ratioNextSeg;
              nextCpy0 = y + vy * smooth * ratioNextSeg;
              nextCpx0 = mathMin(nextCpx0, mathMax(nextX, x));
              nextCpy0 = mathMin(nextCpy0, mathMax(nextY, y));
              nextCpx0 = mathMax(nextCpx0, mathMin(nextX, x));
              nextCpy0 = mathMax(nextCpy0, mathMin(nextY, y));
              vx = nextCpx0 - x;
              vy = nextCpy0 - y;
              cpx1 = x - vx * lenPrevSeg / lenNextSeg;
              cpy1 = y - vy * lenPrevSeg / lenNextSeg;
              cpx1 = mathMin(cpx1, mathMax(prevX, x));
              cpy1 = mathMin(cpy1, mathMax(prevY, y));
              cpx1 = mathMax(cpx1, mathMin(prevX, x));
              cpy1 = mathMax(cpy1, mathMin(prevY, y));
              vx = x - cpx1;
              vy = y - cpy1;
              nextCpx0 = x + vx * lenNextSeg / lenPrevSeg;
              nextCpy0 = y + vy * lenNextSeg / lenPrevSeg;
            }
          }
          ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x, y);
          cpx0 = nextCpx0;
          cpy0 = nextCpy0;
        } else {
          ctx.lineTo(x, y);
        }
      }
      prevX = x;
      prevY = y;
      idx += dir;
    }
    return k;
  }
  var ECPolylineShape = (
    /** @class */
    /* @__PURE__ */ function() {
      function ECPolylineShape2() {
        this.smooth = 0;
        this.smoothConstraint = true;
      }
      return ECPolylineShape2;
    }()
  );
  var ECPolyline = (
    /** @class */
    function(_super) {
      __extends(ECPolyline2, _super);
      function ECPolyline2(opts) {
        var _this = _super.call(this, opts) || this;
        _this.type = "ec-polyline";
        return _this;
      }
      ECPolyline2.prototype.getDefaultStyle = function() {
        return {
          stroke: tokens.color.neutral99,
          fill: null
        };
      };
      ECPolyline2.prototype.getDefaultShape = function() {
        return new ECPolylineShape();
      };
      ECPolyline2.prototype.buildPath = function(ctx, shape) {
        var points2 = shape.points;
        var i = 0;
        var len2 = points2.length / 2;
        if (shape.connectNulls) {
          for (; len2 > 0; len2--) {
            if (!isPointNull$1(points2[len2 * 2 - 2], points2[len2 * 2 - 1])) {
              break;
            }
          }
          for (; i < len2; i++) {
            if (!isPointNull$1(points2[i * 2], points2[i * 2 + 1])) {
              break;
            }
          }
        }
        while (i < len2) {
          i += drawSegment(ctx, points2, i, len2, len2, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
        }
      };
      ECPolyline2.prototype.getPointOn = function(xOrY, dim) {
        if (!this.path) {
          this.createPathProxy();
          this.buildPath(this.path, this.shape);
        }
        var path = this.path;
        var data = path.data;
        var CMD2 = PathProxy.CMD;
        var x0;
        var y0;
        var isDimX = dim === "x";
        var roots2 = [];
        for (var i = 0; i < data.length; ) {
          var cmd = data[i++];
          var x = void 0;
          var y = void 0;
          var x2 = void 0;
          var y2 = void 0;
          var x3 = void 0;
          var y3 = void 0;
          var t = void 0;
          switch (cmd) {
            case CMD2.M:
              x0 = data[i++];
              y0 = data[i++];
              break;
            case CMD2.L:
              x = data[i++];
              y = data[i++];
              t = isDimX ? (xOrY - x0) / (x - x0) : (xOrY - y0) / (y - y0);
              if (t <= 1 && t >= 0) {
                var val = isDimX ? (y - y0) * t + y0 : (x - x0) * t + x0;
                return isDimX ? [xOrY, val] : [val, xOrY];
              }
              x0 = x;
              y0 = y;
              break;
            case CMD2.C:
              x = data[i++];
              y = data[i++];
              x2 = data[i++];
              y2 = data[i++];
              x3 = data[i++];
              y3 = data[i++];
              var nRoot = isDimX ? cubicRootAt(x0, x, x2, x3, xOrY, roots2) : cubicRootAt(y0, y, y2, y3, xOrY, roots2);
              if (nRoot > 0) {
                for (var i_1 = 0; i_1 < nRoot; i_1++) {
                  var t_1 = roots2[i_1];
                  if (t_1 <= 1 && t_1 >= 0) {
                    var val = isDimX ? cubicAt(y0, y, y2, y3, t_1) : cubicAt(x0, x, x2, x3, t_1);
                    return isDimX ? [xOrY, val] : [val, xOrY];
                  }
                }
              }
              x0 = x3;
              y0 = y3;
              break;
          }
        }
      };
      return ECPolyline2;
    }(Path)
  );
  var ECPolygonShape = (
    /** @class */
    function(_super) {
      __extends(ECPolygonShape2, _super);
      function ECPolygonShape2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return ECPolygonShape2;
    }(ECPolylineShape)
  );
  var ECPolygon = (
    /** @class */
    function(_super) {
      __extends(ECPolygon2, _super);
      function ECPolygon2(opts) {
        var _this = _super.call(this, opts) || this;
        _this.type = "ec-polygon";
        return _this;
      }
      ECPolygon2.prototype.getDefaultShape = function() {
        return new ECPolygonShape();
      };
      ECPolygon2.prototype.buildPath = function(ctx, shape) {
        var points2 = shape.points;
        var stackedOnPoints = shape.stackedOnPoints;
        var i = 0;
        var len2 = points2.length / 2;
        var smoothMonotone = shape.smoothMonotone;
        if (shape.connectNulls) {
          for (; len2 > 0; len2--) {
            if (!isPointNull$1(points2[len2 * 2 - 2], points2[len2 * 2 - 1])) {
              break;
            }
          }
          for (; i < len2; i++) {
            if (!isPointNull$1(points2[i * 2], points2[i * 2 + 1])) {
              break;
            }
          }
        }
        while (i < len2) {
          var k = drawSegment(ctx, points2, i, len2, len2, 1, shape.smooth, smoothMonotone, shape.connectNulls);
          drawSegment(ctx, stackedOnPoints, i + k - 1, k, len2, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
          i += k + 1;
          ctx.closePath();
        }
      };
      return ECPolygon2;
    }(Path)
  );
  function createGridClipPath(cartesian, hasAnimation, seriesModel, done, during) {
    var rect = cartesian.getArea();
    var x = rect.x;
    var y = rect.y;
    var width = rect.width;
    var height = rect.height;
    var lineWidth = seriesModel.get(["lineStyle", "width"]) || 0;
    x -= lineWidth / 2;
    y -= lineWidth / 2;
    width += lineWidth;
    height += lineWidth;
    width = Math.ceil(width);
    if (x !== Math.floor(x)) {
      x = Math.floor(x);
      width++;
    }
    var clipPath = new Rect$1({
      shape: {
        x,
        y,
        width,
        height
      }
    });
    if (hasAnimation) {
      var baseAxis = cartesian.getBaseAxis();
      var isHorizontal = baseAxis.isHorizontal();
      var isAxisInversed = baseAxis.inverse;
      if (isHorizontal) {
        if (isAxisInversed) {
          clipPath.shape.x += width;
        }
        clipPath.shape.width = 0;
      } else {
        if (!isAxisInversed) {
          clipPath.shape.y += height;
        }
        clipPath.shape.height = 0;
      }
      var duringCb = isFunction(during) ? function(percent) {
        during(percent, clipPath);
      } : null;
      initProps(clipPath, {
        shape: {
          width,
          height,
          x,
          y
        }
      }, seriesModel, null, done, duringCb);
    }
    return clipPath;
  }
  function createPolarClipPath(polar, hasAnimation, seriesModel) {
    var sectorArea = polar.getArea();
    var r0 = round$1(sectorArea.r0, 1);
    var r = round$1(sectorArea.r, 1);
    var clipPath = new Sector({
      shape: {
        cx: round$1(polar.cx, 1),
        cy: round$1(polar.cy, 1),
        r0,
        r,
        startAngle: sectorArea.startAngle,
        endAngle: sectorArea.endAngle,
        clockwise: sectorArea.clockwise
      }
    });
    if (hasAnimation) {
      var isRadial = polar.getBaseAxis().dim === "angle";
      if (isRadial) {
        clipPath.shape.endAngle = sectorArea.startAngle;
      } else {
        clipPath.shape.r = r0;
      }
      initProps(clipPath, {
        shape: {
          endAngle: sectorArea.endAngle,
          r
        }
      }, seriesModel);
    }
    return clipPath;
  }
  function isCoordinateSystemType(coordSys, type) {
    return coordSys.type === type;
  }
  var define_process_env_default$a = {};
  function isPointsSame(points1, points2) {
    if (points1.length !== points2.length) {
      return;
    }
    for (var i = 0; i < points1.length; i++) {
      if (points1[i] !== points2[i]) {
        return;
      }
    }
    return true;
  }
  function bboxFromPoints(points2) {
    var minX = Infinity;
    var minY = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    for (var i = 0; i < points2.length; ) {
      var x = points2[i++];
      var y = points2[i++];
      if (!isNaN(x)) {
        minX = Math.min(x, minX);
        maxX = Math.max(x, maxX);
      }
      if (!isNaN(y)) {
        minY = Math.min(y, minY);
        maxY = Math.max(y, maxY);
      }
    }
    return [[minX, minY], [maxX, maxY]];
  }
  function getBoundingDiff(points1, points2) {
    var _a2 = bboxFromPoints(points1), min1 = _a2[0], max1 = _a2[1];
    var _b2 = bboxFromPoints(points2), min22 = _b2[0], max22 = _b2[1];
    return Math.max(Math.abs(min1[0] - min22[0]), Math.abs(min1[1] - min22[1]), Math.abs(max1[0] - max22[0]), Math.abs(max1[1] - max22[1]));
  }
  function getSmooth(smooth) {
    return isNumber(smooth) ? smooth : smooth ? 0.5 : 0;
  }
  function getStackedOnPoints(coordSys, data, dataCoordInfo) {
    if (!dataCoordInfo.valueDim) {
      return [];
    }
    var len2 = data.count();
    var points2 = createFloat32Array(len2 * 2);
    for (var idx = 0; idx < len2; idx++) {
      var pt = getStackedOnPoint(dataCoordInfo, coordSys, data, idx);
      points2[idx * 2] = pt[0];
      points2[idx * 2 + 1] = pt[1];
    }
    return points2;
  }
  function turnPointsIntoStep(points2, basePoints, coordSys, stepTurnAt, connectNulls) {
    var baseAxis = coordSys.getBaseAxis();
    var baseIndex = baseAxis.dim === "x" || baseAxis.dim === "radius" ? 0 : 1;
    var stepPoints = [];
    var i = 0;
    var stepPt = [];
    var pt = [];
    var nextPt = [];
    var filteredPoints = [];
    if (connectNulls) {
      for (i = 0; i < points2.length; i += 2) {
        var reference = basePoints || points2;
        if (!isNaN(reference[i]) && !isNaN(reference[i + 1])) {
          filteredPoints.push(points2[i], points2[i + 1]);
        }
      }
      points2 = filteredPoints;
    }
    for (i = 0; i < points2.length - 2; i += 2) {
      nextPt[0] = points2[i + 2];
      nextPt[1] = points2[i + 3];
      pt[0] = points2[i];
      pt[1] = points2[i + 1];
      stepPoints.push(pt[0], pt[1]);
      switch (stepTurnAt) {
        case "end":
          stepPt[baseIndex] = nextPt[baseIndex];
          stepPt[1 - baseIndex] = pt[1 - baseIndex];
          stepPoints.push(stepPt[0], stepPt[1]);
          break;
        case "middle":
          var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
          var stepPt2 = [];
          stepPt[baseIndex] = stepPt2[baseIndex] = middle;
          stepPt[1 - baseIndex] = pt[1 - baseIndex];
          stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
          stepPoints.push(stepPt[0], stepPt[1]);
          stepPoints.push(stepPt2[0], stepPt2[1]);
          break;
        default:
          stepPt[baseIndex] = pt[baseIndex];
          stepPt[1 - baseIndex] = nextPt[1 - baseIndex];
          stepPoints.push(stepPt[0], stepPt[1]);
      }
    }
    stepPoints.push(points2[i++], points2[i++]);
    return stepPoints;
  }
  function clipColorStops(colorStops, maxSize) {
    var newColorStops = [];
    var len2 = colorStops.length;
    var prevOutOfRangeColorStop;
    var prevInRangeColorStop;
    function lerpStop(stop0, stop1, clippedCoord) {
      var coord0 = stop0.coord;
      var p = (clippedCoord - coord0) / (stop1.coord - coord0);
      var color2 = lerp(p, [stop0.color, stop1.color]);
      return {
        coord: clippedCoord,
        color: color2
      };
    }
    for (var i = 0; i < len2; i++) {
      var stop_1 = colorStops[i];
      var coord = stop_1.coord;
      if (coord < 0) {
        prevOutOfRangeColorStop = stop_1;
      } else if (coord > maxSize) {
        if (prevInRangeColorStop) {
          newColorStops.push(lerpStop(prevInRangeColorStop, stop_1, maxSize));
        } else if (prevOutOfRangeColorStop) {
          newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0), lerpStop(prevOutOfRangeColorStop, stop_1, maxSize));
        }
        break;
      } else {
        if (prevOutOfRangeColorStop) {
          newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0));
          prevOutOfRangeColorStop = null;
        }
        newColorStops.push(stop_1);
        prevInRangeColorStop = stop_1;
      }
    }
    return newColorStops;
  }
  function getVisualGradient(data, coordSys, api) {
    var visualMetaList = data.getVisual("visualMeta");
    if (!visualMetaList || !visualMetaList.length || !data.count()) {
      return;
    }
    if (coordSys.type !== "cartesian2d") {
      if (define_process_env_default$a.NODE_ENV !== "production") {
        console.warn("Visual map on line style is only supported on cartesian2d.");
      }
      return;
    }
    var coordDim;
    var visualMeta;
    for (var i = visualMetaList.length - 1; i >= 0; i--) {
      var dimInfo = data.getDimensionInfo(visualMetaList[i].dimension);
      coordDim = dimInfo && dimInfo.coordDim;
      if (coordDim === "x" || coordDim === "y") {
        visualMeta = visualMetaList[i];
        break;
      }
    }
    if (!visualMeta) {
      if (define_process_env_default$a.NODE_ENV !== "production") {
        console.warn("Visual map on line style only support x or y dimension.");
      }
      return;
    }
    var axis = coordSys.getAxis(coordDim);
    var colorStops = map$1(visualMeta.stops, function(stop2) {
      return {
        coord: axis.toGlobalCoord(axis.dataToCoord(stop2.value)),
        color: stop2.color
      };
    });
    var stopLen = colorStops.length;
    var outerColors = visualMeta.outerColors.slice();
    if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
      colorStops.reverse();
      outerColors.reverse();
    }
    var colorStopsInRange = clipColorStops(colorStops, coordDim === "x" ? api.getWidth() : api.getHeight());
    var inRangeStopLen = colorStopsInRange.length;
    if (!inRangeStopLen && stopLen) {
      return colorStops[0].coord < 0 ? outerColors[1] ? outerColors[1] : colorStops[stopLen - 1].color : outerColors[0] ? outerColors[0] : colorStops[0].color;
    }
    var tinyExtent = 10;
    var minCoord = colorStopsInRange[0].coord - tinyExtent;
    var maxCoord = colorStopsInRange[inRangeStopLen - 1].coord + tinyExtent;
    var coordSpan = maxCoord - minCoord;
    if (coordSpan < 1e-3) {
      return "transparent";
    }
    each$5(colorStopsInRange, function(stop2) {
      stop2.offset = (stop2.coord - minCoord) / coordSpan;
    });
    colorStopsInRange.push({
      // NOTE: inRangeStopLen may still be 0 if stoplen is zero.
      offset: inRangeStopLen ? colorStopsInRange[inRangeStopLen - 1].offset : 0.5,
      color: outerColors[1] || "transparent"
    });
    colorStopsInRange.unshift({
      offset: inRangeStopLen ? colorStopsInRange[0].offset : 0.5,
      color: outerColors[0] || "transparent"
    });
    var gradient = new LinearGradient(0, 0, 0, 0, colorStopsInRange, true);
    gradient[coordDim] = minCoord;
    gradient[coordDim + "2"] = maxCoord;
    return gradient;
  }
  function getIsIgnoreFunc(seriesModel, data, coordSys) {
    var showAllSymbol = seriesModel.get("showAllSymbol");
    var isAuto = showAllSymbol === "auto";
    if (showAllSymbol && !isAuto) {
      return;
    }
    var categoryAxis2 = coordSys.getAxesByScale("ordinal")[0];
    if (!categoryAxis2) {
      return;
    }
    if (isAuto && canShowAllSymbolForCategory(categoryAxis2, data)) {
      return;
    }
    var categoryDataDim = data.mapDimension(categoryAxis2.dim);
    var labelMap = {};
    each$5(categoryAxis2.getViewLabels(), function(labelItem) {
      var ordinalNumber = categoryAxis2.scale.getRawOrdinalNumber(labelItem.tickValue);
      labelMap[ordinalNumber] = 1;
    });
    return function(dataIndex) {
      return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));
    };
  }
  function canShowAllSymbolForCategory(categoryAxis2, data) {
    var axisExtent = categoryAxis2.getExtent();
    var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis2.scale.count();
    isNaN(availSize) && (availSize = 0);
    var dataLen = data.count();
    var step = Math.max(1, Math.round(dataLen / 5));
    for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {
      if (Symbol$1.getSymbolSize(
        data,
        dataIndex
        // Only for cartesian, where `isHorizontal` exists.
      )[categoryAxis2.isHorizontal() ? 1 : 0] * 1.5 > availSize) {
        return false;
      }
    }
    return true;
  }
  function isPointNull(x, y) {
    return isNaN(x) || isNaN(y);
  }
  function getLastIndexNotNull(points2) {
    var len2 = points2.length / 2;
    for (; len2 > 0; len2--) {
      if (!isPointNull(points2[len2 * 2 - 2], points2[len2 * 2 - 1])) {
        break;
      }
    }
    return len2 - 1;
  }
  function getPointAtIndex(points2, idx) {
    return [points2[idx * 2], points2[idx * 2 + 1]];
  }
  function getIndexRange(points2, xOrY, dim) {
    var len2 = points2.length / 2;
    var dimIdx = dim === "x" ? 0 : 1;
    var a;
    var b;
    var prevIndex = 0;
    var nextIndex = -1;
    for (var i = 0; i < len2; i++) {
      b = points2[i * 2 + dimIdx];
      if (isNaN(b) || isNaN(points2[i * 2 + 1 - dimIdx])) {
        continue;
      }
      if (i === 0) {
        a = b;
        continue;
      }
      if (a <= xOrY && b >= xOrY || a >= xOrY && b <= xOrY) {
        nextIndex = i;
        break;
      }
      prevIndex = i;
      a = b;
    }
    return {
      range: [prevIndex, nextIndex],
      t: (xOrY - a) / (b - a)
    };
  }
  function anyStateShowEndLabel(seriesModel) {
    if (seriesModel.get(["endLabel", "show"])) {
      return true;
    }
    for (var i = 0; i < SPECIAL_STATES.length; i++) {
      if (seriesModel.get([SPECIAL_STATES[i], "endLabel", "show"])) {
        return true;
      }
    }
    return false;
  }
  function createLineClipPath(lineView, coordSys, hasAnimation, seriesModel) {
    if (isCoordinateSystemType(coordSys, "cartesian2d")) {
      var endLabelModel_1 = seriesModel.getModel("endLabel");
      var valueAnimation_1 = endLabelModel_1.get("valueAnimation");
      var data_1 = seriesModel.getData();
      var labelAnimationRecord_1 = {
        lastFrameIndex: 0
      };
      var during = anyStateShowEndLabel(seriesModel) ? function(percent, clipRect) {
        lineView._endLabelOnDuring(percent, clipRect, data_1, labelAnimationRecord_1, valueAnimation_1, endLabelModel_1, coordSys);
      } : null;
      var isHorizontal = coordSys.getBaseAxis().isHorizontal();
      var clipPath = createGridClipPath(coordSys, hasAnimation, seriesModel, function() {
        var endLabel = lineView._endLabel;
        if (endLabel && hasAnimation) {
          if (labelAnimationRecord_1.originalX != null) {
            endLabel.attr({
              x: labelAnimationRecord_1.originalX,
              y: labelAnimationRecord_1.originalY
            });
          }
        }
      }, during);
      if (!seriesModel.get("clip", true)) {
        var rectShape = clipPath.shape;
        var expandSize = Math.max(rectShape.width, rectShape.height);
        if (isHorizontal) {
          rectShape.y -= expandSize;
          rectShape.height += expandSize * 2;
        } else {
          rectShape.x -= expandSize;
          rectShape.width += expandSize * 2;
        }
      }
      if (during) {
        during(1, clipPath);
      }
      return clipPath;
    } else {
      if (define_process_env_default$a.NODE_ENV !== "production") {
        if (seriesModel.get(["endLabel", "show"])) {
          console.warn("endLabel is not supported for lines in polar systems.");
        }
      }
      return createPolarClipPath(coordSys, hasAnimation, seriesModel);
    }
  }
  function getEndLabelStateSpecified(endLabelModel, coordSys) {
    var baseAxis = coordSys.getBaseAxis();
    var isHorizontal = baseAxis.isHorizontal();
    var isBaseInversed = baseAxis.inverse;
    var align = isHorizontal ? isBaseInversed ? "right" : "left" : "center";
    var verticalAlign = isHorizontal ? "middle" : isBaseInversed ? "top" : "bottom";
    return {
      normal: {
        align: endLabelModel.get("align") || align,
        verticalAlign: endLabelModel.get("verticalAlign") || verticalAlign
      }
    };
  }
  var LineView = (
    /** @class */
    function(_super) {
      __extends(LineView2, _super);
      function LineView2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      LineView2.prototype.init = function() {
        var lineGroup = new Group$2();
        var symbolDraw = new SymbolDraw();
        this.group.add(symbolDraw.group);
        this._symbolDraw = symbolDraw;
        this._lineGroup = lineGroup;
        this._changePolyState = bind$1(this._changePolyState, this);
      };
      LineView2.prototype.render = function(seriesModel, ecModel, api) {
        var coordSys = seriesModel.coordinateSystem;
        var group = this.group;
        var data = seriesModel.getData();
        var lineStyleModel = seriesModel.getModel("lineStyle");
        var areaStyleModel = seriesModel.getModel("areaStyle");
        var points2 = data.getLayout("points") || [];
        var isCoordSysPolar = coordSys.type === "polar";
        var prevCoordSys = this._coordSys;
        var symbolDraw = this._symbolDraw;
        var polyline = this._polyline;
        var polygon = this._polygon;
        var lineGroup = this._lineGroup;
        var hasAnimation = !ecModel.ssr && seriesModel.get("animation");
        var isAreaChart = !areaStyleModel.isEmpty();
        var valueOrigin = areaStyleModel.get("origin");
        var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);
        var stackedOnPoints = isAreaChart && getStackedOnPoints(coordSys, data, dataCoordInfo);
        var showSymbol = seriesModel.get("showSymbol");
        var connectNulls = seriesModel.get("connectNulls");
        var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys);
        var oldData = this._data;
        oldData && oldData.eachItemGraphicEl(function(el, idx) {
          if (el.__temp) {
            group.remove(el);
            oldData.setItemGraphicEl(idx, null);
          }
        });
        if (!showSymbol) {
          symbolDraw.remove();
        }
        group.add(lineGroup);
        var step = !isCoordSysPolar ? seriesModel.get("step") : false;
        var clipShapeForSymbol;
        if (coordSys && coordSys.getArea && seriesModel.get("clip", true)) {
          clipShapeForSymbol = coordSys.getArea();
          if (clipShapeForSymbol.width != null) {
            clipShapeForSymbol.x -= 0.1;
            clipShapeForSymbol.y -= 0.1;
            clipShapeForSymbol.width += 0.2;
            clipShapeForSymbol.height += 0.2;
          } else if (clipShapeForSymbol.r0) {
            clipShapeForSymbol.r0 -= 0.5;
            clipShapeForSymbol.r += 0.5;
          }
        }
        this._clipShapeForSymbol = clipShapeForSymbol;
        var visualColor = getVisualGradient(data, coordSys, api) || data.getVisual("style")[data.getVisual("drawType")];
        if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
          showSymbol && symbolDraw.updateData(data, {
            isIgnore: isIgnoreFunc,
            clipShape: clipShapeForSymbol,
            disableAnimation: true,
            getSymbolPoint: function(idx) {
              return [points2[idx * 2], points2[idx * 2 + 1]];
            }
          });
          hasAnimation && this._initSymbolLabelAnimation(data, coordSys, clipShapeForSymbol);
          if (step) {
            if (stackedOnPoints) {
              stackedOnPoints = turnPointsIntoStep(stackedOnPoints, points2, coordSys, step, connectNulls);
            }
            points2 = turnPointsIntoStep(points2, null, coordSys, step, connectNulls);
          }
          polyline = this._newPolyline(points2);
          if (isAreaChart) {
            polygon = this._newPolygon(points2, stackedOnPoints);
          } else if (polygon) {
            lineGroup.remove(polygon);
            polygon = this._polygon = null;
          }
          if (!isCoordSysPolar) {
            this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
          }
          lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
        } else {
          if (isAreaChart && !polygon) {
            polygon = this._newPolygon(points2, stackedOnPoints);
          } else if (polygon && !isAreaChart) {
            lineGroup.remove(polygon);
            polygon = this._polygon = null;
          }
          if (!isCoordSysPolar) {
            this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
          }
          var oldClipPath = lineGroup.getClipPath();
          if (oldClipPath) {
            var newClipPath = createLineClipPath(this, coordSys, false, seriesModel);
            initProps(oldClipPath, {
              shape: newClipPath.shape
            }, seriesModel);
          } else {
            lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
          }
          showSymbol && symbolDraw.updateData(data, {
            isIgnore: isIgnoreFunc,
            clipShape: clipShapeForSymbol,
            disableAnimation: true,
            getSymbolPoint: function(idx) {
              return [points2[idx * 2], points2[idx * 2 + 1]];
            }
          });
          if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points2)) {
            if (hasAnimation) {
              this._doUpdateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin, connectNulls);
            } else {
              if (step) {
                if (stackedOnPoints) {
                  stackedOnPoints = turnPointsIntoStep(stackedOnPoints, points2, coordSys, step, connectNulls);
                }
                points2 = turnPointsIntoStep(points2, null, coordSys, step, connectNulls);
              }
              polyline.setShape({
                points: points2
              });
              polygon && polygon.setShape({
                points: points2,
                stackedOnPoints
              });
            }
          }
        }
        var emphasisModel = seriesModel.getModel("emphasis");
        var focus = emphasisModel.get("focus");
        var blurScope = emphasisModel.get("blurScope");
        var emphasisDisabled = emphasisModel.get("disabled");
        polyline.useStyle(defaults(
          // Use color in lineStyle first
          lineStyleModel.getLineStyle(),
          {
            fill: "none",
            stroke: visualColor,
            lineJoin: "bevel"
          }
        ));
        setStatesStylesFromModel(polyline, seriesModel, "lineStyle");
        if (polyline.style.lineWidth > 0 && seriesModel.get(["emphasis", "lineStyle", "width"]) === "bolder") {
          var emphasisLineStyle = polyline.getState("emphasis").style;
          emphasisLineStyle.lineWidth = +polyline.style.lineWidth + 1;
        }
        getECData(polyline).seriesIndex = seriesModel.seriesIndex;
        toggleHoverEmphasis(polyline, focus, blurScope, emphasisDisabled);
        var smooth = getSmooth(seriesModel.get("smooth"));
        var smoothMonotone = seriesModel.get("smoothMonotone");
        polyline.setShape({
          smooth,
          smoothMonotone,
          connectNulls
        });
        if (polygon) {
          var stackedOnSeries = data.getCalculationInfo("stackedOnSeries");
          var stackedOnSmooth = 0;
          polygon.useStyle(defaults(areaStyleModel.getAreaStyle(), {
            fill: visualColor,
            opacity: 0.7,
            lineJoin: "bevel",
            decal: data.getVisual("style").decal
          }));
          if (stackedOnSeries) {
            stackedOnSmooth = getSmooth(stackedOnSeries.get("smooth"));
          }
          polygon.setShape({
            smooth,
            stackedOnSmooth,
            smoothMonotone,
            connectNulls
          });
          setStatesStylesFromModel(polygon, seriesModel, "areaStyle");
          getECData(polygon).seriesIndex = seriesModel.seriesIndex;
          toggleHoverEmphasis(polygon, focus, blurScope, emphasisDisabled);
        }
        var changePolyState = this._changePolyState;
        data.eachItemGraphicEl(function(el) {
          el && (el.onHoverStateChange = changePolyState);
        });
        this._polyline.onHoverStateChange = changePolyState;
        this._data = data;
        this._coordSys = coordSys;
        this._stackedOnPoints = stackedOnPoints;
        this._points = points2;
        this._step = step;
        this._valueOrigin = valueOrigin;
        if (seriesModel.get("triggerLineEvent")) {
          this.packEventData(seriesModel, polyline);
          polygon && this.packEventData(seriesModel, polygon);
        }
      };
      LineView2.prototype.packEventData = function(seriesModel, el) {
        getECData(el).eventData = {
          componentType: "series",
          componentSubType: "line",
          componentIndex: seriesModel.componentIndex,
          seriesIndex: seriesModel.seriesIndex,
          seriesName: seriesModel.name,
          seriesType: "line"
        };
      };
      LineView2.prototype.highlight = function(seriesModel, ecModel, api, payload) {
        var data = seriesModel.getData();
        var dataIndex = queryDataIndex(data, payload);
        this._changePolyState("emphasis");
        if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
          var points2 = data.getLayout("points");
          var symbol = data.getItemGraphicEl(dataIndex);
          if (!symbol) {
            var x = points2[dataIndex * 2];
            var y = points2[dataIndex * 2 + 1];
            if (isNaN(x) || isNaN(y)) {
              return;
            }
            if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(x, y)) {
              return;
            }
            var zlevel = seriesModel.get("zlevel") || 0;
            var z = seriesModel.get("z") || 0;
            symbol = new Symbol$1(data, dataIndex);
            symbol.x = x;
            symbol.y = y;
            symbol.setZ(zlevel, z);
            var symbolLabel = symbol.getSymbolPath().getTextContent();
            if (symbolLabel) {
              symbolLabel.zlevel = zlevel;
              symbolLabel.z = z;
              symbolLabel.z2 = this._polyline.z2 + 1;
            }
            symbol.__temp = true;
            data.setItemGraphicEl(dataIndex, symbol);
            symbol.stopSymbolAnimation(true);
            this.group.add(symbol);
          }
          symbol.highlight();
        } else {
          ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
        }
      };
      LineView2.prototype.downplay = function(seriesModel, ecModel, api, payload) {
        var data = seriesModel.getData();
        var dataIndex = queryDataIndex(data, payload);
        this._changePolyState("normal");
        if (dataIndex != null && dataIndex >= 0) {
          var symbol = data.getItemGraphicEl(dataIndex);
          if (symbol) {
            if (symbol.__temp) {
              data.setItemGraphicEl(dataIndex, null);
              this.group.remove(symbol);
            } else {
              symbol.downplay();
            }
          }
        } else {
          ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
        }
      };
      LineView2.prototype._changePolyState = function(toState) {
        var polygon = this._polygon;
        setStatesFlag(this._polyline, toState);
        polygon && setStatesFlag(polygon, toState);
      };
      LineView2.prototype._newPolyline = function(points2) {
        var polyline = this._polyline;
        if (polyline) {
          this._lineGroup.remove(polyline);
        }
        polyline = new ECPolyline({
          shape: {
            points: points2
          },
          segmentIgnoreThreshold: 2,
          z2: 10
        });
        this._lineGroup.add(polyline);
        this._polyline = polyline;
        return polyline;
      };
      LineView2.prototype._newPolygon = function(points2, stackedOnPoints) {
        var polygon = this._polygon;
        if (polygon) {
          this._lineGroup.remove(polygon);
        }
        polygon = new ECPolygon({
          shape: {
            points: points2,
            stackedOnPoints
          },
          segmentIgnoreThreshold: 2
        });
        this._lineGroup.add(polygon);
        this._polygon = polygon;
        return polygon;
      };
      LineView2.prototype._initSymbolLabelAnimation = function(data, coordSys, clipShape) {
        var isHorizontalOrRadial;
        var isCoordSysPolar;
        var baseAxis = coordSys.getBaseAxis();
        var isAxisInverse = baseAxis.inverse;
        if (coordSys.type === "cartesian2d") {
          isHorizontalOrRadial = baseAxis.isHorizontal();
          isCoordSysPolar = false;
        } else if (coordSys.type === "polar") {
          isHorizontalOrRadial = baseAxis.dim === "angle";
          isCoordSysPolar = true;
        }
        var seriesModel = data.hostModel;
        var seriesDuration = seriesModel.get("animationDuration");
        if (isFunction(seriesDuration)) {
          seriesDuration = seriesDuration(null);
        }
        var seriesDelay = seriesModel.get("animationDelay") || 0;
        var seriesDelayValue = isFunction(seriesDelay) ? seriesDelay(null) : seriesDelay;
        data.eachItemGraphicEl(function(symbol, idx) {
          var el = symbol;
          if (el) {
            var point = [symbol.x, symbol.y];
            var start2 = void 0;
            var end2 = void 0;
            var current = void 0;
            if (clipShape) {
              if (isCoordSysPolar) {
                var polarClip = clipShape;
                var coord = coordSys.pointToCoord(point);
                if (isHorizontalOrRadial) {
                  start2 = polarClip.startAngle;
                  end2 = polarClip.endAngle;
                  current = -coord[1] / 180 * Math.PI;
                } else {
                  start2 = polarClip.r0;
                  end2 = polarClip.r;
                  current = coord[0];
                }
              } else {
                var gridClip = clipShape;
                if (isHorizontalOrRadial) {
                  start2 = gridClip.x;
                  end2 = gridClip.x + gridClip.width;
                  current = symbol.x;
                } else {
                  start2 = gridClip.y + gridClip.height;
                  end2 = gridClip.y;
                  current = symbol.y;
                }
              }
            }
            var ratio = end2 === start2 ? 0 : (current - start2) / (end2 - start2);
            if (isAxisInverse) {
              ratio = 1 - ratio;
            }
            var delay = isFunction(seriesDelay) ? seriesDelay(idx) : seriesDuration * ratio + seriesDelayValue;
            var symbolPath = el.getSymbolPath();
            var text = symbolPath.getTextContent();
            el.attr({
              scaleX: 0,
              scaleY: 0
            });
            el.animateTo({
              scaleX: 1,
              scaleY: 1
            }, {
              duration: 200,
              setToFinal: true,
              delay
            });
            if (text) {
              text.animateFrom({
                style: {
                  opacity: 0
                }
              }, {
                duration: 300,
                delay
              });
            }
            symbolPath.disableLabelAnimation = true;
          }
        });
      };
      LineView2.prototype._initOrUpdateEndLabel = function(seriesModel, coordSys, inheritColor) {
        var endLabelModel = seriesModel.getModel("endLabel");
        if (anyStateShowEndLabel(seriesModel)) {
          var data_2 = seriesModel.getData();
          var polyline = this._polyline;
          var points2 = data_2.getLayout("points");
          if (!points2) {
            polyline.removeTextContent();
            this._endLabel = null;
            return;
          }
          var endLabel = this._endLabel;
          if (!endLabel) {
            endLabel = this._endLabel = new ZRText({
              z2: 200
              // should be higher than item symbol
            });
            endLabel.ignoreClip = true;
            polyline.setTextContent(this._endLabel);
            polyline.disableLabelAnimation = true;
          }
          var dataIndex = getLastIndexNotNull(points2);
          if (dataIndex >= 0) {
            setLabelStyle(polyline, getLabelStatesModels(seriesModel, "endLabel"), {
              inheritColor,
              labelFetcher: seriesModel,
              labelDataIndex: dataIndex,
              defaultText: function(dataIndex2, opt, interpolatedValue) {
                return interpolatedValue != null ? getDefaultInterpolatedLabel(data_2, interpolatedValue) : getDefaultLabel(data_2, dataIndex2);
              },
              enableTextSetter: true
            }, getEndLabelStateSpecified(endLabelModel, coordSys));
            polyline.textConfig.position = null;
          }
        } else if (this._endLabel) {
          this._polyline.removeTextContent();
          this._endLabel = null;
        }
      };
      LineView2.prototype._endLabelOnDuring = function(percent, clipRect, data, animationRecord, valueAnimation, endLabelModel, coordSys) {
        var endLabel = this._endLabel;
        var polyline = this._polyline;
        if (endLabel) {
          if (percent < 1 && animationRecord.originalX == null) {
            animationRecord.originalX = endLabel.x;
            animationRecord.originalY = endLabel.y;
          }
          var points2 = data.getLayout("points");
          var seriesModel = data.hostModel;
          var connectNulls = seriesModel.get("connectNulls");
          var precision = endLabelModel.get("precision");
          var distance2 = endLabelModel.get("distance") || 0;
          var baseAxis = coordSys.getBaseAxis();
          var isHorizontal = baseAxis.isHorizontal();
          var isBaseInversed = baseAxis.inverse;
          var clipShape = clipRect.shape;
          var xOrY = isBaseInversed ? isHorizontal ? clipShape.x : clipShape.y + clipShape.height : isHorizontal ? clipShape.x + clipShape.width : clipShape.y;
          var distanceX = (isHorizontal ? distance2 : 0) * (isBaseInversed ? -1 : 1);
          var distanceY = (isHorizontal ? 0 : -distance2) * (isBaseInversed ? -1 : 1);
          var dim = isHorizontal ? "x" : "y";
          var dataIndexRange = getIndexRange(points2, xOrY, dim);
          var indices = dataIndexRange.range;
          var diff = indices[1] - indices[0];
          var value = void 0;
          if (diff >= 1) {
            if (diff > 1 && !connectNulls) {
              var pt = getPointAtIndex(points2, indices[0]);
              endLabel.attr({
                x: pt[0] + distanceX,
                y: pt[1] + distanceY
              });
              valueAnimation && (value = seriesModel.getRawValue(indices[0]));
            } else {
              var pt = polyline.getPointOn(xOrY, dim);
              pt && endLabel.attr({
                x: pt[0] + distanceX,
                y: pt[1] + distanceY
              });
              var startValue = seriesModel.getRawValue(indices[0]);
              var endValue = seriesModel.getRawValue(indices[1]);
              valueAnimation && (value = interpolateRawValues(data, precision, startValue, endValue, dataIndexRange.t));
            }
            animationRecord.lastFrameIndex = indices[0];
          } else {
            var idx = percent === 1 || animationRecord.lastFrameIndex > 0 ? indices[0] : 0;
            var pt = getPointAtIndex(points2, idx);
            valueAnimation && (value = seriesModel.getRawValue(idx));
            endLabel.attr({
              x: pt[0] + distanceX,
              y: pt[1] + distanceY
            });
          }
          if (valueAnimation) {
            var inner2 = labelInner(endLabel);
            if (typeof inner2.setLabelText === "function") {
              inner2.setLabelText(value);
            }
          }
        }
      };
      LineView2.prototype._doUpdateAnimation = function(data, stackedOnPoints, coordSys, api, step, valueOrigin, connectNulls) {
        var polyline = this._polyline;
        var polygon = this._polygon;
        var seriesModel = data.hostModel;
        var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin);
        var current = diff.current;
        var stackedOnCurrent = diff.stackedOnCurrent;
        var next = diff.next;
        var stackedOnNext = diff.stackedOnNext;
        if (step) {
          stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, diff.current, coordSys, step, connectNulls);
          current = turnPointsIntoStep(diff.current, null, coordSys, step, connectNulls);
          stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, diff.next, coordSys, step, connectNulls);
          next = turnPointsIntoStep(diff.next, null, coordSys, step, connectNulls);
        }
        if (getBoundingDiff(current, next) > 3e3 || polygon && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3e3) {
          polyline.stopAnimation();
          polyline.setShape({
            points: next
          });
          if (polygon) {
            polygon.stopAnimation();
            polygon.setShape({
              points: next,
              stackedOnPoints: stackedOnNext
            });
          }
          return;
        }
        polyline.shape.__points = diff.current;
        polyline.shape.points = current;
        var target = {
          shape: {
            points: next
          }
        };
        if (diff.current !== current) {
          target.shape.__points = diff.next;
        }
        polyline.stopAnimation();
        updateProps$1(polyline, target, seriesModel);
        if (polygon) {
          polygon.setShape({
            // Reuse the points with polyline.
            points: current,
            stackedOnPoints: stackedOnCurrent
          });
          polygon.stopAnimation();
          updateProps$1(polygon, {
            shape: {
              stackedOnPoints: stackedOnNext
            }
          }, seriesModel);
          if (polyline.shape.points !== polygon.shape.points) {
            polygon.shape.points = polyline.shape.points;
          }
        }
        var updatedDataInfo = [];
        var diffStatus = diff.status;
        for (var i = 0; i < diffStatus.length; i++) {
          var cmd = diffStatus[i].cmd;
          if (cmd === "=") {
            var el = data.getItemGraphicEl(diffStatus[i].idx1);
            if (el) {
              updatedDataInfo.push({
                el,
                ptIdx: i
                // Index of points
              });
            }
          }
        }
        if (polyline.animators && polyline.animators.length) {
          polyline.animators[0].during(function() {
            polygon && polygon.dirtyShape();
            var points2 = polyline.shape.__points;
            for (var i2 = 0; i2 < updatedDataInfo.length; i2++) {
              var el2 = updatedDataInfo[i2].el;
              var offset = updatedDataInfo[i2].ptIdx * 2;
              el2.x = points2[offset];
              el2.y = points2[offset + 1];
              el2.markRedraw();
            }
          });
        }
      };
      LineView2.prototype.remove = function(ecModel) {
        var group = this.group;
        var oldData = this._data;
        this._lineGroup.removeAll();
        this._symbolDraw.remove(true);
        oldData && oldData.eachItemGraphicEl(function(el, idx) {
          if (el.__temp) {
            group.remove(el);
            oldData.setItemGraphicEl(idx, null);
          }
        });
        this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
      };
      LineView2.type = "line";
      return LineView2;
    }(ChartView)
  );
  function pointsLayout(seriesType2, forceStoreInTypedArray) {
    return {
      seriesType: seriesType2,
      plan: createRenderPlanner(),
      reset: function(seriesModel) {
        var data = seriesModel.getData();
        var coordSys = seriesModel.coordinateSystem;
        var pipelineContext = seriesModel.pipelineContext;
        var useTypedArray = forceStoreInTypedArray || pipelineContext.large;
        if (!coordSys) {
          return;
        }
        var dims = map$1(coordSys.dimensions, function(dim) {
          return data.mapDimension(dim);
        }).slice(0, 2);
        var dimLen = dims.length;
        var stackResultDim = data.getCalculationInfo("stackResultDimension");
        if (isDimensionStacked(data, dims[0])) {
          dims[0] = stackResultDim;
        }
        if (isDimensionStacked(data, dims[1])) {
          dims[1] = stackResultDim;
        }
        var store = data.getStore();
        var dimIdx0 = data.getDimensionIndex(dims[0]);
        var dimIdx1 = data.getDimensionIndex(dims[1]);
        return dimLen && {
          progress: function(params, data2) {
            var segCount = params.end - params.start;
            var points2 = useTypedArray && createFloat32Array(segCount * dimLen);
            var tmpIn = [];
            var tmpOut = [];
            for (var i = params.start, offset = 0; i < params.end; i++) {
              var point = void 0;
              if (dimLen === 1) {
                var x = store.get(dimIdx0, i);
                point = coordSys.dataToPoint(x, null, tmpOut);
              } else {
                tmpIn[0] = store.get(dimIdx0, i);
                tmpIn[1] = store.get(dimIdx1, i);
                point = coordSys.dataToPoint(tmpIn, null, tmpOut);
              }
              if (useTypedArray) {
                points2[offset++] = point[0];
                points2[offset++] = point[1];
              } else {
                data2.setItemLayout(i, point.slice());
              }
            }
            useTypedArray && data2.setLayout("points", points2);
          }
        };
      }
    };
  }
  var samplers = {
    average: function(frame) {
      var sum = 0;
      var count = 0;
      for (var i = 0; i < frame.length; i++) {
        if (!isNaN(frame[i])) {
          sum += frame[i];
          count++;
        }
      }
      return count === 0 ? NaN : sum / count;
    },
    sum: function(frame) {
      var sum = 0;
      for (var i = 0; i < frame.length; i++) {
        sum += frame[i] || 0;
      }
      return sum;
    },
    max: function(frame) {
      var max3 = -Infinity;
      for (var i = 0; i < frame.length; i++) {
        frame[i] > max3 && (max3 = frame[i]);
      }
      return isFinite(max3) ? max3 : NaN;
    },
    min: function(frame) {
      var min3 = Infinity;
      for (var i = 0; i < frame.length; i++) {
        frame[i] < min3 && (min3 = frame[i]);
      }
      return isFinite(min3) ? min3 : NaN;
    },
    // TODO
    // Median
    nearest: function(frame) {
      return frame[0];
    }
  };
  var indexSampler = function(frame) {
    return Math.round(frame.length / 2);
  };
  function dataSample(seriesType2) {
    return {
      seriesType: seriesType2,
      // FIXME:TS never used, so comment it
      // modifyOutputEnd: true,
      reset: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var sampling = seriesModel.get("sampling");
        var coordSys = seriesModel.coordinateSystem;
        var count = data.count();
        if (count > 10 && coordSys.type === "cartesian2d" && sampling) {
          var baseAxis = coordSys.getBaseAxis();
          var valueAxis2 = coordSys.getOtherAxis(baseAxis);
          var extent = baseAxis.getExtent();
          var dpr2 = api.getDevicePixelRatio();
          var size = Math.abs(extent[1] - extent[0]) * (dpr2 || 1);
          var rate = Math.round(count / size);
          if (isFinite(rate) && rate > 1) {
            if (sampling === "lttb") {
              seriesModel.setData(data.lttbDownSample(data.mapDimension(valueAxis2.dim), 1 / rate));
            } else if (sampling === "minmax") {
              seriesModel.setData(data.minmaxDownSample(data.mapDimension(valueAxis2.dim), 1 / rate));
            }
            var sampler = void 0;
            if (isString(sampling)) {
              sampler = samplers[sampling];
            } else if (isFunction(sampling)) {
              sampler = sampling;
            }
            if (sampler) {
              seriesModel.setData(data.downSample(data.mapDimension(valueAxis2.dim), 1 / rate, sampler, indexSampler));
            }
          }
        }
      }
    };
  }
  function install$c(registers) {
    registers.registerChartView(LineView);
    registers.registerSeriesModel(LineSeriesModel);
    registers.registerLayout(pointsLayout("line", true));
    registers.registerVisual({
      seriesType: "line",
      reset: function(seriesModel) {
        var data = seriesModel.getData();
        var lineStyle = seriesModel.getModel("lineStyle").getLineStyle();
        if (lineStyle && !lineStyle.stroke) {
          lineStyle.stroke = data.getVisual("style").fill;
        }
        data.setVisual("legendLineStyle", lineStyle);
      }
    });
    registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample("line"));
  }
  var ScatterSeriesModel = (
    /** @class */
    function(_super) {
      __extends(ScatterSeriesModel2, _super);
      function ScatterSeriesModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = ScatterSeriesModel2.type;
        _this.hasSymbolVisual = true;
        return _this;
      }
      ScatterSeriesModel2.prototype.getInitialData = function(option, ecModel) {
        return createSeriesData(null, this, {
          useEncodeDefaulter: true
        });
      };
      ScatterSeriesModel2.prototype.getProgressive = function() {
        var progressive = this.option.progressive;
        if (progressive == null) {
          return this.option.large ? 5e3 : this.get("progressive");
        }
        return progressive;
      };
      ScatterSeriesModel2.prototype.getProgressiveThreshold = function() {
        var progressiveThreshold = this.option.progressiveThreshold;
        if (progressiveThreshold == null) {
          return this.option.large ? 1e4 : this.get("progressiveThreshold");
        }
        return progressiveThreshold;
      };
      ScatterSeriesModel2.prototype.brushSelector = function(dataIndex, data, selectors) {
        return selectors.point(data.getItemLayout(dataIndex));
      };
      ScatterSeriesModel2.prototype.getZLevelKey = function() {
        return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
      };
      ScatterSeriesModel2.type = "series.scatter";
      ScatterSeriesModel2.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar", "matrix"];
      ScatterSeriesModel2.defaultOption = {
        coordinateSystem: "cartesian2d",
        // zlevel: 0,
        z: 2,
        legendHoverLink: true,
        symbolSize: 10,
        // symbolRotate: null,  // 图形旋转控制
        large: false,
        // Available when large is true
        largeThreshold: 2e3,
        // cursor: null,
        itemStyle: {
          opacity: 0.8
          // color: 各异
        },
        emphasis: {
          scale: true
        },
        // If clip the overflow graphics
        // Works on cartesian / polar series
        clip: true,
        select: {
          itemStyle: {
            borderColor: tokens.color.primary
          }
        },
        universalTransition: {
          divideShape: "clone"
        }
        // progressive: null
      };
      return ScatterSeriesModel2;
    }(SeriesModel)
  );
  var BOOST_SIZE_THRESHOLD = 4;
  var LargeSymbolPathShape = (
    /** @class */
    /* @__PURE__ */ function() {
      function LargeSymbolPathShape2() {
      }
      return LargeSymbolPathShape2;
    }()
  );
  var LargeSymbolPath = (
    /** @class */
    function(_super) {
      __extends(LargeSymbolPath2, _super);
      function LargeSymbolPath2(opts) {
        var _this = _super.call(this, opts) || this;
        _this._off = 0;
        _this.hoverDataIdx = -1;
        return _this;
      }
      LargeSymbolPath2.prototype.getDefaultShape = function() {
        return new LargeSymbolPathShape();
      };
      LargeSymbolPath2.prototype.reset = function() {
        this.notClear = false;
        this._off = 0;
      };
      LargeSymbolPath2.prototype.buildPath = function(path, shape) {
        var points2 = shape.points;
        var size = shape.size;
        var symbolProxy = this.symbolProxy;
        var symbolProxyShape = symbolProxy.shape;
        var ctx = path.getContext ? path.getContext() : path;
        var canBoost = ctx && size[0] < BOOST_SIZE_THRESHOLD;
        var softClipShape = this.softClipShape;
        var i;
        if (canBoost) {
          this._ctx = ctx;
          return;
        }
        this._ctx = null;
        for (i = this._off; i < points2.length; ) {
          var x = points2[i++];
          var y = points2[i++];
          if (isNaN(x) || isNaN(y)) {
            continue;
          }
          if (softClipShape && !softClipShape.contain(x, y)) {
            continue;
          }
          symbolProxyShape.x = x - size[0] / 2;
          symbolProxyShape.y = y - size[1] / 2;
          symbolProxyShape.width = size[0];
          symbolProxyShape.height = size[1];
          symbolProxy.buildPath(path, symbolProxyShape, true);
        }
        if (this.incremental) {
          this._off = i;
          this.notClear = true;
        }
      };
      LargeSymbolPath2.prototype.afterBrush = function() {
        var shape = this.shape;
        var points2 = shape.points;
        var size = shape.size;
        var ctx = this._ctx;
        var softClipShape = this.softClipShape;
        var i;
        if (!ctx) {
          return;
        }
        for (i = this._off; i < points2.length; ) {
          var x = points2[i++];
          var y = points2[i++];
          if (isNaN(x) || isNaN(y)) {
            continue;
          }
          if (softClipShape && !softClipShape.contain(x, y)) {
            continue;
          }
          ctx.fillRect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]);
        }
        if (this.incremental) {
          this._off = i;
          this.notClear = true;
        }
      };
      LargeSymbolPath2.prototype.findDataIndex = function(x, y) {
        var shape = this.shape;
        var points2 = shape.points;
        var size = shape.size;
        var w = Math.max(size[0], 4);
        var h = Math.max(size[1], 4);
        for (var idx = points2.length / 2 - 1; idx >= 0; idx--) {
          var i = idx * 2;
          var x0 = points2[i] - w / 2;
          var y0 = points2[i + 1] - h / 2;
          if (x >= x0 && y >= y0 && x <= x0 + w && y <= y0 + h) {
            return idx;
          }
        }
        return -1;
      };
      LargeSymbolPath2.prototype.contain = function(x, y) {
        var localPos = this.transformCoordToLocal(x, y);
        var rect = this.getBoundingRect();
        x = localPos[0];
        y = localPos[1];
        if (rect.contain(x, y)) {
          var dataIdx = this.hoverDataIdx = this.findDataIndex(x, y);
          return dataIdx >= 0;
        }
        this.hoverDataIdx = -1;
        return false;
      };
      LargeSymbolPath2.prototype.getBoundingRect = function() {
        var rect = this._rect;
        if (!rect) {
          var shape = this.shape;
          var points2 = shape.points;
          var size = shape.size;
          var w = size[0];
          var h = size[1];
          var minX = Infinity;
          var minY = Infinity;
          var maxX = -Infinity;
          var maxY = -Infinity;
          for (var i = 0; i < points2.length; ) {
            var x = points2[i++];
            var y = points2[i++];
            minX = Math.min(x, minX);
            maxX = Math.max(x, maxX);
            minY = Math.min(y, minY);
            maxY = Math.max(y, maxY);
          }
          rect = this._rect = new BoundingRect(minX - w / 2, minY - h / 2, maxX - minX + w, maxY - minY + h);
        }
        return rect;
      };
      return LargeSymbolPath2;
    }(Path)
  );
  var LargeSymbolDraw = (
    /** @class */
    function() {
      function LargeSymbolDraw2() {
        this.group = new Group$2();
      }
      LargeSymbolDraw2.prototype.updateData = function(data, opt) {
        this._clear();
        var symbolEl = this._create();
        symbolEl.setShape({
          points: data.getLayout("points")
        });
        this._setCommon(symbolEl, data, opt);
      };
      LargeSymbolDraw2.prototype.updateLayout = function(data) {
        var points2 = data.getLayout("points");
        this.group.eachChild(function(child) {
          if (child.startIndex != null) {
            var len2 = (child.endIndex - child.startIndex) * 2;
            var byteOffset = child.startIndex * 4 * 2;
            points2 = new Float32Array(points2.buffer, byteOffset, len2);
          }
          child.setShape("points", points2);
          child.reset();
        });
      };
      LargeSymbolDraw2.prototype.incrementalPrepareUpdate = function(data) {
        this._clear();
      };
      LargeSymbolDraw2.prototype.incrementalUpdate = function(taskParams, data, opt) {
        var lastAdded = this._newAdded[0];
        var points2 = data.getLayout("points");
        var oldPoints = lastAdded && lastAdded.shape.points;
        if (oldPoints && oldPoints.length < 2e4) {
          var oldLen = oldPoints.length;
          var newPoints = new Float32Array(oldLen + points2.length);
          newPoints.set(oldPoints);
          newPoints.set(points2, oldLen);
          lastAdded.endIndex = taskParams.end;
          lastAdded.setShape({
            points: newPoints
          });
        } else {
          this._newAdded = [];
          var symbolEl = this._create();
          symbolEl.startIndex = taskParams.start;
          symbolEl.endIndex = taskParams.end;
          symbolEl.incremental = true;
          symbolEl.setShape({
            points: points2
          });
          this._setCommon(symbolEl, data, opt);
        }
      };
      LargeSymbolDraw2.prototype.eachRendered = function(cb) {
        this._newAdded[0] && cb(this._newAdded[0]);
      };
      LargeSymbolDraw2.prototype._create = function() {
        var symbolEl = new LargeSymbolPath({
          cursor: "default"
        });
        symbolEl.ignoreCoarsePointer = true;
        this.group.add(symbolEl);
        this._newAdded.push(symbolEl);
        return symbolEl;
      };
      LargeSymbolDraw2.prototype._setCommon = function(symbolEl, data, opt) {
        var hostModel = data.hostModel;
        opt = opt || {};
        var size = data.getVisual("symbolSize");
        symbolEl.setShape("size", size instanceof Array ? size : [size, size]);
        symbolEl.softClipShape = opt.clipShape || null;
        symbolEl.symbolProxy = createSymbol(data.getVisual("symbol"), 0, 0, 0, 0);
        symbolEl.setColor = symbolEl.symbolProxy.setColor;
        var extrudeShadow = symbolEl.shape.size[0] < BOOST_SIZE_THRESHOLD;
        symbolEl.useStyle(
          // Draw shadow when doing fillRect is extremely slow.
          hostModel.getModel("itemStyle").getItemStyle(extrudeShadow ? ["color", "shadowBlur", "shadowColor"] : ["color"])
        );
        var globalStyle = data.getVisual("style");
        var visualColor = globalStyle && globalStyle.fill;
        if (visualColor) {
          symbolEl.setColor(visualColor);
        }
        var ecData = getECData(symbolEl);
        ecData.seriesIndex = hostModel.seriesIndex;
        symbolEl.on("mousemove", function(e2) {
          ecData.dataIndex = null;
          var dataIndex = symbolEl.hoverDataIdx;
          if (dataIndex >= 0) {
            ecData.dataIndex = dataIndex + (symbolEl.startIndex || 0);
          }
        });
      };
      LargeSymbolDraw2.prototype.remove = function() {
        this._clear();
      };
      LargeSymbolDraw2.prototype._clear = function() {
        this._newAdded = [];
        this.group.removeAll();
      };
      return LargeSymbolDraw2;
    }()
  );
  var ScatterView = (
    /** @class */
    function(_super) {
      __extends(ScatterView2, _super);
      function ScatterView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = ScatterView2.type;
        return _this;
      }
      ScatterView2.prototype.render = function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var symbolDraw = this._updateSymbolDraw(data, seriesModel);
        symbolDraw.updateData(data, {
          // TODO
          // If this parameter should be a shape or a bounding volume
          // shape will be more general.
          // But bounding volume like bounding rect will be much faster in the contain calculation
          clipShape: this._getClipShape(seriesModel)
        });
        this._finished = true;
      };
      ScatterView2.prototype.incrementalPrepareRender = function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var symbolDraw = this._updateSymbolDraw(data, seriesModel);
        symbolDraw.incrementalPrepareUpdate(data);
        this._finished = false;
      };
      ScatterView2.prototype.incrementalRender = function(taskParams, seriesModel, ecModel) {
        this._symbolDraw.incrementalUpdate(taskParams, seriesModel.getData(), {
          clipShape: this._getClipShape(seriesModel)
        });
        this._finished = taskParams.end === seriesModel.getData().count();
      };
      ScatterView2.prototype.updateTransform = function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        this.group.dirty();
        if (!this._finished || data.count() > 1e4) {
          return {
            update: true
          };
        } else {
          var res = pointsLayout("").reset(seriesModel, ecModel, api);
          if (res.progress) {
            res.progress({
              start: 0,
              end: data.count(),
              count: data.count()
            }, data);
          }
          this._symbolDraw.updateLayout(data);
        }
      };
      ScatterView2.prototype.eachRendered = function(cb) {
        this._symbolDraw && this._symbolDraw.eachRendered(cb);
      };
      ScatterView2.prototype._getClipShape = function(seriesModel) {
        if (!seriesModel.get("clip", true)) {
          return;
        }
        var coordSys = seriesModel.coordinateSystem;
        return coordSys && coordSys.getArea && coordSys.getArea(0.1);
      };
      ScatterView2.prototype._updateSymbolDraw = function(data, seriesModel) {
        var symbolDraw = this._symbolDraw;
        var pipelineContext = seriesModel.pipelineContext;
        var isLargeDraw = pipelineContext.large;
        if (!symbolDraw || isLargeDraw !== this._isLargeDraw) {
          symbolDraw && symbolDraw.remove();
          symbolDraw = this._symbolDraw = isLargeDraw ? new LargeSymbolDraw() : new SymbolDraw();
          this._isLargeDraw = isLargeDraw;
          this.group.removeAll();
        }
        this.group.add(symbolDraw.group);
        return symbolDraw;
      };
      ScatterView2.prototype.remove = function(ecModel, api) {
        this._symbolDraw && this._symbolDraw.remove(true);
        this._symbolDraw = null;
      };
      ScatterView2.prototype.dispose = function() {
      };
      ScatterView2.type = "scatter";
      return ScatterView2;
    }(ChartView)
  );
  var OUTER_BOUNDS_DEFAULT = {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  };
  var OUTER_BOUNDS_CLAMP_DEFAULT = ["25%", "25%"];
  var GridModel = (
    /** @class */
    function(_super) {
      __extends(GridModel2, _super);
      function GridModel2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      GridModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
        var outerBoundsCp = getLayoutParams(option.outerBounds);
        _super.prototype.mergeDefaultAndTheme.apply(this, arguments);
        if (outerBoundsCp && option.outerBounds) {
          mergeLayoutParam(option.outerBounds, outerBoundsCp);
        }
      };
      GridModel2.prototype.mergeOption = function(newOption, ecModel) {
        _super.prototype.mergeOption.apply(this, arguments);
        if (this.option.outerBounds && newOption.outerBounds) {
          mergeLayoutParam(this.option.outerBounds, newOption.outerBounds);
        }
      };
      GridModel2.type = "grid";
      GridModel2.dependencies = ["xAxis", "yAxis"];
      GridModel2.layoutMode = "box";
      GridModel2.defaultOption = {
        show: false,
        // zlevel: 0,
        z: 0,
        left: "15%",
        top: 65,
        right: "10%",
        bottom: 80,
        // If grid size contain label
        containLabel: false,
        outerBoundsMode: "auto",
        outerBounds: OUTER_BOUNDS_DEFAULT,
        outerBoundsContain: "all",
        outerBoundsClampWidth: OUTER_BOUNDS_CLAMP_DEFAULT[0],
        outerBoundsClampHeight: OUTER_BOUNDS_CLAMP_DEFAULT[1],
        // width: {totalWidth} - left - right,
        // height: {totalHeight} - top - bottom,
        backgroundColor: tokens.color.transparent,
        borderWidth: 1,
        borderColor: tokens.color.neutral30
      };
      return GridModel2;
    }(ComponentModel)
  );
  var CartesianAxisModel = (
    /** @class */
    function(_super) {
      __extends(CartesianAxisModel2, _super);
      function CartesianAxisModel2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      CartesianAxisModel2.prototype.getCoordSysModel = function() {
        return this.getReferringComponents("grid", SINGLE_REFERRING).models[0];
      };
      CartesianAxisModel2.type = "cartesian2dAxis";
      return CartesianAxisModel2;
    }(ComponentModel)
  );
  mixin(CartesianAxisModel, AxisModelCommonMixin);
  var defaultOption = {
    show: true,
    // zlevel: 0,
    z: 0,
    // Inverse the axis.
    inverse: false,
    // Axis name displayed.
    name: "",
    // 'start' | 'middle' | 'end'
    nameLocation: "end",
    // By degree. By default auto rotate by nameLocation.
    nameRotate: null,
    nameTruncate: {
      maxWidth: null,
      ellipsis: "...",
      placeholder: "."
    },
    // Use global text style by default.
    nameTextStyle: {
      // textMargin: never, // The default value will be specified based on `nameLocation`.
    },
    // The gap between axisName and axisLine.
    nameGap: 15,
    // Default `false` to support tooltip.
    silent: false,
    // Default `false` to avoid legacy user event listener fail.
    triggerEvent: false,
    tooltip: {
      show: false
    },
    axisPointer: {},
    axisLine: {
      show: true,
      onZero: true,
      onZeroAxisIndex: null,
      lineStyle: {
        color: tokens.color.axisLine,
        width: 1,
        type: "solid"
      },
      // The arrow at both ends the the axis.
      symbol: ["none", "none"],
      symbolSize: [10, 15],
      breakLine: true
    },
    axisTick: {
      show: true,
      // Whether axisTick is inside the grid or outside the grid.
      inside: false,
      // The length of axisTick.
      length: 5,
      lineStyle: {
        width: 1
      }
    },
    axisLabel: {
      show: true,
      // Whether axisLabel is inside the grid or outside the grid.
      inside: false,
      rotate: 0,
      // true | false | null/undefined (auto)
      showMinLabel: null,
      // true | false | null/undefined (auto)
      showMaxLabel: null,
      margin: 8,
      // formatter: null,
      fontSize: 12,
      color: tokens.color.axisLabel,
      // In scenarios like axis labels, when labels text's progression direction matches the label
      // layout direction (e.g., when all letters are in a single line), extra start/end margin is
      // needed to prevent the text from appearing visually joined. In the other case, when lables
      // are stacked (e.g., having rotation or horizontal labels on yAxis), the layout needs to be
      // compact, so NO extra top/bottom margin should be applied.
      textMargin: [0, 3]
    },
    splitLine: {
      show: true,
      showMinLine: true,
      showMaxLine: true,
      lineStyle: {
        color: tokens.color.axisSplitLine,
        width: 1,
        type: "solid"
      }
    },
    splitArea: {
      show: false,
      areaStyle: {
        color: [tokens.color.backgroundTint, tokens.color.backgroundTransparent]
      }
    },
    breakArea: {
      show: true,
      itemStyle: {
        color: tokens.color.neutral00,
        // Break border color should be darker than the splitLine
        // because it has opacity and should be more prominent
        borderColor: tokens.color.border,
        borderWidth: 1,
        borderType: [3, 3],
        opacity: 0.6
      },
      zigzagAmplitude: 4,
      zigzagMinSpan: 4,
      zigzagMaxSpan: 20,
      zigzagZ: 100,
      expandOnClick: true
    },
    breakLabelLayout: {
      moveOverlap: "auto"
    }
  };
  var categoryAxis = merge({
    // The gap at both ends of the axis. For categoryAxis, boolean.
    boundaryGap: true,
    // Set false to faster category collection.
    deduplication: null,
    jitter: 0,
    jitterOverlap: true,
    jitterMargin: 2,
    // splitArea: {
    // show: false
    // },
    splitLine: {
      show: false
    },
    axisTick: {
      // If tick is align with label when boundaryGap is true
      alignWithLabel: false,
      interval: "auto",
      show: "auto"
    },
    axisLabel: {
      interval: "auto"
    }
  }, defaultOption);
  var valueAxis = merge({
    boundaryGap: [0, 0],
    axisLine: {
      // Not shown when other axis is categoryAxis in cartesian
      show: "auto"
    },
    axisTick: {
      // Not shown when other axis is categoryAxis in cartesian
      show: "auto"
    },
    // TODO
    // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
    splitNumber: 5,
    minorTick: {
      // Minor tick, not available for cateogry axis.
      show: false,
      // Split number of minor ticks. The value should be in range of (0, 100)
      splitNumber: 5,
      // Length of minor tick
      length: 3,
      // Line style
      lineStyle: {
        // Default to be same with axisTick
      }
    },
    minorSplitLine: {
      show: false,
      lineStyle: {
        color: tokens.color.axisMinorSplitLine,
        width: 1
      }
    }
  }, defaultOption);
  var timeAxis = merge({
    splitNumber: 6,
    axisLabel: {
      // To eliminate labels that are not nice
      showMinLabel: false,
      showMaxLabel: false,
      rich: {
        primary: {
          fontWeight: "bold"
        }
      }
    },
    splitLine: {
      show: false
    }
  }, valueAxis);
  var logAxis = defaults({
    logBase: 10
  }, valueAxis);
  const axisDefault = {
    category: categoryAxis,
    value: valueAxis,
    time: timeAxis,
    log: logAxis
  };
  var AXIS_TYPES = {
    value: 1,
    category: 1,
    time: 1,
    log: 1
  };
  var _impl = null;
  function getAxisBreakHelper() {
    return _impl;
  }
  function axisModelCreator(registers, axisName, BaseAxisModelClass, extraDefaultOption) {
    each$5(AXIS_TYPES, function(v, axisType) {
      var defaultOption2 = merge(merge({}, axisDefault[axisType], true), extraDefaultOption, true);
      var AxisModel = (
        /** @class */
        function(_super) {
          __extends(AxisModel2, _super);
          function AxisModel2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = axisName + "Axis." + axisType;
            return _this;
          }
          AxisModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
            var layoutMode = fetchLayoutMode(this);
            var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
            var themeModel = ecModel.getTheme();
            merge(option, themeModel.get(axisType + "Axis"));
            merge(option, this.getDefaultOption());
            option.type = getAxisType(option);
            if (layoutMode) {
              mergeLayoutParam(option, inputPositionParams, layoutMode);
            }
          };
          AxisModel2.prototype.optionUpdated = function() {
            var thisOption = this.option;
            if (thisOption.type === "category") {
              this.__ordinalMeta = OrdinalMeta.createByAxisModel(this);
            }
          };
          AxisModel2.prototype.getCategories = function(rawData) {
            var option = this.option;
            if (option.type === "category") {
              if (rawData) {
                return option.data;
              }
              return this.__ordinalMeta.categories;
            }
          };
          AxisModel2.prototype.getOrdinalMeta = function() {
            return this.__ordinalMeta;
          };
          AxisModel2.prototype.updateAxisBreaks = function(payload) {
            return {
              breaks: []
            };
          };
          AxisModel2.type = axisName + "Axis." + axisType;
          AxisModel2.defaultOption = defaultOption2;
          return AxisModel2;
        }(BaseAxisModelClass)
      );
      registers.registerComponentModel(AxisModel);
    });
    registers.registerSubTypeDefaulter(axisName + "Axis", getAxisType);
  }
  function getAxisType(option) {
    return option.type || (option.data ? "category" : "value");
  }
  var Cartesian = (
    /** @class */
    function() {
      function Cartesian2(name) {
        this.type = "cartesian";
        this._dimList = [];
        this._axes = {};
        this.name = name || "";
      }
      Cartesian2.prototype.getAxis = function(dim) {
        return this._axes[dim];
      };
      Cartesian2.prototype.getAxes = function() {
        return map$1(this._dimList, function(dim) {
          return this._axes[dim];
        }, this);
      };
      Cartesian2.prototype.getAxesByScale = function(scaleType) {
        scaleType = scaleType.toLowerCase();
        return filter(this.getAxes(), function(axis) {
          return axis.scale.type === scaleType;
        });
      };
      Cartesian2.prototype.addAxis = function(axis) {
        var dim = axis.dim;
        this._axes[dim] = axis;
        this._dimList.push(dim);
      };
      return Cartesian2;
    }()
  );
  var cartesian2DDimensions = ["x", "y"];
  function canCalculateAffineTransform(scale2) {
    return (scale2.type === "interval" || scale2.type === "time") && !scale2.hasBreaks();
  }
  var Cartesian2D = (
    /** @class */
    function(_super) {
      __extends(Cartesian2D2, _super);
      function Cartesian2D2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "cartesian2d";
        _this.dimensions = cartesian2DDimensions;
        return _this;
      }
      Cartesian2D2.prototype.calcAffineTransform = function() {
        this._transform = this._invTransform = null;
        var xAxisScale = this.getAxis("x").scale;
        var yAxisScale = this.getAxis("y").scale;
        if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {
          return;
        }
        var xScaleExtent = xAxisScale.getExtent();
        var yScaleExtent = yAxisScale.getExtent();
        var start2 = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);
        var end2 = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);
        var xScaleSpan = xScaleExtent[1] - xScaleExtent[0];
        var yScaleSpan = yScaleExtent[1] - yScaleExtent[0];
        if (!xScaleSpan || !yScaleSpan) {
          return;
        }
        var scaleX = (end2[0] - start2[0]) / xScaleSpan;
        var scaleY = (end2[1] - start2[1]) / yScaleSpan;
        var translateX = start2[0] - xScaleExtent[0] * scaleX;
        var translateY = start2[1] - yScaleExtent[0] * scaleY;
        var m2 = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY];
        this._invTransform = invert([], m2);
      };
      Cartesian2D2.prototype.getBaseAxis = function() {
        return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
      };
      Cartesian2D2.prototype.containPoint = function(point) {
        var axisX = this.getAxis("x");
        var axisY = this.getAxis("y");
        return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
      };
      Cartesian2D2.prototype.containData = function(data) {
        return this.getAxis("x").containData(data[0]) && this.getAxis("y").containData(data[1]);
      };
      Cartesian2D2.prototype.containZone = function(data1, data2) {
        var zoneDiag1 = this.dataToPoint(data1);
        var zoneDiag2 = this.dataToPoint(data2);
        var area = this.getArea();
        var zone = new BoundingRect(zoneDiag1[0], zoneDiag1[1], zoneDiag2[0] - zoneDiag1[0], zoneDiag2[1] - zoneDiag1[1]);
        return area.intersect(zone);
      };
      Cartesian2D2.prototype.dataToPoint = function(data, clamp2, out2) {
        out2 = out2 || [];
        var xVal = data[0];
        var yVal = data[1];
        if (this._transform && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {
          return applyTransform$1(out2, data, this._transform);
        }
        var xAxis = this.getAxis("x");
        var yAxis = this.getAxis("y");
        out2[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal, clamp2));
        out2[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal, clamp2));
        return out2;
      };
      Cartesian2D2.prototype.clampData = function(data, out2) {
        var xScale = this.getAxis("x").scale;
        var yScale = this.getAxis("y").scale;
        var xAxisExtent = xScale.getExtent();
        var yAxisExtent = yScale.getExtent();
        var x = xScale.parse(data[0]);
        var y = yScale.parse(data[1]);
        out2 = out2 || [];
        out2[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));
        out2[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));
        return out2;
      };
      Cartesian2D2.prototype.pointToData = function(point, clamp2, out2) {
        out2 = out2 || [];
        if (this._invTransform) {
          return applyTransform$1(out2, point, this._invTransform);
        }
        var xAxis = this.getAxis("x");
        var yAxis = this.getAxis("y");
        out2[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp2);
        out2[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp2);
        return out2;
      };
      Cartesian2D2.prototype.getOtherAxis = function(axis) {
        return this.getAxis(axis.dim === "x" ? "y" : "x");
      };
      Cartesian2D2.prototype.getArea = function(tolerance) {
        tolerance = tolerance || 0;
        var xExtent = this.getAxis("x").getGlobalExtent();
        var yExtent = this.getAxis("y").getGlobalExtent();
        var x = Math.min(xExtent[0], xExtent[1]) - tolerance;
        var y = Math.min(yExtent[0], yExtent[1]) - tolerance;
        var width = Math.max(xExtent[0], xExtent[1]) - x + tolerance;
        var height = Math.max(yExtent[0], yExtent[1]) - y + tolerance;
        return new BoundingRect(x, y, width, height);
      };
      return Cartesian2D2;
    }(Cartesian)
  );
  var Axis2D = (
    /** @class */
    function(_super) {
      __extends(Axis2D2, _super);
      function Axis2D2(dim, scale2, coordExtent, axisType, position) {
        var _this = _super.call(this, dim, scale2, coordExtent) || this;
        _this.index = 0;
        _this.type = axisType || "value";
        _this.position = position || "bottom";
        return _this;
      }
      Axis2D2.prototype.isHorizontal = function() {
        var position = this.position;
        return position === "top" || position === "bottom";
      };
      Axis2D2.prototype.getGlobalExtent = function(asc2) {
        var ret = this.getExtent();
        ret[0] = this.toGlobalCoord(ret[0]);
        ret[1] = this.toGlobalCoord(ret[1]);
        asc2 && ret[0] > ret[1] && ret.reverse();
        return ret;
      };
      Axis2D2.prototype.pointToData = function(point, clamp2) {
        return this.coordToData(this.toLocalCoord(point[this.dim === "x" ? 0 : 1]), clamp2);
      };
      Axis2D2.prototype.setCategorySortInfo = function(info) {
        if (this.type !== "category") {
          return false;
        }
        this.model.option.categorySortInfo = info;
        this.scale.setSortInfo(info);
      };
      return Axis2D2;
    }(Axis)
  );
  var AXIS_BREAK_EXPAND_ACTION_TYPE = "expandAxisBreak";
  var define_process_env_default$9 = {};
  var PI = Math.PI;
  var DEFAULT_CENTER_NAME_MARGIN_LEVELS = [[1, 2, 1, 2], [5, 3, 5, 3], [8, 3, 8, 3]];
  var DEFAULT_ENDS_NAME_MARGIN_LEVELS = [[0, 1, 0, 1], [0, 3, 0, 3], [0, 3, 0, 3]];
  var getLabelInner = makeInner();
  var getTickInner = makeInner();
  var AxisBuilderSharedContext = (
    /** @class */
    function() {
      function AxisBuilderSharedContext2(resolveAxisNameOverlap) {
        this.recordMap = {};
        this.resolveAxisNameOverlap = resolveAxisNameOverlap;
      }
      AxisBuilderSharedContext2.prototype.ensureRecord = function(axisModel) {
        var dim = axisModel.axis.dim;
        var idx = axisModel.componentIndex;
        var recordMap = this.recordMap;
        var records = recordMap[dim] || (recordMap[dim] = []);
        return records[idx] || (records[idx] = {
          ready: {}
        });
      };
      return AxisBuilderSharedContext2;
    }()
  );
  function resetOverlapRecordToShared(cfg, shared, axisModel, labelLayoutList) {
    var axis = axisModel.axis;
    var record = shared.ensureRecord(axisModel);
    var labelInfoList = [];
    var stOccupiedRect;
    var useStOccupiedRect = hasAxisName(cfg.axisName) && isNameLocationCenter(cfg.nameLocation);
    each$5(labelLayoutList, function(layout2) {
      var layoutInfo = ensureLabelLayoutWithGeometry(layout2);
      if (!layoutInfo || layoutInfo.label.ignore) {
        return;
      }
      labelInfoList.push(layoutInfo);
      var transGroup = record.transGroup;
      if (useStOccupiedRect) {
        transGroup.transform ? invert(_stTransTmp, transGroup.transform) : identity(_stTransTmp);
        if (layoutInfo.transform) {
          mul(_stTransTmp, _stTransTmp, layoutInfo.transform);
        }
        BoundingRect.copy(_stLabelRectTmp, layoutInfo.localRect);
        _stLabelRectTmp.applyTransform(_stTransTmp);
        stOccupiedRect ? stOccupiedRect.union(_stLabelRectTmp) : BoundingRect.copy(stOccupiedRect = new BoundingRect(0, 0, 0, 0), _stLabelRectTmp);
      }
    });
    var sortByDim = Math.abs(record.dirVec.x) > 0.1 ? "x" : "y";
    var sortByValue = record.transGroup[sortByDim];
    labelInfoList.sort(function(info1, info2) {
      return Math.abs(info1.label[sortByDim] - sortByValue) - Math.abs(info2.label[sortByDim] - sortByValue);
    });
    if (useStOccupiedRect && stOccupiedRect) {
      var extent = axis.getExtent();
      var axisLineX = Math.min(extent[0], extent[1]);
      var axisLineWidth = Math.max(extent[0], extent[1]) - axisLineX;
      stOccupiedRect.union(new BoundingRect(axisLineX, 0, axisLineWidth, 1));
    }
    record.stOccupiedRect = stOccupiedRect;
    record.labelInfoList = labelInfoList;
  }
  var _stTransTmp = create();
  var _stLabelRectTmp = new BoundingRect(0, 0, 0, 0);
  var resolveAxisNameOverlapDefault = function(cfg, ctx, axisModel, nameLayoutInfo, nameMoveDirVec, thisRecord) {
    if (isNameLocationCenter(cfg.nameLocation)) {
      var stOccupiedRect = thisRecord.stOccupiedRect;
      if (stOccupiedRect) {
        moveIfOverlap(computeLabelGeometry2({}, stOccupiedRect, thisRecord.transGroup.transform), nameLayoutInfo, nameMoveDirVec);
      }
    } else {
      moveIfOverlapByLinearLabels(thisRecord.labelInfoList, thisRecord.dirVec, nameLayoutInfo, nameMoveDirVec);
    }
  };
  function moveIfOverlap(basedLayoutInfo, movableLayoutInfo, moveDirVec) {
    var mtv = new Point();
    if (labelIntersect(basedLayoutInfo, movableLayoutInfo, mtv, {
      direction: Math.atan2(moveDirVec.y, moveDirVec.x),
      bidirectional: false,
      touchThreshold: 0.05
    })) {
      labelLayoutApplyTranslation(movableLayoutInfo, mtv);
    }
  }
  function moveIfOverlapByLinearLabels(baseLayoutInfoList, baseDirVec, movableLayoutInfo, moveDirVec) {
    var sameDir = Point.dot(moveDirVec, baseDirVec) >= 0;
    for (var idx = 0, len2 = baseLayoutInfoList.length; idx < len2; idx++) {
      var labelInfo = baseLayoutInfoList[sameDir ? idx : len2 - 1 - idx];
      if (!labelInfo.label.ignore) {
        moveIfOverlap(labelInfo, movableLayoutInfo, moveDirVec);
      }
    }
  }
  var AxisBuilder = (
    /** @class */
    function() {
      function AxisBuilder2(axisModel, api, opt, shared) {
        this.group = new Group$2();
        this._axisModel = axisModel;
        this._api = api;
        this._local = {};
        this._shared = shared || new AxisBuilderSharedContext(resolveAxisNameOverlapDefault);
        this._resetCfgDetermined(opt);
      }
      AxisBuilder2.prototype.updateCfg = function(opt) {
        if (define_process_env_default$9.NODE_ENV !== "production") {
          var ready = this._shared.ensureRecord(this._axisModel).ready;
          assert(!ready.axisLine && !ready.axisTickLabelDetermine);
          ready.axisName = ready.axisTickLabelEstimate = false;
        }
        var raw = this._cfg.raw;
        raw.position = opt.position;
        raw.labelOffset = opt.labelOffset;
        this._resetCfgDetermined(raw);
      };
      AxisBuilder2.prototype.__getRawCfg = function() {
        return this._cfg.raw;
      };
      AxisBuilder2.prototype._resetCfgDetermined = function(raw) {
        var axisModel = this._axisModel;
        var axisModelDefaultOption = axisModel.getDefaultOption ? axisModel.getDefaultOption() : {};
        var axisName = retrieve2(raw.axisName, axisModel.get("name"));
        var nameMoveOverlapOption = axisModel.get("nameMoveOverlap");
        if (nameMoveOverlapOption == null || nameMoveOverlapOption === "auto") {
          nameMoveOverlapOption = retrieve2(raw.defaultNameMoveOverlap, true);
        }
        var cfg = {
          raw,
          position: raw.position,
          rotation: raw.rotation,
          nameDirection: retrieve2(raw.nameDirection, 1),
          tickDirection: retrieve2(raw.tickDirection, 1),
          labelDirection: retrieve2(raw.labelDirection, 1),
          labelOffset: retrieve2(raw.labelOffset, 0),
          silent: retrieve2(raw.silent, true),
          axisName,
          nameLocation: retrieve3(axisModel.get("nameLocation"), axisModelDefaultOption.nameLocation, "end"),
          shouldNameMoveOverlap: hasAxisName(axisName) && nameMoveOverlapOption,
          optionHideOverlap: axisModel.get(["axisLabel", "hideOverlap"]),
          showMinorTicks: axisModel.get(["minorTick", "show"])
        };
        if (define_process_env_default$9.NODE_ENV !== "production") {
          assert(cfg.position != null);
          assert(cfg.rotation != null);
        }
        this._cfg = cfg;
        var transformGroup = new Group$2({
          x: cfg.position[0],
          y: cfg.position[1],
          rotation: cfg.rotation
        });
        transformGroup.updateTransform();
        this._transformGroup = transformGroup;
        var record = this._shared.ensureRecord(axisModel);
        record.transGroup = this._transformGroup;
        record.dirVec = new Point(Math.cos(-cfg.rotation), Math.sin(-cfg.rotation));
      };
      AxisBuilder2.prototype.build = function(axisPartNameMap, extraParams) {
        var _this = this;
        if (!axisPartNameMap) {
          axisPartNameMap = {
            axisLine: true,
            axisTickLabelEstimate: false,
            axisTickLabelDetermine: true,
            axisName: true
          };
        }
        each$5(AXIS_BUILDER_AXIS_PART_NAMES, function(partName) {
          if (axisPartNameMap[partName]) {
            builders[partName](_this._cfg, _this._local, _this._shared, _this._axisModel, _this.group, _this._transformGroup, _this._api, extraParams || {});
          }
        });
        return this;
      };
      AxisBuilder2.innerTextLayout = function(axisRotation, textRotation, direction) {
        var rotationDiff = remRadian(textRotation - axisRotation);
        var textAlign;
        var textVerticalAlign;
        if (isRadianAroundZero(rotationDiff)) {
          textVerticalAlign = direction > 0 ? "top" : "bottom";
          textAlign = "center";
        } else if (isRadianAroundZero(rotationDiff - PI)) {
          textVerticalAlign = direction > 0 ? "bottom" : "top";
          textAlign = "center";
        } else {
          textVerticalAlign = "middle";
          if (rotationDiff > 0 && rotationDiff < PI) {
            textAlign = direction > 0 ? "right" : "left";
          } else {
            textAlign = direction > 0 ? "left" : "right";
          }
        }
        return {
          rotation: rotationDiff,
          textAlign,
          textVerticalAlign
        };
      };
      AxisBuilder2.makeAxisEventDataBase = function(axisModel) {
        var eventData = {
          componentType: axisModel.mainType,
          componentIndex: axisModel.componentIndex
        };
        eventData[axisModel.mainType + "Index"] = axisModel.componentIndex;
        return eventData;
      };
      AxisBuilder2.isLabelSilent = function(axisModel) {
        var tooltipOpt = axisModel.get("tooltip");
        return axisModel.get("silent") || !(axisModel.get("triggerEvent") || tooltipOpt && tooltipOpt.show);
      };
      return AxisBuilder2;
    }()
  );
  var AXIS_BUILDER_AXIS_PART_NAMES = ["axisLine", "axisTickLabelEstimate", "axisTickLabelDetermine", "axisName"];
  var builders = {
    axisLine: function(cfg, local, shared, axisModel, group, transformGroup, api) {
      if (define_process_env_default$9.NODE_ENV !== "production") {
        var ready = shared.ensureRecord(axisModel).ready;
        assert(!ready.axisLine);
        ready.axisLine = true;
      }
      var shown = axisModel.get(["axisLine", "show"]);
      if (shown === "auto") {
        shown = true;
        if (cfg.raw.axisLineAutoShow != null) {
          shown = !!cfg.raw.axisLineAutoShow;
        }
      }
      if (!shown) {
        return;
      }
      var extent = axisModel.axis.getExtent();
      var matrix = transformGroup.transform;
      var pt1 = [extent[0], 0];
      var pt2 = [extent[1], 0];
      var inverse = pt1[0] > pt2[0];
      if (matrix) {
        applyTransform$1(pt1, pt1, matrix);
        applyTransform$1(pt2, pt2, matrix);
      }
      var lineStyle = extend({
        lineCap: "round"
      }, axisModel.getModel(["axisLine", "lineStyle"]).getLineStyle());
      var pathBaseProp = {
        strokeContainThreshold: cfg.raw.strokeContainThreshold || 5,
        silent: true,
        z2: 1,
        style: lineStyle
      };
      if (axisModel.get(["axisLine", "breakLine"]) && axisModel.axis.scale.hasBreaks()) {
        getAxisBreakHelper().buildAxisBreakLine(axisModel, group, transformGroup, pathBaseProp);
      } else {
        var line = new Line(extend({
          shape: {
            x1: pt1[0],
            y1: pt1[1],
            x2: pt2[0],
            y2: pt2[1]
          }
        }, pathBaseProp));
        subPixelOptimizeLine(line.shape, line.style.lineWidth);
        line.anid = "line";
        group.add(line);
      }
      var arrows = axisModel.get(["axisLine", "symbol"]);
      if (arrows != null) {
        var arrowSize = axisModel.get(["axisLine", "symbolSize"]);
        if (isString(arrows)) {
          arrows = [arrows, arrows];
        }
        if (isString(arrowSize) || isNumber(arrowSize)) {
          arrowSize = [arrowSize, arrowSize];
        }
        var arrowOffset = normalizeSymbolOffset(axisModel.get(["axisLine", "symbolOffset"]) || 0, arrowSize);
        var symbolWidth_1 = arrowSize[0];
        var symbolHeight_1 = arrowSize[1];
        each$5([{
          rotate: cfg.rotation + Math.PI / 2,
          offset: arrowOffset[0],
          r: 0
        }, {
          rotate: cfg.rotation - Math.PI / 2,
          offset: arrowOffset[1],
          r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))
        }], function(point, index2) {
          if (arrows[index2] !== "none" && arrows[index2] != null) {
            var symbol = createSymbol(arrows[index2], -symbolWidth_1 / 2, -symbolHeight_1 / 2, symbolWidth_1, symbolHeight_1, lineStyle.stroke, true);
            var r = point.r + point.offset;
            var pt = inverse ? pt2 : pt1;
            symbol.attr({
              rotation: point.rotate,
              x: pt[0] + r * Math.cos(cfg.rotation),
              y: pt[1] - r * Math.sin(cfg.rotation),
              silent: true,
              z2: 11
            });
            group.add(symbol);
          }
        });
      }
    },
    /**
     * [CAUTION] This method can be called multiple times, following the change due to `resetCfg` called
     *  in size measurement. Thus this method should be idempotent, and should be performant.
     */
    axisTickLabelEstimate: function(cfg, local, shared, axisModel, group, transformGroup, api, extraParams) {
      if (define_process_env_default$9.NODE_ENV !== "production") {
        var ready = shared.ensureRecord(axisModel).ready;
        assert(!ready.axisTickLabelDetermine);
        ready.axisTickLabelEstimate = true;
      }
      var needCallLayout = dealLastTickLabelResultReusable(local, group, extraParams);
      if (needCallLayout) {
        layOutAxisTickLabel(cfg, local, shared, axisModel, group, transformGroup, api, AxisTickLabelComputingKind.estimate);
      }
    },
    /**
     * Finish axis tick label build.
     * Can be only called once.
     */
    axisTickLabelDetermine: function(cfg, local, shared, axisModel, group, transformGroup, api, extraParams) {
      if (define_process_env_default$9.NODE_ENV !== "production") {
        var ready = shared.ensureRecord(axisModel).ready;
        ready.axisTickLabelDetermine = true;
      }
      var needCallLayout = dealLastTickLabelResultReusable(local, group, extraParams);
      if (needCallLayout) {
        layOutAxisTickLabel(cfg, local, shared, axisModel, group, transformGroup, api, AxisTickLabelComputingKind.determine);
      }
      var ticksEls = buildAxisMajorTicks(cfg, group, transformGroup, axisModel);
      syncLabelIgnoreToMajorTicks(cfg, local.labelLayoutList, ticksEls);
      buildAxisMinorTicks(cfg, group, transformGroup, axisModel, cfg.tickDirection);
    },
    /**
     * [CAUTION] This method can be called multiple times, following the change due to `resetCfg` called
     *  in size measurement. Thus this method should be idempotent, and should be performant.
     */
    axisName: function(cfg, local, shared, axisModel, group, transformGroup, api, extraParams) {
      var sharedRecord = shared.ensureRecord(axisModel);
      if (define_process_env_default$9.NODE_ENV !== "production") {
        var ready = sharedRecord.ready;
        assert(ready.axisTickLabelEstimate || ready.axisTickLabelDetermine);
        ready.axisName = true;
      }
      if (local.nameEl) {
        group.remove(local.nameEl);
        local.nameEl = sharedRecord.nameLayout = sharedRecord.nameLocation = null;
      }
      var name = cfg.axisName;
      if (!hasAxisName(name)) {
        return;
      }
      var nameLocation = cfg.nameLocation;
      var nameDirection = cfg.nameDirection;
      var textStyleModel = axisModel.getModel("nameTextStyle");
      var gap = axisModel.get("nameGap") || 0;
      var extent = axisModel.axis.getExtent();
      var gapStartEndSignal = axisModel.axis.inverse ? -1 : 1;
      var pos = new Point(0, 0);
      var nameMoveDirVec = new Point(0, 0);
      if (nameLocation === "start") {
        pos.x = extent[0] - gapStartEndSignal * gap;
        nameMoveDirVec.x = -gapStartEndSignal;
      } else if (nameLocation === "end") {
        pos.x = extent[1] + gapStartEndSignal * gap;
        nameMoveDirVec.x = gapStartEndSignal;
      } else {
        pos.x = (extent[0] + extent[1]) / 2;
        pos.y = cfg.labelOffset + nameDirection * gap;
        nameMoveDirVec.y = nameDirection;
      }
      var mt = create();
      nameMoveDirVec.transform(rotate(mt, mt, cfg.rotation));
      var nameRotation = axisModel.get("nameRotate");
      if (nameRotation != null) {
        nameRotation = nameRotation * PI / 180;
      }
      var labelLayout;
      var axisNameAvailableWidth;
      if (isNameLocationCenter(nameLocation)) {
        labelLayout = AxisBuilder.innerTextLayout(
          cfg.rotation,
          nameRotation != null ? nameRotation : cfg.rotation,
          // Adapt to axis.
          nameDirection
        );
      } else {
        labelLayout = endTextLayout(cfg.rotation, nameLocation, nameRotation || 0, extent);
        axisNameAvailableWidth = cfg.raw.axisNameAvailableWidth;
        if (axisNameAvailableWidth != null) {
          axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));
          !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
        }
      }
      var textFont = textStyleModel.getFont();
      var truncateOpt = axisModel.get("nameTruncate", true) || {};
      var ellipsis = truncateOpt.ellipsis;
      var maxWidth = retrieve(cfg.raw.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);
      var nameMarginLevel = extraParams.nameMarginLevel || 0;
      var textEl = new ZRText({
        x: pos.x,
        y: pos.y,
        rotation: labelLayout.rotation,
        silent: AxisBuilder.isLabelSilent(axisModel),
        style: createTextStyle(textStyleModel, {
          text: name,
          font: textFont,
          overflow: "truncate",
          width: maxWidth,
          ellipsis,
          fill: textStyleModel.getTextColor() || axisModel.get(["axisLine", "lineStyle", "color"]),
          align: textStyleModel.get("align") || labelLayout.textAlign,
          verticalAlign: textStyleModel.get("verticalAlign") || labelLayout.textVerticalAlign
        }),
        z2: 1
      });
      setTooltipConfig({
        el: textEl,
        componentModel: axisModel,
        itemName: name
      });
      textEl.__fullText = name;
      textEl.anid = "name";
      if (axisModel.get("triggerEvent")) {
        var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
        eventData.targetType = "axisName";
        eventData.name = name;
        getECData(textEl).eventData = eventData;
      }
      transformGroup.add(textEl);
      textEl.updateTransform();
      local.nameEl = textEl;
      var nameLayout = sharedRecord.nameLayout = ensureLabelLayoutWithGeometry({
        label: textEl,
        priority: textEl.z2,
        defaultAttr: {
          ignore: textEl.ignore
        },
        marginDefault: isNameLocationCenter(nameLocation) ? DEFAULT_CENTER_NAME_MARGIN_LEVELS[nameMarginLevel] : DEFAULT_ENDS_NAME_MARGIN_LEVELS[nameMarginLevel]
      });
      sharedRecord.nameLocation = nameLocation;
      group.add(textEl);
      textEl.decomposeTransform();
      if (cfg.shouldNameMoveOverlap && nameLayout) {
        var record = shared.ensureRecord(axisModel);
        if (define_process_env_default$9.NODE_ENV !== "production") {
          assert(record.labelInfoList);
        }
        shared.resolveAxisNameOverlap(cfg, shared, axisModel, nameLayout, nameMoveDirVec, record);
      }
    }
  };
  function layOutAxisTickLabel(cfg, local, shared, axisModel, group, transformGroup, api, kind) {
    if (!axisLabelBuildResultExists(local)) {
      buildAxisLabel(cfg, local, group, kind, axisModel, api);
    }
    var labelLayoutList = local.labelLayoutList;
    updateAxisLabelChangableProps(cfg, axisModel, labelLayoutList, transformGroup);
    adjustBreakLabels(axisModel, cfg.rotation);
    var optionHideOverlap = cfg.optionHideOverlap;
    fixMinMaxLabelShow(axisModel, labelLayoutList, optionHideOverlap);
    if (optionHideOverlap) {
      hideOverlap(
        // Filter the already ignored labels by the previous overlap resolving methods.
        filter(labelLayoutList, function(layout2) {
          return layout2 && !layout2.label.ignore;
        })
      );
    }
    resetOverlapRecordToShared(cfg, shared, axisModel, labelLayoutList);
  }
  function endTextLayout(rotation, textPosition, textRotate, extent) {
    var rotationDiff = remRadian(textRotate - rotation);
    var textAlign;
    var textVerticalAlign;
    var inverse = extent[0] > extent[1];
    var onLeft = textPosition === "start" && !inverse || textPosition !== "start" && inverse;
    if (isRadianAroundZero(rotationDiff - PI / 2)) {
      textVerticalAlign = onLeft ? "bottom" : "top";
      textAlign = "center";
    } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {
      textVerticalAlign = onLeft ? "top" : "bottom";
      textAlign = "center";
    } else {
      textVerticalAlign = "middle";
      if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {
        textAlign = onLeft ? "left" : "right";
      } else {
        textAlign = onLeft ? "right" : "left";
      }
    }
    return {
      rotation: rotationDiff,
      textAlign,
      textVerticalAlign
    };
  }
  function fixMinMaxLabelShow(axisModel, labelLayoutList, optionHideOverlap) {
    if (shouldShowAllLabels(axisModel.axis)) {
      return;
    }
    function deal(showMinMaxLabel, outmostLabelIdx, innerLabelIdx) {
      var outmostLabelLayout = ensureLabelLayoutWithGeometry(labelLayoutList[outmostLabelIdx]);
      var innerLabelLayout = ensureLabelLayoutWithGeometry(labelLayoutList[innerLabelIdx]);
      if (!outmostLabelLayout || !innerLabelLayout) {
        return;
      }
      if (showMinMaxLabel === false || outmostLabelLayout.suggestIgnore) {
        ignoreEl(outmostLabelLayout.label);
        return;
      }
      if (innerLabelLayout.suggestIgnore) {
        ignoreEl(innerLabelLayout.label);
        return;
      }
      var touchThreshold = 0.1;
      if (!optionHideOverlap) {
        var marginForce = [0, 0, 0, 0];
        outmostLabelLayout = newLabelLayoutWithGeometry({
          marginForce
        }, outmostLabelLayout);
        innerLabelLayout = newLabelLayoutWithGeometry({
          marginForce
        }, innerLabelLayout);
      }
      if (labelIntersect(outmostLabelLayout, innerLabelLayout, null, {
        touchThreshold
      })) {
        if (showMinMaxLabel) {
          ignoreEl(innerLabelLayout.label);
        } else {
          ignoreEl(outmostLabelLayout.label);
        }
      }
    }
    var showMinLabel = axisModel.get(["axisLabel", "showMinLabel"]);
    var showMaxLabel = axisModel.get(["axisLabel", "showMaxLabel"]);
    var labelsLen = labelLayoutList.length;
    deal(showMinLabel, 0, 1);
    deal(showMaxLabel, labelsLen - 1, labelsLen - 2);
  }
  function syncLabelIgnoreToMajorTicks(cfg, labelLayoutList, tickEls) {
    if (cfg.showMinorTicks) {
      return;
    }
    each$5(labelLayoutList, function(labelLayout) {
      if (labelLayout && labelLayout.label.ignore) {
        for (var idx = 0; idx < tickEls.length; idx++) {
          var tickEl = tickEls[idx];
          var tickInner = getTickInner(tickEl);
          var labelInner2 = getLabelInner(labelLayout.label);
          if (tickInner.tickValue != null && !tickInner.onBand && tickInner.tickValue === labelInner2.tickValue) {
            ignoreEl(tickEl);
            return;
          }
        }
      }
    });
  }
  function ignoreEl(el) {
    el && (el.ignore = true);
  }
  function createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {
    var tickEls = [];
    var pt1 = [];
    var pt2 = [];
    for (var i = 0; i < ticksCoords.length; i++) {
      var tickCoord = ticksCoords[i].coord;
      pt1[0] = tickCoord;
      pt1[1] = 0;
      pt2[0] = tickCoord;
      pt2[1] = tickEndCoord;
      if (tickTransform) {
        applyTransform$1(pt1, pt1, tickTransform);
        applyTransform$1(pt2, pt2, tickTransform);
      }
      var tickEl = new Line({
        shape: {
          x1: pt1[0],
          y1: pt1[1],
          x2: pt2[0],
          y2: pt2[1]
        },
        style: tickLineStyle,
        z2: 2,
        autoBatch: true,
        silent: true
      });
      subPixelOptimizeLine(tickEl.shape, tickEl.style.lineWidth);
      tickEl.anid = anidPrefix + "_" + ticksCoords[i].tickValue;
      tickEls.push(tickEl);
      var inner2 = getTickInner(tickEl);
      inner2.onBand = !!ticksCoords[i].onBand;
      inner2.tickValue = ticksCoords[i].tickValue;
    }
    return tickEls;
  }
  function buildAxisMajorTicks(cfg, group, transformGroup, axisModel) {
    var axis = axisModel.axis;
    var tickModel = axisModel.getModel("axisTick");
    var shown = tickModel.get("show");
    if (shown === "auto") {
      shown = true;
      if (cfg.raw.axisTickAutoShow != null) {
        shown = !!cfg.raw.axisTickAutoShow;
      }
    }
    if (!shown || axis.scale.isBlank()) {
      return [];
    }
    var lineStyleModel = tickModel.getModel("lineStyle");
    var tickEndCoord = cfg.tickDirection * tickModel.get("length");
    var ticksCoords = axis.getTicksCoords();
    var ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, defaults(lineStyleModel.getLineStyle(), {
      stroke: axisModel.get(["axisLine", "lineStyle", "color"])
    }), "ticks");
    for (var i = 0; i < ticksEls.length; i++) {
      group.add(ticksEls[i]);
    }
    return ticksEls;
  }
  function buildAxisMinorTicks(cfg, group, transformGroup, axisModel, tickDirection) {
    var axis = axisModel.axis;
    var minorTickModel = axisModel.getModel("minorTick");
    if (!cfg.showMinorTicks || axis.scale.isBlank()) {
      return;
    }
    var minorTicksCoords = axis.getMinorTicksCoords();
    if (!minorTicksCoords.length) {
      return;
    }
    var lineStyleModel = minorTickModel.getModel("lineStyle");
    var tickEndCoord = tickDirection * minorTickModel.get("length");
    var minorTickLineStyle = defaults(lineStyleModel.getLineStyle(), defaults(axisModel.getModel("axisTick").getLineStyle(), {
      stroke: axisModel.get(["axisLine", "lineStyle", "color"])
    }));
    for (var i = 0; i < minorTicksCoords.length; i++) {
      var minorTicksEls = createTicks(minorTicksCoords[i], transformGroup.transform, tickEndCoord, minorTickLineStyle, "minorticks_" + i);
      for (var k = 0; k < minorTicksEls.length; k++) {
        group.add(minorTicksEls[k]);
      }
    }
  }
  function dealLastTickLabelResultReusable(local, group, extraParams) {
    if (axisLabelBuildResultExists(local)) {
      var axisLabelsCreationContext = local.axisLabelsCreationContext;
      if (define_process_env_default$9.NODE_ENV !== "production") {
        assert(local.labelGroup && axisLabelsCreationContext);
      }
      var noPxChangeTryDetermine = axisLabelsCreationContext.out.noPxChangeTryDetermine;
      if (extraParams.noPxChange) {
        var canDetermine = true;
        for (var idx = 0; idx < noPxChangeTryDetermine.length; idx++) {
          canDetermine = canDetermine && noPxChangeTryDetermine[idx]();
        }
        if (canDetermine) {
          return false;
        }
      }
      if (noPxChangeTryDetermine.length) {
        group.remove(local.labelGroup);
        axisLabelBuildResultSet(local, null, null, null);
      }
    }
    return true;
  }
  function buildAxisLabel(cfg, local, group, kind, axisModel, api) {
    var axis = axisModel.axis;
    var show = retrieve(cfg.raw.axisLabelShow, axisModel.get(["axisLabel", "show"]));
    var labelGroup = new Group$2();
    group.add(labelGroup);
    var axisLabelCreationCtx = createAxisLabelsComputingContext(kind);
    if (!show || axis.scale.isBlank()) {
      axisLabelBuildResultSet(local, [], labelGroup, axisLabelCreationCtx);
      return;
    }
    var labelModel = axisModel.getModel("axisLabel");
    var labels = axis.getViewLabels(axisLabelCreationCtx);
    var labelRotation = (retrieve(cfg.raw.labelRotate, labelModel.get("rotate")) || 0) * PI / 180;
    var labelLayout = AxisBuilder.innerTextLayout(cfg.rotation, labelRotation, cfg.labelDirection);
    var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);
    var labelEls = [];
    var triggerEvent = axisModel.get("triggerEvent");
    var z2Min = Infinity;
    var z2Max = -Infinity;
    each$5(labels, function(labelItem, index2) {
      var _a2;
      var tickValue = axis.scale.type === "ordinal" ? axis.scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;
      var formattedLabel = labelItem.formattedLabel;
      var rawLabel = labelItem.rawLabel;
      var itemLabelModel = labelModel;
      if (rawCategoryData && rawCategoryData[tickValue]) {
        var rawCategoryItem = rawCategoryData[tickValue];
        if (isObject$2(rawCategoryItem) && rawCategoryItem.textStyle) {
          itemLabelModel = new Model(rawCategoryItem.textStyle, labelModel, axisModel.ecModel);
        }
      }
      var textColor = itemLabelModel.getTextColor() || axisModel.get(["axisLine", "lineStyle", "color"]);
      var align = itemLabelModel.getShallow("align", true) || labelLayout.textAlign;
      var alignMin = retrieve2(itemLabelModel.getShallow("alignMinLabel", true), align);
      var alignMax = retrieve2(itemLabelModel.getShallow("alignMaxLabel", true), align);
      var verticalAlign = itemLabelModel.getShallow("verticalAlign", true) || itemLabelModel.getShallow("baseline", true) || labelLayout.textVerticalAlign;
      var verticalAlignMin = retrieve2(itemLabelModel.getShallow("verticalAlignMinLabel", true), verticalAlign);
      var verticalAlignMax = retrieve2(itemLabelModel.getShallow("verticalAlignMaxLabel", true), verticalAlign);
      var z2 = 10 + (((_a2 = labelItem.time) === null || _a2 === void 0 ? void 0 : _a2.level) || 0);
      z2Min = Math.min(z2Min, z2);
      z2Max = Math.max(z2Max, z2);
      var textEl = new ZRText({
        // --- transform props start ---
        // All of the transform props MUST not be set here, but should be set in
        // `updateAxisLabelChangableProps`, because they may change in estimation,
        // and need to calculate based on global coord sys by `decomposeTransform`.
        x: 0,
        y: 0,
        rotation: 0,
        // --- transform props end ---
        silent: AxisBuilder.isLabelSilent(axisModel),
        z2,
        style: createTextStyle(itemLabelModel, {
          text: formattedLabel,
          align: index2 === 0 ? alignMin : index2 === labels.length - 1 ? alignMax : align,
          verticalAlign: index2 === 0 ? verticalAlignMin : index2 === labels.length - 1 ? verticalAlignMax : verticalAlign,
          fill: isFunction(textColor) ? textColor(
            // (1) In category axis with data zoom, tick is not the original
            // index of axis.data. So tick should not be exposed to user
            // in category axis.
            // (2) Compatible with previous version, which always use formatted label as
            // input. But in interval scale the formatted label is like '223,445', which
            // maked user replace ','. So we modify it to return original val but remain
            // it as 'string' to avoid error in replacing.
            axis.type === "category" ? rawLabel : axis.type === "value" ? tickValue + "" : tickValue,
            index2
          ) : textColor
        })
      });
      textEl.anid = "label_" + tickValue;
      var inner2 = getLabelInner(textEl);
      inner2["break"] = labelItem["break"];
      inner2.tickValue = tickValue;
      inner2.layoutRotation = labelLayout.rotation;
      setTooltipConfig({
        el: textEl,
        componentModel: axisModel,
        itemName: formattedLabel,
        formatterParamsExtra: {
          isTruncated: function() {
            return textEl.isTruncated;
          },
          value: rawLabel,
          tickIndex: index2
        }
      });
      if (triggerEvent) {
        var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
        eventData.targetType = "axisLabel";
        eventData.value = rawLabel;
        eventData.tickIndex = index2;
        if (labelItem["break"]) {
          eventData["break"] = {
            // type: labelItem.break.type,
            start: labelItem["break"].parsedBreak.vmin,
            end: labelItem["break"].parsedBreak.vmax
          };
        }
        if (axis.type === "category") {
          eventData.dataIndex = tickValue;
        }
        getECData(textEl).eventData = eventData;
        if (labelItem["break"]) {
          addBreakEventHandler(axisModel, api, textEl, labelItem["break"]);
        }
      }
      labelEls.push(textEl);
      labelGroup.add(textEl);
    });
    var labelLayoutList = map$1(labelEls, function(label) {
      return {
        label,
        priority: getLabelInner(label)["break"] ? label.z2 + (z2Max - z2Min + 1) : label.z2,
        defaultAttr: {
          ignore: label.ignore
        }
      };
    });
    axisLabelBuildResultSet(local, labelLayoutList, labelGroup, axisLabelCreationCtx);
  }
  function axisLabelBuildResultExists(local) {
    return !!local.labelLayoutList;
  }
  function axisLabelBuildResultSet(local, labelLayoutList, labelGroup, axisLabelsCreationContext) {
    local.labelLayoutList = labelLayoutList;
    local.labelGroup = labelGroup;
    local.axisLabelsCreationContext = axisLabelsCreationContext;
  }
  function updateAxisLabelChangableProps(cfg, axisModel, labelLayoutList, transformGroup) {
    var labelMargin = axisModel.get(["axisLabel", "margin"]);
    each$5(labelLayoutList, function(layout2, idx) {
      var geometry = ensureLabelLayoutWithGeometry(layout2);
      if (!geometry) {
        return;
      }
      var labelEl = geometry.label;
      var inner2 = getLabelInner(labelEl);
      geometry.suggestIgnore = labelEl.ignore;
      labelEl.ignore = false;
      copyTransform(_tmpLayoutEl, _tmpLayoutElReset);
      _tmpLayoutEl.x = axisModel.axis.dataToCoord(inner2.tickValue);
      _tmpLayoutEl.y = cfg.labelOffset + cfg.labelDirection * labelMargin;
      _tmpLayoutEl.rotation = inner2.layoutRotation;
      transformGroup.add(_tmpLayoutEl);
      _tmpLayoutEl.updateTransform();
      transformGroup.remove(_tmpLayoutEl);
      _tmpLayoutEl.decomposeTransform();
      copyTransform(labelEl, _tmpLayoutEl);
      labelEl.markRedraw();
      setLabelLayoutDirty(geometry, true);
      ensureLabelLayoutWithGeometry(geometry);
    });
  }
  var _tmpLayoutEl = new Rect$1();
  var _tmpLayoutElReset = new Rect$1();
  function hasAxisName(axisName) {
    return !!axisName;
  }
  function addBreakEventHandler(axisModel, api, textEl, visualBreak) {
    textEl.on("click", function(params) {
      var payload = {
        type: AXIS_BREAK_EXPAND_ACTION_TYPE,
        breaks: [{
          start: visualBreak.parsedBreak.breakOption.start,
          end: visualBreak.parsedBreak.breakOption.end
        }]
      };
      payload[axisModel.axis.dim + "AxisIndex"] = axisModel.componentIndex;
      api.dispatchAction(payload);
    });
  }
  function adjustBreakLabels(axisModel, axisRotation, labelLayoutList) {
    {
      return;
    }
  }
  var define_process_env_default$8 = {};
  function layout(rect, axisModel, opt) {
    opt = opt || {};
    var axis = axisModel.axis;
    var layout2 = {};
    var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];
    var rawAxisPosition = axis.position;
    var axisPosition = otherAxisOnZeroOf ? "onZero" : rawAxisPosition;
    var axisDim = axis.dim;
    var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
    var idx = {
      left: 0,
      right: 1,
      top: 0,
      bottom: 1,
      onZero: 2
    };
    var axisOffset = axisModel.get("offset") || 0;
    var posBound = axisDim === "x" ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];
    if (otherAxisOnZeroOf) {
      var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));
      posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
    }
    layout2.position = [axisDim === "y" ? posBound[idx[axisPosition]] : rectBound[0], axisDim === "x" ? posBound[idx[axisPosition]] : rectBound[3]];
    layout2.rotation = Math.PI / 2 * (axisDim === "x" ? 0 : 1);
    var dirMap = {
      top: -1,
      bottom: 1,
      left: -1,
      right: 1
    };
    layout2.labelDirection = layout2.tickDirection = layout2.nameDirection = dirMap[rawAxisPosition];
    layout2.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0;
    if (axisModel.get(["axisTick", "inside"])) {
      layout2.tickDirection = -layout2.tickDirection;
    }
    if (retrieve(opt.labelInside, axisModel.get(["axisLabel", "inside"]))) {
      layout2.labelDirection = -layout2.labelDirection;
    }
    var labelRotate = axisModel.get(["axisLabel", "rotate"]);
    layout2.labelRotate = axisPosition === "top" ? -labelRotate : labelRotate;
    layout2.z2 = 1;
    return layout2;
  }
  function isCartesian2DInjectedAsDataCoordSys(seriesModel) {
    return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "cartesian2d";
  }
  function findAxisModels(seriesModel) {
    var axisModelMap = {
      xAxisModel: null,
      yAxisModel: null
    };
    each$5(axisModelMap, function(v, key2) {
      var axisType = key2.replace(/Model$/, "");
      var axisModel = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0];
      if (define_process_env_default$8.NODE_ENV !== "production") {
        if (!axisModel) {
          throw new Error(axisType + ' "' + retrieve3(seriesModel.get(axisType + "Index"), seriesModel.get(axisType + "Id"), 0) + '" not found');
        }
      }
      axisModelMap[key2] = axisModel;
    });
    return axisModelMap;
  }
  function createCartesianAxisViewCommonPartBuilder(gridRect, cartesians, axisModel, api, ctx, defaultNameMoveOverlap) {
    var layoutResult = layout(gridRect, axisModel);
    var axisLineAutoShow = false;
    var axisTickAutoShow = false;
    for (var i = 0; i < cartesians.length; i++) {
      if (isIntervalOrLogScale(cartesians[i].getOtherAxis(axisModel.axis).scale)) {
        axisLineAutoShow = axisTickAutoShow = true;
        if (axisModel.axis.type === "category" && axisModel.axis.onBand) {
          axisTickAutoShow = false;
        }
      }
    }
    layoutResult.axisLineAutoShow = axisLineAutoShow;
    layoutResult.axisTickAutoShow = axisTickAutoShow;
    layoutResult.defaultNameMoveOverlap = defaultNameMoveOverlap;
    return new AxisBuilder(axisModel, api, layoutResult, ctx);
  }
  function updateCartesianAxisViewCommonPartBuilder(axisBuilder, gridRect, axisModel) {
    var newRaw = layout(gridRect, axisModel);
    if (define_process_env_default$8.NODE_ENV !== "production") {
      var oldRaw_1 = axisBuilder.__getRawCfg();
      each$5(keys(newRaw), function(prop) {
        if (prop !== "position" && prop !== "labelOffset") {
          assert(newRaw[prop] === oldRaw_1[prop]);
        }
      });
    }
    axisBuilder.updateCfg(newRaw);
  }
  var define_process_env_default$7 = {};
  function alignScaleTicks(scale2, axisModel, alignToScale) {
    var _a2;
    var intervalScaleProto = IntervalScale.prototype;
    var alignToTicks = intervalScaleProto.getTicks.call(alignToScale);
    var alignToNicedTicks = intervalScaleProto.getTicks.call(alignToScale, {
      expandToNicedExtent: true
    });
    var alignToSplitNumber = alignToTicks.length - 1;
    var alignToInterval = intervalScaleProto.getInterval.call(alignToScale);
    var scaleExtent = getScaleExtent(scale2, axisModel);
    var rawExtent = scaleExtent.extent;
    var isMinFixed = scaleExtent.fixMin;
    var isMaxFixed = scaleExtent.fixMax;
    if (scale2.type === "log") {
      rawExtent = logTransform(scale2.base, rawExtent, true);
    }
    scale2.setBreaksFromOption(retrieveAxisBreaksOption(axisModel));
    scale2.setExtent(rawExtent[0], rawExtent[1]);
    scale2.calcNiceExtent({
      splitNumber: alignToSplitNumber,
      fixMin: isMinFixed,
      fixMax: isMaxFixed
    });
    var extent = intervalScaleProto.getExtent.call(scale2);
    if (isMinFixed) {
      rawExtent[0] = extent[0];
    }
    if (isMaxFixed) {
      rawExtent[1] = extent[1];
    }
    var interval = intervalScaleProto.getInterval.call(scale2);
    var min3 = rawExtent[0];
    var max3 = rawExtent[1];
    if (isMinFixed && isMaxFixed) {
      interval = (max3 - min3) / alignToSplitNumber;
    } else if (isMinFixed) {
      max3 = rawExtent[0] + interval * alignToSplitNumber;
      while (max3 < rawExtent[1] && isFinite(max3) && isFinite(rawExtent[1])) {
        interval = increaseInterval(interval);
        max3 = rawExtent[0] + interval * alignToSplitNumber;
      }
    } else if (isMaxFixed) {
      min3 = rawExtent[1] - interval * alignToSplitNumber;
      while (min3 > rawExtent[0] && isFinite(min3) && isFinite(rawExtent[0])) {
        interval = increaseInterval(interval);
        min3 = rawExtent[1] - interval * alignToSplitNumber;
      }
    } else {
      var nicedSplitNumber = scale2.getTicks().length - 1;
      if (nicedSplitNumber > alignToSplitNumber) {
        interval = increaseInterval(interval);
      }
      var range = interval * alignToSplitNumber;
      max3 = Math.ceil(rawExtent[1] / interval) * interval;
      min3 = round$1(max3 - range);
      if (min3 < 0 && rawExtent[0] >= 0) {
        min3 = 0;
        max3 = round$1(range);
      } else if (max3 > 0 && rawExtent[1] <= 0) {
        max3 = 0;
        min3 = -round$1(range);
      }
    }
    var t0 = (alignToTicks[0].value - alignToNicedTicks[0].value) / alignToInterval;
    var t1 = (alignToTicks[alignToSplitNumber].value - alignToNicedTicks[alignToSplitNumber].value) / alignToInterval;
    intervalScaleProto.setExtent.call(scale2, min3 + interval * t0, max3 + interval * t1);
    intervalScaleProto.setInterval.call(scale2, interval);
    if (t0 || t1) {
      intervalScaleProto.setNiceExtent.call(scale2, min3 + interval, max3 - interval);
    }
    if (define_process_env_default$7.NODE_ENV !== "production") {
      var ticks = intervalScaleProto.getTicks.call(scale2);
      if (ticks[1] && (!isValueNice(interval) || getPrecisionSafe(ticks[1].value) > getPrecisionSafe(interval))) {
        warn("The ticks may be not readable when set min: " + axisModel.get("min") + ", max: " + axisModel.get("max") + (" and alignTicks: true. (" + ((_a2 = axisModel.axis) === null || _a2 === void 0 ? void 0 : _a2.dim) + "AxisIndex: " + axisModel.componentIndex + ")"), true);
      }
    }
  }
  var define_process_env_default$6 = {};
  var XY_TO_MARGIN_IDX = [
    [3, 1],
    [0, 2]
    // xyIdx 1 => 'y'
  ];
  var Grid = (
    /** @class */
    function() {
      function Grid2(gridModel, ecModel, api) {
        this.type = "grid";
        this._coordsMap = {};
        this._coordsList = [];
        this._axesMap = {};
        this._axesList = [];
        this.axisPointerEnabled = true;
        this.dimensions = cartesian2DDimensions;
        this._initCartesian(gridModel, ecModel, api);
        this.model = gridModel;
      }
      Grid2.prototype.getRect = function() {
        return this._rect;
      };
      Grid2.prototype.update = function(ecModel, api) {
        var axesMap = this._axesMap;
        this._updateScale(ecModel, this.model);
        function updateAxisTicks(axes) {
          var alignTo;
          var axesIndices = keys(axes);
          var len2 = axesIndices.length;
          if (!len2) {
            return;
          }
          var axisNeedsAlign = [];
          for (var i = len2 - 1; i >= 0; i--) {
            var idx = +axesIndices[i];
            var axis = axes[idx];
            var model = axis.model;
            var scale2 = axis.scale;
            if (
              // Only value and log axis without interval support alignTicks.
              isIntervalOrLogScale(scale2) && model.get("alignTicks") && model.get("interval") == null
            ) {
              axisNeedsAlign.push(axis);
            } else {
              niceScaleExtent(scale2, model);
              if (isIntervalOrLogScale(scale2)) {
                alignTo = axis;
              }
            }
          }
          if (axisNeedsAlign.length) {
            if (!alignTo) {
              alignTo = axisNeedsAlign.pop();
              niceScaleExtent(alignTo.scale, alignTo.model);
            }
            each$5(axisNeedsAlign, function(axis2) {
              alignScaleTicks(axis2.scale, axis2.model, alignTo.scale);
            });
          }
        }
        updateAxisTicks(axesMap.x);
        updateAxisTicks(axesMap.y);
        var onZeroRecords = {};
        each$5(axesMap.x, function(xAxis) {
          fixAxisOnZero(axesMap, "y", xAxis, onZeroRecords);
        });
        each$5(axesMap.y, function(yAxis) {
          fixAxisOnZero(axesMap, "x", yAxis, onZeroRecords);
        });
        this.resize(this.model, api);
      };
      Grid2.prototype.resize = function(gridModel, api, beforeDataProcessing) {
        var layoutRef = createBoxLayoutReference(gridModel, api);
        var gridRect = this._rect = getLayoutRect(gridModel.getBoxLayoutParams(), layoutRef.refContainer);
        var axesMap = this._axesMap;
        var coordsList = this._coordsList;
        var optionContainLabel = gridModel.get("containLabel");
        updateAllAxisExtentTransByGridRect(axesMap, gridRect);
        if (!beforeDataProcessing) {
          var axisBuilderSharedCtx = createAxisBiulders(gridRect, coordsList, axesMap, optionContainLabel, api);
          var noPxChange = void 0;
          if (optionContainLabel) {
            {
              if (define_process_env_default$6.NODE_ENV !== "production") {
                log("Specified `grid.containLabel` but no `use(LegacyGridContainLabel)`;use `grid.outerBounds` instead.", true);
              }
              noPxChange = layOutGridByOuterBounds(gridRect.clone(), "axisLabel", null, gridRect, axesMap, axisBuilderSharedCtx, layoutRef);
            }
          } else {
            var _a2 = prepareOuterBounds(gridModel, gridRect, layoutRef), outerBoundsRect = _a2.outerBoundsRect, parsedOuterBoundsContain = _a2.parsedOuterBoundsContain, outerBoundsClamp = _a2.outerBoundsClamp;
            if (outerBoundsRect) {
              noPxChange = layOutGridByOuterBounds(outerBoundsRect, parsedOuterBoundsContain, outerBoundsClamp, gridRect, axesMap, axisBuilderSharedCtx, layoutRef);
            }
          }
          createOrUpdateAxesView(gridRect, axesMap, AxisTickLabelComputingKind.determine, null, noPxChange, layoutRef);
        }
        each$5(this._coordsList, function(coord) {
          coord.calcAffineTransform();
        });
      };
      Grid2.prototype.getAxis = function(dim, axisIndex) {
        var axesMapOnDim = this._axesMap[dim];
        if (axesMapOnDim != null) {
          return axesMapOnDim[axisIndex || 0];
        }
      };
      Grid2.prototype.getAxes = function() {
        return this._axesList.slice();
      };
      Grid2.prototype.getCartesian = function(xAxisIndex, yAxisIndex) {
        if (xAxisIndex != null && yAxisIndex != null) {
          var key2 = "x" + xAxisIndex + "y" + yAxisIndex;
          return this._coordsMap[key2];
        }
        if (isObject$2(xAxisIndex)) {
          yAxisIndex = xAxisIndex.yAxisIndex;
          xAxisIndex = xAxisIndex.xAxisIndex;
        }
        for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {
          if (coordList[i].getAxis("x").index === xAxisIndex || coordList[i].getAxis("y").index === yAxisIndex) {
            return coordList[i];
          }
        }
      };
      Grid2.prototype.getCartesians = function() {
        return this._coordsList.slice();
      };
      Grid2.prototype.convertToPixel = function(ecModel, finder, value) {
        var target = this._findConvertTarget(finder);
        return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
      };
      Grid2.prototype.convertFromPixel = function(ecModel, finder, value) {
        var target = this._findConvertTarget(finder);
        return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
      };
      Grid2.prototype._findConvertTarget = function(finder) {
        var seriesModel = finder.seriesModel;
        var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
        var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
        var gridModel = finder.gridModel;
        var coordsList = this._coordsList;
        var cartesian;
        var axis;
        if (seriesModel) {
          cartesian = seriesModel.coordinateSystem;
          indexOf(coordsList, cartesian) < 0 && (cartesian = null);
        } else if (xAxisModel && yAxisModel) {
          cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
        } else if (xAxisModel) {
          axis = this.getAxis("x", xAxisModel.componentIndex);
        } else if (yAxisModel) {
          axis = this.getAxis("y", yAxisModel.componentIndex);
        } else if (gridModel) {
          var grid = gridModel.coordinateSystem;
          if (grid === this) {
            cartesian = this._coordsList[0];
          }
        }
        return {
          cartesian,
          axis
        };
      };
      Grid2.prototype.containPoint = function(point) {
        var coord = this._coordsList[0];
        if (coord) {
          return coord.containPoint(point);
        }
      };
      Grid2.prototype._initCartesian = function(gridModel, ecModel, api) {
        var _this = this;
        var grid = this;
        var axisPositionUsed = {
          left: false,
          right: false,
          top: false,
          bottom: false
        };
        var axesMap = {
          x: {},
          y: {}
        };
        var axesCount = {
          x: 0,
          y: 0
        };
        ecModel.eachComponent("xAxis", createAxisCreator("x"), this);
        ecModel.eachComponent("yAxis", createAxisCreator("y"), this);
        if (!axesCount.x || !axesCount.y) {
          this._axesMap = {};
          this._axesList = [];
          return;
        }
        this._axesMap = axesMap;
        each$5(axesMap.x, function(xAxis, xAxisIndex) {
          each$5(axesMap.y, function(yAxis, yAxisIndex) {
            var key2 = "x" + xAxisIndex + "y" + yAxisIndex;
            var cartesian = new Cartesian2D(key2);
            cartesian.master = _this;
            cartesian.model = gridModel;
            _this._coordsMap[key2] = cartesian;
            _this._coordsList.push(cartesian);
            cartesian.addAxis(xAxis);
            cartesian.addAxis(yAxis);
          });
        });
        function createAxisCreator(dimName) {
          return function(axisModel, idx) {
            if (!isAxisUsedInTheGrid(axisModel, gridModel)) {
              return;
            }
            var axisPosition = axisModel.get("position");
            if (dimName === "x") {
              if (axisPosition !== "top" && axisPosition !== "bottom") {
                axisPosition = axisPositionUsed.bottom ? "top" : "bottom";
              }
            } else {
              if (axisPosition !== "left" && axisPosition !== "right") {
                axisPosition = axisPositionUsed.left ? "right" : "left";
              }
            }
            axisPositionUsed[axisPosition] = true;
            var axis = new Axis2D(dimName, createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisPosition);
            var isCategory2 = axis.type === "category";
            axis.onBand = isCategory2 && axisModel.get("boundaryGap");
            axis.inverse = axisModel.get("inverse");
            axisModel.axis = axis;
            axis.model = axisModel;
            axis.grid = grid;
            axis.index = idx;
            grid._axesList.push(axis);
            axesMap[dimName][idx] = axis;
            axesCount[dimName]++;
          };
        }
      };
      Grid2.prototype._updateScale = function(ecModel, gridModel) {
        each$5(this._axesList, function(axis) {
          axis.scale.setExtent(Infinity, -Infinity);
          if (axis.type === "category") {
            var categorySortInfo = axis.model.get("categorySortInfo");
            axis.scale.setSortInfo(categorySortInfo);
          }
        });
        ecModel.eachSeries(function(seriesModel) {
          if (isCartesian2DInjectedAsDataCoordSys(seriesModel)) {
            var axesModelMap = findAxisModels(seriesModel);
            var xAxisModel = axesModelMap.xAxisModel;
            var yAxisModel = axesModelMap.yAxisModel;
            if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {
              return;
            }
            var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
            var data = seriesModel.getData();
            var xAxis = cartesian.getAxis("x");
            var yAxis = cartesian.getAxis("y");
            unionExtent(data, xAxis);
            unionExtent(data, yAxis);
          }
        }, this);
        function unionExtent(data, axis) {
          each$5(getDataDimensionsOnAxis(data, axis.dim), function(dim) {
            axis.scale.unionExtentFromData(data, dim);
          });
        }
      };
      Grid2.prototype.getTooltipAxes = function(dim) {
        var baseAxes = [];
        var otherAxes = [];
        each$5(this.getCartesians(), function(cartesian) {
          var baseAxis = dim != null && dim !== "auto" ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
          var otherAxis = cartesian.getOtherAxis(baseAxis);
          indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
          indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
        });
        return {
          baseAxes,
          otherAxes
        };
      };
      Grid2.create = function(ecModel, api) {
        var grids = [];
        ecModel.eachComponent("grid", function(gridModel, idx) {
          var grid = new Grid2(gridModel, ecModel, api);
          grid.name = "grid_" + idx;
          grid.resize(gridModel, api, true);
          gridModel.coordinateSystem = grid;
          grids.push(grid);
        });
        ecModel.eachSeries(function(seriesModel) {
          injectCoordSysByOption({
            targetModel: seriesModel,
            coordSysType: "cartesian2d",
            coordSysProvider
          });
          function coordSysProvider() {
            var axesModelMap = findAxisModels(seriesModel);
            var xAxisModel = axesModelMap.xAxisModel;
            var yAxisModel = axesModelMap.yAxisModel;
            var gridModel = xAxisModel.getCoordSysModel();
            if (define_process_env_default$6.NODE_ENV !== "production") {
              if (!gridModel) {
                throw new Error('Grid "' + retrieve3(xAxisModel.get("gridIndex"), xAxisModel.get("gridId"), 0) + '" not found');
              }
              if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {
                throw new Error("xAxis and yAxis must use the same grid");
              }
            }
            var grid = gridModel.coordinateSystem;
            return grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
          }
        });
        return grids;
      };
      Grid2.dimensions = cartesian2DDimensions;
      return Grid2;
    }()
  );
  function isAxisUsedInTheGrid(axisModel, gridModel) {
    return axisModel.getCoordSysModel() === gridModel;
  }
  function fixAxisOnZero(axesMap, otherAxisDim, axis, onZeroRecords) {
    axis.getAxesOnZeroOf = function() {
      return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];
    };
    var otherAxes = axesMap[otherAxisDim];
    var otherAxisOnZeroOf;
    var axisModel = axis.model;
    var onZero = axisModel.get(["axisLine", "onZero"]);
    var onZeroAxisIndex = axisModel.get(["axisLine", "onZeroAxisIndex"]);
    if (!onZero) {
      return;
    }
    if (onZeroAxisIndex != null) {
      if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {
        otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];
      }
    } else {
      for (var idx in otherAxes) {
        if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
          otherAxisOnZeroOf = otherAxes[idx];
          break;
        }
      }
    }
    if (otherAxisOnZeroOf) {
      onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;
    }
    function getOnZeroRecordKey(axis2) {
      return axis2.dim + "_" + axis2.index;
    }
  }
  function canOnZeroToAxis(axis) {
    return axis && axis.type !== "category" && axis.type !== "time" && ifAxisCrossZero(axis);
  }
  function updateAxisTransform(axis, coordBase) {
    var axisExtent = axis.getExtent();
    var axisExtentSum = axisExtent[0] + axisExtent[1];
    axis.toGlobalCoord = axis.dim === "x" ? function(coord) {
      return coord + coordBase;
    } : function(coord) {
      return axisExtentSum - coord + coordBase;
    };
    axis.toLocalCoord = axis.dim === "x" ? function(coord) {
      return coord - coordBase;
    } : function(coord) {
      return axisExtentSum - coord + coordBase;
    };
  }
  function updateAllAxisExtentTransByGridRect(axesMap, gridRect) {
    each$5(axesMap.x, function(axis) {
      return updateAxisExtentTransByGridRect(axis, gridRect.x, gridRect.width);
    });
    each$5(axesMap.y, function(axis) {
      return updateAxisExtentTransByGridRect(axis, gridRect.y, gridRect.height);
    });
  }
  function updateAxisExtentTransByGridRect(axis, gridXY, gridWH) {
    var extent = [0, gridWH];
    var idx = axis.inverse ? 1 : 0;
    axis.setExtent(extent[idx], extent[1 - idx]);
    updateAxisTransform(axis, gridXY);
  }
  function layOutGridByOuterBounds(outerBoundsRect, outerBoundsContain, outerBoundsClamp, gridRect, axesMap, axisBuilderSharedCtx, layoutRef) {
    if (define_process_env_default$6.NODE_ENV !== "production") {
      assert(outerBoundsContain === "all" || outerBoundsContain === "axisLabel");
    }
    createOrUpdateAxesView(gridRect, axesMap, AxisTickLabelComputingKind.estimate, outerBoundsContain, false, layoutRef);
    var margin = [0, 0, 0, 0];
    fillLabelNameOverflowOnOneDimension(0);
    fillLabelNameOverflowOnOneDimension(1);
    fillMarginOnOneDimension(gridRect, 0, NaN);
    fillMarginOnOneDimension(gridRect, 1, NaN);
    var noPxChange = find(margin, function(item) {
      return item > 0;
    }) == null;
    expandOrShrinkRect(gridRect, margin, true, true, outerBoundsClamp);
    updateAllAxisExtentTransByGridRect(axesMap, gridRect);
    return noPxChange;
    function fillLabelNameOverflowOnOneDimension(xyIdx) {
      each$5(axesMap[XY$1[xyIdx]], function(axis) {
        if (!shouldAxisShow(axis.model)) {
          return;
        }
        var sharedRecord = axisBuilderSharedCtx.ensureRecord(axis.model);
        var labelInfoList = sharedRecord.labelInfoList;
        if (labelInfoList) {
          for (var idx = 0; idx < labelInfoList.length; idx++) {
            var labelInfo = labelInfoList[idx];
            var proportion = axis.scale.normalize(getLabelInner(labelInfo.label).tickValue);
            proportion = xyIdx === 1 ? 1 - proportion : proportion;
            fillMarginOnOneDimension(labelInfo.rect, xyIdx, proportion);
            fillMarginOnOneDimension(labelInfo.rect, 1 - xyIdx, NaN);
          }
        }
        var nameLayout = sharedRecord.nameLayout;
        if (nameLayout) {
          var proportion = isNameLocationCenter(sharedRecord.nameLocation) ? 0.5 : NaN;
          fillMarginOnOneDimension(nameLayout.rect, xyIdx, proportion);
          fillMarginOnOneDimension(nameLayout.rect, 1 - xyIdx, NaN);
        }
      });
    }
    function fillMarginOnOneDimension(itemRect, xyIdx, proportion) {
      var overflow1 = outerBoundsRect[XY$1[xyIdx]] - itemRect[XY$1[xyIdx]];
      var overflow2 = itemRect[WH$1[xyIdx]] + itemRect[XY$1[xyIdx]] - (outerBoundsRect[WH$1[xyIdx]] + outerBoundsRect[XY$1[xyIdx]]);
      overflow1 = applyProportion(overflow1, 1 - proportion);
      overflow2 = applyProportion(overflow2, proportion);
      var minIdx = XY_TO_MARGIN_IDX[xyIdx][0];
      var maxIdx = XY_TO_MARGIN_IDX[xyIdx][1];
      margin[minIdx] = mathMax$5(margin[minIdx], overflow1);
      margin[maxIdx] = mathMax$5(margin[maxIdx], overflow2);
    }
    function applyProportion(overflow, proportion) {
      if (overflow > 0 && !eqNaN(proportion) && proportion > 1e-4) {
        overflow /= proportion;
      }
      return overflow;
    }
  }
  function createAxisBiulders(gridRect, cartesians, axesMap, optionContainLabel, api) {
    var axisBuilderSharedCtx = new AxisBuilderSharedContext(resolveAxisNameOverlapForGrid);
    each$5(axesMap, function(axisList) {
      return each$5(axisList, function(axis) {
        if (shouldAxisShow(axis.model)) {
          var defaultNameMoveOverlap = !optionContainLabel;
          axis.axisBuilder = createCartesianAxisViewCommonPartBuilder(gridRect, cartesians, axis.model, api, axisBuilderSharedCtx, defaultNameMoveOverlap);
        }
      });
    });
    return axisBuilderSharedCtx;
  }
  function createOrUpdateAxesView(gridRect, axesMap, kind, outerBoundsContain, noPxChange, layoutRef) {
    var isDetermine = kind === AxisTickLabelComputingKind.determine;
    each$5(axesMap, function(axisList) {
      return each$5(axisList, function(axis) {
        if (shouldAxisShow(axis.model)) {
          updateCartesianAxisViewCommonPartBuilder(axis.axisBuilder, gridRect, axis.model);
          axis.axisBuilder.build(isDetermine ? {
            axisTickLabelDetermine: true
          } : {
            axisTickLabelEstimate: true
          }, {
            noPxChange
          });
        }
      });
    });
    var nameMarginLevelMap = {
      x: 0,
      y: 0
    };
    calcNameMarginLevel(0);
    calcNameMarginLevel(1);
    function calcNameMarginLevel(xyIdx) {
      nameMarginLevelMap[XY$1[1 - xyIdx]] = gridRect[WH$1[xyIdx]] <= layoutRef.refContainer[WH$1[xyIdx]] * 0.5 ? 0 : 1 - xyIdx === 1 ? 2 : 1;
    }
    each$5(axesMap, function(axisList, xy) {
      return each$5(axisList, function(axis) {
        if (shouldAxisShow(axis.model)) {
          if (outerBoundsContain === "all" || isDetermine) {
            axis.axisBuilder.build({
              axisName: true
            }, {
              nameMarginLevel: nameMarginLevelMap[xy]
            });
          }
          if (isDetermine) {
            axis.axisBuilder.build({
              axisLine: true
            });
          }
        }
      });
    });
  }
  function prepareOuterBounds(gridModel, rawRridRect, layoutRef) {
    var outerBoundsRect;
    var optionOuterBoundsMode = gridModel.get("outerBoundsMode", true);
    if (optionOuterBoundsMode === "same") {
      outerBoundsRect = rawRridRect.clone();
    } else if (optionOuterBoundsMode == null || optionOuterBoundsMode === "auto") {
      outerBoundsRect = getLayoutRect(gridModel.get("outerBounds", true) || OUTER_BOUNDS_DEFAULT, layoutRef.refContainer);
    } else if (optionOuterBoundsMode !== "none") {
      if (define_process_env_default$6.NODE_ENV !== "production") {
        error("Invalid grid[" + gridModel.componentIndex + "].outerBoundsMode.");
      }
    }
    var optionOuterBoundsContain = gridModel.get("outerBoundsContain", true);
    var parsedOuterBoundsContain;
    if (optionOuterBoundsContain == null || optionOuterBoundsContain === "auto") {
      parsedOuterBoundsContain = "all";
    } else if (indexOf(["all", "axisLabel"], optionOuterBoundsContain) < 0) {
      if (define_process_env_default$6.NODE_ENV !== "production") {
        error("Invalid grid[" + gridModel.componentIndex + "].outerBoundsContain.");
      }
      parsedOuterBoundsContain = "all";
    } else {
      parsedOuterBoundsContain = optionOuterBoundsContain;
    }
    var outerBoundsClamp = [parsePositionSizeOption(retrieve2(gridModel.get("outerBoundsClampWidth", true), OUTER_BOUNDS_CLAMP_DEFAULT[0]), rawRridRect.width), parsePositionSizeOption(retrieve2(gridModel.get("outerBoundsClampHeight", true), OUTER_BOUNDS_CLAMP_DEFAULT[1]), rawRridRect.height)];
    return {
      outerBoundsRect,
      parsedOuterBoundsContain,
      outerBoundsClamp
    };
  }
  var resolveAxisNameOverlapForGrid = function(cfg, ctx, axisModel, nameLayoutInfo, nameMoveDirVec, thisRecord) {
    var perpendicularDim = axisModel.axis.dim === "x" ? "y" : "x";
    resolveAxisNameOverlapDefault(cfg, ctx, axisModel, nameLayoutInfo, nameMoveDirVec, thisRecord);
    if (!isNameLocationCenter(cfg.nameLocation)) {
      each$5(ctx.recordMap[perpendicularDim], function(perpenRecord) {
        if (perpenRecord && perpenRecord.labelInfoList && perpenRecord.dirVec) {
          moveIfOverlapByLinearLabels(perpenRecord.labelInfoList, perpenRecord.dirVec, nameLayoutInfo, nameMoveDirVec);
        }
      });
    }
  };
  function collect(ecModel, api) {
    var result = {
      /**
       * key: makeKey(axis.model)
       * value: {
       *      axis,
       *      coordSys,
       *      axisPointerModel,
       *      triggerTooltip,
       *      triggerEmphasis,
       *      involveSeries,
       *      snap,
       *      seriesModels,
       *      seriesDataCount
       * }
       */
      axesInfo: {},
      seriesInvolved: false,
      /**
       * key: makeKey(coordSys.model)
       * value: Object: key makeKey(axis.model), value: axisInfo
       */
      coordSysAxesInfo: {},
      coordSysMap: {}
    };
    collectAxesInfo(result, ecModel, api);
    result.seriesInvolved && collectSeriesInfo(result, ecModel);
    return result;
  }
  function collectAxesInfo(result, ecModel, api) {
    var globalTooltipModel = ecModel.getComponent("tooltip");
    var globalAxisPointerModel = ecModel.getComponent("axisPointer");
    var linksOption = globalAxisPointerModel.get("link", true) || [];
    var linkGroups = [];
    each$5(api.getCoordinateSystems(), function(coordSys) {
      if (!coordSys.axisPointerEnabled) {
        return;
      }
      var coordSysKey = makeKey(coordSys.model);
      var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
      result.coordSysMap[coordSysKey] = coordSys;
      var coordSysModel = coordSys.model;
      var baseTooltipModel = coordSysModel.getModel("tooltip", globalTooltipModel);
      each$5(coordSys.getAxes(), curry$1(saveTooltipAxisInfo, false, null));
      if (coordSys.getTooltipAxes && globalTooltipModel && baseTooltipModel.get("show")) {
        var triggerAxis = baseTooltipModel.get("trigger") === "axis";
        var cross = baseTooltipModel.get(["axisPointer", "type"]) === "cross";
        var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get(["axisPointer", "axis"]));
        if (triggerAxis || cross) {
          each$5(tooltipAxes.baseAxes, curry$1(saveTooltipAxisInfo, cross ? "cross" : true, triggerAxis));
        }
        if (cross) {
          each$5(tooltipAxes.otherAxes, curry$1(saveTooltipAxisInfo, "cross", false));
        }
      }
      function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
        var axisPointerModel = axis.model.getModel("axisPointer", globalAxisPointerModel);
        var axisPointerShow = axisPointerModel.get("show");
        if (!axisPointerShow || axisPointerShow === "auto" && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
          return;
        }
        if (triggerTooltip == null) {
          triggerTooltip = axisPointerModel.get("triggerTooltip");
        }
        axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
        var snap = axisPointerModel.get("snap");
        var triggerEmphasis = axisPointerModel.get("triggerEmphasis");
        var axisKey = makeKey(axis.model);
        var involveSeries = triggerTooltip || snap || axis.type === "category";
        var axisInfo = result.axesInfo[axisKey] = {
          key: axisKey,
          axis,
          coordSys,
          axisPointerModel,
          triggerTooltip,
          triggerEmphasis,
          involveSeries,
          snap,
          useHandle: isHandleTrigger(axisPointerModel),
          seriesModels: [],
          linkGroup: null
        };
        axesInfoInCoordSys[axisKey] = axisInfo;
        result.seriesInvolved = result.seriesInvolved || involveSeries;
        var groupIndex = getLinkGroupIndex(linksOption, axis);
        if (groupIndex != null) {
          var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {
            axesInfo: {}
          });
          linkGroup.axesInfo[axisKey] = axisInfo;
          linkGroup.mapper = linksOption[groupIndex].mapper;
          axisInfo.linkGroup = linkGroup;
        }
      }
    });
  }
  function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
    var tooltipAxisPointerModel = baseTooltipModel.getModel("axisPointer");
    var fields = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"];
    var volatileOption = {};
    each$5(fields, function(field) {
      volatileOption[field] = clone$2(tooltipAxisPointerModel.get(field));
    });
    volatileOption.snap = axis.type !== "category" && !!triggerTooltip;
    if (tooltipAxisPointerModel.get("type") === "cross") {
      volatileOption.type = "line";
    }
    var labelOption = volatileOption.label || (volatileOption.label = {});
    labelOption.show == null && (labelOption.show = false);
    if (fromTooltip === "cross") {
      var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get(["label", "show"]);
      labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true;
      if (!triggerTooltip) {
        var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get("crossStyle");
        crossStyle && defaults(labelOption, crossStyle.textStyle);
      }
    }
    return axis.model.getModel("axisPointer", new Model(volatileOption, globalAxisPointerModel, ecModel));
  }
  function collectSeriesInfo(result, ecModel) {
    ecModel.eachSeries(function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var seriesTooltipTrigger = seriesModel.get(["tooltip", "trigger"], true);
      var seriesTooltipShow = seriesModel.get(["tooltip", "show"], true);
      if (!coordSys || !coordSys.model || seriesTooltipTrigger === "none" || seriesTooltipTrigger === false || seriesTooltipTrigger === "item" || seriesTooltipShow === false || seriesModel.get(["axisPointer", "show"], true) === false) {
        return;
      }
      each$5(result.coordSysAxesInfo[makeKey(coordSys.model)], function(axisInfo) {
        var axis = axisInfo.axis;
        if (coordSys.getAxis(axis.dim) === axis) {
          axisInfo.seriesModels.push(seriesModel);
          axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
          axisInfo.seriesDataCount += seriesModel.getData().count();
        }
      });
    });
  }
  function getLinkGroupIndex(linksOption, axis) {
    var axisModel = axis.model;
    var dim = axis.dim;
    for (var i = 0; i < linksOption.length; i++) {
      var linkOption = linksOption[i] || {};
      if (checkPropInLink(linkOption[dim + "AxisId"], axisModel.id) || checkPropInLink(linkOption[dim + "AxisIndex"], axisModel.componentIndex) || checkPropInLink(linkOption[dim + "AxisName"], axisModel.name)) {
        return i;
      }
    }
  }
  function checkPropInLink(linkPropValue, axisPropValue) {
    return linkPropValue === "all" || isArray(linkPropValue) && indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
  }
  function fixValue(axisModel) {
    var axisInfo = getAxisInfo(axisModel);
    if (!axisInfo) {
      return;
    }
    var axisPointerModel = axisInfo.axisPointerModel;
    var scale2 = axisInfo.axis.scale;
    var option = axisPointerModel.option;
    var status = axisPointerModel.get("status");
    var value = axisPointerModel.get("value");
    if (value != null) {
      value = scale2.parse(value);
    }
    var useHandle = isHandleTrigger(axisPointerModel);
    if (status == null) {
      option.status = useHandle ? "show" : "hide";
    }
    var extent = scale2.getExtent().slice();
    extent[0] > extent[1] && extent.reverse();
    if (
      // Pick a value on axis when initializing.
      value == null || value > extent[1]
    ) {
      value = extent[1];
    }
    if (value < extent[0]) {
      value = extent[0];
    }
    option.value = value;
    if (useHandle) {
      option.status = axisInfo.axis.scale.isBlank() ? "hide" : "show";
    }
  }
  function getAxisInfo(axisModel) {
    var coordSysAxesInfo = (axisModel.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
    return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
  }
  function getAxisPointerModel(axisModel) {
    var axisInfo = getAxisInfo(axisModel);
    return axisInfo && axisInfo.axisPointerModel;
  }
  function isHandleTrigger(axisPointerModel) {
    return !!axisPointerModel.get(["handle", "show"]);
  }
  function makeKey(model) {
    return model.type + "||" + model.id;
  }
  var define_process_env_default$5 = {};
  var axisPointerClazz = {};
  var AxisView = (
    /** @class */
    function(_super) {
      __extends(AxisView2, _super);
      function AxisView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = AxisView2.type;
        return _this;
      }
      AxisView2.prototype.render = function(axisModel, ecModel, api, payload) {
        this.axisPointerClass && fixValue(axisModel);
        _super.prototype.render.apply(this, arguments);
        this._doUpdateAxisPointerClass(axisModel, api, true);
      };
      AxisView2.prototype.updateAxisPointer = function(axisModel, ecModel, api, payload) {
        this._doUpdateAxisPointerClass(axisModel, api, false);
      };
      AxisView2.prototype.remove = function(ecModel, api) {
        var axisPointer = this._axisPointer;
        axisPointer && axisPointer.remove(api);
      };
      AxisView2.prototype.dispose = function(ecModel, api) {
        this._disposeAxisPointer(api);
        _super.prototype.dispose.apply(this, arguments);
      };
      AxisView2.prototype._doUpdateAxisPointerClass = function(axisModel, api, forceRender) {
        var Clazz = AxisView2.getAxisPointerClass(this.axisPointerClass);
        if (!Clazz) {
          return;
        }
        var axisPointerModel = getAxisPointerModel(axisModel);
        axisPointerModel ? (this._axisPointer || (this._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : this._disposeAxisPointer(api);
      };
      AxisView2.prototype._disposeAxisPointer = function(api) {
        this._axisPointer && this._axisPointer.dispose(api);
        this._axisPointer = null;
      };
      AxisView2.registerAxisPointerClass = function(type, clazz) {
        if (define_process_env_default$5.NODE_ENV !== "production") {
          if (axisPointerClazz[type]) {
            throw new Error("axisPointer " + type + " exists");
          }
        }
        axisPointerClazz[type] = clazz;
      };
      AxisView2.getAxisPointerClass = function(type) {
        return type && axisPointerClazz[type];
      };
      AxisView2.type = "axis";
      return AxisView2;
    }(ComponentView)
  );
  var inner$5 = makeInner();
  function rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {
    var axis = axisModel.axis;
    if (axis.scale.isBlank()) {
      return;
    }
    var splitAreaModel = axisModel.getModel("splitArea");
    var areaStyleModel = splitAreaModel.getModel("areaStyle");
    var areaColors = areaStyleModel.get("color");
    var gridRect = gridModel.coordinateSystem.getRect();
    var ticksCoords = axis.getTicksCoords({
      tickModel: splitAreaModel,
      clamp: true,
      breakTicks: "none",
      pruneByBreak: "preserve_extent_bound"
    });
    if (!ticksCoords.length) {
      return;
    }
    var areaColorsLen = areaColors.length;
    var lastSplitAreaColors = inner$5(axisView).splitAreaColors;
    var newSplitAreaColors = createHashMap();
    var colorIndex = 0;
    if (lastSplitAreaColors) {
      for (var i = 0; i < ticksCoords.length; i++) {
        var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);
        if (cIndex != null) {
          colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;
          break;
        }
      }
    }
    var prev = axis.toGlobalCoord(ticksCoords[0].coord);
    var areaStyle = areaStyleModel.getAreaStyle();
    areaColors = isArray(areaColors) ? areaColors : [areaColors];
    for (var i = 1; i < ticksCoords.length; i++) {
      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
      var x = void 0;
      var y = void 0;
      var width = void 0;
      var height = void 0;
      if (axis.isHorizontal()) {
        x = prev;
        y = gridRect.y;
        width = tickCoord - x;
        height = gridRect.height;
        prev = x + width;
      } else {
        x = gridRect.x;
        y = prev;
        width = gridRect.width;
        height = tickCoord - y;
        prev = y + height;
      }
      var tickValue = ticksCoords[i - 1].tickValue;
      tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);
      axisGroup.add(new Rect$1({
        anid: tickValue != null ? "area_" + tickValue : null,
        shape: {
          x,
          y,
          width,
          height
        },
        style: defaults({
          fill: areaColors[colorIndex]
        }, areaStyle),
        autoBatch: true,
        silent: true
      }));
      colorIndex = (colorIndex + 1) % areaColorsLen;
    }
    inner$5(axisView).splitAreaColors = newSplitAreaColors;
  }
  function rectCoordAxisHandleRemove(axisView) {
    inner$5(axisView).splitAreaColors = null;
  }
  var selfBuilderAttrs = ["splitArea", "splitLine", "minorSplitLine", "breakArea"];
  var CartesianAxisView = (
    /** @class */
    function(_super) {
      __extends(CartesianAxisView2, _super);
      function CartesianAxisView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = CartesianAxisView2.type;
        _this.axisPointerClass = "CartesianAxisPointer";
        return _this;
      }
      CartesianAxisView2.prototype.render = function(axisModel, ecModel, api, payload) {
        this.group.removeAll();
        var oldAxisGroup = this._axisGroup;
        this._axisGroup = new Group$2();
        this.group.add(this._axisGroup);
        if (!shouldAxisShow(axisModel)) {
          return;
        }
        this._axisGroup.add(axisModel.axis.axisBuilder.group);
        each$5(selfBuilderAttrs, function(name) {
          if (axisModel.get([name, "show"])) {
            axisElementBuilders[name](this, this._axisGroup, axisModel, axisModel.getCoordSysModel(), api);
          }
        }, this);
        var isInitialSortFromBarRacing = payload && payload.type === "changeAxisOrder" && payload.isInitSort;
        if (!isInitialSortFromBarRacing) {
          groupTransition(oldAxisGroup, this._axisGroup, axisModel);
        }
        _super.prototype.render.call(this, axisModel, ecModel, api, payload);
      };
      CartesianAxisView2.prototype.remove = function() {
        rectCoordAxisHandleRemove(this);
      };
      CartesianAxisView2.type = "cartesianAxis";
      return CartesianAxisView2;
    }(AxisView)
  );
  var axisElementBuilders = {
    splitLine: function(axisView, axisGroup, axisModel, gridModel, api) {
      var axis = axisModel.axis;
      if (axis.scale.isBlank()) {
        return;
      }
      var splitLineModel = axisModel.getModel("splitLine");
      var lineStyleModel = splitLineModel.getModel("lineStyle");
      var lineColors = lineStyleModel.get("color");
      var showMinLine = splitLineModel.get("showMinLine") !== false;
      var showMaxLine = splitLineModel.get("showMaxLine") !== false;
      lineColors = isArray(lineColors) ? lineColors : [lineColors];
      var gridRect = gridModel.coordinateSystem.getRect();
      var isHorizontal = axis.isHorizontal();
      var lineCount = 0;
      var ticksCoords = axis.getTicksCoords({
        tickModel: splitLineModel,
        breakTicks: "none",
        pruneByBreak: "preserve_extent_bound"
      });
      var p1 = [];
      var p2 = [];
      var lineStyle = lineStyleModel.getLineStyle();
      for (var i = 0; i < ticksCoords.length; i++) {
        var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
        if (i === 0 && !showMinLine || i === ticksCoords.length - 1 && !showMaxLine) {
          continue;
        }
        var tickValue = ticksCoords[i].tickValue;
        if (isHorizontal) {
          p1[0] = tickCoord;
          p1[1] = gridRect.y;
          p2[0] = tickCoord;
          p2[1] = gridRect.y + gridRect.height;
        } else {
          p1[0] = gridRect.x;
          p1[1] = tickCoord;
          p2[0] = gridRect.x + gridRect.width;
          p2[1] = tickCoord;
        }
        var colorIndex = lineCount++ % lineColors.length;
        var line = new Line({
          anid: tickValue != null ? "line_" + tickValue : null,
          autoBatch: true,
          shape: {
            x1: p1[0],
            y1: p1[1],
            x2: p2[0],
            y2: p2[1]
          },
          style: defaults({
            stroke: lineColors[colorIndex]
          }, lineStyle),
          silent: true
        });
        subPixelOptimizeLine(line.shape, lineStyle.lineWidth);
        axisGroup.add(line);
      }
    },
    minorSplitLine: function(axisView, axisGroup, axisModel, gridModel, api) {
      var axis = axisModel.axis;
      var minorSplitLineModel = axisModel.getModel("minorSplitLine");
      var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
      var gridRect = gridModel.coordinateSystem.getRect();
      var isHorizontal = axis.isHorizontal();
      var minorTicksCoords = axis.getMinorTicksCoords();
      if (!minorTicksCoords.length) {
        return;
      }
      var p1 = [];
      var p2 = [];
      var lineStyle = lineStyleModel.getLineStyle();
      for (var i = 0; i < minorTicksCoords.length; i++) {
        for (var k = 0; k < minorTicksCoords[i].length; k++) {
          var tickCoord = axis.toGlobalCoord(minorTicksCoords[i][k].coord);
          if (isHorizontal) {
            p1[0] = tickCoord;
            p1[1] = gridRect.y;
            p2[0] = tickCoord;
            p2[1] = gridRect.y + gridRect.height;
          } else {
            p1[0] = gridRect.x;
            p1[1] = tickCoord;
            p2[0] = gridRect.x + gridRect.width;
            p2[1] = tickCoord;
          }
          var line = new Line({
            anid: "minor_line_" + minorTicksCoords[i][k].tickValue,
            autoBatch: true,
            shape: {
              x1: p1[0],
              y1: p1[1],
              x2: p2[0],
              y2: p2[1]
            },
            style: lineStyle,
            silent: true
          });
          subPixelOptimizeLine(line.shape, lineStyle.lineWidth);
          axisGroup.add(line);
        }
      }
    },
    splitArea: function(axisView, axisGroup, axisModel, gridModel, api) {
      rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel);
    },
    breakArea: function(axisView, axisGroup, axisModel, gridModel, api) {
      axisModel.axis.scale;
    }
  };
  var CartesianXAxisView = (
    /** @class */
    function(_super) {
      __extends(CartesianXAxisView2, _super);
      function CartesianXAxisView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = CartesianXAxisView2.type;
        return _this;
      }
      CartesianXAxisView2.type = "xAxis";
      return CartesianXAxisView2;
    }(CartesianAxisView)
  );
  var CartesianYAxisView = (
    /** @class */
    function(_super) {
      __extends(CartesianYAxisView2, _super);
      function CartesianYAxisView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = CartesianXAxisView.type;
        return _this;
      }
      CartesianYAxisView2.type = "yAxis";
      return CartesianYAxisView2;
    }(CartesianAxisView)
  );
  var GridView = (
    /** @class */
    function(_super) {
      __extends(GridView2, _super);
      function GridView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "grid";
        return _this;
      }
      GridView2.prototype.render = function(gridModel, ecModel) {
        this.group.removeAll();
        if (gridModel.get("show")) {
          this.group.add(new Rect$1({
            shape: gridModel.coordinateSystem.getRect(),
            style: defaults({
              fill: gridModel.get("backgroundColor")
            }, gridModel.getItemStyle()),
            silent: true,
            z2: -1
          }));
        }
      };
      GridView2.type = "grid";
      return GridView2;
    }(ComponentView)
  );
  var extraOption = {
    // gridIndex: 0,
    // gridId: '',
    offset: 0
  };
  function install$b(registers) {
    registers.registerComponentView(GridView);
    registers.registerComponentModel(GridModel);
    registers.registerCoordinateSystem("cartesian2d", Grid);
    axisModelCreator(registers, "x", CartesianAxisModel, extraOption);
    axisModelCreator(registers, "y", CartesianAxisModel, extraOption);
    registers.registerComponentView(CartesianXAxisView);
    registers.registerComponentView(CartesianYAxisView);
    registers.registerPreprocessor(function(option) {
      if (option.xAxis && option.yAxis && !option.grid) {
        option.grid = {};
      }
    });
  }
  function install$a(registers) {
    use(install$b);
    registers.registerSeriesModel(ScatterSeriesModel);
    registers.registerChartView(ScatterView);
    registers.registerLayout(pointsLayout("scatter"));
  }
  var inner$4 = makeInner();
  function isTaken(zr, resourceKey) {
    return !!inner$4(zr)[resourceKey];
  }
  registerAction({
    type: "takeGlobalCursor",
    event: "globalCursorTaken",
    update: "update"
  }, noop);
  var IRRELEVANT_EXCLUDES = {
    "axisPointer": 1,
    "tooltip": 1,
    "brush": 1
  };
  function onIrrelevantElement(e2, api, targetComponent) {
    var eventElComponent = api.getComponentByElement(e2.topTarget);
    if (!eventElComponent || eventElComponent === targetComponent || IRRELEVANT_EXCLUDES.hasOwnProperty(eventElComponent.mainType)) {
      return false;
    }
    var eventElCoordSys = eventElComponent.coordinateSystem;
    if (!eventElCoordSys || eventElCoordSys.model === targetComponent) {
      return false;
    }
    var eventElCmptZInfo = retrieveZInfo(eventElComponent);
    var targetCmptZInfo = retrieveZInfo(targetComponent);
    if ((eventElCmptZInfo.zlevel - targetCmptZInfo.zlevel || eventElCmptZInfo.z - targetCmptZInfo.z) <= 0) {
      return false;
    }
    return true;
  }
  var RoamController = (
    /** @class */
    function(_super) {
      __extends(RoamController2, _super);
      function RoamController2(zr) {
        var _this = _super.call(this) || this;
        _this._zr = zr;
        var mousedownHandler = bind$1(_this._mousedownHandler, _this);
        var mousemoveHandler = bind$1(_this._mousemoveHandler, _this);
        var mouseupHandler = bind$1(_this._mouseupHandler, _this);
        var mousewheelHandler = bind$1(_this._mousewheelHandler, _this);
        var pinchHandler = bind$1(_this._pinchHandler, _this);
        _this.enable = function(controlType, rawOpt) {
          var zInfo = rawOpt.zInfo;
          var _a2 = retrieveZInfo(zInfo.component), z = _a2.z, zlevel = _a2.zlevel;
          var zInfoParsed = {
            component: zInfo.component,
            z,
            zlevel,
            // By default roam controller is the lowest z2 comparing to other elememts in a component.
            z2: retrieve2(zInfo.z2, -Infinity)
          };
          var triggerInfo = extend({}, rawOpt.triggerInfo);
          this._opt = defaults(extend({}, rawOpt), {
            zoomOnMouseWheel: true,
            moveOnMouseMove: true,
            // By default, wheel do not trigger move.
            moveOnMouseWheel: false,
            preventDefaultMouseMove: true,
            zInfoParsed,
            triggerInfo
          });
          if (controlType == null) {
            controlType = true;
          }
          if (!this._enabled || this._controlType !== controlType) {
            this._enabled = true;
            this.disable();
            if (controlType === true || controlType === "move" || controlType === "pan") {
              addRoamZrListener(zr, "mousedown", mousedownHandler, zInfoParsed);
              addRoamZrListener(zr, "mousemove", mousemoveHandler, zInfoParsed);
              addRoamZrListener(zr, "mouseup", mouseupHandler, zInfoParsed);
            }
            if (controlType === true || controlType === "scale" || controlType === "zoom") {
              addRoamZrListener(zr, "mousewheel", mousewheelHandler, zInfoParsed);
              addRoamZrListener(zr, "pinch", pinchHandler, zInfoParsed);
            }
          }
        };
        _this.disable = function() {
          this._enabled = false;
          removeRoamZrListener(zr, "mousedown", mousedownHandler);
          removeRoamZrListener(zr, "mousemove", mousemoveHandler);
          removeRoamZrListener(zr, "mouseup", mouseupHandler);
          removeRoamZrListener(zr, "mousewheel", mousewheelHandler);
          removeRoamZrListener(zr, "pinch", pinchHandler);
        };
        return _this;
      }
      RoamController2.prototype.isDragging = function() {
        return this._dragging;
      };
      RoamController2.prototype.isPinching = function() {
        return this._pinching;
      };
      RoamController2.prototype._checkPointer = function(e2, x, y) {
        var opt = this._opt;
        var zInfoParsed = opt.zInfoParsed;
        if (onIrrelevantElement(e2, opt.api, zInfoParsed.component)) {
          return false;
        }
        var triggerInfo = opt.triggerInfo;
        var roamTrigger = triggerInfo.roamTrigger;
        var inArea = false;
        if (roamTrigger === "global") {
          inArea = true;
        }
        if (!inArea) {
          inArea = triggerInfo.isInSelf(e2, x, y);
        }
        if (inArea && triggerInfo.isInClip && !triggerInfo.isInClip(e2, x, y)) {
          inArea = false;
        }
        return inArea;
      };
      RoamController2.prototype._decideCursorStyle = function(e2, x, y, forReverse) {
        var target = e2.target;
        if (!target && this._checkPointer(e2, x, y)) {
          return "grab";
        }
        if (forReverse) {
          return target && target.cursor || "default";
        }
      };
      RoamController2.prototype.dispose = function() {
        this.disable();
      };
      RoamController2.prototype._mousedownHandler = function(e2) {
        if (isMiddleOrRightButtonOnMouseUpDown(e2) || eventConsumed(e2)) {
          return;
        }
        var el = e2.target;
        while (el) {
          if (el.draggable) {
            return;
          }
          el = el.__hostTarget || el.parent;
        }
        var x = e2.offsetX;
        var y = e2.offsetY;
        if (this._checkPointer(e2, x, y)) {
          this._x = x;
          this._y = y;
          this._dragging = true;
        }
      };
      RoamController2.prototype._mousemoveHandler = function(e2) {
        var zr = this._zr;
        if (e2.gestureEvent === "pinch" || isTaken(zr, "globalPan") || eventConsumed(e2)) {
          return;
        }
        var x = e2.offsetX;
        var y = e2.offsetY;
        if (!this._dragging || !isAvailableBehavior("moveOnMouseMove", e2, this._opt)) {
          var cursorStyle = this._decideCursorStyle(e2, x, y, false);
          if (cursorStyle) {
            zr.setCursorStyle(cursorStyle);
          }
          return;
        }
        zr.setCursorStyle("grabbing");
        var oldX = this._x;
        var oldY = this._y;
        var dx = x - oldX;
        var dy = y - oldY;
        this._x = x;
        this._y = y;
        if (this._opt.preventDefaultMouseMove) {
          stop(e2.event);
        }
        e2.__ecRoamConsumed = true;
        trigger(this, "pan", "moveOnMouseMove", e2, {
          dx,
          dy,
          oldX,
          oldY,
          newX: x,
          newY: y,
          isAvailableBehavior: null
        });
      };
      RoamController2.prototype._mouseupHandler = function(e2) {
        if (eventConsumed(e2)) {
          return;
        }
        var zr = this._zr;
        if (!isMiddleOrRightButtonOnMouseUpDown(e2)) {
          this._dragging = false;
          var cursorStyle = this._decideCursorStyle(e2, e2.offsetX, e2.offsetY, true);
          if (cursorStyle) {
            zr.setCursorStyle(cursorStyle);
          }
        }
      };
      RoamController2.prototype._mousewheelHandler = function(e2) {
        if (eventConsumed(e2)) {
          return;
        }
        var shouldZoom = isAvailableBehavior("zoomOnMouseWheel", e2, this._opt);
        var shouldMove = isAvailableBehavior("moveOnMouseWheel", e2, this._opt);
        var wheelDelta = e2.wheelDelta;
        var absWheelDeltaDelta = Math.abs(wheelDelta);
        var originX = e2.offsetX;
        var originY = e2.offsetY;
        if (wheelDelta === 0 || !shouldZoom && !shouldMove) {
          return;
        }
        if (shouldZoom) {
          var factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1;
          var scale2 = wheelDelta > 0 ? factor : 1 / factor;
          this._checkTriggerMoveZoom(this, "zoom", "zoomOnMouseWheel", e2, {
            scale: scale2,
            originX,
            originY,
            isAvailableBehavior: null
          });
        }
        if (shouldMove) {
          var absDelta = Math.abs(wheelDelta);
          var scrollDelta = (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? 0.4 : absDelta > 1 ? 0.15 : 0.05);
          this._checkTriggerMoveZoom(this, "scrollMove", "moveOnMouseWheel", e2, {
            scrollDelta,
            originX,
            originY,
            isAvailableBehavior: null
          });
        }
      };
      RoamController2.prototype._pinchHandler = function(e2) {
        if (isTaken(this._zr, "globalPan") || eventConsumed(e2)) {
          return;
        }
        var scale2 = e2.pinchScale > 1 ? 1.1 : 1 / 1.1;
        this._checkTriggerMoveZoom(this, "zoom", null, e2, {
          scale: scale2,
          originX: e2.pinchX,
          originY: e2.pinchY,
          isAvailableBehavior: null
        });
      };
      RoamController2.prototype._checkTriggerMoveZoom = function(controller, eventName, behaviorToCheck, e2, contollerEvent) {
        if (controller._checkPointer(e2, contollerEvent.originX, contollerEvent.originY)) {
          stop(e2.event);
          e2.__ecRoamConsumed = true;
          trigger(controller, eventName, behaviorToCheck, e2, contollerEvent);
        }
      };
      return RoamController2;
    }(Eventful)
  );
  function eventConsumed(e2) {
    return e2.__ecRoamConsumed;
  }
  var innerZrStore = makeInner();
  function ensureZrStore(zr) {
    var store = innerZrStore(zr);
    store.roam = store.roam || {};
    store.uniform = store.uniform || {};
    return store;
  }
  function addRoamZrListener(zr, eventType, listener, zInfoParsed) {
    var store = ensureZrStore(zr);
    var roam = store.roam;
    var listenerList = roam[eventType] = roam[eventType] || [];
    var idx = 0;
    for (; idx < listenerList.length; idx++) {
      var currZInfo = listenerList[idx].zInfoParsed;
      if ((currZInfo.zlevel - zInfoParsed.zlevel || currZInfo.z - zInfoParsed.z || currZInfo.z2 - zInfoParsed.z2) <= 0) {
        break;
      }
    }
    listenerList.splice(idx, 0, {
      listener,
      zInfoParsed
    });
    ensureUniformListener(zr, eventType);
  }
  function removeRoamZrListener(zr, eventType, listener) {
    var store = ensureZrStore(zr);
    var listenerList = store.roam[eventType] || [];
    for (var idx = 0; idx < listenerList.length; idx++) {
      if (listenerList[idx].listener === listener) {
        listenerList.splice(idx, 1);
        if (!listenerList.length) {
          removeUniformListener(zr, eventType);
        }
        return;
      }
    }
  }
  function ensureUniformListener(zr, eventType) {
    var store = ensureZrStore(zr);
    if (!store.uniform[eventType]) {
      zr.on(eventType, store.uniform[eventType] = function(event) {
        var listenerList = store.roam[eventType];
        if (listenerList) {
          for (var i = 0; i < listenerList.length; i++) {
            listenerList[i].listener(event);
          }
        }
      });
    }
  }
  function removeUniformListener(zr, eventType) {
    var store = ensureZrStore(zr);
    var uniform = store.uniform;
    if (uniform[eventType]) {
      zr.off(eventType, uniform[eventType]);
      uniform[eventType] = null;
    }
  }
  function trigger(controller, eventName, behaviorToCheck, e2, contollerEvent) {
    contollerEvent.isAvailableBehavior = bind$1(isAvailableBehavior, null, behaviorToCheck, e2);
    controller.trigger(eventName, contollerEvent);
  }
  function isAvailableBehavior(behaviorToCheck, e2, settings) {
    var setting = settings[behaviorToCheck];
    return !behaviorToCheck || setting && (!isString(setting) || e2.event[setting + "Key"]);
  }
  function sliderMove(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {
    delta = delta || 0;
    var extentSpan = extent[1] - extent[0];
    if (minSpan != null) {
      minSpan = restrict(minSpan, [0, extentSpan]);
    }
    if (maxSpan != null) {
      maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);
    }
    if (handleIndex === "all") {
      var handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);
      handleSpan = restrict(handleSpan, [0, extentSpan]);
      minSpan = maxSpan = restrict(handleSpan, [minSpan, maxSpan]);
      handleIndex = 0;
    }
    handleEnds[0] = restrict(handleEnds[0], extent);
    handleEnds[1] = restrict(handleEnds[1], extent);
    var originalDistSign = getSpanSign(handleEnds, handleIndex);
    handleEnds[handleIndex] += delta;
    var extentMinSpan = minSpan || 0;
    var realExtent = extent.slice();
    originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;
    handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent);
    var currDistSign;
    currDistSign = getSpanSign(handleEnds, handleIndex);
    if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {
      handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;
    }
    currDistSign = getSpanSign(handleEnds, handleIndex);
    if (maxSpan != null && currDistSign.span > maxSpan) {
      handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;
    }
    return handleEnds;
  }
  function getSpanSign(handleEnds, handleIndex) {
    var dist2 = handleEnds[handleIndex] - handleEnds[1 - handleIndex];
    return {
      span: Math.abs(dist2),
      sign: dist2 > 0 ? -1 : dist2 < 0 ? 1 : handleIndex ? -1 : 1
    };
  }
  function restrict(value, extend2) {
    return Math.min(extend2[1] != null ? extend2[1] : Infinity, Math.max(extend2[0] != null ? extend2[0] : -Infinity, value));
  }
  var inner$3 = makeInner();
  var clone = clone$2;
  var bind = bind$1;
  var BaseAxisPointer = (
    /** @class */
    function() {
      function BaseAxisPointer2() {
        this._dragging = false;
        this.animationThreshold = 15;
      }
      BaseAxisPointer2.prototype.render = function(axisModel, axisPointerModel, api, forceRender) {
        var value = axisPointerModel.get("value");
        var status = axisPointerModel.get("status");
        this._axisModel = axisModel;
        this._axisPointerModel = axisPointerModel;
        this._api = api;
        if (!forceRender && this._lastValue === value && this._lastStatus === status) {
          return;
        }
        this._lastValue = value;
        this._lastStatus = status;
        var group = this._group;
        var handle = this._handle;
        if (!status || status === "hide") {
          group && group.hide();
          handle && handle.hide();
          return;
        }
        group && group.show();
        handle && handle.show();
        var elOption = {};
        this.makeElOption(elOption, value, axisModel, axisPointerModel, api);
        var graphicKey = elOption.graphicKey;
        if (graphicKey !== this._lastGraphicKey) {
          this.clear(api);
        }
        this._lastGraphicKey = graphicKey;
        var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);
        if (!group) {
          group = this._group = new Group$2();
          this.createPointerEl(group, elOption, axisModel, axisPointerModel);
          this.createLabelEl(group, elOption, axisModel, axisPointerModel);
          api.getZr().add(group);
        } else {
          var doUpdateProps = curry$1(updateProps, axisPointerModel, moveAnimation);
          this.updatePointerEl(group, elOption, doUpdateProps);
          this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
        }
        updateMandatoryProps(group, axisPointerModel, true);
        this._renderHandle(value);
      };
      BaseAxisPointer2.prototype.remove = function(api) {
        this.clear(api);
      };
      BaseAxisPointer2.prototype.dispose = function(api) {
        this.clear(api);
      };
      BaseAxisPointer2.prototype.determineAnimation = function(axisModel, axisPointerModel) {
        var animation = axisPointerModel.get("animation");
        var axis = axisModel.axis;
        var isCategoryAxis = axis.type === "category";
        var useSnap = axisPointerModel.get("snap");
        if (!useSnap && !isCategoryAxis) {
          return false;
        }
        if (animation === "auto" || animation == null) {
          var animationThreshold = this.animationThreshold;
          if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
            return true;
          }
          if (useSnap) {
            var seriesDataCount = getAxisInfo(axisModel).seriesDataCount;
            var axisExtent = axis.getExtent();
            return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
          }
          return false;
        }
        return animation === true;
      };
      BaseAxisPointer2.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {
      };
      BaseAxisPointer2.prototype.createPointerEl = function(group, elOption, axisModel, axisPointerModel) {
        var pointerOption = elOption.pointer;
        if (pointerOption) {
          var pointerEl = inner$3(group).pointerEl = new graphic[pointerOption.type](clone(elOption.pointer));
          group.add(pointerEl);
        }
      };
      BaseAxisPointer2.prototype.createLabelEl = function(group, elOption, axisModel, axisPointerModel) {
        if (elOption.label) {
          var labelEl = inner$3(group).labelEl = new ZRText(clone(elOption.label));
          group.add(labelEl);
          updateLabelShowHide(labelEl, axisPointerModel);
        }
      };
      BaseAxisPointer2.prototype.updatePointerEl = function(group, elOption, updateProps2) {
        var pointerEl = inner$3(group).pointerEl;
        if (pointerEl && elOption.pointer) {
          pointerEl.setStyle(elOption.pointer.style);
          updateProps2(pointerEl, {
            shape: elOption.pointer.shape
          });
        }
      };
      BaseAxisPointer2.prototype.updateLabelEl = function(group, elOption, updateProps2, axisPointerModel) {
        var labelEl = inner$3(group).labelEl;
        if (labelEl) {
          labelEl.setStyle(elOption.label.style);
          updateProps2(labelEl, {
            // Consider text length change in vertical axis, animation should
            // be used on shape, otherwise the effect will be weird.
            // TODOTODO
            // shape: elOption.label.shape,
            x: elOption.label.x,
            y: elOption.label.y
          });
          updateLabelShowHide(labelEl, axisPointerModel);
        }
      };
      BaseAxisPointer2.prototype._renderHandle = function(value) {
        if (this._dragging || !this.updateHandleTransform) {
          return;
        }
        var axisPointerModel = this._axisPointerModel;
        var zr = this._api.getZr();
        var handle = this._handle;
        var handleModel = axisPointerModel.getModel("handle");
        var status = axisPointerModel.get("status");
        if (!handleModel.get("show") || !status || status === "hide") {
          handle && zr.remove(handle);
          this._handle = null;
          return;
        }
        var isInit;
        if (!this._handle) {
          isInit = true;
          handle = this._handle = createIcon(handleModel.get("icon"), {
            cursor: "move",
            draggable: true,
            onmousemove: function(e2) {
              stop(e2.event);
            },
            onmousedown: bind(this._onHandleDragMove, this, 0, 0),
            drift: bind(this._onHandleDragMove, this),
            ondragend: bind(this._onHandleDragEnd, this)
          });
          zr.add(handle);
        }
        updateMandatoryProps(handle, axisPointerModel, false);
        handle.setStyle(handleModel.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
        var handleSize = handleModel.get("size");
        if (!isArray(handleSize)) {
          handleSize = [handleSize, handleSize];
        }
        handle.scaleX = handleSize[0] / 2;
        handle.scaleY = handleSize[1] / 2;
        createOrUpdate(this, "_doDispatchAxisPointer", handleModel.get("throttle") || 0, "fixRate");
        this._moveHandleToValue(value, isInit);
      };
      BaseAxisPointer2.prototype._moveHandleToValue = function(value, isInit) {
        updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
      };
      BaseAxisPointer2.prototype._onHandleDragMove = function(dx, dy) {
        var handle = this._handle;
        if (!handle) {
          return;
        }
        this._dragging = true;
        var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
        this._payloadInfo = trans;
        handle.stopAnimation();
        handle.attr(getHandleTransProps(trans));
        inner$3(handle).lastProp = null;
        this._doDispatchAxisPointer();
      };
      BaseAxisPointer2.prototype._doDispatchAxisPointer = function() {
        var handle = this._handle;
        if (!handle) {
          return;
        }
        var payloadInfo = this._payloadInfo;
        var axisModel = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: payloadInfo.cursorPoint[0],
          y: payloadInfo.cursorPoint[1],
          tooltipOption: payloadInfo.tooltipOption,
          axesInfo: [{
            axisDim: axisModel.axis.dim,
            axisIndex: axisModel.componentIndex
          }]
        });
      };
      BaseAxisPointer2.prototype._onHandleDragEnd = function() {
        this._dragging = false;
        var handle = this._handle;
        if (!handle) {
          return;
        }
        var value = this._axisPointerModel.get("value");
        this._moveHandleToValue(value);
        this._api.dispatchAction({
          type: "hideTip"
        });
      };
      BaseAxisPointer2.prototype.clear = function(api) {
        this._lastValue = null;
        this._lastStatus = null;
        var zr = api.getZr();
        var group = this._group;
        var handle = this._handle;
        if (zr && group) {
          this._lastGraphicKey = null;
          group && zr.remove(group);
          handle && zr.remove(handle);
          this._group = null;
          this._handle = null;
          this._payloadInfo = null;
        }
        clear(this, "_doDispatchAxisPointer");
      };
      BaseAxisPointer2.prototype.doClear = function() {
      };
      BaseAxisPointer2.prototype.buildLabel = function(xy, wh, xDimIndex) {
        xDimIndex = xDimIndex || 0;
        return {
          x: xy[xDimIndex],
          y: xy[1 - xDimIndex],
          width: wh[xDimIndex],
          height: wh[1 - xDimIndex]
        };
      };
      return BaseAxisPointer2;
    }()
  );
  function updateProps(animationModel, moveAnimation, el, props) {
    if (!propsEqual(inner$3(el).lastProp, props)) {
      inner$3(el).lastProp = props;
      moveAnimation ? updateProps$1(el, props, animationModel) : (el.stopAnimation(), el.attr(props));
    }
  }
  function propsEqual(lastProps, newProps) {
    if (isObject$2(lastProps) && isObject$2(newProps)) {
      var equals_1 = true;
      each$5(newProps, function(item, key2) {
        equals_1 = equals_1 && propsEqual(lastProps[key2], item);
      });
      return !!equals_1;
    } else {
      return lastProps === newProps;
    }
  }
  function updateLabelShowHide(labelEl, axisPointerModel) {
    labelEl[axisPointerModel.get(["label", "show"]) ? "show" : "hide"]();
  }
  function getHandleTransProps(trans) {
    return {
      x: trans.x || 0,
      y: trans.y || 0,
      rotation: trans.rotation || 0
    };
  }
  function updateMandatoryProps(group, axisPointerModel, silent) {
    var z = axisPointerModel.get("z");
    var zlevel = axisPointerModel.get("zlevel");
    group && group.traverse(function(el) {
      if (el.type !== "group") {
        z != null && (el.z = z);
        zlevel != null && (el.zlevel = zlevel);
        el.silent = silent;
      }
    });
  }
  function buildElStyle(axisPointerModel) {
    var axisPointerType = axisPointerModel.get("type");
    var styleModel = axisPointerModel.getModel(axisPointerType + "Style");
    var style;
    if (axisPointerType === "line") {
      style = styleModel.getLineStyle();
      style.fill = null;
    } else if (axisPointerType === "shadow") {
      style = styleModel.getAreaStyle();
      style.stroke = null;
    }
    return style;
  }
  function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {
    var value = axisPointerModel.get("value");
    var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get("seriesDataIndices"), {
      precision: axisPointerModel.get(["label", "precision"]),
      formatter: axisPointerModel.get(["label", "formatter"])
    });
    var labelModel = axisPointerModel.getModel("label");
    var paddings = normalizeCssArray(labelModel.get("padding") || 0);
    var font = labelModel.getFont();
    var textRect = getBoundingRect(text, font);
    var position = labelPos.position;
    var width = textRect.width + paddings[1] + paddings[3];
    var height = textRect.height + paddings[0] + paddings[2];
    var align = labelPos.align;
    align === "right" && (position[0] -= width);
    align === "center" && (position[0] -= width / 2);
    var verticalAlign = labelPos.verticalAlign;
    verticalAlign === "bottom" && (position[1] -= height);
    verticalAlign === "middle" && (position[1] -= height / 2);
    confineInContainer(position, width, height, api);
    var bgColor = labelModel.get("backgroundColor");
    if (!bgColor || bgColor === "auto") {
      bgColor = axisModel.get(["axisLine", "lineStyle", "color"]);
    }
    elOption.label = {
      // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},
      x: position[0],
      y: position[1],
      style: createTextStyle(labelModel, {
        text,
        font,
        fill: labelModel.getTextColor(),
        padding: paddings,
        backgroundColor: bgColor
      }),
      // Label should be over axisPointer.
      z2: 10
    };
  }
  function confineInContainer(position, width, height, api) {
    var viewWidth = api.getWidth();
    var viewHeight = api.getHeight();
    position[0] = Math.min(position[0] + width, viewWidth) - width;
    position[1] = Math.min(position[1] + height, viewHeight) - height;
    position[0] = Math.max(position[0], 0);
    position[1] = Math.max(position[1], 0);
  }
  function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
    value = axis.scale.parse(value);
    var text = axis.scale.getLabel({
      value
    }, {
      // If `precision` is set, width can be fixed (like '12.00500'), which
      // helps to debounce when when moving label.
      precision: opt.precision
    });
    var formatter = opt.formatter;
    if (formatter) {
      var params_1 = {
        value: getAxisRawValue(axis, {
          value
        }),
        axisDimension: axis.dim,
        axisIndex: axis.index,
        seriesData: []
      };
      each$5(seriesDataIndices, function(idxItem) {
        var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
        var dataIndex = idxItem.dataIndexInside;
        var dataParams = series && series.getDataParams(dataIndex);
        dataParams && params_1.seriesData.push(dataParams);
      });
      if (isString(formatter)) {
        text = formatter.replace("{value}", text);
      } else if (isFunction(formatter)) {
        text = formatter(params_1);
      }
    }
    return text;
  }
  function getTransformedPosition(axis, value, layoutInfo) {
    var transform = create();
    rotate(transform, transform, layoutInfo.rotation);
    translate(transform, transform, layoutInfo.position);
    return applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);
  }
  function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {
    var textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
    layoutInfo.labelMargin = axisPointerModel.get(["label", "margin"]);
    buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
      position: getTransformedPosition(axisModel.axis, value, layoutInfo),
      align: textLayout.textAlign,
      verticalAlign: textLayout.textVerticalAlign
    });
  }
  function makeLineShape(p1, p2, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
      x1: p1[xDimIndex],
      y1: p1[1 - xDimIndex],
      x2: p2[xDimIndex],
      y2: p2[1 - xDimIndex]
    };
  }
  function makeRectShape(xy, wh, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
      x: xy[xDimIndex],
      y: xy[1 - xDimIndex],
      width: wh[xDimIndex],
      height: wh[1 - xDimIndex]
    };
  }
  var CartesianAxisPointer = (
    /** @class */
    function(_super) {
      __extends(CartesianAxisPointer2, _super);
      function CartesianAxisPointer2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      CartesianAxisPointer2.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {
        var axis = axisModel.axis;
        var grid = axis.grid;
        var axisPointerType = axisPointerModel.get("type");
        var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
        var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));
        if (axisPointerType && axisPointerType !== "none") {
          var elStyle = buildElStyle(axisPointerModel);
          var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
          pointerOption.style = elStyle;
          elOption.graphicKey = pointerOption.type;
          elOption.pointer = pointerOption;
        }
        var layoutInfo = layout(grid.getRect(), axisModel);
        buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
      };
      CartesianAxisPointer2.prototype.getHandleTransform = function(value, axisModel, axisPointerModel) {
        var layoutInfo = layout(axisModel.axis.grid.getRect(), axisModel, {
          labelInside: false
        });
        layoutInfo.labelMargin = axisPointerModel.get(["handle", "margin"]);
        var pos = getTransformedPosition(axisModel.axis, value, layoutInfo);
        return {
          x: pos[0],
          y: pos[1],
          rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
        };
      };
      CartesianAxisPointer2.prototype.updateHandleTransform = function(transform, delta, axisModel, axisPointerModel) {
        var axis = axisModel.axis;
        var grid = axis.grid;
        var axisExtent = axis.getGlobalExtent(true);
        var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
        var dimIndex = axis.dim === "x" ? 0 : 1;
        var currPosition = [transform.x, transform.y];
        currPosition[dimIndex] += delta[dimIndex];
        currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
        currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
        var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
        var cursorPoint = [cursorOtherValue, cursorOtherValue];
        cursorPoint[dimIndex] = currPosition[dimIndex];
        var tooltipOptions = [{
          verticalAlign: "middle"
        }, {
          align: "center"
        }];
        return {
          x: currPosition[0],
          y: currPosition[1],
          rotation: transform.rotation,
          cursorPoint,
          tooltipOption: tooltipOptions[dimIndex]
        };
      };
      return CartesianAxisPointer2;
    }(BaseAxisPointer)
  );
  function getCartesian(grid, axis) {
    var opt = {};
    opt[axis.dim + "AxisIndex"] = axis.index;
    return grid.getCartesian(opt);
  }
  var pointerShapeBuilder = {
    line: function(axis, pixelValue, otherExtent) {
      var targetShape = makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));
      return {
        type: "Line",
        subPixelOptimize: true,
        shape: targetShape
      };
    },
    shadow: function(axis, pixelValue, otherExtent) {
      var bandWidth = Math.max(1, axis.getBandWidth());
      var span = otherExtent[1] - otherExtent[0];
      return {
        type: "Rect",
        shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
      };
    }
  };
  function getAxisDimIndex(axis) {
    return axis.dim === "x" ? 0 : 1;
  }
  var AxisPointerModel = (
    /** @class */
    function(_super) {
      __extends(AxisPointerModel2, _super);
      function AxisPointerModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = AxisPointerModel2.type;
        return _this;
      }
      AxisPointerModel2.type = "axisPointer";
      AxisPointerModel2.defaultOption = {
        // 'auto' means that show when triggered by tooltip or handle.
        show: "auto",
        // zlevel: 0,
        z: 50,
        type: "line",
        // axispointer triggered by tootip determine snap automatically,
        // see `modelHelper`.
        snap: false,
        triggerTooltip: true,
        triggerEmphasis: true,
        value: null,
        status: null,
        link: [],
        // Do not set 'auto' here, otherwise global animation: false
        // will not effect at this axispointer.
        animation: null,
        animationDurationUpdate: 200,
        lineStyle: {
          color: tokens.color.border,
          width: 1,
          type: "dashed"
        },
        shadowStyle: {
          color: tokens.color.shadowTint
        },
        label: {
          show: true,
          formatter: null,
          precision: "auto",
          margin: 3,
          color: tokens.color.neutral00,
          padding: [5, 7, 5, 7],
          backgroundColor: tokens.color.accent60,
          borderColor: null,
          borderWidth: 0,
          borderRadius: 3
        },
        handle: {
          show: false,
          // eslint-disable-next-line
          icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
          size: 45,
          // handle margin is from symbol center to axis, which is stable when circular move.
          margin: 50,
          // color: '#1b8bbd'
          // color: '#2f4554'
          color: tokens.color.accent40,
          // For mobile performance
          throttle: 40
        }
      };
      return AxisPointerModel2;
    }(ComponentModel)
  );
  var inner$2 = makeInner();
  var each$2 = each$5;
  function register$1(key2, api, handler) {
    if (env.node) {
      return;
    }
    var zr = api.getZr();
    inner$2(zr).records || (inner$2(zr).records = {});
    initGlobalListeners(zr, api);
    var record = inner$2(zr).records[key2] || (inner$2(zr).records[key2] = {});
    record.handler = handler;
  }
  function initGlobalListeners(zr, api) {
    if (inner$2(zr).initialized) {
      return;
    }
    inner$2(zr).initialized = true;
    useHandler("click", curry$1(doEnter, "click"));
    useHandler("mousemove", curry$1(doEnter, "mousemove"));
    useHandler("globalout", onLeave);
    function useHandler(eventType, cb) {
      zr.on(eventType, function(e2) {
        var dis = makeDispatchAction$1(api);
        each$2(inner$2(zr).records, function(record) {
          record && cb(record, e2, dis.dispatchAction);
        });
        dispatchTooltipFinally(dis.pendings, api);
      });
    }
  }
  function dispatchTooltipFinally(pendings, api) {
    var showLen = pendings.showTip.length;
    var hideLen = pendings.hideTip.length;
    var actuallyPayload;
    if (showLen) {
      actuallyPayload = pendings.showTip[showLen - 1];
    } else if (hideLen) {
      actuallyPayload = pendings.hideTip[hideLen - 1];
    }
    if (actuallyPayload) {
      actuallyPayload.dispatchAction = null;
      api.dispatchAction(actuallyPayload);
    }
  }
  function onLeave(record, e2, dispatchAction2) {
    record.handler("leave", null, dispatchAction2);
  }
  function doEnter(currTrigger, record, e2, dispatchAction2) {
    record.handler(currTrigger, e2, dispatchAction2);
  }
  function makeDispatchAction$1(api) {
    var pendings = {
      showTip: [],
      hideTip: []
    };
    var dispatchAction2 = function(payload) {
      var pendingList = pendings[payload.type];
      if (pendingList) {
        pendingList.push(payload);
      } else {
        payload.dispatchAction = dispatchAction2;
        api.dispatchAction(payload);
      }
    };
    return {
      dispatchAction: dispatchAction2,
      pendings
    };
  }
  function unregister(key2, api) {
    if (env.node) {
      return;
    }
    var zr = api.getZr();
    var record = (inner$2(zr).records || {})[key2];
    if (record) {
      inner$2(zr).records[key2] = null;
    }
  }
  var AxisPointerView = (
    /** @class */
    function(_super) {
      __extends(AxisPointerView2, _super);
      function AxisPointerView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = AxisPointerView2.type;
        return _this;
      }
      AxisPointerView2.prototype.render = function(globalAxisPointerModel, ecModel, api) {
        var globalTooltipModel = ecModel.getComponent("tooltip");
        var triggerOn = globalAxisPointerModel.get("triggerOn") || globalTooltipModel && globalTooltipModel.get("triggerOn") || "mousemove|click";
        register$1("axisPointer", api, function(currTrigger, e2, dispatchAction2) {
          if (triggerOn !== "none" && (currTrigger === "leave" || triggerOn.indexOf(currTrigger) >= 0)) {
            dispatchAction2({
              type: "updateAxisPointer",
              currTrigger,
              x: e2 && e2.offsetX,
              y: e2 && e2.offsetY
            });
          }
        });
      };
      AxisPointerView2.prototype.remove = function(ecModel, api) {
        unregister("axisPointer", api);
      };
      AxisPointerView2.prototype.dispose = function(ecModel, api) {
        unregister("axisPointer", api);
      };
      AxisPointerView2.type = "axisPointer";
      return AxisPointerView2;
    }(ComponentView)
  );
  function findPointFromSeries(finder, ecModel) {
    var point = [];
    var seriesIndex = finder.seriesIndex;
    var seriesModel;
    if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
      return {
        point: []
      };
    }
    var data = seriesModel.getData();
    var dataIndex = queryDataIndex(data, finder);
    if (dataIndex == null || dataIndex < 0 || isArray(dataIndex)) {
      return {
        point: []
      };
    }
    var el = data.getItemGraphicEl(dataIndex);
    var coordSys = seriesModel.coordinateSystem;
    if (seriesModel.getTooltipPosition) {
      point = seriesModel.getTooltipPosition(dataIndex) || [];
    } else if (coordSys && coordSys.dataToPoint) {
      if (finder.isStacked) {
        var baseAxis = coordSys.getBaseAxis();
        var valueAxis2 = coordSys.getOtherAxis(baseAxis);
        var valueAxisDim = valueAxis2.dim;
        var baseAxisDim = baseAxis.dim;
        var baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
        var baseDim = data.mapDimension(baseAxisDim);
        var stackedData = [];
        stackedData[baseDataOffset] = data.get(baseDim, dataIndex);
        stackedData[1 - baseDataOffset] = data.get(data.getCalculationInfo("stackResultDimension"), dataIndex);
        point = coordSys.dataToPoint(stackedData) || [];
      } else {
        point = coordSys.dataToPoint(data.getValues(map$1(coordSys.dimensions, function(dim) {
          return data.mapDimension(dim);
        }), dataIndex)) || [];
      }
    } else if (el) {
      var rect = el.getBoundingRect().clone();
      rect.applyTransform(el.transform);
      point = [rect.x + rect.width / 2, rect.y + rect.height / 2];
    }
    return {
      point,
      el
    };
  }
  var inner$1 = makeInner();
  function axisTrigger(payload, ecModel, api) {
    var currTrigger = payload.currTrigger;
    var point = [payload.x, payload.y];
    var finder = payload;
    var dispatchAction2 = payload.dispatchAction || bind$1(api.dispatchAction, api);
    var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
    if (!coordSysAxesInfo) {
      return;
    }
    if (illegalPoint(point)) {
      point = findPointFromSeries({
        seriesIndex: finder.seriesIndex,
        // Do not use dataIndexInside from other ec instance.
        // FIXME: auto detect it?
        dataIndex: finder.dataIndex
      }, ecModel).point;
    }
    var isIllegalPoint = illegalPoint(point);
    var inputAxesInfo = finder.axesInfo;
    var axesInfo = coordSysAxesInfo.axesInfo;
    var shouldHide = currTrigger === "leave" || illegalPoint(point);
    var outputPayload = {};
    var showValueMap = {};
    var dataByCoordSys = {
      list: [],
      map: {}
    };
    var updaters = {
      showPointer: curry$1(showPointer, showValueMap),
      showTooltip: curry$1(showTooltip, dataByCoordSys)
    };
    each$5(coordSysAxesInfo.coordSysMap, function(coordSys, coordSysKey) {
      var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
      each$5(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function(axisInfo, key2) {
        var axis = axisInfo.axis;
        var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);
        if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
          var val = inputAxisInfo && inputAxisInfo.value;
          if (val == null && !isIllegalPoint) {
            val = axis.pointToData(point);
          }
          val != null && processOnAxis(axisInfo, val, updaters, false, outputPayload);
        }
      });
    });
    var linkTriggers = {};
    each$5(axesInfo, function(tarAxisInfo, tarKey) {
      var linkGroup = tarAxisInfo.linkGroup;
      if (linkGroup && !showValueMap[tarKey]) {
        each$5(linkGroup.axesInfo, function(srcAxisInfo, srcKey) {
          var srcValItem = showValueMap[srcKey];
          if (srcAxisInfo !== tarAxisInfo && srcValItem) {
            var val = srcValItem.value;
            linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
            linkTriggers[tarAxisInfo.key] = val;
          }
        });
      }
    });
    each$5(linkTriggers, function(val, tarKey) {
      processOnAxis(axesInfo[tarKey], val, updaters, true, outputPayload);
    });
    updateModelActually(showValueMap, axesInfo, outputPayload);
    dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction2);
    dispatchHighDownActually(axesInfo, dispatchAction2, api);
    return outputPayload;
  }
  function processOnAxis(axisInfo, newValue, updaters, noSnap, outputFinder) {
    var axis = axisInfo.axis;
    if (axis.scale.isBlank() || !axis.containData(newValue)) {
      return;
    }
    if (!axisInfo.involveSeries) {
      updaters.showPointer(axisInfo, newValue);
      return;
    }
    var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
    var payloadBatch = payloadInfo.payloadBatch;
    var snapToValue = payloadInfo.snapToValue;
    if (payloadBatch[0] && outputFinder.seriesIndex == null) {
      extend(outputFinder, payloadBatch[0]);
    }
    if (!noSnap && axisInfo.snap) {
      if (axis.containData(snapToValue) && snapToValue != null) {
        newValue = snapToValue;
      }
    }
    updaters.showPointer(axisInfo, newValue, payloadBatch);
    updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
  }
  function buildPayloadsBySeries(value, axisInfo) {
    var axis = axisInfo.axis;
    var dim = axis.dim;
    var snapToValue = value;
    var payloadBatch = [];
    var minDist = Number.MAX_VALUE;
    var minDiff = -1;
    each$5(axisInfo.seriesModels, function(series, idx) {
      var dataDim = series.getData().mapDimensionsAll(dim);
      var seriesNestestValue;
      var dataIndices;
      if (series.getAxisTooltipData) {
        var result = series.getAxisTooltipData(dataDim, value, axis);
        dataIndices = result.dataIndices;
        seriesNestestValue = result.nestestValue;
      } else {
        dataIndices = series.indicesOfNearest(
          dim,
          dataDim[0],
          value,
          // Add a threshold to avoid find the wrong dataIndex
          // when data length is not same.
          // false,
          axis.type === "category" ? 0.5 : null
        );
        if (!dataIndices.length) {
          return;
        }
        seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
      }
      if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
        return;
      }
      var diff = value - seriesNestestValue;
      var dist2 = Math.abs(diff);
      if (dist2 <= minDist) {
        if (dist2 < minDist || diff >= 0 && minDiff < 0) {
          minDist = dist2;
          minDiff = diff;
          snapToValue = seriesNestestValue;
          payloadBatch.length = 0;
        }
        each$5(dataIndices, function(dataIndex) {
          payloadBatch.push({
            seriesIndex: series.seriesIndex,
            dataIndexInside: dataIndex,
            dataIndex: series.getData().getRawIndex(dataIndex)
          });
        });
      }
    });
    return {
      payloadBatch,
      snapToValue
    };
  }
  function showPointer(showValueMap, axisInfo, value, payloadBatch) {
    showValueMap[axisInfo.key] = {
      value,
      payloadBatch
    };
  }
  function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
    var payloadBatch = payloadInfo.payloadBatch;
    var axis = axisInfo.axis;
    var axisModel = axis.model;
    var axisPointerModel = axisInfo.axisPointerModel;
    if (!axisInfo.triggerTooltip || !payloadBatch.length) {
      return;
    }
    var coordSysModel = axisInfo.coordSys.model;
    var coordSysKey = makeKey(coordSysModel);
    var coordSysItem = dataByCoordSys.map[coordSysKey];
    if (!coordSysItem) {
      coordSysItem = dataByCoordSys.map[coordSysKey] = {
        coordSysId: coordSysModel.id,
        coordSysIndex: coordSysModel.componentIndex,
        coordSysType: coordSysModel.type,
        coordSysMainType: coordSysModel.mainType,
        dataByAxis: []
      };
      dataByCoordSys.list.push(coordSysItem);
    }
    coordSysItem.dataByAxis.push({
      axisDim: axis.dim,
      axisIndex: axisModel.componentIndex,
      axisType: axisModel.type,
      axisId: axisModel.id,
      value,
      // Caustion: viewHelper.getValueLabel is actually on "view stage", which
      // depends that all models have been updated. So it should not be performed
      // here. Considering axisPointerModel used here is volatile, which is hard
      // to be retrieve in TooltipView, we prepare parameters here.
      valueLabelOpt: {
        precision: axisPointerModel.get(["label", "precision"]),
        formatter: axisPointerModel.get(["label", "formatter"])
      },
      seriesDataIndices: payloadBatch.slice()
    });
  }
  function updateModelActually(showValueMap, axesInfo, outputPayload) {
    var outputAxesInfo = outputPayload.axesInfo = [];
    each$5(axesInfo, function(axisInfo, key2) {
      var option = axisInfo.axisPointerModel.option;
      var valItem = showValueMap[key2];
      if (valItem) {
        !axisInfo.useHandle && (option.status = "show");
        option.value = valItem.value;
        option.seriesDataIndices = (valItem.payloadBatch || []).slice();
      } else {
        !axisInfo.useHandle && (option.status = "hide");
      }
      option.status === "show" && outputAxesInfo.push({
        axisDim: axisInfo.axis.dim,
        axisIndex: axisInfo.axis.model.componentIndex,
        value: option.value
      });
    });
  }
  function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction2) {
    if (illegalPoint(point) || !dataByCoordSys.list.length) {
      dispatchAction2({
        type: "hideTip"
      });
      return;
    }
    var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
    dispatchAction2({
      type: "showTip",
      escapeConnect: true,
      x: point[0],
      y: point[1],
      tooltipOption: payload.tooltipOption,
      position: payload.position,
      dataIndexInside: sampleItem.dataIndexInside,
      dataIndex: sampleItem.dataIndex,
      seriesIndex: sampleItem.seriesIndex,
      dataByCoordSys: dataByCoordSys.list
    });
  }
  function dispatchHighDownActually(axesInfo, dispatchAction2, api) {
    var zr = api.getZr();
    var highDownKey = "axisPointerLastHighlights";
    var lastHighlights = inner$1(zr)[highDownKey] || {};
    var newHighlights = inner$1(zr)[highDownKey] = {};
    each$5(axesInfo, function(axisInfo, key2) {
      var option = axisInfo.axisPointerModel.option;
      option.status === "show" && axisInfo.triggerEmphasis && each$5(option.seriesDataIndices, function(batchItem) {
        var key3 = batchItem.seriesIndex + " | " + batchItem.dataIndex;
        newHighlights[key3] = batchItem;
      });
    });
    var toHighlight = [];
    var toDownplay = [];
    each$5(lastHighlights, function(batchItem, key2) {
      !newHighlights[key2] && toDownplay.push(batchItem);
    });
    each$5(newHighlights, function(batchItem, key2) {
      !lastHighlights[key2] && toHighlight.push(batchItem);
    });
    toDownplay.length && api.dispatchAction({
      type: "downplay",
      escapeConnect: true,
      // Not blur others when highlight in axisPointer.
      notBlur: true,
      batch: toDownplay
    });
    toHighlight.length && api.dispatchAction({
      type: "highlight",
      escapeConnect: true,
      // Not blur others when highlight in axisPointer.
      notBlur: true,
      batch: toHighlight
    });
  }
  function findInputAxisInfo(inputAxesInfo, axisInfo) {
    for (var i = 0; i < (inputAxesInfo || []).length; i++) {
      var inputAxisInfo = inputAxesInfo[i];
      if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
        return inputAxisInfo;
      }
    }
  }
  function makeMapperParam(axisInfo) {
    var axisModel = axisInfo.axis.model;
    var item = {};
    var dim = item.axisDim = axisInfo.axis.dim;
    item.axisIndex = item[dim + "AxisIndex"] = axisModel.componentIndex;
    item.axisName = item[dim + "AxisName"] = axisModel.name;
    item.axisId = item[dim + "AxisId"] = axisModel.id;
    return item;
  }
  function illegalPoint(point) {
    return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
  }
  function install$9(registers) {
    AxisView.registerAxisPointerClass("CartesianAxisPointer", CartesianAxisPointer);
    registers.registerComponentModel(AxisPointerModel);
    registers.registerComponentView(AxisPointerView);
    registers.registerPreprocessor(function(option) {
      if (option) {
        (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
        var link = option.axisPointer.link;
        if (link && !isArray(link)) {
          option.axisPointer.link = [link];
        }
      }
    });
    registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, function(ecModel, api) {
      ecModel.getComponent("axisPointer").coordSysAxesInfo = collect(ecModel, api);
    });
    registers.registerAction({
      type: "updateAxisPointer",
      event: "updateAxisPointer",
      update: ":updateAxisPointer"
    }, axisTrigger);
  }
  function install$8(registers) {
    use(install$b);
    use(install$9);
  }
  var define_process_env_default$4 = {};
  var DATA_ZOOM_AXIS_DIMENSIONS = ["x", "y", "radius", "angle", "single"];
  var SERIES_COORDS = ["cartesian2d", "polar", "singleAxis"];
  function isCoordSupported(seriesModel) {
    var coordType = seriesModel.get("coordinateSystem");
    return indexOf(SERIES_COORDS, coordType) >= 0;
  }
  function getAxisMainType(axisDim) {
    if (define_process_env_default$4.NODE_ENV !== "production") {
      assert(axisDim);
    }
    return axisDim + "Axis";
  }
  function findEffectedDataZooms(ecModel, payload) {
    var axisRecords = createHashMap();
    var effectedModels = [];
    var effectedModelMap = createHashMap();
    ecModel.eachComponent({
      mainType: "dataZoom",
      query: payload
    }, function(dataZoomModel) {
      if (!effectedModelMap.get(dataZoomModel.uid)) {
        addToEffected(dataZoomModel);
      }
    });
    var foundNewLink;
    do {
      foundNewLink = false;
      ecModel.eachComponent("dataZoom", processSingle);
    } while (foundNewLink);
    function processSingle(dataZoomModel) {
      if (!effectedModelMap.get(dataZoomModel.uid) && isLinked(dataZoomModel)) {
        addToEffected(dataZoomModel);
        foundNewLink = true;
      }
    }
    function addToEffected(dataZoom) {
      effectedModelMap.set(dataZoom.uid, true);
      effectedModels.push(dataZoom);
      markAxisControlled(dataZoom);
    }
    function isLinked(dataZoomModel) {
      var isLink = false;
      dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
        var axisIdxArr = axisRecords.get(axisDim);
        if (axisIdxArr && axisIdxArr[axisIndex]) {
          isLink = true;
        }
      });
      return isLink;
    }
    function markAxisControlled(dataZoomModel) {
      dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
        (axisRecords.get(axisDim) || axisRecords.set(axisDim, []))[axisIndex] = true;
      });
    }
    return effectedModels;
  }
  function collectReferCoordSysModelInfo(dataZoomModel) {
    var ecModel = dataZoomModel.ecModel;
    var coordSysInfoWrap = {
      infoList: [],
      infoMap: createHashMap()
    };
    dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
      var axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
      if (!axisModel) {
        return;
      }
      var coordSysModel = axisModel.getCoordSysModel();
      if (!coordSysModel) {
        return;
      }
      var coordSysUid = coordSysModel.uid;
      var coordSysInfo = coordSysInfoWrap.infoMap.get(coordSysUid);
      if (!coordSysInfo) {
        coordSysInfo = {
          model: coordSysModel,
          axisModels: []
        };
        coordSysInfoWrap.infoList.push(coordSysInfo);
        coordSysInfoWrap.infoMap.set(coordSysUid, coordSysInfo);
      }
      coordSysInfo.axisModels.push(axisModel);
    });
    return coordSysInfoWrap;
  }
  var define_process_env_default$3 = {};
  var DataZoomAxisInfo = (
    /** @class */
    function() {
      function DataZoomAxisInfo2() {
        this.indexList = [];
        this.indexMap = [];
      }
      DataZoomAxisInfo2.prototype.add = function(axisCmptIdx) {
        if (!this.indexMap[axisCmptIdx]) {
          this.indexList.push(axisCmptIdx);
          this.indexMap[axisCmptIdx] = true;
        }
      };
      return DataZoomAxisInfo2;
    }()
  );
  var DataZoomModel = (
    /** @class */
    function(_super) {
      __extends(DataZoomModel2, _super);
      function DataZoomModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = DataZoomModel2.type;
        _this._autoThrottle = true;
        _this._noTarget = true;
        _this._rangePropMode = ["percent", "percent"];
        return _this;
      }
      DataZoomModel2.prototype.init = function(option, parentModel, ecModel) {
        var inputRawOption = retrieveRawOption(option);
        this.settledOption = inputRawOption;
        this.mergeDefaultAndTheme(option, ecModel);
        this._doInit(inputRawOption);
      };
      DataZoomModel2.prototype.mergeOption = function(newOption) {
        var inputRawOption = retrieveRawOption(newOption);
        merge(this.option, newOption, true);
        merge(this.settledOption, inputRawOption, true);
        this._doInit(inputRawOption);
      };
      DataZoomModel2.prototype._doInit = function(inputRawOption) {
        var thisOption = this.option;
        this._setDefaultThrottle(inputRawOption);
        this._updateRangeUse(inputRawOption);
        var settledOption = this.settledOption;
        each$5([["start", "startValue"], ["end", "endValue"]], function(names, index2) {
          if (this._rangePropMode[index2] === "value") {
            thisOption[names[0]] = settledOption[names[0]] = null;
          }
        }, this);
        this._resetTarget();
      };
      DataZoomModel2.prototype._resetTarget = function() {
        var optionOrient = this.get("orient", true);
        var targetAxisIndexMap = this._targetAxisInfoMap = createHashMap();
        var hasAxisSpecified = this._fillSpecifiedTargetAxis(targetAxisIndexMap);
        if (hasAxisSpecified) {
          this._orient = optionOrient || this._makeAutoOrientByTargetAxis();
        } else {
          this._orient = optionOrient || "horizontal";
          this._fillAutoTargetAxisByOrient(targetAxisIndexMap, this._orient);
        }
        this._noTarget = true;
        targetAxisIndexMap.each(function(axisInfo) {
          if (axisInfo.indexList.length) {
            this._noTarget = false;
          }
        }, this);
      };
      DataZoomModel2.prototype._fillSpecifiedTargetAxis = function(targetAxisIndexMap) {
        var hasAxisSpecified = false;
        each$5(DATA_ZOOM_AXIS_DIMENSIONS, function(axisDim) {
          var refering = this.getReferringComponents(getAxisMainType(axisDim), MULTIPLE_REFERRING);
          if (!refering.specified) {
            return;
          }
          hasAxisSpecified = true;
          var axisInfo = new DataZoomAxisInfo();
          each$5(refering.models, function(axisModel) {
            axisInfo.add(axisModel.componentIndex);
          });
          targetAxisIndexMap.set(axisDim, axisInfo);
        }, this);
        return hasAxisSpecified;
      };
      DataZoomModel2.prototype._fillAutoTargetAxisByOrient = function(targetAxisIndexMap, orient) {
        var ecModel = this.ecModel;
        var needAuto = true;
        if (needAuto) {
          var axisDim = orient === "vertical" ? "y" : "x";
          var axisModels = ecModel.findComponents({
            mainType: axisDim + "Axis"
          });
          setParallelAxis(axisModels, axisDim);
        }
        if (needAuto) {
          var axisModels = ecModel.findComponents({
            mainType: "singleAxis",
            filter: function(axisModel) {
              return axisModel.get("orient", true) === orient;
            }
          });
          setParallelAxis(axisModels, "single");
        }
        function setParallelAxis(axisModels2, axisDim2) {
          var axisModel = axisModels2[0];
          if (!axisModel) {
            return;
          }
          var axisInfo = new DataZoomAxisInfo();
          axisInfo.add(axisModel.componentIndex);
          targetAxisIndexMap.set(axisDim2, axisInfo);
          needAuto = false;
          if (axisDim2 === "x" || axisDim2 === "y") {
            var gridModel_1 = axisModel.getReferringComponents("grid", SINGLE_REFERRING).models[0];
            gridModel_1 && each$5(axisModels2, function(axModel) {
              if (axisModel.componentIndex !== axModel.componentIndex && gridModel_1 === axModel.getReferringComponents("grid", SINGLE_REFERRING).models[0]) {
                axisInfo.add(axModel.componentIndex);
              }
            });
          }
        }
        if (needAuto) {
          each$5(DATA_ZOOM_AXIS_DIMENSIONS, function(axisDim2) {
            if (!needAuto) {
              return;
            }
            var axisModels2 = ecModel.findComponents({
              mainType: getAxisMainType(axisDim2),
              filter: function(axisModel) {
                return axisModel.get("type", true) === "category";
              }
            });
            if (axisModels2[0]) {
              var axisInfo = new DataZoomAxisInfo();
              axisInfo.add(axisModels2[0].componentIndex);
              targetAxisIndexMap.set(axisDim2, axisInfo);
              needAuto = false;
            }
          }, this);
        }
      };
      DataZoomModel2.prototype._makeAutoOrientByTargetAxis = function() {
        var dim;
        this.eachTargetAxis(function(axisDim) {
          !dim && (dim = axisDim);
        }, this);
        return dim === "y" ? "vertical" : "horizontal";
      };
      DataZoomModel2.prototype._setDefaultThrottle = function(inputRawOption) {
        if (inputRawOption.hasOwnProperty("throttle")) {
          this._autoThrottle = false;
        }
        if (this._autoThrottle) {
          var globalOption = this.ecModel.option;
          this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;
        }
      };
      DataZoomModel2.prototype._updateRangeUse = function(inputRawOption) {
        var rangePropMode = this._rangePropMode;
        var rangeModeInOption = this.get("rangeMode");
        each$5([["start", "startValue"], ["end", "endValue"]], function(names, index2) {
          var percentSpecified = inputRawOption[names[0]] != null;
          var valueSpecified = inputRawOption[names[1]] != null;
          if (percentSpecified && !valueSpecified) {
            rangePropMode[index2] = "percent";
          } else if (!percentSpecified && valueSpecified) {
            rangePropMode[index2] = "value";
          } else if (rangeModeInOption) {
            rangePropMode[index2] = rangeModeInOption[index2];
          } else if (percentSpecified) {
            rangePropMode[index2] = "percent";
          }
        });
      };
      DataZoomModel2.prototype.noTarget = function() {
        return this._noTarget;
      };
      DataZoomModel2.prototype.getFirstTargetAxisModel = function() {
        var firstAxisModel;
        this.eachTargetAxis(function(axisDim, axisIndex) {
          if (firstAxisModel == null) {
            firstAxisModel = this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
          }
        }, this);
        return firstAxisModel;
      };
      DataZoomModel2.prototype.eachTargetAxis = function(callback, context) {
        this._targetAxisInfoMap.each(function(axisInfo, axisDim) {
          each$5(axisInfo.indexList, function(axisIndex) {
            callback.call(context, axisDim, axisIndex);
          });
        });
      };
      DataZoomModel2.prototype.getAxisProxy = function(axisDim, axisIndex) {
        var axisModel = this.getAxisModel(axisDim, axisIndex);
        if (axisModel) {
          return axisModel.__dzAxisProxy;
        }
      };
      DataZoomModel2.prototype.getAxisModel = function(axisDim, axisIndex) {
        if (define_process_env_default$3.NODE_ENV !== "production") {
          assert(axisDim && axisIndex != null);
        }
        var axisInfo = this._targetAxisInfoMap.get(axisDim);
        if (axisInfo && axisInfo.indexMap[axisIndex]) {
          return this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
        }
      };
      DataZoomModel2.prototype.setRawRange = function(opt) {
        var thisOption = this.option;
        var settledOption = this.settledOption;
        each$5([["start", "startValue"], ["end", "endValue"]], function(names) {
          if (opt[names[0]] != null || opt[names[1]] != null) {
            thisOption[names[0]] = settledOption[names[0]] = opt[names[0]];
            thisOption[names[1]] = settledOption[names[1]] = opt[names[1]];
          }
        }, this);
        this._updateRangeUse(opt);
      };
      DataZoomModel2.prototype.setCalculatedRange = function(opt) {
        var option = this.option;
        each$5(["start", "startValue", "end", "endValue"], function(name) {
          option[name] = opt[name];
        });
      };
      DataZoomModel2.prototype.getPercentRange = function() {
        var axisProxy = this.findRepresentativeAxisProxy();
        if (axisProxy) {
          return axisProxy.getDataPercentWindow();
        }
      };
      DataZoomModel2.prototype.getValueRange = function(axisDim, axisIndex) {
        if (axisDim == null && axisIndex == null) {
          var axisProxy = this.findRepresentativeAxisProxy();
          if (axisProxy) {
            return axisProxy.getDataValueWindow();
          }
        } else {
          return this.getAxisProxy(axisDim, axisIndex).getDataValueWindow();
        }
      };
      DataZoomModel2.prototype.findRepresentativeAxisProxy = function(axisModel) {
        if (axisModel) {
          return axisModel.__dzAxisProxy;
        }
        var firstProxy;
        var axisDimList = this._targetAxisInfoMap.keys();
        for (var i = 0; i < axisDimList.length; i++) {
          var axisDim = axisDimList[i];
          var axisInfo = this._targetAxisInfoMap.get(axisDim);
          for (var j = 0; j < axisInfo.indexList.length; j++) {
            var proxy = this.getAxisProxy(axisDim, axisInfo.indexList[j]);
            if (proxy.hostedBy(this)) {
              return proxy;
            }
            if (!firstProxy) {
              firstProxy = proxy;
            }
          }
        }
        return firstProxy;
      };
      DataZoomModel2.prototype.getRangePropMode = function() {
        return this._rangePropMode.slice();
      };
      DataZoomModel2.prototype.getOrient = function() {
        if (define_process_env_default$3.NODE_ENV !== "production") {
          assert(this._orient);
        }
        return this._orient;
      };
      DataZoomModel2.type = "dataZoom";
      DataZoomModel2.dependencies = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "series", "toolbox"];
      DataZoomModel2.defaultOption = {
        // zlevel: 0,
        z: 4,
        filterMode: "filter",
        start: 0,
        end: 100
      };
      return DataZoomModel2;
    }(ComponentModel)
  );
  function retrieveRawOption(option) {
    var ret = {};
    each$5(["start", "end", "startValue", "endValue", "throttle"], function(name) {
      option.hasOwnProperty(name) && (ret[name] = option[name]);
    });
    return ret;
  }
  var DataZoomView = (
    /** @class */
    function(_super) {
      __extends(DataZoomView2, _super);
      function DataZoomView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = DataZoomView2.type;
        return _this;
      }
      DataZoomView2.prototype.render = function(dataZoomModel, ecModel, api, payload) {
        this.dataZoomModel = dataZoomModel;
        this.ecModel = ecModel;
        this.api = api;
      };
      DataZoomView2.type = "dataZoom";
      return DataZoomView2;
    }(ComponentView)
  );
  var each$1 = each$5;
  var asc = asc$1;
  var AxisProxy = (
    /** @class */
    function() {
      function AxisProxy2(dimName, axisIndex, dataZoomModel, ecModel) {
        this._dimName = dimName;
        this._axisIndex = axisIndex;
        this.ecModel = ecModel;
        this._dataZoomModel = dataZoomModel;
      }
      AxisProxy2.prototype.hostedBy = function(dataZoomModel) {
        return this._dataZoomModel === dataZoomModel;
      };
      AxisProxy2.prototype.getDataValueWindow = function() {
        return this._valueWindow.slice();
      };
      AxisProxy2.prototype.getDataPercentWindow = function() {
        return this._percentWindow.slice();
      };
      AxisProxy2.prototype.getTargetSeriesModels = function() {
        var seriesModels = [];
        this.ecModel.eachSeries(function(seriesModel) {
          if (isCoordSupported(seriesModel)) {
            var axisMainType = getAxisMainType(this._dimName);
            var axisModel = seriesModel.getReferringComponents(axisMainType, SINGLE_REFERRING).models[0];
            if (axisModel && this._axisIndex === axisModel.componentIndex) {
              seriesModels.push(seriesModel);
            }
          }
        }, this);
        return seriesModels;
      };
      AxisProxy2.prototype.getAxisModel = function() {
        return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
      };
      AxisProxy2.prototype.getMinMaxSpan = function() {
        return clone$2(this._minMaxSpan);
      };
      AxisProxy2.prototype.calculateDataWindow = function(opt) {
        var dataExtent = this._dataExtent;
        var axisModel = this.getAxisModel();
        var scale2 = axisModel.axis.scale;
        var rangePropMode = this._dataZoomModel.getRangePropMode();
        var percentExtent = [0, 100];
        var percentWindow = [];
        var valueWindow = [];
        var hasPropModeValue;
        each$1(["start", "end"], function(prop, idx) {
          var boundPercent = opt[prop];
          var boundValue = opt[prop + "Value"];
          if (rangePropMode[idx] === "percent") {
            boundPercent == null && (boundPercent = percentExtent[idx]);
            boundValue = scale2.parse(linearMap(boundPercent, percentExtent, dataExtent));
          } else {
            hasPropModeValue = true;
            boundValue = boundValue == null ? dataExtent[idx] : scale2.parse(boundValue);
            boundPercent = linearMap(boundValue, dataExtent, percentExtent);
          }
          valueWindow[idx] = boundValue == null || isNaN(boundValue) ? dataExtent[idx] : boundValue;
          percentWindow[idx] = boundPercent == null || isNaN(boundPercent) ? percentExtent[idx] : boundPercent;
        });
        asc(valueWindow);
        asc(percentWindow);
        var spans = this._minMaxSpan;
        hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);
        function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {
          var suffix = toValue ? "Span" : "ValueSpan";
          sliderMove(0, fromWindow, fromExtent, "all", spans["min" + suffix], spans["max" + suffix]);
          for (var i = 0; i < 2; i++) {
            toWindow[i] = linearMap(fromWindow[i], fromExtent, toExtent, true);
            toValue && (toWindow[i] = scale2.parse(toWindow[i]));
          }
        }
        return {
          valueWindow,
          percentWindow
        };
      };
      AxisProxy2.prototype.reset = function(dataZoomModel) {
        if (dataZoomModel !== this._dataZoomModel) {
          return;
        }
        var targetSeries = this.getTargetSeriesModels();
        this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries);
        this._updateMinMaxSpan();
        var dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);
        this._valueWindow = dataWindow.valueWindow;
        this._percentWindow = dataWindow.percentWindow;
        this._setAxisModel();
      };
      AxisProxy2.prototype.filterData = function(dataZoomModel, api) {
        if (dataZoomModel !== this._dataZoomModel) {
          return;
        }
        var axisDim = this._dimName;
        var seriesModels = this.getTargetSeriesModels();
        var filterMode = dataZoomModel.get("filterMode");
        var valueWindow = this._valueWindow;
        if (filterMode === "none") {
          return;
        }
        each$1(seriesModels, function(seriesModel) {
          var seriesData = seriesModel.getData();
          var dataDims = seriesData.mapDimensionsAll(axisDim);
          if (!dataDims.length) {
            return;
          }
          if (filterMode === "weakFilter") {
            var store_1 = seriesData.getStore();
            var dataDimIndices_1 = map$1(dataDims, function(dim) {
              return seriesData.getDimensionIndex(dim);
            }, seriesData);
            seriesData.filterSelf(function(dataIndex) {
              var leftOut;
              var rightOut;
              var hasValue;
              for (var i = 0; i < dataDims.length; i++) {
                var value = store_1.get(dataDimIndices_1[i], dataIndex);
                var thisHasValue = !isNaN(value);
                var thisLeftOut = value < valueWindow[0];
                var thisRightOut = value > valueWindow[1];
                if (thisHasValue && !thisLeftOut && !thisRightOut) {
                  return true;
                }
                thisHasValue && (hasValue = true);
                thisLeftOut && (leftOut = true);
                thisRightOut && (rightOut = true);
              }
              return hasValue && leftOut && rightOut;
            });
          } else {
            each$1(dataDims, function(dim) {
              if (filterMode === "empty") {
                seriesModel.setData(seriesData = seriesData.map(dim, function(value) {
                  return !isInWindow(value) ? NaN : value;
                }));
              } else {
                var range = {};
                range[dim] = valueWindow;
                seriesData.selectRange(range);
              }
            });
          }
          each$1(dataDims, function(dim) {
            seriesData.setApproximateExtent(valueWindow, dim);
          });
        });
        function isInWindow(value) {
          return value >= valueWindow[0] && value <= valueWindow[1];
        }
      };
      AxisProxy2.prototype._updateMinMaxSpan = function() {
        var minMaxSpan = this._minMaxSpan = {};
        var dataZoomModel = this._dataZoomModel;
        var dataExtent = this._dataExtent;
        each$1(["min", "max"], function(minMax) {
          var percentSpan = dataZoomModel.get(minMax + "Span");
          var valueSpan = dataZoomModel.get(minMax + "ValueSpan");
          valueSpan != null && (valueSpan = this.getAxisModel().axis.scale.parse(valueSpan));
          if (valueSpan != null) {
            percentSpan = linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);
          } else if (percentSpan != null) {
            valueSpan = linearMap(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];
          }
          minMaxSpan[minMax + "Span"] = percentSpan;
          minMaxSpan[minMax + "ValueSpan"] = valueSpan;
        }, this);
      };
      AxisProxy2.prototype._setAxisModel = function() {
        var axisModel = this.getAxisModel();
        var percentWindow = this._percentWindow;
        var valueWindow = this._valueWindow;
        if (!percentWindow) {
          return;
        }
        var precision = getPixelPrecision(valueWindow, [0, 500]);
        precision = Math.min(precision, 20);
        var rawExtentInfo = axisModel.axis.scale.rawExtentInfo;
        if (percentWindow[0] !== 0) {
          rawExtentInfo.setDeterminedMinMax("min", +valueWindow[0].toFixed(precision));
        }
        if (percentWindow[1] !== 100) {
          rawExtentInfo.setDeterminedMinMax("max", +valueWindow[1].toFixed(precision));
        }
        rawExtentInfo.freeze();
      };
      return AxisProxy2;
    }()
  );
  function calculateDataExtent(axisProxy, axisDim, seriesModels) {
    var dataExtent = [Infinity, -Infinity];
    each$1(seriesModels, function(seriesModel) {
      unionAxisExtentFromData(dataExtent, seriesModel.getData(), axisDim);
    });
    var axisModel = axisProxy.getAxisModel();
    var rawExtentResult = ensureScaleRawExtentInfo(axisModel.axis.scale, axisModel, dataExtent).calculate();
    return [rawExtentResult.min, rawExtentResult.max];
  }
  var dataZoomProcessor = {
    // `dataZoomProcessor` will only be performed in needed series. Consider if
    // there is a line series and a pie series, it is better not to update the
    // line series if only pie series is needed to be updated.
    getTargetSeries: function(ecModel) {
      function eachAxisModel(cb) {
        ecModel.eachComponent("dataZoom", function(dataZoomModel) {
          dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
            var axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
            cb(axisDim, axisIndex, axisModel, dataZoomModel);
          });
        });
      }
      eachAxisModel(function(axisDim, axisIndex, axisModel, dataZoomModel) {
        axisModel.__dzAxisProxy = null;
      });
      var proxyList = [];
      eachAxisModel(function(axisDim, axisIndex, axisModel, dataZoomModel) {
        if (!axisModel.__dzAxisProxy) {
          axisModel.__dzAxisProxy = new AxisProxy(axisDim, axisIndex, dataZoomModel, ecModel);
          proxyList.push(axisModel.__dzAxisProxy);
        }
      });
      var seriesModelMap = createHashMap();
      each$5(proxyList, function(axisProxy) {
        each$5(axisProxy.getTargetSeriesModels(), function(seriesModel) {
          seriesModelMap.set(seriesModel.uid, seriesModel);
        });
      });
      return seriesModelMap;
    },
    // Consider appendData, where filter should be performed. Because data process is
    // in block mode currently, it is not need to worry about that the overallProgress
    // execute every frame.
    overallReset: function(ecModel, api) {
      ecModel.eachComponent("dataZoom", function(dataZoomModel) {
        dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
          dataZoomModel.getAxisProxy(axisDim, axisIndex).reset(dataZoomModel);
        });
        dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
          dataZoomModel.getAxisProxy(axisDim, axisIndex).filterData(dataZoomModel, api);
        });
      });
      ecModel.eachComponent("dataZoom", function(dataZoomModel) {
        var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
        if (axisProxy) {
          var percentRange = axisProxy.getDataPercentWindow();
          var valueRange = axisProxy.getDataValueWindow();
          dataZoomModel.setCalculatedRange({
            start: percentRange[0],
            end: percentRange[1],
            startValue: valueRange[0],
            endValue: valueRange[1]
          });
        }
      });
    }
  };
  function installDataZoomAction(registers) {
    registers.registerAction("dataZoom", function(payload, ecModel) {
      var effectedModels = findEffectedDataZooms(ecModel, payload);
      each$5(effectedModels, function(dataZoomModel) {
        dataZoomModel.setRawRange({
          start: payload.start,
          end: payload.end,
          startValue: payload.startValue,
          endValue: payload.endValue
        });
      });
    });
  }
  var installed = false;
  function installCommon(registers) {
    if (installed) {
      return;
    }
    installed = true;
    registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, dataZoomProcessor);
    installDataZoomAction(registers);
    registers.registerSubTypeDefaulter("dataZoom", function() {
      return "slider";
    });
  }
  function makeBackground(rect, componentModel) {
    var padding = normalizeCssArray(componentModel.get("padding"));
    var style = componentModel.getItemStyle(["color", "opacity"]);
    style.fill = componentModel.get("backgroundColor");
    var bgRect = new Rect$1({
      shape: {
        x: rect.x - padding[3],
        y: rect.y - padding[0],
        width: rect.width + padding[1] + padding[3],
        height: rect.height + padding[0] + padding[2],
        r: componentModel.get("borderRadius")
      },
      style,
      silent: true,
      z2: -1
    });
    return bgRect;
  }
  var TooltipModel = (
    /** @class */
    function(_super) {
      __extends(TooltipModel2, _super);
      function TooltipModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = TooltipModel2.type;
        return _this;
      }
      TooltipModel2.type = "tooltip";
      TooltipModel2.dependencies = ["axisPointer"];
      TooltipModel2.defaultOption = {
        // zlevel: 0,
        z: 60,
        show: true,
        // tooltip main content
        showContent: true,
        // 'trigger' only works on coordinate system.
        // 'item' | 'axis' | 'none'
        trigger: "item",
        // 'click' | 'mousemove' | 'none'
        triggerOn: "mousemove|click",
        alwaysShowContent: false,
        renderMode: "auto",
        // whether restraint content inside viewRect.
        // If renderMode: 'richText', default true.
        // If renderMode: 'html', defaults to `false` (for backward compat).
        confine: null,
        showDelay: 0,
        hideDelay: 100,
        // Animation transition time, unit is second
        transitionDuration: 0.4,
        displayTransition: true,
        enterable: false,
        backgroundColor: tokens.color.neutral00,
        // box shadow
        shadowBlur: 10,
        shadowColor: "rgba(0, 0, 0, .2)",
        shadowOffsetX: 1,
        shadowOffsetY: 2,
        // tooltip border radius, unit is px, default is 4
        borderRadius: 4,
        // tooltip border width, unit is px, default is 0 (no border)
        borderWidth: 1,
        defaultBorderColor: tokens.color.border,
        // Tooltip inside padding, default is 5 for all direction
        // Array is allowed to set up, right, bottom, left, same with css
        // The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.
        padding: null,
        // Extra css text
        extraCssText: "",
        // axis indicator, trigger by axis
        axisPointer: {
          // default is line
          // legal values: 'line' | 'shadow' | 'cross'
          type: "line",
          // Valid when type is line, appoint tooltip line locate on which line. Optional
          // legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'
          // default is 'auto', chose the axis which type is category.
          // for multiply y axis, cartesian coord chose x axis, polar chose angle axis
          axis: "auto",
          animation: "auto",
          animationDurationUpdate: 200,
          animationEasingUpdate: "exponentialOut",
          crossStyle: {
            color: tokens.color.borderShade,
            width: 1,
            type: "dashed",
            // TODO formatter
            textStyle: {}
          }
          // lineStyle and shadowStyle should not be specified here,
          // otherwise it will always override those styles on option.axisPointer.
        },
        textStyle: {
          color: tokens.color.tertiary,
          fontSize: 14
        }
      };
      return TooltipModel2;
    }(ComponentModel)
  );
  function shouldTooltipConfine(tooltipModel) {
    var confineOption = tooltipModel.get("confine");
    return confineOption != null ? !!confineOption : tooltipModel.get("renderMode") === "richText";
  }
  function testStyle(styleProps) {
    if (!env.domSupported) {
      return;
    }
    var style = document.documentElement.style;
    for (var i = 0, len2 = styleProps.length; i < len2; i++) {
      if (styleProps[i] in style) {
        return styleProps[i];
      }
    }
  }
  var TRANSFORM_VENDOR = testStyle(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]);
  var TRANSITION_VENDOR = testStyle(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
  function toCSSVendorPrefix(styleVendor, styleProp) {
    if (!styleVendor) {
      return styleProp;
    }
    styleProp = toCamelCase(styleProp, true);
    var idx = styleVendor.indexOf(styleProp);
    styleVendor = idx === -1 ? styleProp : "-" + styleVendor.slice(0, idx) + "-" + styleProp;
    return styleVendor.toLowerCase();
  }
  function getComputedStyle(el, style) {
    var stl = el.currentStyle || document.defaultView && document.defaultView.getComputedStyle(el);
    return stl ? stl[style] : null;
  }
  var CSS_TRANSITION_VENDOR = toCSSVendorPrefix(TRANSITION_VENDOR, "transition");
  var CSS_TRANSFORM_VENDOR = toCSSVendorPrefix(TRANSFORM_VENDOR, "transform");
  var gCssText = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (env.transform3dSupported ? "will-change:transform;" : "");
  function mirrorPos(pos) {
    pos = pos === "left" ? "right" : pos === "right" ? "left" : pos === "top" ? "bottom" : "top";
    return pos;
  }
  function assembleArrow(tooltipModel, borderColor, arrowPosition) {
    if (!isString(arrowPosition) || arrowPosition === "inside") {
      return "";
    }
    var backgroundColor2 = tooltipModel.get("backgroundColor");
    var borderWidth = tooltipModel.get("borderWidth");
    borderColor = convertToColorString(borderColor);
    var arrowPos = mirrorPos(arrowPosition);
    var arrowSize = Math.max(Math.round(borderWidth) * 1.5, 6);
    var positionStyle = "";
    var transformStyle = CSS_TRANSFORM_VENDOR + ":";
    var rotateDeg;
    if (indexOf(["left", "right"], arrowPos) > -1) {
      positionStyle += "top:50%";
      transformStyle += "translateY(-50%) rotate(" + (rotateDeg = arrowPos === "left" ? -225 : -45) + "deg)";
    } else {
      positionStyle += "left:50%";
      transformStyle += "translateX(-50%) rotate(" + (rotateDeg = arrowPos === "top" ? 225 : 45) + "deg)";
    }
    var rotateRadian = rotateDeg * Math.PI / 180;
    var arrowWH = arrowSize + borderWidth;
    var rotatedWH = arrowWH * Math.abs(Math.cos(rotateRadian)) + arrowWH * Math.abs(Math.sin(rotateRadian));
    var arrowOffset = Math.round(((rotatedWH - Math.SQRT2 * borderWidth) / 2 + Math.SQRT2 * borderWidth - (rotatedWH - arrowWH) / 2) * 100) / 100;
    positionStyle += ";" + arrowPos + ":-" + arrowOffset + "px";
    var borderStyle = borderColor + " solid " + borderWidth + "px;";
    var styleCss = ["position:absolute;width:" + arrowSize + "px;height:" + arrowSize + "px;z-index:-1;", positionStyle + ";" + transformStyle + ";", "border-bottom:" + borderStyle, "border-right:" + borderStyle, "background-color:" + backgroundColor2 + ";"];
    return '<div style="' + styleCss.join("") + '"></div>';
  }
  function assembleTransition(duration, onlyFadeTransition, enableDisplayTransition) {
    var transitionCurve = "cubic-bezier(0.23,1,0.32,1)";
    var transitionOption = "";
    var transitionText = "";
    if (enableDisplayTransition) {
      transitionOption = " " + duration / 2 + "s " + transitionCurve;
      transitionText = "opacity" + transitionOption + ",visibility" + transitionOption;
    }
    if (!onlyFadeTransition) {
      transitionOption = " " + duration + "s " + transitionCurve;
      transitionText += (transitionText.length ? "," : "") + (env.transformSupported ? "" + CSS_TRANSFORM_VENDOR + transitionOption : ",left" + transitionOption + ",top" + transitionOption);
    }
    return CSS_TRANSITION_VENDOR + ":" + transitionText;
  }
  function assembleTransform(x, y, toString2) {
    var x0 = x.toFixed(0) + "px";
    var y0 = y.toFixed(0) + "px";
    if (!env.transformSupported) {
      return toString2 ? "top:" + y0 + ";left:" + x0 + ";" : [["top", y0], ["left", x0]];
    }
    var is3d = env.transform3dSupported;
    var translate2 = "translate" + (is3d ? "3d" : "") + "(" + x0 + "," + y0 + (is3d ? ",0" : "") + ")";
    return toString2 ? "top:0;left:0;" + CSS_TRANSFORM_VENDOR + ":" + translate2 + ";" : [["top", 0], ["left", 0], [TRANSFORM_VENDOR, translate2]];
  }
  function assembleFont(textStyleModel) {
    var cssText = [];
    var fontSize = textStyleModel.get("fontSize");
    var color2 = textStyleModel.getTextColor();
    color2 && cssText.push("color:" + color2);
    cssText.push("font:" + textStyleModel.getFont());
    var lineHeight = retrieve2(textStyleModel.get("lineHeight"), Math.round(fontSize * 3 / 2));
    fontSize && cssText.push("line-height:" + lineHeight + "px");
    var shadowColor = textStyleModel.get("textShadowColor");
    var shadowBlur = textStyleModel.get("textShadowBlur") || 0;
    var shadowOffsetX = textStyleModel.get("textShadowOffsetX") || 0;
    var shadowOffsetY = textStyleModel.get("textShadowOffsetY") || 0;
    shadowColor && shadowBlur && cssText.push("text-shadow:" + shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor);
    each$5(["decoration", "align"], function(name) {
      var val = textStyleModel.get(name);
      val && cssText.push("text-" + name + ":" + val);
    });
    return cssText.join(";");
  }
  function assembleCssText(tooltipModel, enableTransition, onlyFadeTransition, enableDisplayTransition) {
    var cssText = [];
    var transitionDuration = tooltipModel.get("transitionDuration");
    var backgroundColor2 = tooltipModel.get("backgroundColor");
    var shadowBlur = tooltipModel.get("shadowBlur");
    var shadowColor = tooltipModel.get("shadowColor");
    var shadowOffsetX = tooltipModel.get("shadowOffsetX");
    var shadowOffsetY = tooltipModel.get("shadowOffsetY");
    var textStyleModel = tooltipModel.getModel("textStyle");
    var padding = getPaddingFromTooltipModel(tooltipModel, "html");
    var boxShadow = shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor;
    cssText.push("box-shadow:" + boxShadow);
    enableTransition && transitionDuration > 0 && cssText.push(assembleTransition(transitionDuration, onlyFadeTransition, enableDisplayTransition));
    if (backgroundColor2) {
      cssText.push("background-color:" + backgroundColor2);
    }
    each$5(["width", "color", "radius"], function(name) {
      var borderName = "border-" + name;
      var camelCase = toCamelCase(borderName);
      var val = tooltipModel.get(camelCase);
      val != null && cssText.push(borderName + ":" + val + (name === "color" ? "" : "px"));
    });
    cssText.push(assembleFont(textStyleModel));
    if (padding != null) {
      cssText.push("padding:" + normalizeCssArray(padding).join("px ") + "px");
    }
    return cssText.join(";") + ";";
  }
  function makeStyleCoord$1(out2, zr, container, zrX, zrY) {
    var zrPainter = zr && zr.painter;
    if (container) {
      var zrViewportRoot = zrPainter && zrPainter.getViewportRoot();
      if (zrViewportRoot) {
        transformLocalCoord(out2, zrViewportRoot, container, zrX, zrY);
      }
    } else {
      out2[0] = zrX;
      out2[1] = zrY;
      var viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset();
      if (viewportRootOffset) {
        out2[0] += viewportRootOffset.offsetLeft;
        out2[1] += viewportRootOffset.offsetTop;
      }
    }
    out2[2] = out2[0] / zr.getWidth();
    out2[3] = out2[1] / zr.getHeight();
  }
  var TooltipHTMLContent = (
    /** @class */
    function() {
      function TooltipHTMLContent2(api, opt) {
        this._show = false;
        this._styleCoord = [0, 0, 0, 0];
        this._enterable = true;
        this._alwaysShowContent = false;
        this._firstShow = true;
        this._longHide = true;
        if (env.wxa) {
          return null;
        }
        var el = document.createElement("div");
        el.domBelongToZr = true;
        this.el = el;
        var zr = this._zr = api.getZr();
        var appendTo = opt.appendTo;
        var container = appendTo && (isString(appendTo) ? document.querySelector(appendTo) : isDom(appendTo) ? appendTo : isFunction(appendTo) && appendTo(api.getDom()));
        makeStyleCoord$1(this._styleCoord, zr, container, api.getWidth() / 2, api.getHeight() / 2);
        (container || api.getDom()).appendChild(el);
        this._api = api;
        this._container = container;
        var self2 = this;
        el.onmouseenter = function() {
          if (self2._enterable) {
            clearTimeout(self2._hideTimeout);
            self2._show = true;
          }
          self2._inContent = true;
        };
        el.onmousemove = function(e2) {
          e2 = e2 || window.event;
          if (!self2._enterable) {
            var handler = zr.handler;
            var zrViewportRoot = zr.painter.getViewportRoot();
            normalizeEvent(zrViewportRoot, e2, true);
            handler.dispatch("mousemove", e2);
          }
        };
        el.onmouseleave = function() {
          self2._inContent = false;
          if (self2._enterable) {
            if (self2._show) {
              self2.hideLater(self2._hideDelay);
            }
          }
        };
      }
      TooltipHTMLContent2.prototype.update = function(tooltipModel) {
        if (!this._container) {
          var container = this._api.getDom();
          var position = getComputedStyle(container, "position");
          var domStyle = container.style;
          if (domStyle.position !== "absolute" && position !== "absolute") {
            domStyle.position = "relative";
          }
        }
        var alwaysShowContent = tooltipModel.get("alwaysShowContent");
        alwaysShowContent && this._moveIfResized();
        this._alwaysShowContent = alwaysShowContent;
        this._enableDisplayTransition = tooltipModel.get("displayTransition") && tooltipModel.get("transitionDuration") > 0;
        this.el.className = tooltipModel.get("className") || "";
      };
      TooltipHTMLContent2.prototype.show = function(tooltipModel, nearPointColor) {
        clearTimeout(this._hideTimeout);
        clearTimeout(this._longHideTimeout);
        var el = this.el;
        var style = el.style;
        var styleCoord = this._styleCoord;
        if (!el.innerHTML) {
          style.display = "none";
        } else {
          style.cssText = gCssText + assembleCssText(tooltipModel, !this._firstShow, this._longHide, this._enableDisplayTransition) + assembleTransform(styleCoord[0], styleCoord[1], true) + ("border-color:" + convertToColorString(nearPointColor) + ";") + (tooltipModel.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none"));
        }
        this._show = true;
        this._firstShow = false;
        this._longHide = false;
      };
      TooltipHTMLContent2.prototype.setContent = function(content, markers, tooltipModel, borderColor, arrowPosition) {
        var el = this.el;
        if (content == null) {
          el.innerHTML = "";
          return;
        }
        var arrow = "";
        if (isString(arrowPosition) && tooltipModel.get("trigger") === "item" && !shouldTooltipConfine(tooltipModel)) {
          arrow = assembleArrow(tooltipModel, borderColor, arrowPosition);
        }
        if (isString(content)) {
          el.innerHTML = content + arrow;
        } else if (content) {
          el.innerHTML = "";
          if (!isArray(content)) {
            content = [content];
          }
          for (var i = 0; i < content.length; i++) {
            if (isDom(content[i]) && content[i].parentNode !== el) {
              el.appendChild(content[i]);
            }
          }
          if (arrow && el.childNodes.length) {
            var arrowEl = document.createElement("div");
            arrowEl.innerHTML = arrow;
            el.appendChild(arrowEl);
          }
        }
      };
      TooltipHTMLContent2.prototype.setEnterable = function(enterable) {
        this._enterable = enterable;
      };
      TooltipHTMLContent2.prototype.getSize = function() {
        var el = this.el;
        return el ? [el.offsetWidth, el.offsetHeight] : [0, 0];
      };
      TooltipHTMLContent2.prototype.moveTo = function(zrX, zrY) {
        if (!this.el) {
          return;
        }
        var styleCoord = this._styleCoord;
        makeStyleCoord$1(styleCoord, this._zr, this._container, zrX, zrY);
        if (styleCoord[0] != null && styleCoord[1] != null) {
          var style_1 = this.el.style;
          var transforms = assembleTransform(styleCoord[0], styleCoord[1]);
          each$5(transforms, function(transform) {
            style_1[transform[0]] = transform[1];
          });
        }
      };
      TooltipHTMLContent2.prototype._moveIfResized = function() {
        var ratioX = this._styleCoord[2];
        var ratioY = this._styleCoord[3];
        this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
      };
      TooltipHTMLContent2.prototype.hide = function() {
        var _this = this;
        var style = this.el.style;
        if (this._enableDisplayTransition) {
          style.visibility = "hidden";
          style.opacity = "0";
        } else {
          style.display = "none";
        }
        env.transform3dSupported && (style.willChange = "");
        this._show = false;
        this._longHideTimeout = setTimeout(function() {
          return _this._longHide = true;
        }, 500);
      };
      TooltipHTMLContent2.prototype.hideLater = function(time) {
        if (this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent) {
          if (time) {
            this._hideDelay = time;
            this._show = false;
            this._hideTimeout = setTimeout(bind$1(this.hide, this), time);
          } else {
            this.hide();
          }
        }
      };
      TooltipHTMLContent2.prototype.isShow = function() {
        return this._show;
      };
      TooltipHTMLContent2.prototype.dispose = function() {
        clearTimeout(this._hideTimeout);
        clearTimeout(this._longHideTimeout);
        var zr = this._zr;
        transformLocalCoordClear(zr && zr.painter && zr.painter.getViewportRoot(), this._container);
        var el = this.el;
        if (el) {
          el.onmouseenter = el.onmousemove = el.onmouseleave = null;
          var parentNode = el.parentNode;
          parentNode && parentNode.removeChild(el);
        }
        this.el = this._container = null;
      };
      return TooltipHTMLContent2;
    }()
  );
  var define_process_env_default$2 = {};
  var TooltipRichContent = (
    /** @class */
    function() {
      function TooltipRichContent2(api) {
        this._show = false;
        this._styleCoord = [0, 0, 0, 0];
        this._alwaysShowContent = false;
        this._enterable = true;
        this._zr = api.getZr();
        makeStyleCoord(this._styleCoord, this._zr, api.getWidth() / 2, api.getHeight() / 2);
      }
      TooltipRichContent2.prototype.update = function(tooltipModel) {
        var alwaysShowContent = tooltipModel.get("alwaysShowContent");
        alwaysShowContent && this._moveIfResized();
        this._alwaysShowContent = alwaysShowContent;
      };
      TooltipRichContent2.prototype.show = function() {
        if (this._hideTimeout) {
          clearTimeout(this._hideTimeout);
        }
        this.el.show();
        this._show = true;
      };
      TooltipRichContent2.prototype.setContent = function(content, markupStyleCreator, tooltipModel, borderColor, arrowPosition) {
        var _this = this;
        if (isObject$2(content)) {
          throwError(define_process_env_default$2.NODE_ENV !== "production" ? "Passing DOM nodes as content is not supported in richText tooltip!" : "");
        }
        if (this.el) {
          this._zr.remove(this.el);
        }
        var textStyleModel = tooltipModel.getModel("textStyle");
        this.el = new ZRText({
          style: {
            rich: markupStyleCreator.richTextStyles,
            text: content,
            lineHeight: 22,
            borderWidth: 1,
            borderColor,
            textShadowColor: textStyleModel.get("textShadowColor"),
            fill: tooltipModel.get(["textStyle", "color"]),
            padding: getPaddingFromTooltipModel(tooltipModel, "richText"),
            verticalAlign: "top",
            align: "left"
          },
          z: tooltipModel.get("z")
        });
        each$5(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(propName) {
          _this.el.style[propName] = tooltipModel.get(propName);
        });
        each$5(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(propName) {
          _this.el.style[propName] = textStyleModel.get(propName) || 0;
        });
        this._zr.add(this.el);
        var self2 = this;
        this.el.on("mouseover", function() {
          if (self2._enterable) {
            clearTimeout(self2._hideTimeout);
            self2._show = true;
          }
          self2._inContent = true;
        });
        this.el.on("mouseout", function() {
          if (self2._enterable) {
            if (self2._show) {
              self2.hideLater(self2._hideDelay);
            }
          }
          self2._inContent = false;
        });
      };
      TooltipRichContent2.prototype.setEnterable = function(enterable) {
        this._enterable = enterable;
      };
      TooltipRichContent2.prototype.getSize = function() {
        var el = this.el;
        var bounding = this.el.getBoundingRect();
        var shadowOuterSize = calcShadowOuterSize(el.style);
        return [bounding.width + shadowOuterSize.left + shadowOuterSize.right, bounding.height + shadowOuterSize.top + shadowOuterSize.bottom];
      };
      TooltipRichContent2.prototype.moveTo = function(x, y) {
        var el = this.el;
        if (el) {
          var styleCoord = this._styleCoord;
          makeStyleCoord(styleCoord, this._zr, x, y);
          x = styleCoord[0];
          y = styleCoord[1];
          var style = el.style;
          var borderWidth = mathMaxWith0(style.borderWidth || 0);
          var shadowOuterSize = calcShadowOuterSize(style);
          el.x = x + borderWidth + shadowOuterSize.left;
          el.y = y + borderWidth + shadowOuterSize.top;
          el.markRedraw();
        }
      };
      TooltipRichContent2.prototype._moveIfResized = function() {
        var ratioX = this._styleCoord[2];
        var ratioY = this._styleCoord[3];
        this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
      };
      TooltipRichContent2.prototype.hide = function() {
        if (this.el) {
          this.el.hide();
        }
        this._show = false;
      };
      TooltipRichContent2.prototype.hideLater = function(time) {
        if (this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent) {
          if (time) {
            this._hideDelay = time;
            this._show = false;
            this._hideTimeout = setTimeout(bind$1(this.hide, this), time);
          } else {
            this.hide();
          }
        }
      };
      TooltipRichContent2.prototype.isShow = function() {
        return this._show;
      };
      TooltipRichContent2.prototype.dispose = function() {
        this._zr.remove(this.el);
      };
      return TooltipRichContent2;
    }()
  );
  function mathMaxWith0(val) {
    return Math.max(0, val);
  }
  function calcShadowOuterSize(style) {
    var shadowBlur = mathMaxWith0(style.shadowBlur || 0);
    var shadowOffsetX = mathMaxWith0(style.shadowOffsetX || 0);
    var shadowOffsetY = mathMaxWith0(style.shadowOffsetY || 0);
    return {
      left: mathMaxWith0(shadowBlur - shadowOffsetX),
      right: mathMaxWith0(shadowBlur + shadowOffsetX),
      top: mathMaxWith0(shadowBlur - shadowOffsetY),
      bottom: mathMaxWith0(shadowBlur + shadowOffsetY)
    };
  }
  function makeStyleCoord(out2, zr, zrX, zrY) {
    out2[0] = zrX;
    out2[1] = zrY;
    out2[2] = out2[0] / zr.getWidth();
    out2[3] = out2[1] / zr.getHeight();
  }
  var proxyRect = new Rect$1({
    shape: {
      x: -1,
      y: -1,
      width: 2,
      height: 2
    }
  });
  var TooltipView = (
    /** @class */
    function(_super) {
      __extends(TooltipView2, _super);
      function TooltipView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = TooltipView2.type;
        return _this;
      }
      TooltipView2.prototype.init = function(ecModel, api) {
        if (env.node || !api.getDom()) {
          return;
        }
        var tooltipModel = ecModel.getComponent("tooltip");
        var renderMode = this._renderMode = getTooltipRenderMode(tooltipModel.get("renderMode"));
        this._tooltipContent = renderMode === "richText" ? new TooltipRichContent(api) : new TooltipHTMLContent(api, {
          appendTo: tooltipModel.get("appendToBody", true) ? "body" : tooltipModel.get("appendTo", true)
        });
      };
      TooltipView2.prototype.render = function(tooltipModel, ecModel, api) {
        if (env.node || !api.getDom()) {
          return;
        }
        this.group.removeAll();
        this._tooltipModel = tooltipModel;
        this._ecModel = ecModel;
        this._api = api;
        var tooltipContent = this._tooltipContent;
        tooltipContent.update(tooltipModel);
        tooltipContent.setEnterable(tooltipModel.get("enterable"));
        this._initGlobalListener();
        this._keepShow();
        if (this._renderMode !== "richText" && tooltipModel.get("transitionDuration")) {
          createOrUpdate(this, "_updatePosition", 50, "fixRate");
        } else {
          clear(this, "_updatePosition");
        }
      };
      TooltipView2.prototype._initGlobalListener = function() {
        var tooltipModel = this._tooltipModel;
        var triggerOn = tooltipModel.get("triggerOn");
        register$1("itemTooltip", this._api, bind$1(function(currTrigger, e2, dispatchAction2) {
          if (triggerOn !== "none") {
            if (triggerOn.indexOf(currTrigger) >= 0) {
              this._tryShow(e2, dispatchAction2);
            } else if (currTrigger === "leave") {
              this._hide(dispatchAction2);
            }
          }
        }, this));
      };
      TooltipView2.prototype._keepShow = function() {
        var tooltipModel = this._tooltipModel;
        var ecModel = this._ecModel;
        var api = this._api;
        var triggerOn = tooltipModel.get("triggerOn");
        if (this._lastX != null && this._lastY != null && triggerOn !== "none" && triggerOn !== "click") {
          var self_1 = this;
          clearTimeout(this._refreshUpdateTimeout);
          this._refreshUpdateTimeout = setTimeout(function() {
            !api.isDisposed() && self_1.manuallyShowTip(tooltipModel, ecModel, api, {
              x: self_1._lastX,
              y: self_1._lastY,
              dataByCoordSys: self_1._lastDataByCoordSys
            });
          });
        }
      };
      TooltipView2.prototype.manuallyShowTip = function(tooltipModel, ecModel, api, payload) {
        if (payload.from === this.uid || env.node || !api.getDom()) {
          return;
        }
        var dispatchAction2 = makeDispatchAction(payload, api);
        this._ticket = "";
        var dataByCoordSys = payload.dataByCoordSys;
        var cmptRef = findComponentReference(payload, ecModel, api);
        if (cmptRef) {
          var rect = cmptRef.el.getBoundingRect().clone();
          rect.applyTransform(cmptRef.el.transform);
          this._tryShow({
            offsetX: rect.x + rect.width / 2,
            offsetY: rect.y + rect.height / 2,
            target: cmptRef.el,
            position: payload.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, dispatchAction2);
        } else if (payload.tooltip && payload.x != null && payload.y != null) {
          var el = proxyRect;
          el.x = payload.x;
          el.y = payload.y;
          el.update();
          getECData(el).tooltipConfig = {
            name: null,
            option: payload.tooltip
          };
          this._tryShow({
            offsetX: payload.x,
            offsetY: payload.y,
            target: el
          }, dispatchAction2);
        } else if (dataByCoordSys) {
          this._tryShow({
            offsetX: payload.x,
            offsetY: payload.y,
            position: payload.position,
            dataByCoordSys,
            tooltipOption: payload.tooltipOption
          }, dispatchAction2);
        } else if (payload.seriesIndex != null) {
          if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {
            return;
          }
          var pointInfo = findPointFromSeries(payload, ecModel);
          var cx = pointInfo.point[0];
          var cy = pointInfo.point[1];
          if (cx != null && cy != null) {
            this._tryShow({
              offsetX: cx,
              offsetY: cy,
              target: pointInfo.el,
              position: payload.position,
              // When manully trigger, the mouse is not on the el, so we'd better to
              // position tooltip on the bottom of the el and display arrow is possible.
              positionDefault: "bottom"
            }, dispatchAction2);
          }
        } else if (payload.x != null && payload.y != null) {
          api.dispatchAction({
            type: "updateAxisPointer",
            x: payload.x,
            y: payload.y
          });
          this._tryShow({
            offsetX: payload.x,
            offsetY: payload.y,
            position: payload.position,
            target: api.getZr().findHover(payload.x, payload.y).target
          }, dispatchAction2);
        }
      };
      TooltipView2.prototype.manuallyHideTip = function(tooltipModel, ecModel, api, payload) {
        var tooltipContent = this._tooltipContent;
        if (this._tooltipModel) {
          tooltipContent.hideLater(this._tooltipModel.get("hideDelay"));
        }
        this._lastX = this._lastY = this._lastDataByCoordSys = null;
        if (payload.from !== this.uid) {
          this._hide(makeDispatchAction(payload, api));
        }
      };
      TooltipView2.prototype._manuallyAxisShowTip = function(tooltipModel, ecModel, api, payload) {
        var seriesIndex = payload.seriesIndex;
        var dataIndex = payload.dataIndex;
        var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
        if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
          return;
        }
        var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
        if (!seriesModel) {
          return;
        }
        var data = seriesModel.getData();
        var tooltipCascadedModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model], this._tooltipModel);
        if (tooltipCascadedModel.get("trigger") !== "axis") {
          return;
        }
        api.dispatchAction({
          type: "updateAxisPointer",
          seriesIndex,
          dataIndex,
          position: payload.position
        });
        return true;
      };
      TooltipView2.prototype._tryShow = function(e2, dispatchAction2) {
        var el = e2.target;
        var tooltipModel = this._tooltipModel;
        if (!tooltipModel) {
          return;
        }
        this._lastX = e2.offsetX;
        this._lastY = e2.offsetY;
        var dataByCoordSys = e2.dataByCoordSys;
        if (dataByCoordSys && dataByCoordSys.length) {
          this._showAxisTooltip(dataByCoordSys, e2);
        } else if (el) {
          var ecData = getECData(el);
          if (ecData.ssrType === "legend") {
            return;
          }
          this._lastDataByCoordSys = null;
          var seriesDispatcher_1;
          var cmptDispatcher_1;
          findEventDispatcher(el, function(target) {
            if (target.tooltipDisabled) {
              seriesDispatcher_1 = cmptDispatcher_1 = null;
              return true;
            }
            if (seriesDispatcher_1 || cmptDispatcher_1) {
              return;
            }
            if (getECData(target).dataIndex != null) {
              seriesDispatcher_1 = target;
            } else if (getECData(target).tooltipConfig != null) {
              cmptDispatcher_1 = target;
            }
          }, true);
          if (seriesDispatcher_1) {
            this._showSeriesItemTooltip(e2, seriesDispatcher_1, dispatchAction2);
          } else if (cmptDispatcher_1) {
            this._showComponentItemTooltip(e2, cmptDispatcher_1, dispatchAction2);
          } else {
            this._hide(dispatchAction2);
          }
        } else {
          this._lastDataByCoordSys = null;
          this._hide(dispatchAction2);
        }
      };
      TooltipView2.prototype._showOrMove = function(tooltipModel, cb) {
        var delay = tooltipModel.get("showDelay");
        cb = bind$1(cb, this);
        clearTimeout(this._showTimout);
        delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
      };
      TooltipView2.prototype._showAxisTooltip = function(dataByCoordSys, e2) {
        var ecModel = this._ecModel;
        var globalTooltipModel = this._tooltipModel;
        var point = [e2.offsetX, e2.offsetY];
        var singleTooltipModel = buildTooltipModel([e2.tooltipOption], globalTooltipModel);
        var renderMode = this._renderMode;
        var cbParamsList = [];
        var articleMarkup = createTooltipMarkup("section", {
          blocks: [],
          noHeader: true
        });
        var markupTextArrLegacy = [];
        var markupStyleCreator = new TooltipMarkupStyleCreator();
        each$5(dataByCoordSys, function(itemCoordSys) {
          each$5(itemCoordSys.dataByAxis, function(axisItem) {
            var axisModel = ecModel.getComponent(axisItem.axisDim + "Axis", axisItem.axisIndex);
            var axisValue = axisItem.value;
            if (!axisModel || axisValue == null) {
              return;
            }
            var axisValueLabel = getValueLabel(axisValue, axisModel.axis, ecModel, axisItem.seriesDataIndices, axisItem.valueLabelOpt);
            var axisSectionMarkup = createTooltipMarkup("section", {
              header: axisValueLabel,
              noHeader: !trim(axisValueLabel),
              sortBlocks: true,
              blocks: []
            });
            articleMarkup.blocks.push(axisSectionMarkup);
            each$5(axisItem.seriesDataIndices, function(idxItem) {
              var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
              var dataIndex = idxItem.dataIndexInside;
              var cbParams = series.getDataParams(dataIndex);
              if (cbParams.dataIndex < 0) {
                return;
              }
              cbParams.axisDim = axisItem.axisDim;
              cbParams.axisIndex = axisItem.axisIndex;
              cbParams.axisType = axisItem.axisType;
              cbParams.axisId = axisItem.axisId;
              cbParams.axisValue = getAxisRawValue(axisModel.axis, {
                value: axisValue
              });
              cbParams.axisValueLabel = axisValueLabel;
              cbParams.marker = markupStyleCreator.makeTooltipMarker("item", convertToColorString(cbParams.color), renderMode);
              var seriesTooltipResult = normalizeTooltipFormatResult(series.formatTooltip(dataIndex, true, null));
              var frag = seriesTooltipResult.frag;
              if (frag) {
                var valueFormatter = buildTooltipModel([series], globalTooltipModel).get("valueFormatter");
                axisSectionMarkup.blocks.push(valueFormatter ? extend({
                  valueFormatter
                }, frag) : frag);
              }
              if (seriesTooltipResult.text) {
                markupTextArrLegacy.push(seriesTooltipResult.text);
              }
              cbParamsList.push(cbParams);
            });
          });
        });
        articleMarkup.blocks.reverse();
        markupTextArrLegacy.reverse();
        var positionExpr = e2.position;
        var orderMode = singleTooltipModel.get("order");
        var builtMarkupText = buildTooltipMarkup(articleMarkup, markupStyleCreator, renderMode, orderMode, ecModel.get("useUTC"), singleTooltipModel.get("textStyle"));
        builtMarkupText && markupTextArrLegacy.unshift(builtMarkupText);
        var blockBreak = renderMode === "richText" ? "\n\n" : "<br/>";
        var allMarkupText = markupTextArrLegacy.join(blockBreak);
        this._showOrMove(singleTooltipModel, function() {
          if (this._updateContentNotChangedOnAxis(dataByCoordSys, cbParamsList)) {
            this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, cbParamsList);
          } else {
            this._showTooltipContent(singleTooltipModel, allMarkupText, cbParamsList, Math.random() + "", point[0], point[1], positionExpr, null, markupStyleCreator);
          }
        });
      };
      TooltipView2.prototype._showSeriesItemTooltip = function(e2, dispatcher, dispatchAction2) {
        var ecModel = this._ecModel;
        var ecData = getECData(dispatcher);
        var seriesIndex = ecData.seriesIndex;
        var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
        var dataModel = ecData.dataModel || seriesModel;
        var dataIndex = ecData.dataIndex;
        var dataType = ecData.dataType;
        var data = dataModel.getData(dataType);
        var renderMode = this._renderMode;
        var positionDefault = e2.positionDefault;
        var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model], this._tooltipModel, positionDefault ? {
          position: positionDefault
        } : null);
        var tooltipTrigger = tooltipModel.get("trigger");
        if (tooltipTrigger != null && tooltipTrigger !== "item") {
          return;
        }
        var params = dataModel.getDataParams(dataIndex, dataType);
        var markupStyleCreator = new TooltipMarkupStyleCreator();
        params.marker = markupStyleCreator.makeTooltipMarker("item", convertToColorString(params.color), renderMode);
        var seriesTooltipResult = normalizeTooltipFormatResult(dataModel.formatTooltip(dataIndex, false, dataType));
        var orderMode = tooltipModel.get("order");
        var valueFormatter = tooltipModel.get("valueFormatter");
        var frag = seriesTooltipResult.frag;
        var markupText = frag ? buildTooltipMarkup(valueFormatter ? extend({
          valueFormatter
        }, frag) : frag, markupStyleCreator, renderMode, orderMode, ecModel.get("useUTC"), tooltipModel.get("textStyle")) : seriesTooltipResult.text;
        var asyncTicket = "item_" + dataModel.name + "_" + dataIndex;
        this._showOrMove(tooltipModel, function() {
          this._showTooltipContent(tooltipModel, markupText, params, asyncTicket, e2.offsetX, e2.offsetY, e2.position, e2.target, markupStyleCreator);
        });
        dispatchAction2({
          type: "showTip",
          dataIndexInside: dataIndex,
          dataIndex: data.getRawIndex(dataIndex),
          seriesIndex,
          from: this.uid
        });
      };
      TooltipView2.prototype._showComponentItemTooltip = function(e2, el, dispatchAction2) {
        var isHTMLRenderMode = this._renderMode === "html";
        var ecData = getECData(el);
        var tooltipConfig = ecData.tooltipConfig;
        var tooltipOpt = tooltipConfig.option || {};
        var encodeHTMLContent = tooltipOpt.encodeHTMLContent;
        if (isString(tooltipOpt)) {
          var content = tooltipOpt;
          tooltipOpt = {
            content,
            // Fixed formatter
            formatter: content
          };
          encodeHTMLContent = true;
        }
        if (encodeHTMLContent && isHTMLRenderMode && tooltipOpt.content) {
          tooltipOpt = clone$2(tooltipOpt);
          tooltipOpt.content = encodeHTML(tooltipOpt.content);
        }
        var tooltipModelCascade = [tooltipOpt];
        var cmpt = this._ecModel.getComponent(ecData.componentMainType, ecData.componentIndex);
        if (cmpt) {
          tooltipModelCascade.push(cmpt);
        }
        tooltipModelCascade.push({
          formatter: tooltipOpt.content
        });
        var positionDefault = e2.positionDefault;
        var subTooltipModel = buildTooltipModel(tooltipModelCascade, this._tooltipModel, positionDefault ? {
          position: positionDefault
        } : null);
        var defaultHtml = subTooltipModel.get("content");
        var asyncTicket = Math.random() + "";
        var markupStyleCreator = new TooltipMarkupStyleCreator();
        this._showOrMove(subTooltipModel, function() {
          var formatterParams = clone$2(subTooltipModel.get("formatterParams") || {});
          this._showTooltipContent(subTooltipModel, defaultHtml, formatterParams, asyncTicket, e2.offsetX, e2.offsetY, e2.position, el, markupStyleCreator);
        });
        dispatchAction2({
          type: "showTip",
          from: this.uid
        });
      };
      TooltipView2.prototype._showTooltipContent = function(tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el, markupStyleCreator) {
        this._ticket = "";
        if (!tooltipModel.get("showContent") || !tooltipModel.get("show")) {
          return;
        }
        var tooltipContent = this._tooltipContent;
        tooltipContent.setEnterable(tooltipModel.get("enterable"));
        var formatter = tooltipModel.get("formatter");
        positionExpr = positionExpr || tooltipModel.get("position");
        var html = defaultHtml;
        var nearPoint = this._getNearestPoint([x, y], params, tooltipModel.get("trigger"), tooltipModel.get("borderColor"), tooltipModel.get("defaultBorderColor", true));
        var nearPointColor = nearPoint.color;
        if (formatter) {
          if (isString(formatter)) {
            var useUTC = tooltipModel.ecModel.get("useUTC");
            var params0 = isArray(params) ? params[0] : params;
            var isTimeAxis = params0 && params0.axisType && params0.axisType.indexOf("time") >= 0;
            html = formatter;
            if (isTimeAxis) {
              html = format(params0.axisValue, html, useUTC);
            }
            html = formatTpl(html, params, true);
          } else if (isFunction(formatter)) {
            var callback = bind$1(function(cbTicket, html2) {
              if (cbTicket === this._ticket) {
                tooltipContent.setContent(html2, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
                this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
              }
            }, this);
            this._ticket = asyncTicket;
            html = formatter(params, asyncTicket, callback);
          } else {
            html = formatter;
          }
        }
        tooltipContent.setContent(html, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
        tooltipContent.show(tooltipModel, nearPointColor);
        this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
      };
      TooltipView2.prototype._getNearestPoint = function(point, tooltipDataParams, trigger2, borderColor, defaultBorderColor) {
        if (trigger2 === "axis" || isArray(tooltipDataParams)) {
          return {
            color: borderColor || defaultBorderColor
          };
        }
        if (!isArray(tooltipDataParams)) {
          return {
            color: borderColor || tooltipDataParams.color || tooltipDataParams.borderColor
          };
        }
      };
      TooltipView2.prototype._updatePosition = function(tooltipModel, positionExpr, x, y, content, params, el) {
        var viewWidth = this._api.getWidth();
        var viewHeight = this._api.getHeight();
        positionExpr = positionExpr || tooltipModel.get("position");
        var contentSize = content.getSize();
        var align = tooltipModel.get("align");
        var vAlign = tooltipModel.get("verticalAlign");
        var rect = el && el.getBoundingRect().clone();
        el && rect.applyTransform(el.transform);
        if (isFunction(positionExpr)) {
          positionExpr = positionExpr([x, y], params, content.el, rect, {
            viewSize: [viewWidth, viewHeight],
            contentSize: contentSize.slice()
          });
        }
        if (isArray(positionExpr)) {
          x = parsePercent(positionExpr[0], viewWidth);
          y = parsePercent(positionExpr[1], viewHeight);
        } else if (isObject$2(positionExpr)) {
          var boxLayoutPosition = positionExpr;
          boxLayoutPosition.width = contentSize[0];
          boxLayoutPosition.height = contentSize[1];
          var layoutRect = getLayoutRect(boxLayoutPosition, {
            width: viewWidth,
            height: viewHeight
          });
          x = layoutRect.x;
          y = layoutRect.y;
          align = null;
          vAlign = null;
        } else if (isString(positionExpr) && el) {
          var pos = calcTooltipPosition(positionExpr, rect, contentSize, tooltipModel.get("borderWidth"));
          x = pos[0];
          y = pos[1];
        } else {
          var pos = refixTooltipPosition(x, y, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
          x = pos[0];
          y = pos[1];
        }
        align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === "right" ? contentSize[0] : 0);
        vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === "bottom" ? contentSize[1] : 0);
        if (shouldTooltipConfine(tooltipModel)) {
          var pos = confineTooltipPosition(x, y, content, viewWidth, viewHeight);
          x = pos[0];
          y = pos[1];
        }
        content.moveTo(x, y);
      };
      TooltipView2.prototype._updateContentNotChangedOnAxis = function(dataByCoordSys, cbParamsList) {
        var lastCoordSys = this._lastDataByCoordSys;
        var lastCbParamsList = this._cbParamsList;
        var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
        contentNotChanged && each$5(lastCoordSys, function(lastItemCoordSys, indexCoordSys) {
          var lastDataByAxis = lastItemCoordSys.dataByAxis || [];
          var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
          var thisDataByAxis = thisItemCoordSys.dataByAxis || [];
          contentNotChanged = contentNotChanged && lastDataByAxis.length === thisDataByAxis.length;
          contentNotChanged && each$5(lastDataByAxis, function(lastItem, indexAxis) {
            var thisItem = thisDataByAxis[indexAxis] || {};
            var lastIndices = lastItem.seriesDataIndices || [];
            var newIndices = thisItem.seriesDataIndices || [];
            contentNotChanged = contentNotChanged && lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
            contentNotChanged && each$5(lastIndices, function(lastIdxItem, j) {
              var newIdxItem = newIndices[j];
              contentNotChanged = contentNotChanged && lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
            });
            lastCbParamsList && each$5(lastItem.seriesDataIndices, function(idxItem) {
              var seriesIdx = idxItem.seriesIndex;
              var cbParams = cbParamsList[seriesIdx];
              var lastCbParams = lastCbParamsList[seriesIdx];
              if (cbParams && lastCbParams && lastCbParams.data !== cbParams.data) {
                contentNotChanged = false;
              }
            });
          });
        });
        this._lastDataByCoordSys = dataByCoordSys;
        this._cbParamsList = cbParamsList;
        return !!contentNotChanged;
      };
      TooltipView2.prototype._hide = function(dispatchAction2) {
        this._lastDataByCoordSys = null;
        dispatchAction2({
          type: "hideTip",
          from: this.uid
        });
      };
      TooltipView2.prototype.dispose = function(ecModel, api) {
        if (env.node || !api.getDom()) {
          return;
        }
        clear(this, "_updatePosition");
        this._tooltipContent.dispose();
        unregister("itemTooltip", api);
      };
      TooltipView2.type = "tooltip";
      return TooltipView2;
    }(ComponentView)
  );
  function buildTooltipModel(modelCascade, globalTooltipModel, defaultTooltipOption) {
    var ecModel = globalTooltipModel.ecModel;
    var resultModel;
    if (defaultTooltipOption) {
      resultModel = new Model(defaultTooltipOption, ecModel, ecModel);
      resultModel = new Model(globalTooltipModel.option, resultModel, ecModel);
    } else {
      resultModel = globalTooltipModel;
    }
    for (var i = modelCascade.length - 1; i >= 0; i--) {
      var tooltipOpt = modelCascade[i];
      if (tooltipOpt) {
        if (tooltipOpt instanceof Model) {
          tooltipOpt = tooltipOpt.get("tooltip", true);
        }
        if (isString(tooltipOpt)) {
          tooltipOpt = {
            formatter: tooltipOpt
          };
        }
        if (tooltipOpt) {
          resultModel = new Model(tooltipOpt, resultModel, ecModel);
        }
      }
    }
    return resultModel;
  }
  function makeDispatchAction(payload, api) {
    return payload.dispatchAction || bind$1(api.dispatchAction, api);
  }
  function refixTooltipPosition(x, y, content, viewWidth, viewHeight, gapH, gapV) {
    var size = content.getSize();
    var width = size[0];
    var height = size[1];
    if (gapH != null) {
      if (x + width + gapH + 2 > viewWidth) {
        x -= width + gapH;
      } else {
        x += gapH;
      }
    }
    if (gapV != null) {
      if (y + height + gapV > viewHeight) {
        y -= height + gapV;
      } else {
        y += gapV;
      }
    }
    return [x, y];
  }
  function confineTooltipPosition(x, y, content, viewWidth, viewHeight) {
    var size = content.getSize();
    var width = size[0];
    var height = size[1];
    x = Math.min(x + width, viewWidth) - width;
    y = Math.min(y + height, viewHeight) - height;
    x = Math.max(x, 0);
    y = Math.max(y, 0);
    return [x, y];
  }
  function calcTooltipPosition(position, rect, contentSize, borderWidth) {
    var domWidth = contentSize[0];
    var domHeight = contentSize[1];
    var offset = Math.ceil(Math.SQRT2 * borderWidth) + 8;
    var x = 0;
    var y = 0;
    var rectWidth = rect.width;
    var rectHeight = rect.height;
    switch (position) {
      case "inside":
        x = rect.x + rectWidth / 2 - domWidth / 2;
        y = rect.y + rectHeight / 2 - domHeight / 2;
        break;
      case "top":
        x = rect.x + rectWidth / 2 - domWidth / 2;
        y = rect.y - domHeight - offset;
        break;
      case "bottom":
        x = rect.x + rectWidth / 2 - domWidth / 2;
        y = rect.y + rectHeight + offset;
        break;
      case "left":
        x = rect.x - domWidth - offset;
        y = rect.y + rectHeight / 2 - domHeight / 2;
        break;
      case "right":
        x = rect.x + rectWidth + offset;
        y = rect.y + rectHeight / 2 - domHeight / 2;
    }
    return [x, y];
  }
  function isCenterAlign(align) {
    return align === "center" || align === "middle";
  }
  function findComponentReference(payload, ecModel, api) {
    var queryOptionMap = preParseFinder(payload).queryOptionMap;
    var componentMainType = queryOptionMap.keys()[0];
    if (!componentMainType || componentMainType === "series") {
      return;
    }
    var queryResult = queryReferringComponents(ecModel, componentMainType, queryOptionMap.get(componentMainType), {
      useDefault: false,
      enableAll: false,
      enableNone: false
    });
    var model = queryResult.models[0];
    if (!model) {
      return;
    }
    var view = api.getViewOfComponentModel(model);
    var el;
    view.group.traverse(function(subEl) {
      var tooltipConfig = getECData(subEl).tooltipConfig;
      if (tooltipConfig && tooltipConfig.name === payload.name) {
        el = subEl;
        return true;
      }
    });
    if (el) {
      return {
        componentMainType,
        componentIndex: model.componentIndex,
        el
      };
    }
  }
  function install$7(registers) {
    use(install$9);
    registers.registerComponentModel(TooltipModel);
    registers.registerComponentView(TooltipView);
    registers.registerAction({
      type: "showTip",
      event: "showTip",
      update: "tooltip:manuallyShowTip"
    }, noop);
    registers.registerAction({
      type: "hideTip",
      event: "hideTip",
      update: "tooltip:manuallyHideTip"
    }, noop);
  }
  var TitleModel = (
    /** @class */
    function(_super) {
      __extends(TitleModel2, _super);
      function TitleModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = TitleModel2.type;
        _this.layoutMode = {
          type: "box",
          ignoreSize: true
        };
        return _this;
      }
      TitleModel2.type = "title";
      TitleModel2.defaultOption = {
        // zlevel: 0,
        z: 6,
        show: true,
        text: "",
        target: "blank",
        subtext: "",
        subtarget: "blank",
        left: "center",
        top: tokens.size.m,
        backgroundColor: tokens.color.transparent,
        borderColor: tokens.color.primary,
        borderWidth: 0,
        padding: 5,
        itemGap: 10,
        textStyle: {
          fontSize: 18,
          fontWeight: "bold",
          color: tokens.color.primary
        },
        subtextStyle: {
          fontSize: 12,
          color: tokens.color.quaternary
        }
      };
      return TitleModel2;
    }(ComponentModel)
  );
  var TitleView = (
    /** @class */
    function(_super) {
      __extends(TitleView2, _super);
      function TitleView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = TitleView2.type;
        return _this;
      }
      TitleView2.prototype.render = function(titleModel, ecModel, api) {
        this.group.removeAll();
        if (!titleModel.get("show")) {
          return;
        }
        var group = this.group;
        var textStyleModel = titleModel.getModel("textStyle");
        var subtextStyleModel = titleModel.getModel("subtextStyle");
        var textAlign = titleModel.get("textAlign");
        var textVerticalAlign = retrieve2(titleModel.get("textBaseline"), titleModel.get("textVerticalAlign"));
        var textEl = new ZRText({
          style: createTextStyle(textStyleModel, {
            text: titleModel.get("text"),
            fill: textStyleModel.getTextColor()
          }, {
            disableBox: true
          }),
          z2: 10
        });
        var textRect = textEl.getBoundingRect();
        var subText = titleModel.get("subtext");
        var subTextEl = new ZRText({
          style: createTextStyle(subtextStyleModel, {
            text: subText,
            fill: subtextStyleModel.getTextColor(),
            y: textRect.height + titleModel.get("itemGap"),
            verticalAlign: "top"
          }, {
            disableBox: true
          }),
          z2: 10
        });
        var link = titleModel.get("link");
        var sublink = titleModel.get("sublink");
        var triggerEvent = titleModel.get("triggerEvent", true);
        textEl.silent = !link && !triggerEvent;
        subTextEl.silent = !sublink && !triggerEvent;
        if (link) {
          textEl.on("click", function() {
            windowOpen(link, "_" + titleModel.get("target"));
          });
        }
        if (sublink) {
          subTextEl.on("click", function() {
            windowOpen(sublink, "_" + titleModel.get("subtarget"));
          });
        }
        getECData(textEl).eventData = getECData(subTextEl).eventData = triggerEvent ? {
          componentType: "title",
          componentIndex: titleModel.componentIndex
        } : null;
        group.add(textEl);
        subText && group.add(subTextEl);
        var groupRect = group.getBoundingRect();
        var layoutOption = titleModel.getBoxLayoutParams();
        layoutOption.width = groupRect.width;
        layoutOption.height = groupRect.height;
        var layoutRef = createBoxLayoutReference(titleModel, api);
        var layoutRect = getLayoutRect(layoutOption, layoutRef.refContainer, titleModel.get("padding"));
        if (!textAlign) {
          textAlign = titleModel.get("left") || titleModel.get("right");
          if (textAlign === "middle") {
            textAlign = "center";
          }
          if (textAlign === "right") {
            layoutRect.x += layoutRect.width;
          } else if (textAlign === "center") {
            layoutRect.x += layoutRect.width / 2;
          }
        }
        if (!textVerticalAlign) {
          textVerticalAlign = titleModel.get("top") || titleModel.get("bottom");
          if (textVerticalAlign === "center") {
            textVerticalAlign = "middle";
          }
          if (textVerticalAlign === "bottom") {
            layoutRect.y += layoutRect.height;
          } else if (textVerticalAlign === "middle") {
            layoutRect.y += layoutRect.height / 2;
          }
          textVerticalAlign = textVerticalAlign || "top";
        }
        group.x = layoutRect.x;
        group.y = layoutRect.y;
        group.markRedraw();
        var alignStyle = {
          align: textAlign,
          verticalAlign: textVerticalAlign
        };
        textEl.setStyle(alignStyle);
        subTextEl.setStyle(alignStyle);
        groupRect = group.getBoundingRect();
        var padding = layoutRect.margin;
        var style = titleModel.getItemStyle(["color", "opacity"]);
        style.fill = titleModel.get("backgroundColor");
        var rect = new Rect$1({
          shape: {
            x: groupRect.x - padding[3],
            y: groupRect.y - padding[0],
            width: groupRect.width + padding[1] + padding[3],
            height: groupRect.height + padding[0] + padding[2],
            r: titleModel.get("borderRadius")
          },
          style,
          subPixelOptimize: true,
          silent: true
        });
        group.add(rect);
      };
      TitleView2.type = "title";
      return TitleView2;
    }(ComponentView)
  );
  function install$6(registers) {
    registers.registerComponentModel(TitleModel);
    registers.registerComponentView(TitleView);
  }
  var getDefaultSelectorOptions = function(ecModel, type) {
    if (type === "all") {
      return {
        type: "all",
        title: ecModel.getLocaleModel().get(["legend", "selector", "all"])
      };
    } else if (type === "inverse") {
      return {
        type: "inverse",
        title: ecModel.getLocaleModel().get(["legend", "selector", "inverse"])
      };
    }
  };
  var LegendModel = (
    /** @class */
    function(_super) {
      __extends(LegendModel2, _super);
      function LegendModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = LegendModel2.type;
        _this.layoutMode = {
          type: "box",
          // legend.width/height are maxWidth/maxHeight actually,
          // whereas real width/height is calculated by its content.
          // (Setting {left: 10, right: 10} does not make sense).
          // So consider the case:
          // `setOption({legend: {left: 10});`
          // then `setOption({legend: {right: 10});`
          // The previous `left` should be cleared by setting `ignoreSize`.
          ignoreSize: true
        };
        return _this;
      }
      LegendModel2.prototype.init = function(option, parentModel, ecModel) {
        this.mergeDefaultAndTheme(option, ecModel);
        option.selected = option.selected || {};
        this._updateSelector(option);
      };
      LegendModel2.prototype.mergeOption = function(option, ecModel) {
        _super.prototype.mergeOption.call(this, option, ecModel);
        this._updateSelector(option);
      };
      LegendModel2.prototype._updateSelector = function(option) {
        var selector = option.selector;
        var ecModel = this.ecModel;
        if (selector === true) {
          selector = option.selector = ["all", "inverse"];
        }
        if (isArray(selector)) {
          each$5(selector, function(item, index2) {
            isString(item) && (item = {
              type: item
            });
            selector[index2] = merge(item, getDefaultSelectorOptions(ecModel, item.type));
          });
        }
      };
      LegendModel2.prototype.optionUpdated = function() {
        this._updateData(this.ecModel);
        var legendData = this._data;
        if (legendData[0] && this.get("selectedMode") === "single") {
          var hasSelected = false;
          for (var i = 0; i < legendData.length; i++) {
            var name_1 = legendData[i].get("name");
            if (this.isSelected(name_1)) {
              this.select(name_1);
              hasSelected = true;
              break;
            }
          }
          !hasSelected && this.select(legendData[0].get("name"));
        }
      };
      LegendModel2.prototype._updateData = function(ecModel) {
        var potentialData = [];
        var availableNames = [];
        ecModel.eachRawSeries(function(seriesModel) {
          var seriesName = seriesModel.name;
          availableNames.push(seriesName);
          var isPotential;
          if (seriesModel.legendVisualProvider) {
            var provider = seriesModel.legendVisualProvider;
            var names = provider.getAllNames();
            if (!ecModel.isSeriesFiltered(seriesModel)) {
              availableNames = availableNames.concat(names);
            }
            if (names.length) {
              potentialData = potentialData.concat(names);
            } else {
              isPotential = true;
            }
          } else {
            isPotential = true;
          }
          if (isPotential && isNameSpecified(seriesModel)) {
            potentialData.push(seriesModel.name);
          }
        });
        this._availableNames = availableNames;
        var rawData = this.get("data") || potentialData;
        var legendNameMap = createHashMap();
        var legendData = map$1(rawData, function(dataItem) {
          if (isString(dataItem) || isNumber(dataItem)) {
            dataItem = {
              name: dataItem
            };
          }
          if (legendNameMap.get(dataItem.name)) {
            return null;
          }
          legendNameMap.set(dataItem.name, true);
          return new Model(dataItem, this, this.ecModel);
        }, this);
        this._data = filter(legendData, function(item) {
          return !!item;
        });
      };
      LegendModel2.prototype.getData = function() {
        return this._data;
      };
      LegendModel2.prototype.select = function(name) {
        var selected = this.option.selected;
        var selectedMode = this.get("selectedMode");
        if (selectedMode === "single") {
          var data = this._data;
          each$5(data, function(dataItem) {
            selected[dataItem.get("name")] = false;
          });
        }
        selected[name] = true;
      };
      LegendModel2.prototype.unSelect = function(name) {
        if (this.get("selectedMode") !== "single") {
          this.option.selected[name] = false;
        }
      };
      LegendModel2.prototype.toggleSelected = function(name) {
        var selected = this.option.selected;
        if (!selected.hasOwnProperty(name)) {
          selected[name] = true;
        }
        this[selected[name] ? "unSelect" : "select"](name);
      };
      LegendModel2.prototype.allSelect = function() {
        var data = this._data;
        var selected = this.option.selected;
        each$5(data, function(dataItem) {
          selected[dataItem.get("name", true)] = true;
        });
      };
      LegendModel2.prototype.inverseSelect = function() {
        var data = this._data;
        var selected = this.option.selected;
        each$5(data, function(dataItem) {
          var name = dataItem.get("name", true);
          if (!selected.hasOwnProperty(name)) {
            selected[name] = true;
          }
          selected[name] = !selected[name];
        });
      };
      LegendModel2.prototype.isSelected = function(name) {
        var selected = this.option.selected;
        return !(selected.hasOwnProperty(name) && !selected[name]) && indexOf(this._availableNames, name) >= 0;
      };
      LegendModel2.prototype.getOrient = function() {
        return this.get("orient") === "vertical" ? {
          index: 1,
          name: "vertical"
        } : {
          index: 0,
          name: "horizontal"
        };
      };
      LegendModel2.type = "legend.plain";
      LegendModel2.dependencies = ["series"];
      LegendModel2.defaultOption = {
        // zlevel: 0,
        z: 4,
        show: true,
        orient: "horizontal",
        left: "center",
        // right: 'center',
        // top: 0,
        bottom: tokens.size.m,
        align: "auto",
        backgroundColor: tokens.color.transparent,
        borderColor: tokens.color.border,
        borderRadius: 0,
        borderWidth: 0,
        padding: 5,
        itemGap: 8,
        itemWidth: 25,
        itemHeight: 14,
        symbolRotate: "inherit",
        symbolKeepAspect: true,
        inactiveColor: tokens.color.disabled,
        inactiveBorderColor: tokens.color.disabled,
        inactiveBorderWidth: "auto",
        itemStyle: {
          color: "inherit",
          opacity: "inherit",
          borderColor: "inherit",
          borderWidth: "auto",
          borderCap: "inherit",
          borderJoin: "inherit",
          borderDashOffset: "inherit",
          borderMiterLimit: "inherit"
        },
        lineStyle: {
          width: "auto",
          color: "inherit",
          inactiveColor: tokens.color.disabled,
          inactiveWidth: 2,
          opacity: "inherit",
          type: "inherit",
          cap: "inherit",
          join: "inherit",
          dashOffset: "inherit",
          miterLimit: "inherit"
        },
        textStyle: {
          color: tokens.color.secondary
        },
        selectedMode: true,
        selector: false,
        selectorLabel: {
          show: true,
          borderRadius: 10,
          padding: [3, 5, 3, 5],
          fontSize: 12,
          fontFamily: "sans-serif",
          color: tokens.color.tertiary,
          borderWidth: 1,
          borderColor: tokens.color.border
        },
        emphasis: {
          selectorLabel: {
            show: true,
            color: tokens.color.quaternary
          }
        },
        selectorPosition: "auto",
        selectorItemGap: 7,
        selectorButtonGap: 10,
        tooltip: {
          show: false
        },
        triggerEvent: false
      };
      return LegendModel2;
    }(ComponentModel)
  );
  var define_process_env_default$1 = {};
  var curry = curry$1;
  var each = each$5;
  var Group$1 = Group$2;
  var LegendView = (
    /** @class */
    function(_super) {
      __extends(LegendView2, _super);
      function LegendView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = LegendView2.type;
        _this.newlineDisabled = false;
        return _this;
      }
      LegendView2.prototype.init = function() {
        this.group.add(this._contentGroup = new Group$1());
        this.group.add(this._selectorGroup = new Group$1());
        this._isFirstRender = true;
      };
      LegendView2.prototype.getContentGroup = function() {
        return this._contentGroup;
      };
      LegendView2.prototype.getSelectorGroup = function() {
        return this._selectorGroup;
      };
      LegendView2.prototype.render = function(legendModel, ecModel, api) {
        var isFirstRender = this._isFirstRender;
        this._isFirstRender = false;
        this.resetInner();
        if (!legendModel.get("show", true)) {
          return;
        }
        var itemAlign = legendModel.get("align");
        var orient = legendModel.get("orient");
        if (!itemAlign || itemAlign === "auto") {
          itemAlign = legendModel.get("left") === "right" && orient === "vertical" ? "right" : "left";
        }
        var selector = legendModel.get("selector", true);
        var selectorPosition = legendModel.get("selectorPosition", true);
        if (selector && (!selectorPosition || selectorPosition === "auto")) {
          selectorPosition = orient === "horizontal" ? "end" : "start";
        }
        this.renderInner(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);
        var refContainer = createBoxLayoutReference(legendModel, api).refContainer;
        var positionInfo = legendModel.getBoxLayoutParams();
        var padding = legendModel.get("padding");
        var maxSize = getLayoutRect(positionInfo, refContainer, padding);
        var mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition);
        var layoutRect = getLayoutRect(defaults({
          width: mainRect.width,
          height: mainRect.height
        }, positionInfo), refContainer, padding);
        this.group.x = layoutRect.x - mainRect.x;
        this.group.y = layoutRect.y - mainRect.y;
        this.group.markRedraw();
        this.group.add(this._backgroundEl = makeBackground(
          mainRect,
          // FXIME: most itemStyle options does not work in background because inherit is not handled yet.
          legendModel
        ));
      };
      LegendView2.prototype.resetInner = function() {
        this.getContentGroup().removeAll();
        this._backgroundEl && this.group.remove(this._backgroundEl);
        this.getSelectorGroup().removeAll();
      };
      LegendView2.prototype.renderInner = function(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
        var contentGroup = this.getContentGroup();
        var legendDrawnMap = createHashMap();
        var selectMode = legendModel.get("selectedMode");
        var triggerEvent = legendModel.get("triggerEvent");
        var excludeSeriesId = [];
        ecModel.eachRawSeries(function(seriesModel) {
          !seriesModel.get("legendHoverLink") && excludeSeriesId.push(seriesModel.id);
        });
        each(legendModel.getData(), function(legendItemModel, dataIndex) {
          var _this = this;
          var name = legendItemModel.get("name");
          if (!this.newlineDisabled && (name === "" || name === "\n")) {
            var g = new Group$1();
            g.newline = true;
            contentGroup.add(g);
            return;
          }
          var seriesModel = ecModel.getSeriesByName(name)[0];
          if (legendDrawnMap.get(name)) {
            return;
          }
          if (seriesModel) {
            var data = seriesModel.getData();
            var lineVisualStyle = data.getVisual("legendLineStyle") || {};
            var legendIcon = data.getVisual("legendIcon");
            var style = data.getVisual("style");
            var itemGroup = this._createItem(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, style, legendIcon, selectMode, api);
            itemGroup.on("click", curry(dispatchSelectAction, name, null, api, excludeSeriesId)).on("mouseover", curry(dispatchHighlightAction, seriesModel.name, null, api, excludeSeriesId)).on("mouseout", curry(dispatchDownplayAction, seriesModel.name, null, api, excludeSeriesId));
            if (ecModel.ssr) {
              itemGroup.eachChild(function(child) {
                var ecData = getECData(child);
                ecData.seriesIndex = seriesModel.seriesIndex;
                ecData.dataIndex = dataIndex;
                ecData.ssrType = "legend";
              });
            }
            if (triggerEvent) {
              itemGroup.eachChild(function(child) {
                _this.packEventData(child, legendModel, seriesModel, dataIndex, name);
              });
            }
            legendDrawnMap.set(name, true);
          } else {
            ecModel.eachRawSeries(function(seriesModel2) {
              var _this2 = this;
              if (legendDrawnMap.get(name)) {
                return;
              }
              if (seriesModel2.legendVisualProvider) {
                var provider = seriesModel2.legendVisualProvider;
                if (!provider.containName(name)) {
                  return;
                }
                var idx = provider.indexOfName(name);
                var style2 = provider.getItemVisual(idx, "style");
                var legendIcon2 = provider.getItemVisual(idx, "legendIcon");
                var colorArr = parse(style2.fill);
                if (colorArr && colorArr[3] === 0) {
                  colorArr[3] = 0.2;
                  style2 = extend(extend({}, style2), {
                    fill: stringify(colorArr, "rgba")
                  });
                }
                var itemGroup2 = this._createItem(seriesModel2, name, dataIndex, legendItemModel, legendModel, itemAlign, {}, style2, legendIcon2, selectMode, api);
                itemGroup2.on("click", curry(dispatchSelectAction, null, name, api, excludeSeriesId)).on("mouseover", curry(dispatchHighlightAction, null, name, api, excludeSeriesId)).on("mouseout", curry(dispatchDownplayAction, null, name, api, excludeSeriesId));
                if (ecModel.ssr) {
                  itemGroup2.eachChild(function(child) {
                    var ecData = getECData(child);
                    ecData.seriesIndex = seriesModel2.seriesIndex;
                    ecData.dataIndex = dataIndex;
                    ecData.ssrType = "legend";
                  });
                }
                if (triggerEvent) {
                  itemGroup2.eachChild(function(child) {
                    _this2.packEventData(child, legendModel, seriesModel2, dataIndex, name);
                  });
                }
                legendDrawnMap.set(name, true);
              }
            }, this);
          }
          if (define_process_env_default$1.NODE_ENV !== "production") {
            if (!legendDrawnMap.get(name)) {
              console.warn(name + " series not exists. Legend data should be same with series name or data name.");
            }
          }
        }, this);
        if (selector) {
          this._createSelector(selector, legendModel, api, orient, selectorPosition);
        }
      };
      LegendView2.prototype.packEventData = function(el, legendModel, seriesModel, dataIndex, name) {
        var eventData = {
          componentType: "legend",
          componentIndex: legendModel.componentIndex,
          dataIndex,
          value: name,
          seriesIndex: seriesModel.seriesIndex
        };
        getECData(el).eventData = eventData;
      };
      LegendView2.prototype._createSelector = function(selector, legendModel, api, orient, selectorPosition) {
        var selectorGroup = this.getSelectorGroup();
        each(selector, function createSelectorButton(selectorItem) {
          var type = selectorItem.type;
          var labelText = new ZRText({
            style: {
              x: 0,
              y: 0,
              align: "center",
              verticalAlign: "middle"
            },
            onclick: function() {
              api.dispatchAction({
                type: type === "all" ? "legendAllSelect" : "legendInverseSelect",
                legendId: legendModel.id
              });
            }
          });
          selectorGroup.add(labelText);
          var labelModel = legendModel.getModel("selectorLabel");
          var emphasisLabelModel = legendModel.getModel(["emphasis", "selectorLabel"]);
          setLabelStyle(labelText, {
            normal: labelModel,
            emphasis: emphasisLabelModel
          }, {
            defaultText: selectorItem.title
          });
          enableHoverEmphasis(labelText);
        });
      };
      LegendView2.prototype._createItem = function(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, itemVisualStyle, legendIcon, selectMode, api) {
        var drawType = seriesModel.visualDrawType;
        var itemWidth = legendModel.get("itemWidth");
        var itemHeight = legendModel.get("itemHeight");
        var isSelected = legendModel.isSelected(name);
        var iconRotate = legendItemModel.get("symbolRotate");
        var symbolKeepAspect = legendItemModel.get("symbolKeepAspect");
        var legendIconType = legendItemModel.get("icon");
        legendIcon = legendIconType || legendIcon || "roundRect";
        var style = getLegendStyle(legendIcon, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api);
        var itemGroup = new Group$1();
        var textStyleModel = legendItemModel.getModel("textStyle");
        if (isFunction(seriesModel.getLegendIcon) && (!legendIconType || legendIconType === "inherit")) {
          itemGroup.add(seriesModel.getLegendIcon({
            itemWidth,
            itemHeight,
            icon: legendIcon,
            iconRotate,
            itemStyle: style.itemStyle,
            lineStyle: style.lineStyle,
            symbolKeepAspect
          }));
        } else {
          var rotate2 = legendIconType === "inherit" && seriesModel.getData().getVisual("symbol") ? iconRotate === "inherit" ? seriesModel.getData().getVisual("symbolRotate") : iconRotate : 0;
          itemGroup.add(getDefaultLegendIcon({
            itemWidth,
            itemHeight,
            icon: legendIcon,
            iconRotate: rotate2,
            itemStyle: style.itemStyle,
            symbolKeepAspect
          }));
        }
        var textX = itemAlign === "left" ? itemWidth + 5 : -5;
        var textAlign = itemAlign;
        var formatter = legendModel.get("formatter");
        var content = name;
        if (isString(formatter) && formatter) {
          content = formatter.replace("{name}", name != null ? name : "");
        } else if (isFunction(formatter)) {
          content = formatter(name);
        }
        var textColor = isSelected ? textStyleModel.getTextColor() : legendItemModel.get("inactiveColor");
        itemGroup.add(new ZRText({
          style: createTextStyle(textStyleModel, {
            text: content,
            x: textX,
            y: itemHeight / 2,
            fill: textColor,
            align: textAlign,
            verticalAlign: "middle"
          }, {
            inheritColor: textColor
          })
        }));
        var hitRect = new Rect$1({
          shape: itemGroup.getBoundingRect(),
          style: {
            // Cannot use 'invisible' because SVG SSR will miss the node
            fill: "transparent"
          }
        });
        var tooltipModel = legendItemModel.getModel("tooltip");
        if (tooltipModel.get("show")) {
          setTooltipConfig({
            el: hitRect,
            componentModel: legendModel,
            itemName: name,
            itemTooltipOption: tooltipModel.option
          });
        }
        itemGroup.add(hitRect);
        itemGroup.eachChild(function(child) {
          child.silent = true;
        });
        hitRect.silent = !selectMode;
        this.getContentGroup().add(itemGroup);
        enableHoverEmphasis(itemGroup);
        itemGroup.__legendDataIndex = dataIndex;
        return itemGroup;
      };
      LegendView2.prototype.layoutInner = function(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
        var contentGroup = this.getContentGroup();
        var selectorGroup = this.getSelectorGroup();
        box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), maxSize.width, maxSize.height);
        var contentRect = contentGroup.getBoundingRect();
        var contentPos = [-contentRect.x, -contentRect.y];
        selectorGroup.markRedraw();
        contentGroup.markRedraw();
        if (selector) {
          box(
            // Buttons in selectorGroup always layout horizontally
            "horizontal",
            selectorGroup,
            legendModel.get("selectorItemGap", true)
          );
          var selectorRect = selectorGroup.getBoundingRect();
          var selectorPos = [-selectorRect.x, -selectorRect.y];
          var selectorButtonGap = legendModel.get("selectorButtonGap", true);
          var orientIdx = legendModel.getOrient().index;
          var wh = orientIdx === 0 ? "width" : "height";
          var hw = orientIdx === 0 ? "height" : "width";
          var yx = orientIdx === 0 ? "y" : "x";
          if (selectorPosition === "end") {
            selectorPos[orientIdx] += contentRect[wh] + selectorButtonGap;
          } else {
            contentPos[orientIdx] += selectorRect[wh] + selectorButtonGap;
          }
          selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2;
          selectorGroup.x = selectorPos[0];
          selectorGroup.y = selectorPos[1];
          contentGroup.x = contentPos[0];
          contentGroup.y = contentPos[1];
          var mainRect = {
            x: 0,
            y: 0
          };
          mainRect[wh] = contentRect[wh] + selectorButtonGap + selectorRect[wh];
          mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw]);
          mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx]);
          return mainRect;
        } else {
          contentGroup.x = contentPos[0];
          contentGroup.y = contentPos[1];
          return this.group.getBoundingRect();
        }
      };
      LegendView2.prototype.remove = function() {
        this.getContentGroup().removeAll();
        this._isFirstRender = true;
      };
      LegendView2.type = "legend.plain";
      return LegendView2;
    }(ComponentView)
  );
  function getLegendStyle(iconType, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api) {
    function handleCommonProps(style, visualStyle) {
      if (style.lineWidth === "auto") {
        style.lineWidth = visualStyle.lineWidth > 0 ? 2 : 0;
      }
      each(style, function(propVal, propName) {
        style[propName] === "inherit" && (style[propName] = visualStyle[propName]);
      });
    }
    var itemStyleModel = legendItemModel.getModel("itemStyle");
    var itemStyle = itemStyleModel.getItemStyle();
    var iconBrushType = iconType.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke";
    var decalStyle = itemStyleModel.getShallow("decal");
    itemStyle.decal = !decalStyle || decalStyle === "inherit" ? itemVisualStyle.decal : createOrUpdatePatternFromDecal(decalStyle, api);
    if (itemStyle.fill === "inherit") {
      itemStyle.fill = itemVisualStyle[drawType];
    }
    if (itemStyle.stroke === "inherit") {
      itemStyle.stroke = itemVisualStyle[iconBrushType];
    }
    if (itemStyle.opacity === "inherit") {
      itemStyle.opacity = (drawType === "fill" ? itemVisualStyle : lineVisualStyle).opacity;
    }
    handleCommonProps(itemStyle, itemVisualStyle);
    var legendLineModel = legendItemModel.getModel("lineStyle");
    var lineStyle = legendLineModel.getLineStyle();
    handleCommonProps(lineStyle, lineVisualStyle);
    itemStyle.fill === "auto" && (itemStyle.fill = itemVisualStyle.fill);
    itemStyle.stroke === "auto" && (itemStyle.stroke = itemVisualStyle.fill);
    lineStyle.stroke === "auto" && (lineStyle.stroke = itemVisualStyle.fill);
    if (!isSelected) {
      var borderWidth = legendItemModel.get("inactiveBorderWidth");
      var visualHasBorder = itemStyle[iconBrushType];
      itemStyle.lineWidth = borderWidth === "auto" ? itemVisualStyle.lineWidth > 0 && visualHasBorder ? 2 : 0 : itemStyle.lineWidth;
      itemStyle.fill = legendItemModel.get("inactiveColor");
      itemStyle.stroke = legendItemModel.get("inactiveBorderColor");
      lineStyle.stroke = legendLineModel.get("inactiveColor");
      lineStyle.lineWidth = legendLineModel.get("inactiveWidth");
    }
    return {
      itemStyle,
      lineStyle
    };
  }
  function getDefaultLegendIcon(opt) {
    var symboType = opt.icon || "roundRect";
    var icon = createSymbol(symboType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill, opt.symbolKeepAspect);
    icon.setStyle(opt.itemStyle);
    icon.rotation = (opt.iconRotate || 0) * Math.PI / 180;
    icon.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);
    if (symboType.indexOf("empty") > -1) {
      icon.style.stroke = icon.style.fill;
      icon.style.fill = tokens.color.neutral00;
      icon.style.lineWidth = 2;
    }
    return icon;
  }
  function dispatchSelectAction(seriesName, dataName, api, excludeSeriesId) {
    dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId);
    api.dispatchAction({
      type: "legendToggleSelect",
      name: seriesName != null ? seriesName : dataName
    });
    dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId);
  }
  function isUseHoverLayer(api) {
    var list = api.getZr().storage.getDisplayList();
    var emphasisState;
    var i = 0;
    var len2 = list.length;
    while (i < len2 && !(emphasisState = list[i].states.emphasis)) {
      i++;
    }
    return emphasisState && emphasisState.hoverLayer;
  }
  function dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId) {
    if (!isUseHoverLayer(api)) {
      api.dispatchAction({
        type: "highlight",
        seriesName,
        name: dataName,
        excludeSeriesId
      });
    }
  }
  function dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId) {
    if (!isUseHoverLayer(api)) {
      api.dispatchAction({
        type: "downplay",
        seriesName,
        name: dataName,
        excludeSeriesId
      });
    }
  }
  function legendFilter(ecModel) {
    var legendModels = ecModel.findComponents({
      mainType: "legend"
    });
    if (legendModels && legendModels.length) {
      ecModel.filterSeries(function(series) {
        for (var i = 0; i < legendModels.length; i++) {
          if (!legendModels[i].isSelected(series.name)) {
            return false;
          }
        }
        return true;
      });
    }
  }
  function legendSelectActionHandler(methodName, payload, ecModel) {
    var isAllSelect = methodName === "allSelect" || methodName === "inverseSelect";
    var selectedMap = {};
    var actionLegendIndices = [];
    ecModel.eachComponent({
      mainType: "legend",
      query: payload
    }, function(legendModel) {
      if (isAllSelect) {
        legendModel[methodName]();
      } else {
        legendModel[methodName](payload.name);
      }
      makeSelectedMap(legendModel, selectedMap);
      actionLegendIndices.push(legendModel.componentIndex);
    });
    var allSelectedMap = {};
    ecModel.eachComponent("legend", function(legendModel) {
      each$5(selectedMap, function(isSelected, name) {
        legendModel[isSelected ? "select" : "unSelect"](name);
      });
      makeSelectedMap(legendModel, allSelectedMap);
    });
    return isAllSelect ? {
      selected: allSelectedMap,
      // return legendIndex array to tell the developers which legends are allSelect / inverseSelect
      legendIndex: actionLegendIndices
    } : {
      name: payload.name,
      selected: allSelectedMap
    };
  }
  function makeSelectedMap(legendModel, out2) {
    var selectedMap = out2 || {};
    each$5(legendModel.getData(), function(model) {
      var name = model.get("name");
      if (name === "\n" || name === "") {
        return;
      }
      var isItemSelected = legendModel.isSelected(name);
      if (hasOwn(selectedMap, name)) {
        selectedMap[name] = selectedMap[name] && isItemSelected;
      } else {
        selectedMap[name] = isItemSelected;
      }
    });
    return selectedMap;
  }
  function installLegendAction(registers) {
    registers.registerAction("legendToggleSelect", "legendselectchanged", curry$1(legendSelectActionHandler, "toggleSelected"));
    registers.registerAction("legendAllSelect", "legendselectall", curry$1(legendSelectActionHandler, "allSelect"));
    registers.registerAction("legendInverseSelect", "legendinverseselect", curry$1(legendSelectActionHandler, "inverseSelect"));
    registers.registerAction("legendSelect", "legendselected", curry$1(legendSelectActionHandler, "select"));
    registers.registerAction("legendUnSelect", "legendunselected", curry$1(legendSelectActionHandler, "unSelect"));
  }
  function install$5(registers) {
    registers.registerComponentModel(LegendModel);
    registers.registerComponentView(LegendView);
    registers.registerProcessor(registers.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter);
    registers.registerSubTypeDefaulter("legend", function() {
      return "plain";
    });
    installLegendAction(registers);
  }
  var ScrollableLegendModel = (
    /** @class */
    function(_super) {
      __extends(ScrollableLegendModel2, _super);
      function ScrollableLegendModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = ScrollableLegendModel2.type;
        return _this;
      }
      ScrollableLegendModel2.prototype.setScrollDataIndex = function(scrollDataIndex) {
        this.option.scrollDataIndex = scrollDataIndex;
      };
      ScrollableLegendModel2.prototype.init = function(option, parentModel, ecModel) {
        var inputPositionParams = getLayoutParams(option);
        _super.prototype.init.call(this, option, parentModel, ecModel);
        mergeAndNormalizeLayoutParams(this, option, inputPositionParams);
      };
      ScrollableLegendModel2.prototype.mergeOption = function(option, ecModel) {
        _super.prototype.mergeOption.call(this, option, ecModel);
        mergeAndNormalizeLayoutParams(this, this.option, option);
      };
      ScrollableLegendModel2.type = "legend.scroll";
      ScrollableLegendModel2.defaultOption = inheritDefaultOption(LegendModel.defaultOption, {
        scrollDataIndex: 0,
        pageButtonItemGap: 5,
        pageButtonGap: null,
        pageButtonPosition: "end",
        pageFormatter: "{current}/{total}",
        pageIcons: {
          horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
          vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
        },
        pageIconColor: tokens.color.accent50,
        pageIconInactiveColor: tokens.color.accent10,
        pageIconSize: 15,
        pageTextStyle: {
          color: tokens.color.tertiary
        },
        animationDurationUpdate: 800
      });
      return ScrollableLegendModel2;
    }(LegendModel)
  );
  function mergeAndNormalizeLayoutParams(legendModel, target, raw) {
    var orient = legendModel.getOrient();
    var ignoreSize = [1, 1];
    ignoreSize[orient.index] = 0;
    mergeLayoutParam(target, raw, {
      type: "box",
      ignoreSize: !!ignoreSize
    });
  }
  var Group = Group$2;
  var WH = ["width", "height"];
  var XY = ["x", "y"];
  var ScrollableLegendView = (
    /** @class */
    function(_super) {
      __extends(ScrollableLegendView2, _super);
      function ScrollableLegendView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = ScrollableLegendView2.type;
        _this.newlineDisabled = true;
        _this._currentIndex = 0;
        return _this;
      }
      ScrollableLegendView2.prototype.init = function() {
        _super.prototype.init.call(this);
        this.group.add(this._containerGroup = new Group());
        this._containerGroup.add(this.getContentGroup());
        this.group.add(this._controllerGroup = new Group());
      };
      ScrollableLegendView2.prototype.resetInner = function() {
        _super.prototype.resetInner.call(this);
        this._controllerGroup.removeAll();
        this._containerGroup.removeClipPath();
        this._containerGroup.__rectSize = null;
      };
      ScrollableLegendView2.prototype.renderInner = function(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
        var self2 = this;
        _super.prototype.renderInner.call(this, itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);
        var controllerGroup = this._controllerGroup;
        var pageIconSize = legendModel.get("pageIconSize", true);
        var pageIconSizeArr = isArray(pageIconSize) ? pageIconSize : [pageIconSize, pageIconSize];
        createPageButton("pagePrev", 0);
        var pageTextStyleModel = legendModel.getModel("pageTextStyle");
        controllerGroup.add(new ZRText({
          name: "pageText",
          style: {
            // Placeholder to calculate a proper layout.
            text: "xx/xx",
            fill: pageTextStyleModel.getTextColor(),
            font: pageTextStyleModel.getFont(),
            verticalAlign: "middle",
            align: "center"
          },
          silent: true
        }));
        createPageButton("pageNext", 1);
        function createPageButton(name, iconIdx) {
          var pageDataIndexName = name + "DataIndex";
          var icon = createIcon(legendModel.get("pageIcons", true)[legendModel.getOrient().name][iconIdx], {
            // Buttons will be created in each render, so we do not need
            // to worry about avoiding using legendModel kept in scope.
            onclick: bind$1(self2._pageGo, self2, pageDataIndexName, legendModel, api)
          }, {
            x: -pageIconSizeArr[0] / 2,
            y: -pageIconSizeArr[1] / 2,
            width: pageIconSizeArr[0],
            height: pageIconSizeArr[1]
          });
          icon.name = name;
          controllerGroup.add(icon);
        }
      };
      ScrollableLegendView2.prototype.layoutInner = function(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
        var selectorGroup = this.getSelectorGroup();
        var orientIdx = legendModel.getOrient().index;
        var wh = WH[orientIdx];
        var xy = XY[orientIdx];
        var hw = WH[1 - orientIdx];
        var yx = XY[1 - orientIdx];
        selector && box(
          // Buttons in selectorGroup always layout horizontally
          "horizontal",
          selectorGroup,
          legendModel.get("selectorItemGap", true)
        );
        var selectorButtonGap = legendModel.get("selectorButtonGap", true);
        var selectorRect = selectorGroup.getBoundingRect();
        var selectorPos = [-selectorRect.x, -selectorRect.y];
        var processMaxSize = clone$2(maxSize);
        selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);
        var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx, xy);
        if (selector) {
          if (selectorPosition === "end") {
            selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;
          } else {
            var offset = selectorRect[wh] + selectorButtonGap;
            selectorPos[orientIdx] -= offset;
            mainRect[xy] -= offset;
          }
          mainRect[wh] += selectorRect[wh] + selectorButtonGap;
          selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;
          mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);
          mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);
          selectorGroup.x = selectorPos[0];
          selectorGroup.y = selectorPos[1];
          selectorGroup.markRedraw();
        }
        return mainRect;
      };
      ScrollableLegendView2.prototype._layoutContentAndController = function(legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx, xy) {
        var contentGroup = this.getContentGroup();
        var containerGroup = this._containerGroup;
        var controllerGroup = this._controllerGroup;
        box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);
        box(
          // Buttons in controller are layout always horizontally.
          "horizontal",
          controllerGroup,
          legendModel.get("pageButtonItemGap", true)
        );
        var contentRect = contentGroup.getBoundingRect();
        var controllerRect = controllerGroup.getBoundingRect();
        var showController = this._showController = contentRect[wh] > maxSize[wh];
        var contentPos = [-contentRect.x, -contentRect.y];
        if (!isFirstRender) {
          contentPos[orientIdx] = contentGroup[xy];
        }
        var containerPos = [0, 0];
        var controllerPos = [-controllerRect.x, -controllerRect.y];
        var pageButtonGap = retrieve2(legendModel.get("pageButtonGap", true), legendModel.get("itemGap", true));
        if (showController) {
          var pageButtonPosition = legendModel.get("pageButtonPosition", true);
          if (pageButtonPosition === "end") {
            controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];
          } else {
            containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;
          }
        }
        controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;
        contentGroup.setPosition(contentPos);
        containerGroup.setPosition(containerPos);
        controllerGroup.setPosition(controllerPos);
        var mainRect = {
          x: 0,
          y: 0
        };
        mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];
        mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]);
        mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);
        containerGroup.__rectSize = maxSize[wh];
        if (showController) {
          var clipShape = {
            x: 0,
            y: 0
          };
          clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);
          clipShape[hw] = mainRect[hw];
          containerGroup.setClipPath(new Rect$1({
            shape: clipShape
          }));
          containerGroup.__rectSize = clipShape[wh];
        } else {
          controllerGroup.eachChild(function(child) {
            child.attr({
              invisible: true,
              silent: true
            });
          });
        }
        var pageInfo = this._getPageInfo(legendModel);
        pageInfo.pageIndex != null && updateProps$1(
          contentGroup,
          {
            x: pageInfo.contentPosition[0],
            y: pageInfo.contentPosition[1]
          },
          // When switch from "show controller" to "not show controller", view should be
          // updated immediately without animation, otherwise causes weird effect.
          showController ? legendModel : null
        );
        this._updatePageInfoView(legendModel, pageInfo);
        return mainRect;
      };
      ScrollableLegendView2.prototype._pageGo = function(to, legendModel, api) {
        var scrollDataIndex = this._getPageInfo(legendModel)[to];
        scrollDataIndex != null && api.dispatchAction({
          type: "legendScroll",
          scrollDataIndex,
          legendId: legendModel.id
        });
      };
      ScrollableLegendView2.prototype._updatePageInfoView = function(legendModel, pageInfo) {
        var controllerGroup = this._controllerGroup;
        each$5(["pagePrev", "pageNext"], function(name) {
          var key2 = name + "DataIndex";
          var canJump = pageInfo[key2] != null;
          var icon = controllerGroup.childOfName(name);
          if (icon) {
            icon.setStyle("fill", canJump ? legendModel.get("pageIconColor", true) : legendModel.get("pageIconInactiveColor", true));
            icon.cursor = canJump ? "pointer" : "default";
          }
        });
        var pageText = controllerGroup.childOfName("pageText");
        var pageFormatter = legendModel.get("pageFormatter");
        var pageIndex = pageInfo.pageIndex;
        var current = pageIndex != null ? pageIndex + 1 : 0;
        var total = pageInfo.pageCount;
        pageText && pageFormatter && pageText.setStyle("text", isString(pageFormatter) ? pageFormatter.replace("{current}", current == null ? "" : current + "").replace("{total}", total == null ? "" : total + "") : pageFormatter({
          current,
          total
        }));
      };
      ScrollableLegendView2.prototype._getPageInfo = function(legendModel) {
        var scrollDataIndex = legendModel.get("scrollDataIndex", true);
        var contentGroup = this.getContentGroup();
        var containerRectSize = this._containerGroup.__rectSize;
        var orientIdx = legendModel.getOrient().index;
        var wh = WH[orientIdx];
        var xy = XY[orientIdx];
        var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);
        var children = contentGroup.children();
        var targetItem = children[targetItemIndex];
        var itemCount = children.length;
        var pCount = !itemCount ? 0 : 1;
        var result = {
          contentPosition: [contentGroup.x, contentGroup.y],
          pageCount: pCount,
          pageIndex: pCount - 1,
          pagePrevDataIndex: null,
          pageNextDataIndex: null
        };
        if (!targetItem) {
          return result;
        }
        var targetItemInfo = getItemInfo(targetItem);
        result.contentPosition[orientIdx] = -targetItemInfo.s;
        for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {
          currItemInfo = getItemInfo(children[i]);
          if (
            // Half of the last item is out of the window.
            !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || currItemInfo && !intersect2(currItemInfo, winStartItemInfo.s)
          ) {
            if (winEndItemInfo.i > winStartItemInfo.i) {
              winStartItemInfo = winEndItemInfo;
            } else {
              winStartItemInfo = currItemInfo;
            }
            if (winStartItemInfo) {
              if (result.pageNextDataIndex == null) {
                result.pageNextDataIndex = winStartItemInfo.i;
              }
              ++result.pageCount;
            }
          }
          winEndItemInfo = currItemInfo;
        }
        for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {
          currItemInfo = getItemInfo(children[i]);
          if (
            // If the the end item does not intersect with the window started
            // from the current item, a page can be settled.
            (!currItemInfo || !intersect2(winEndItemInfo, currItemInfo.s)) && winStartItemInfo.i < winEndItemInfo.i
          ) {
            winEndItemInfo = winStartItemInfo;
            if (result.pagePrevDataIndex == null) {
              result.pagePrevDataIndex = winStartItemInfo.i;
            }
            ++result.pageCount;
            ++result.pageIndex;
          }
          winStartItemInfo = currItemInfo;
        }
        return result;
        function getItemInfo(el) {
          if (el) {
            var itemRect = el.getBoundingRect();
            var start2 = itemRect[xy] + el[xy];
            return {
              s: start2,
              e: start2 + itemRect[wh],
              i: el.__legendDataIndex
            };
          }
        }
        function intersect2(itemInfo, winStart) {
          return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;
        }
      };
      ScrollableLegendView2.prototype._findTargetItemIndex = function(targetDataIndex) {
        if (!this._showController) {
          return 0;
        }
        var index2;
        var contentGroup = this.getContentGroup();
        var defaultIndex;
        contentGroup.eachChild(function(child, idx) {
          var legendDataIdx = child.__legendDataIndex;
          if (defaultIndex == null && legendDataIdx != null) {
            defaultIndex = idx;
          }
          if (legendDataIdx === targetDataIndex) {
            index2 = idx;
          }
        });
        return index2 != null ? index2 : defaultIndex;
      };
      ScrollableLegendView2.type = "legend.scroll";
      return ScrollableLegendView2;
    }(LegendView)
  );
  function installScrollableLegendAction(registers) {
    registers.registerAction("legendScroll", "legendscroll", function(payload, ecModel) {
      var scrollDataIndex = payload.scrollDataIndex;
      scrollDataIndex != null && ecModel.eachComponent({
        mainType: "legend",
        subType: "scroll",
        query: payload
      }, function(legendModel) {
        legendModel.setScrollDataIndex(scrollDataIndex);
      });
    });
  }
  function install$4(registers) {
    use(install$5);
    registers.registerComponentModel(ScrollableLegendModel);
    registers.registerComponentView(ScrollableLegendView);
    installScrollableLegendAction(registers);
  }
  function install$3(registers) {
    use(install$5);
    use(install$4);
  }
  var InsideZoomModel = (
    /** @class */
    function(_super) {
      __extends(InsideZoomModel2, _super);
      function InsideZoomModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = InsideZoomModel2.type;
        return _this;
      }
      InsideZoomModel2.type = "dataZoom.inside";
      InsideZoomModel2.defaultOption = inheritDefaultOption(DataZoomModel.defaultOption, {
        disabled: false,
        zoomLock: false,
        zoomOnMouseWheel: true,
        moveOnMouseMove: true,
        moveOnMouseWheel: false,
        preventDefaultMouseMove: true
      });
      return InsideZoomModel2;
    }(DataZoomModel)
  );
  var inner = makeInner();
  function setViewInfoToCoordSysRecord(api, dataZoomModel, getRange) {
    inner(api).coordSysRecordMap.each(function(coordSysRecord) {
      var dzInfo = coordSysRecord.dataZoomInfoMap.get(dataZoomModel.uid);
      if (dzInfo) {
        dzInfo.getRange = getRange;
      }
    });
  }
  function disposeCoordSysRecordIfNeeded(api, dataZoomModel) {
    var coordSysRecordMap = inner(api).coordSysRecordMap;
    var coordSysKeyArr = coordSysRecordMap.keys();
    for (var i = 0; i < coordSysKeyArr.length; i++) {
      var coordSysKey = coordSysKeyArr[i];
      var coordSysRecord = coordSysRecordMap.get(coordSysKey);
      var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;
      if (dataZoomInfoMap) {
        var dzUid = dataZoomModel.uid;
        var dzInfo = dataZoomInfoMap.get(dzUid);
        if (dzInfo) {
          dataZoomInfoMap.removeKey(dzUid);
          if (!dataZoomInfoMap.keys().length) {
            disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);
          }
        }
      }
    }
  }
  function disposeCoordSysRecord(coordSysRecordMap, coordSysRecord) {
    if (coordSysRecord) {
      coordSysRecordMap.removeKey(coordSysRecord.model.uid);
      var controller = coordSysRecord.controller;
      controller && controller.dispose();
    }
  }
  function createCoordSysRecord(api, coordSysModel) {
    var coordSysRecord = {
      model: coordSysModel,
      containsPoint: curry$1(containsPoint, coordSysModel),
      dispatchAction: curry$1(dispatchAction, api),
      dataZoomInfoMap: null,
      controller: null
    };
    var controller = coordSysRecord.controller = new RoamController(api.getZr());
    each$5(["pan", "zoom", "scrollMove"], function(eventName) {
      controller.on(eventName, function(event) {
        var batch = [];
        coordSysRecord.dataZoomInfoMap.each(function(dzInfo) {
          if (!event.isAvailableBehavior(dzInfo.model.option)) {
            return;
          }
          var method = (dzInfo.getRange || {})[eventName];
          var range = method && method(dzInfo.dzReferCoordSysInfo, coordSysRecord.model.mainType, coordSysRecord.controller, event);
          !dzInfo.model.get("disabled", true) && range && batch.push({
            dataZoomId: dzInfo.model.id,
            start: range[0],
            end: range[1]
          });
        });
        batch.length && coordSysRecord.dispatchAction(batch);
      });
    });
    return coordSysRecord;
  }
  function dispatchAction(api, batch) {
    if (!api.isDisposed()) {
      api.dispatchAction({
        type: "dataZoom",
        animation: {
          easing: "cubicOut",
          duration: 100
        },
        batch
      });
    }
  }
  function containsPoint(coordSysModel, e2, x, y) {
    return coordSysModel.coordinateSystem.containPoint([x, y]);
  }
  function mergeControllerParams(dataZoomInfoMap, coordSysRecord, api) {
    var controlType;
    var prefix = "type_";
    var typePriority = {
      "type_true": 2,
      "type_move": 1,
      "type_false": 0,
      "type_undefined": -1
    };
    var preventDefaultMouseMove = true;
    dataZoomInfoMap.each(function(dataZoomInfo) {
      var dataZoomModel = dataZoomInfo.model;
      var oneType = dataZoomModel.get("disabled", true) ? false : dataZoomModel.get("zoomLock", true) ? "move" : true;
      if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {
        controlType = oneType;
      }
      preventDefaultMouseMove = preventDefaultMouseMove && dataZoomModel.get("preventDefaultMouseMove", true);
    });
    return {
      controlType,
      opt: {
        // RoamController will enable all of these functionalities,
        // and the final behavior is determined by its event listener
        // provided by each inside zoom.
        zoomOnMouseWheel: true,
        moveOnMouseMove: true,
        moveOnMouseWheel: true,
        preventDefaultMouseMove: !!preventDefaultMouseMove,
        api,
        zInfo: {
          component: coordSysRecord.model
        },
        triggerInfo: {
          roamTrigger: null,
          isInSelf: coordSysRecord.containsPoint
        }
      }
    };
  }
  function installDataZoomRoamProcessor(registers) {
    registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, function(ecModel, api) {
      var apiInner = inner(api);
      var coordSysRecordMap = apiInner.coordSysRecordMap || (apiInner.coordSysRecordMap = createHashMap());
      coordSysRecordMap.each(function(coordSysRecord) {
        coordSysRecord.dataZoomInfoMap = null;
      });
      ecModel.eachComponent({
        mainType: "dataZoom",
        subType: "inside"
      }, function(dataZoomModel) {
        var dzReferCoordSysWrap = collectReferCoordSysModelInfo(dataZoomModel);
        each$5(dzReferCoordSysWrap.infoList, function(dzCoordSysInfo) {
          var coordSysUid = dzCoordSysInfo.model.uid;
          var coordSysRecord = coordSysRecordMap.get(coordSysUid) || coordSysRecordMap.set(coordSysUid, createCoordSysRecord(api, dzCoordSysInfo.model));
          var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap || (coordSysRecord.dataZoomInfoMap = createHashMap());
          dataZoomInfoMap.set(dataZoomModel.uid, {
            dzReferCoordSysInfo: dzCoordSysInfo,
            model: dataZoomModel,
            getRange: null
          });
        });
      });
      coordSysRecordMap.each(function(coordSysRecord) {
        var controller = coordSysRecord.controller;
        var firstDzInfo;
        var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;
        if (dataZoomInfoMap) {
          var firstDzKey = dataZoomInfoMap.keys()[0];
          if (firstDzKey != null) {
            firstDzInfo = dataZoomInfoMap.get(firstDzKey);
          }
        }
        if (!firstDzInfo) {
          disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);
          return;
        }
        var controllerParams = mergeControllerParams(dataZoomInfoMap, coordSysRecord, api);
        controller.enable(controllerParams.controlType, controllerParams.opt);
        createOrUpdate(coordSysRecord, "dispatchAction", firstDzInfo.model.get("throttle", true), "fixRate");
      });
    });
  }
  var InsideZoomView = (
    /** @class */
    function(_super) {
      __extends(InsideZoomView2, _super);
      function InsideZoomView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "dataZoom.inside";
        return _this;
      }
      InsideZoomView2.prototype.render = function(dataZoomModel, ecModel, api) {
        _super.prototype.render.apply(this, arguments);
        if (dataZoomModel.noTarget()) {
          this._clear();
          return;
        }
        this.range = dataZoomModel.getPercentRange();
        setViewInfoToCoordSysRecord(api, dataZoomModel, {
          pan: bind$1(getRangeHandlers.pan, this),
          zoom: bind$1(getRangeHandlers.zoom, this),
          scrollMove: bind$1(getRangeHandlers.scrollMove, this)
        });
      };
      InsideZoomView2.prototype.dispose = function() {
        this._clear();
        _super.prototype.dispose.apply(this, arguments);
      };
      InsideZoomView2.prototype._clear = function() {
        disposeCoordSysRecordIfNeeded(this.api, this.dataZoomModel);
        this.range = null;
      };
      InsideZoomView2.type = "dataZoom.inside";
      return InsideZoomView2;
    }(DataZoomView)
  );
  var getRangeHandlers = {
    zoom: function(coordSysInfo, coordSysMainType, controller, e2) {
      var lastRange = this.range;
      var range = lastRange.slice();
      var axisModel = coordSysInfo.axisModels[0];
      if (!axisModel) {
        return;
      }
      var directionInfo = getDirectionInfo[coordSysMainType](null, [e2.originX, e2.originY], axisModel, controller, coordSysInfo);
      var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];
      var scale2 = Math.max(1 / e2.scale, 0);
      range[0] = (range[0] - percentPoint) * scale2 + percentPoint;
      range[1] = (range[1] - percentPoint) * scale2 + percentPoint;
      var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
      sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);
      this.range = range;
      if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
        return range;
      }
    },
    pan: makeMover(function(range, axisModel, coordSysInfo, coordSysMainType, controller, e2) {
      var directionInfo = getDirectionInfo[coordSysMainType]([e2.oldX, e2.oldY], [e2.newX, e2.newY], axisModel, controller, coordSysInfo);
      return directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;
    }),
    scrollMove: makeMover(function(range, axisModel, coordSysInfo, coordSysMainType, controller, e2) {
      var directionInfo = getDirectionInfo[coordSysMainType]([0, 0], [e2.scrollDelta, e2.scrollDelta], axisModel, controller, coordSysInfo);
      return directionInfo.signal * (range[1] - range[0]) * e2.scrollDelta;
    })
  };
  function makeMover(getPercentDelta) {
    return function(coordSysInfo, coordSysMainType, controller, e2) {
      var lastRange = this.range;
      var range = lastRange.slice();
      var axisModel = coordSysInfo.axisModels[0];
      if (!axisModel) {
        return;
      }
      var percentDelta = getPercentDelta(range, axisModel, coordSysInfo, coordSysMainType, controller, e2);
      sliderMove(percentDelta, range, [0, 100], "all");
      this.range = range;
      if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
        return range;
      }
    };
  }
  var getDirectionInfo = {
    grid: function(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
      var axis = axisModel.axis;
      var ret = {};
      var rect = coordSysInfo.model.coordinateSystem.getRect();
      oldPoint = oldPoint || [0, 0];
      if (axis.dim === "x") {
        ret.pixel = newPoint[0] - oldPoint[0];
        ret.pixelLength = rect.width;
        ret.pixelStart = rect.x;
        ret.signal = axis.inverse ? 1 : -1;
      } else {
        ret.pixel = newPoint[1] - oldPoint[1];
        ret.pixelLength = rect.height;
        ret.pixelStart = rect.y;
        ret.signal = axis.inverse ? -1 : 1;
      }
      return ret;
    },
    polar: function(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
      var axis = axisModel.axis;
      var ret = {};
      var polar = coordSysInfo.model.coordinateSystem;
      var radiusExtent = polar.getRadiusAxis().getExtent();
      var angleExtent = polar.getAngleAxis().getExtent();
      oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];
      newPoint = polar.pointToCoord(newPoint);
      if (axisModel.mainType === "radiusAxis") {
        ret.pixel = newPoint[0] - oldPoint[0];
        ret.pixelLength = radiusExtent[1] - radiusExtent[0];
        ret.pixelStart = radiusExtent[0];
        ret.signal = axis.inverse ? 1 : -1;
      } else {
        ret.pixel = newPoint[1] - oldPoint[1];
        ret.pixelLength = angleExtent[1] - angleExtent[0];
        ret.pixelStart = angleExtent[0];
        ret.signal = axis.inverse ? -1 : 1;
      }
      return ret;
    },
    singleAxis: function(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
      var axis = axisModel.axis;
      var rect = coordSysInfo.model.coordinateSystem.getRect();
      var ret = {};
      oldPoint = oldPoint || [0, 0];
      if (axis.orient === "horizontal") {
        ret.pixel = newPoint[0] - oldPoint[0];
        ret.pixelLength = rect.width;
        ret.pixelStart = rect.x;
        ret.signal = axis.inverse ? 1 : -1;
      } else {
        ret.pixel = newPoint[1] - oldPoint[1];
        ret.pixelLength = rect.height;
        ret.pixelStart = rect.y;
        ret.signal = axis.inverse ? -1 : 1;
      }
      return ret;
    }
  };
  function install$2(registers) {
    installCommon(registers);
    registers.registerComponentModel(InsideZoomModel);
    registers.registerComponentView(InsideZoomView);
    installDataZoomRoamProcessor(registers);
  }
  var SliderZoomModel = (
    /** @class */
    function(_super) {
      __extends(SliderZoomModel2, _super);
      function SliderZoomModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = SliderZoomModel2.type;
        return _this;
      }
      SliderZoomModel2.type = "dataZoom.slider";
      SliderZoomModel2.layoutMode = "box";
      SliderZoomModel2.defaultOption = inheritDefaultOption(DataZoomModel.defaultOption, {
        show: true,
        // deault value can only be drived in view stage.
        right: "ph",
        top: "ph",
        width: "ph",
        height: "ph",
        left: null,
        bottom: null,
        borderColor: tokens.color.accent10,
        borderRadius: 0,
        backgroundColor: tokens.color.transparent,
        // dataBackgroundColor: '#ddd',
        dataBackground: {
          lineStyle: {
            color: tokens.color.accent30,
            width: 0.5
          },
          areaStyle: {
            color: tokens.color.accent20,
            opacity: 0.2
          }
        },
        selectedDataBackground: {
          lineStyle: {
            color: tokens.color.accent40,
            width: 0.5
          },
          areaStyle: {
            color: tokens.color.accent20,
            opacity: 0.3
          }
        },
        // Color of selected window.
        fillerColor: "rgba(135,175,274,0.2)",
        handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
        // Percent of the slider height
        handleSize: "100%",
        handleStyle: {
          color: tokens.color.neutral00,
          borderColor: tokens.color.accent20
        },
        moveHandleSize: 7,
        moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
        moveHandleStyle: {
          color: tokens.color.accent40,
          opacity: 0.5
        },
        showDetail: true,
        showDataShadow: "auto",
        realtime: true,
        zoomLock: false,
        textStyle: {
          color: tokens.color.tertiary
        },
        brushSelect: true,
        brushStyle: {
          color: tokens.color.accent30,
          opacity: 0.3
        },
        emphasis: {
          handleLabel: {
            show: true
          },
          handleStyle: {
            borderColor: tokens.color.accent40
          },
          moveHandleStyle: {
            opacity: 0.8
          }
        },
        defaultLocationEdgeGap: 15
      });
      return SliderZoomModel2;
    }(DataZoomModel)
  );
  var define_process_env_default = {};
  var Rect = Rect$1;
  var DEFAULT_FRAME_BORDER_WIDTH = 1;
  var DEFAULT_FILLER_SIZE = 30;
  var DEFAULT_MOVE_HANDLE_SIZE = 7;
  var HORIZONTAL = "horizontal";
  var VERTICAL = "vertical";
  var LABEL_GAP = 5;
  var SHOW_DATA_SHADOW_SERIES_TYPE = ["line", "bar", "candlestick", "scatter"];
  var REALTIME_ANIMATION_CONFIG = {
    easing: "cubicOut",
    duration: 100,
    delay: 0
  };
  var SliderZoomView = (
    /** @class */
    function(_super) {
      __extends(SliderZoomView2, _super);
      function SliderZoomView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = SliderZoomView2.type;
        _this._displayables = {};
        return _this;
      }
      SliderZoomView2.prototype.init = function(ecModel, api) {
        this.api = api;
        this._onBrush = bind$1(this._onBrush, this);
        this._onBrushEnd = bind$1(this._onBrushEnd, this);
      };
      SliderZoomView2.prototype.render = function(dataZoomModel, ecModel, api, payload) {
        _super.prototype.render.apply(this, arguments);
        createOrUpdate(this, "_dispatchZoomAction", dataZoomModel.get("throttle"), "fixRate");
        this._orient = dataZoomModel.getOrient();
        if (dataZoomModel.get("show") === false) {
          this.group.removeAll();
          return;
        }
        if (dataZoomModel.noTarget()) {
          this._clear();
          this.group.removeAll();
          return;
        }
        if (!payload || payload.type !== "dataZoom" || payload.from !== this.uid) {
          this._buildView();
        }
        this._updateView();
      };
      SliderZoomView2.prototype.dispose = function() {
        this._clear();
        _super.prototype.dispose.apply(this, arguments);
      };
      SliderZoomView2.prototype._clear = function() {
        clear(this, "_dispatchZoomAction");
        var zr = this.api.getZr();
        zr.off("mousemove", this._onBrush);
        zr.off("mouseup", this._onBrushEnd);
      };
      SliderZoomView2.prototype._buildView = function() {
        var thisGroup = this.group;
        thisGroup.removeAll();
        this._brushing = false;
        this._displayables.brushRect = null;
        this._resetLocation();
        this._resetInterval();
        var barGroup = this._displayables.sliderGroup = new Group$2();
        this._renderBackground();
        this._renderHandle();
        this._renderDataShadow();
        thisGroup.add(barGroup);
        this._positionGroup();
      };
      SliderZoomView2.prototype._resetLocation = function() {
        var dataZoomModel = this.dataZoomModel;
        var api = this.api;
        var showMoveHandle = dataZoomModel.get("brushSelect");
        var moveHandleSize = showMoveHandle ? DEFAULT_MOVE_HANDLE_SIZE : 0;
        var refContainer = createBoxLayoutReference(dataZoomModel, api).refContainer;
        var coordRect = this._findCoordRect();
        var edgeGap = dataZoomModel.get("defaultLocationEdgeGap", true) || 0;
        var positionInfo = this._orient === HORIZONTAL ? {
          // Why using 'right', because right should be used in vertical,
          // and it is better to be consistent for dealing with position param merge.
          right: refContainer.width - coordRect.x - coordRect.width,
          top: refContainer.height - DEFAULT_FILLER_SIZE - edgeGap - moveHandleSize,
          width: coordRect.width,
          height: DEFAULT_FILLER_SIZE
        } : {
          right: edgeGap,
          top: coordRect.y,
          width: DEFAULT_FILLER_SIZE,
          height: coordRect.height
        };
        var layoutParams = getLayoutParams(dataZoomModel.option);
        each$5(["right", "top", "width", "height"], function(name) {
          if (layoutParams[name] === "ph") {
            layoutParams[name] = positionInfo[name];
          }
        });
        var layoutRect = getLayoutRect(layoutParams, refContainer);
        this._location = {
          x: layoutRect.x,
          y: layoutRect.y
        };
        this._size = [layoutRect.width, layoutRect.height];
        this._orient === VERTICAL && this._size.reverse();
      };
      SliderZoomView2.prototype._positionGroup = function() {
        var thisGroup = this.group;
        var location = this._location;
        var orient = this._orient;
        var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();
        var inverse = targetAxisModel && targetAxisModel.get("inverse");
        var sliderGroup = this._displayables.sliderGroup;
        var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse;
        sliderGroup.attr(orient === HORIZONTAL && !inverse ? {
          scaleY: otherAxisInverse ? 1 : -1,
          scaleX: 1
        } : orient === HORIZONTAL && inverse ? {
          scaleY: otherAxisInverse ? 1 : -1,
          scaleX: -1
        } : orient === VERTICAL && !inverse ? {
          scaleY: otherAxisInverse ? -1 : 1,
          scaleX: 1,
          rotation: Math.PI / 2
        } : {
          scaleY: otherAxisInverse ? -1 : 1,
          scaleX: -1,
          rotation: Math.PI / 2
        });
        var rect = thisGroup.getBoundingRect([sliderGroup]);
        thisGroup.x = location.x - rect.x;
        thisGroup.y = location.y - rect.y;
        thisGroup.markRedraw();
      };
      SliderZoomView2.prototype._getViewExtent = function() {
        return [0, this._size[0]];
      };
      SliderZoomView2.prototype._renderBackground = function() {
        var dataZoomModel = this.dataZoomModel;
        var size = this._size;
        var barGroup = this._displayables.sliderGroup;
        var brushSelect = dataZoomModel.get("brushSelect");
        barGroup.add(new Rect({
          silent: true,
          shape: {
            x: 0,
            y: 0,
            width: size[0],
            height: size[1]
          },
          style: {
            fill: dataZoomModel.get("backgroundColor")
          },
          z2: -40
        }));
        var clickPanel = new Rect({
          shape: {
            x: 0,
            y: 0,
            width: size[0],
            height: size[1]
          },
          style: {
            fill: "transparent"
          },
          z2: 0,
          onclick: bind$1(this._onClickPanel, this)
        });
        var zr = this.api.getZr();
        if (brushSelect) {
          clickPanel.on("mousedown", this._onBrushStart, this);
          clickPanel.cursor = "crosshair";
          zr.on("mousemove", this._onBrush);
          zr.on("mouseup", this._onBrushEnd);
        } else {
          zr.off("mousemove", this._onBrush);
          zr.off("mouseup", this._onBrushEnd);
        }
        barGroup.add(clickPanel);
      };
      SliderZoomView2.prototype._renderDataShadow = function() {
        var info = this._dataShadowInfo = this._prepareDataShadowInfo();
        this._displayables.dataShadowSegs = [];
        if (!info) {
          return;
        }
        var size = this._size;
        var oldSize = this._shadowSize || [];
        var seriesModel = info.series;
        var data = seriesModel.getRawData();
        var candlestickDim = seriesModel.getShadowDim && seriesModel.getShadowDim();
        var otherDim = candlestickDim && data.getDimensionInfo(candlestickDim) ? seriesModel.getShadowDim() : info.otherDim;
        if (otherDim == null) {
          return;
        }
        var polygonPts = this._shadowPolygonPts;
        var polylinePts = this._shadowPolylinePts;
        if (data !== this._shadowData || otherDim !== this._shadowDim || size[0] !== oldSize[0] || size[1] !== oldSize[1]) {
          var thisDataExtent_1 = data.getDataExtent(info.thisDim);
          var otherDataExtent_1 = data.getDataExtent(otherDim);
          var otherOffset = (otherDataExtent_1[1] - otherDataExtent_1[0]) * 0.3;
          otherDataExtent_1 = [otherDataExtent_1[0] - otherOffset, otherDataExtent_1[1] + otherOffset];
          var otherShadowExtent_1 = [0, size[1]];
          var thisShadowExtent = [0, size[0]];
          var areaPoints_1 = [[size[0], 0], [0, 0]];
          var linePoints_1 = [];
          var step_1 = thisShadowExtent[1] / Math.max(1, data.count() - 1);
          var normalizationConstant_1 = size[0] / (thisDataExtent_1[1] - thisDataExtent_1[0]);
          var isTimeAxis_1 = info.thisAxis.type === "time";
          var thisCoord_1 = -step_1;
          var stride_1 = Math.round(data.count() / size[0]);
          var lastIsEmpty_1;
          data.each([info.thisDim, otherDim], function(thisValue, otherValue, index2) {
            if (stride_1 > 0 && index2 % stride_1) {
              if (!isTimeAxis_1) {
                thisCoord_1 += step_1;
              }
              return;
            }
            thisCoord_1 = isTimeAxis_1 ? (+thisValue - thisDataExtent_1[0]) * normalizationConstant_1 : thisCoord_1 + step_1;
            var isEmpty = otherValue == null || isNaN(otherValue) || otherValue === "";
            var otherCoord = isEmpty ? 0 : linearMap(otherValue, otherDataExtent_1, otherShadowExtent_1, true);
            if (isEmpty && !lastIsEmpty_1 && index2) {
              areaPoints_1.push([areaPoints_1[areaPoints_1.length - 1][0], 0]);
              linePoints_1.push([linePoints_1[linePoints_1.length - 1][0], 0]);
            } else if (!isEmpty && lastIsEmpty_1) {
              areaPoints_1.push([thisCoord_1, 0]);
              linePoints_1.push([thisCoord_1, 0]);
            }
            if (!isEmpty) {
              areaPoints_1.push([thisCoord_1, otherCoord]);
              linePoints_1.push([thisCoord_1, otherCoord]);
            }
            lastIsEmpty_1 = isEmpty;
          });
          polygonPts = this._shadowPolygonPts = areaPoints_1;
          polylinePts = this._shadowPolylinePts = linePoints_1;
        }
        this._shadowData = data;
        this._shadowDim = otherDim;
        this._shadowSize = [size[0], size[1]];
        var dataZoomModel = this.dataZoomModel;
        function createDataShadowGroup(isSelectedArea) {
          var model = dataZoomModel.getModel(isSelectedArea ? "selectedDataBackground" : "dataBackground");
          var group2 = new Group$2();
          var polygon = new Polygon({
            shape: {
              points: polygonPts
            },
            segmentIgnoreThreshold: 1,
            style: model.getModel("areaStyle").getAreaStyle(),
            silent: true,
            z2: -20
          });
          var polyline = new Polyline({
            shape: {
              points: polylinePts
            },
            segmentIgnoreThreshold: 1,
            style: model.getModel("lineStyle").getLineStyle(),
            silent: true,
            z2: -19
          });
          group2.add(polygon);
          group2.add(polyline);
          return group2;
        }
        for (var i = 0; i < 3; i++) {
          var group = createDataShadowGroup(i === 1);
          this._displayables.sliderGroup.add(group);
          this._displayables.dataShadowSegs.push(group);
        }
      };
      SliderZoomView2.prototype._prepareDataShadowInfo = function() {
        var dataZoomModel = this.dataZoomModel;
        var showDataShadow = dataZoomModel.get("showDataShadow");
        if (showDataShadow === false) {
          return;
        }
        var result;
        var ecModel = this.ecModel;
        dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
          var seriesModels = dataZoomModel.getAxisProxy(axisDim, axisIndex).getTargetSeriesModels();
          each$5(seriesModels, function(seriesModel) {
            if (result) {
              return;
            }
            if (showDataShadow !== true && indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get("type")) < 0) {
              return;
            }
            var thisAxis = ecModel.getComponent(getAxisMainType(axisDim), axisIndex).axis;
            var otherDim = getOtherDim(axisDim);
            var otherAxisInverse;
            var coordSys = seriesModel.coordinateSystem;
            if (otherDim != null && coordSys.getOtherAxis) {
              otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;
            }
            otherDim = seriesModel.getData().mapDimension(otherDim);
            var thisDim = seriesModel.getData().mapDimension(axisDim);
            result = {
              thisAxis,
              series: seriesModel,
              thisDim,
              otherDim,
              otherAxisInverse
            };
          }, this);
        }, this);
        return result;
      };
      SliderZoomView2.prototype._renderHandle = function() {
        var thisGroup = this.group;
        var displayables = this._displayables;
        var handles = displayables.handles = [null, null];
        var handleLabels = displayables.handleLabels = [null, null];
        var sliderGroup = this._displayables.sliderGroup;
        var size = this._size;
        var dataZoomModel = this.dataZoomModel;
        var api = this.api;
        var borderRadius = dataZoomModel.get("borderRadius") || 0;
        var brushSelect = dataZoomModel.get("brushSelect");
        var filler = displayables.filler = new Rect({
          silent: brushSelect,
          style: {
            fill: dataZoomModel.get("fillerColor")
          },
          textConfig: {
            position: "inside"
          }
        });
        sliderGroup.add(filler);
        sliderGroup.add(new Rect({
          silent: true,
          subPixelOptimize: true,
          shape: {
            x: 0,
            y: 0,
            width: size[0],
            height: size[1],
            r: borderRadius
          },
          style: {
            // deprecated option
            stroke: dataZoomModel.get("dataBackgroundColor") || dataZoomModel.get("borderColor"),
            lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
            fill: tokens.color.transparent
          }
        }));
        each$5([0, 1], function(handleIndex) {
          var iconStr = dataZoomModel.get("handleIcon");
          if (!symbolBuildProxies[iconStr] && iconStr.indexOf("path://") < 0 && iconStr.indexOf("image://") < 0) {
            iconStr = "path://" + iconStr;
            if (define_process_env_default.NODE_ENV !== "production") {
              deprecateLog("handleIcon now needs 'path://' prefix when using a path string");
            }
          }
          var path = createSymbol(iconStr, -1, 0, 2, 2, null, true);
          path.attr({
            cursor: getCursor(this._orient),
            draggable: true,
            drift: bind$1(this._onDragMove, this, handleIndex),
            ondragend: bind$1(this._onDragEnd, this),
            onmouseover: bind$1(this._showDataInfo, this, true),
            onmouseout: bind$1(this._showDataInfo, this, false),
            z2: 5
          });
          var bRect = path.getBoundingRect();
          var handleSize = dataZoomModel.get("handleSize");
          this._handleHeight = parsePercent(handleSize, this._size[1]);
          this._handleWidth = bRect.width / bRect.height * this._handleHeight;
          path.setStyle(dataZoomModel.getModel("handleStyle").getItemStyle());
          path.style.strokeNoScale = true;
          path.rectHover = true;
          path.ensureState("emphasis").style = dataZoomModel.getModel(["emphasis", "handleStyle"]).getItemStyle();
          enableHoverEmphasis(path);
          var handleColor = dataZoomModel.get("handleColor");
          if (handleColor != null) {
            path.style.fill = handleColor;
          }
          sliderGroup.add(handles[handleIndex] = path);
          var textStyleModel = dataZoomModel.getModel("textStyle");
          var handleLabel = dataZoomModel.get("handleLabel") || {};
          var handleLabelShow = handleLabel.show || false;
          thisGroup.add(handleLabels[handleIndex] = new ZRText({
            silent: true,
            invisible: !handleLabelShow,
            style: createTextStyle(textStyleModel, {
              x: 0,
              y: 0,
              text: "",
              verticalAlign: "middle",
              align: "center",
              fill: textStyleModel.getTextColor(),
              font: textStyleModel.getFont()
            }),
            z2: 10
          }));
        }, this);
        var actualMoveZone = filler;
        if (brushSelect) {
          var moveHandleHeight = parsePercent(dataZoomModel.get("moveHandleSize"), size[1]);
          var moveHandle_1 = displayables.moveHandle = new Rect$1({
            style: dataZoomModel.getModel("moveHandleStyle").getItemStyle(),
            silent: true,
            shape: {
              r: [0, 0, 2, 2],
              y: size[1] - 0.5,
              height: moveHandleHeight
            }
          });
          var iconSize = moveHandleHeight * 0.8;
          var moveHandleIcon = displayables.moveHandleIcon = createSymbol(dataZoomModel.get("moveHandleIcon"), -iconSize / 2, -iconSize / 2, iconSize, iconSize, tokens.color.neutral00, true);
          moveHandleIcon.silent = true;
          moveHandleIcon.y = size[1] + moveHandleHeight / 2 - 0.5;
          moveHandle_1.ensureState("emphasis").style = dataZoomModel.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
          var moveZoneExpandSize = Math.min(size[1] / 2, Math.max(moveHandleHeight, 10));
          actualMoveZone = displayables.moveZone = new Rect$1({
            invisible: true,
            shape: {
              y: size[1] - moveZoneExpandSize,
              height: moveHandleHeight + moveZoneExpandSize
            }
          });
          actualMoveZone.on("mouseover", function() {
            api.enterEmphasis(moveHandle_1);
          }).on("mouseout", function() {
            api.leaveEmphasis(moveHandle_1);
          });
          sliderGroup.add(moveHandle_1);
          sliderGroup.add(moveHandleIcon);
          sliderGroup.add(actualMoveZone);
        }
        actualMoveZone.attr({
          draggable: true,
          cursor: "default",
          drift: bind$1(this._onDragMove, this, "all"),
          ondragstart: bind$1(this._showDataInfo, this, true),
          ondragend: bind$1(this._onDragEnd, this),
          onmouseover: bind$1(this._showDataInfo, this, true),
          onmouseout: bind$1(this._showDataInfo, this, false)
        });
      };
      SliderZoomView2.prototype._resetInterval = function() {
        var range = this._range = this.dataZoomModel.getPercentRange();
        var viewExtent = this._getViewExtent();
        this._handleEnds = [linearMap(range[0], [0, 100], viewExtent, true), linearMap(range[1], [0, 100], viewExtent, true)];
      };
      SliderZoomView2.prototype._updateInterval = function(handleIndex, delta) {
        var dataZoomModel = this.dataZoomModel;
        var handleEnds = this._handleEnds;
        var viewExtend = this._getViewExtent();
        var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
        var percentExtent = [0, 100];
        sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get("zoomLock") ? "all" : handleIndex, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);
        var lastRange = this._range;
        var range = this._range = asc$1([linearMap(handleEnds[0], viewExtend, percentExtent, true), linearMap(handleEnds[1], viewExtend, percentExtent, true)]);
        return !lastRange || lastRange[0] !== range[0] || lastRange[1] !== range[1];
      };
      SliderZoomView2.prototype._updateView = function(nonRealtime) {
        var displaybles = this._displayables;
        var handleEnds = this._handleEnds;
        var handleInterval = asc$1(handleEnds.slice());
        var size = this._size;
        each$5([0, 1], function(handleIndex) {
          var handle = displaybles.handles[handleIndex];
          var handleHeight = this._handleHeight;
          handle.attr({
            scaleX: handleHeight / 2,
            scaleY: handleHeight / 2,
            // This is a trick, by adding an extra tiny offset to let the default handle's end point align to the drag window.
            // NOTE: It may affect some custom shapes a bit. But we prefer to have better result by default.
            x: handleEnds[handleIndex] + (handleIndex ? -1 : 1),
            y: size[1] / 2 - handleHeight / 2
          });
        }, this);
        displaybles.filler.setShape({
          x: handleInterval[0],
          y: 0,
          width: handleInterval[1] - handleInterval[0],
          height: size[1]
        });
        var viewExtent = {
          x: handleInterval[0],
          width: handleInterval[1] - handleInterval[0]
        };
        if (displaybles.moveHandle) {
          displaybles.moveHandle.setShape(viewExtent);
          displaybles.moveZone.setShape(viewExtent);
          displaybles.moveZone.getBoundingRect();
          displaybles.moveHandleIcon && displaybles.moveHandleIcon.attr("x", viewExtent.x + viewExtent.width / 2);
        }
        var dataShadowSegs = displaybles.dataShadowSegs;
        var segIntervals = [0, handleInterval[0], handleInterval[1], size[0]];
        for (var i = 0; i < dataShadowSegs.length; i++) {
          var segGroup = dataShadowSegs[i];
          var clipPath = segGroup.getClipPath();
          if (!clipPath) {
            clipPath = new Rect$1();
            segGroup.setClipPath(clipPath);
          }
          clipPath.setShape({
            x: segIntervals[i],
            y: 0,
            width: segIntervals[i + 1] - segIntervals[i],
            height: size[1]
          });
        }
        this._updateDataInfo(nonRealtime);
      };
      SliderZoomView2.prototype._updateDataInfo = function(nonRealtime) {
        var dataZoomModel = this.dataZoomModel;
        var displaybles = this._displayables;
        var handleLabels = displaybles.handleLabels;
        var orient = this._orient;
        var labelTexts = ["", ""];
        if (dataZoomModel.get("showDetail")) {
          var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
          if (axisProxy) {
            var axis = axisProxy.getAxisModel().axis;
            var range = this._range;
            var dataInterval = nonRealtime ? axisProxy.calculateDataWindow({
              start: range[0],
              end: range[1]
            }).valueWindow : axisProxy.getDataValueWindow();
            labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];
          }
        }
        var orderedHandleEnds = asc$1(this._handleEnds.slice());
        setLabel.call(this, 0);
        setLabel.call(this, 1);
        function setLabel(handleIndex) {
          var barTransform = getTransform(displaybles.handles[handleIndex].parent, this.group);
          var direction = transformDirection(handleIndex === 0 ? "right" : "left", barTransform);
          var offset = this._handleWidth / 2 + LABEL_GAP;
          var textPoint = applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);
          handleLabels[handleIndex].setStyle({
            x: textPoint[0],
            y: textPoint[1],
            verticalAlign: orient === HORIZONTAL ? "middle" : direction,
            align: orient === HORIZONTAL ? direction : "center",
            text: labelTexts[handleIndex]
          });
        }
      };
      SliderZoomView2.prototype._formatLabel = function(value, axis) {
        var dataZoomModel = this.dataZoomModel;
        var labelFormatter = dataZoomModel.get("labelFormatter");
        var labelPrecision = dataZoomModel.get("labelPrecision");
        if (labelPrecision == null || labelPrecision === "auto") {
          labelPrecision = axis.getPixelPrecision();
        }
        var valueStr = value == null || isNaN(value) ? "" : axis.type === "category" || axis.type === "time" ? axis.scale.getLabel({
          value: Math.round(value)
        }) : value.toFixed(Math.min(labelPrecision, 20));
        return isFunction(labelFormatter) ? labelFormatter(value, valueStr) : isString(labelFormatter) ? labelFormatter.replace("{value}", valueStr) : valueStr;
      };
      SliderZoomView2.prototype._showDataInfo = function(isEmphasis) {
        var handleLabel = this.dataZoomModel.get("handleLabel") || {};
        var normalShow = handleLabel.show || false;
        var emphasisHandleLabel = this.dataZoomModel.getModel(["emphasis", "handleLabel"]);
        var emphasisShow = emphasisHandleLabel.get("show") || false;
        var toShow = isEmphasis || this._dragging ? emphasisShow : normalShow;
        var displayables = this._displayables;
        var handleLabels = displayables.handleLabels;
        handleLabels[0].attr("invisible", !toShow);
        handleLabels[1].attr("invisible", !toShow);
        displayables.moveHandle && this.api[toShow ? "enterEmphasis" : "leaveEmphasis"](displayables.moveHandle, 1);
      };
      SliderZoomView2.prototype._onDragMove = function(handleIndex, dx, dy, event) {
        this._dragging = true;
        stop(event.event);
        var barTransform = this._displayables.sliderGroup.getLocalTransform();
        var vertex = applyTransform([dx, dy], barTransform, true);
        var changed = this._updateInterval(handleIndex, vertex[0]);
        var realtime = this.dataZoomModel.get("realtime");
        this._updateView(!realtime);
        changed && realtime && this._dispatchZoomAction(true);
      };
      SliderZoomView2.prototype._onDragEnd = function() {
        this._dragging = false;
        this._showDataInfo(false);
        var realtime = this.dataZoomModel.get("realtime");
        !realtime && this._dispatchZoomAction(false);
      };
      SliderZoomView2.prototype._onClickPanel = function(e2) {
        var size = this._size;
        var localPoint = this._displayables.sliderGroup.transformCoordToLocal(e2.offsetX, e2.offsetY);
        if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {
          return;
        }
        var handleEnds = this._handleEnds;
        var center2 = (handleEnds[0] + handleEnds[1]) / 2;
        var changed = this._updateInterval("all", localPoint[0] - center2);
        this._updateView();
        changed && this._dispatchZoomAction(false);
      };
      SliderZoomView2.prototype._onBrushStart = function(e2) {
        var x = e2.offsetX;
        var y = e2.offsetY;
        this._brushStart = new Point(x, y);
        this._brushing = true;
        this._brushStartTime = +/* @__PURE__ */ new Date();
      };
      SliderZoomView2.prototype._onBrushEnd = function(e2) {
        if (!this._brushing) {
          return;
        }
        var brushRect = this._displayables.brushRect;
        this._brushing = false;
        if (!brushRect) {
          return;
        }
        brushRect.attr("ignore", true);
        var brushShape = brushRect.shape;
        var brushEndTime = +/* @__PURE__ */ new Date();
        if (brushEndTime - this._brushStartTime < 200 && Math.abs(brushShape.width) < 5) {
          return;
        }
        var viewExtend = this._getViewExtent();
        var percentExtent = [0, 100];
        var handleEnds = this._handleEnds = [brushShape.x, brushShape.x + brushShape.width];
        var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
        sliderMove(0, handleEnds, viewExtend, 0, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);
        this._range = asc$1([linearMap(handleEnds[0], viewExtend, percentExtent, true), linearMap(handleEnds[1], viewExtend, percentExtent, true)]);
        this._updateView();
        this._dispatchZoomAction(false);
      };
      SliderZoomView2.prototype._onBrush = function(e2) {
        if (this._brushing) {
          stop(e2.event);
          this._updateBrushRect(e2.offsetX, e2.offsetY);
        }
      };
      SliderZoomView2.prototype._updateBrushRect = function(mouseX, mouseY) {
        var displayables = this._displayables;
        var dataZoomModel = this.dataZoomModel;
        var brushRect = displayables.brushRect;
        if (!brushRect) {
          brushRect = displayables.brushRect = new Rect({
            silent: true,
            style: dataZoomModel.getModel("brushStyle").getItemStyle()
          });
          displayables.sliderGroup.add(brushRect);
        }
        brushRect.attr("ignore", false);
        var brushStart = this._brushStart;
        var sliderGroup = this._displayables.sliderGroup;
        var endPoint = sliderGroup.transformCoordToLocal(mouseX, mouseY);
        var startPoint = sliderGroup.transformCoordToLocal(brushStart.x, brushStart.y);
        var size = this._size;
        endPoint[0] = Math.max(Math.min(size[0], endPoint[0]), 0);
        brushRect.setShape({
          x: startPoint[0],
          y: 0,
          width: endPoint[0] - startPoint[0],
          height: size[1]
        });
      };
      SliderZoomView2.prototype._dispatchZoomAction = function(realtime) {
        var range = this._range;
        this.api.dispatchAction({
          type: "dataZoom",
          from: this.uid,
          dataZoomId: this.dataZoomModel.id,
          animation: realtime ? REALTIME_ANIMATION_CONFIG : null,
          start: range[0],
          end: range[1]
        });
      };
      SliderZoomView2.prototype._findCoordRect = function() {
        var rect;
        var coordSysInfoList = collectReferCoordSysModelInfo(this.dataZoomModel).infoList;
        if (!rect && coordSysInfoList.length) {
          var coordSys = coordSysInfoList[0].model.coordinateSystem;
          rect = coordSys.getRect && coordSys.getRect();
        }
        if (!rect) {
          var width = this.api.getWidth();
          var height = this.api.getHeight();
          rect = {
            x: width * 0.2,
            y: height * 0.2,
            width: width * 0.6,
            height: height * 0.6
          };
        }
        return rect;
      };
      SliderZoomView2.type = "dataZoom.slider";
      return SliderZoomView2;
    }(DataZoomView)
  );
  function getOtherDim(thisDim) {
    var map2 = {
      x: "y",
      y: "x",
      radius: "angle",
      angle: "radius"
    };
    return map2[thisDim];
  }
  function getCursor(orient) {
    return orient === "vertical" ? "ns-resize" : "ew-resize";
  }
  function install$1(registers) {
    registers.registerComponentModel(SliderZoomModel);
    registers.registerComponentView(SliderZoomView);
    installCommon(registers);
  }
  function install(registers) {
    use(install$2);
    use(install$1);
  }
  const METHOD_NAMES = [
    "getWidth",
    "getHeight",
    "getDom",
    "getOption",
    "resize",
    "dispatchAction",
    "convertToPixel",
    "convertFromPixel",
    "containPixel",
    "getDataURL",
    "getConnectedDataURL",
    "appendData",
    "clear",
    "isDisposed",
    "dispose"
  ];
  function usePublicAPI(chart) {
    function makePublicMethod(name) {
      const fn = function(...args) {
        if (!chart.value) throw new Error("ECharts is not initialized yet.");
        return Reflect.apply(chart.value[name], chart.value, args);
      };
      return fn;
    }
    return METHOD_NAMES.reduce((acc, name) => {
      acc[name] = makePublicMethod(name);
      return acc;
    }, {});
  }
  function useAutoresize(chart, autoresize, root) {
    vue.watch([
      root,
      chart,
      autoresize
    ], ([root$1, chart$1, autoresize$1], _, onCleanup) => {
      let ro = null;
      if (root$1 && chart$1 && autoresize$1) {
        const { offsetWidth, offsetHeight } = root$1;
        const { throttle: wait = 100, onResize } = autoresize$1 === true ? {} : autoresize$1;
        let initialResizeTriggered = false;
        const callback = () => {
          chart$1.resize();
          onResize == null ? void 0 : onResize();
        };
        const resizeCallback = wait ? throttle(callback, wait) : callback;
        ro = new ResizeObserver(() => {
          if (!initialResizeTriggered) {
            initialResizeTriggered = true;
            if (root$1.offsetWidth === offsetWidth && root$1.offsetHeight === offsetHeight) return;
          }
          if (root$1.offsetWidth === 0 || root$1.offsetHeight === 0) return;
          resizeCallback();
        });
        ro.observe(root$1);
      }
      onCleanup(() => {
        if (ro) {
          ro.disconnect();
          ro = null;
        }
      });
    });
  }
  const autoresizeProps = { autoresize: [Boolean, Object] };
  const LOADING_OPTIONS_KEY = Symbol();
  function useLoading(chart, loading, loadingOptions) {
    const defaultLoadingOptions = vue.inject(LOADING_OPTIONS_KEY, {});
    const realLoadingOptions = vue.computed(() => ({
      ...vue.toValue(defaultLoadingOptions),
      ...loadingOptions == null ? void 0 : loadingOptions.value
    }));
    vue.watchEffect(() => {
      const instance = chart.value;
      if (!instance) return;
      if (loading.value) instance.showLoading(realLoadingOptions.value);
      else instance.hideLoading();
    });
  }
  const loadingProps = {
    loading: Boolean,
    loadingOptions: Object
  };
  function isBrowser() {
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  const onRE = /^on[^a-z]/;
  const isOn = (key2) => onRE.test(key2);
  function omitOn(attrs) {
    const result = {};
    for (const key2 in attrs) if (!isOn(key2)) result[key2] = attrs[key2];
    return result;
  }
  function isValidArrayIndex(key2) {
    const num = Number(key2);
    return Number.isInteger(num) && num >= 0 && num < Math.pow(2, 32) - 1 && String(num) === key2;
  }
  function isSameSet(a, b) {
    const setA = new Set(a);
    const setB = new Set(b);
    if (setA.size !== setB.size) return false;
    for (const val of setA) if (!setB.has(val)) return false;
    return true;
  }
  function isPlainObject(v) {
    return v != null && typeof v === "object" && !Array.isArray(v);
  }
  const LOG_PREFIX = "[vue-echarts]";
  function warn$1(message) {
    vue.warn(`${LOG_PREFIX} ${message}`);
  }
  const SLOT_OPTION_PATHS = {
    tooltip: ["tooltip", "formatter"],
    dataView: [
      "toolbox",
      "feature",
      "dataView",
      "optionToContent"
    ]
  };
  const SLOT_PREFIXES = Object.keys(SLOT_OPTION_PATHS);
  function isValidSlotName(key2) {
    return SLOT_PREFIXES.some((slotPrefix) => key2 === slotPrefix || key2.startsWith(slotPrefix + "-"));
  }
  function useSlotOption(slots, onSlotsChange) {
    const detachedRoot = isBrowser() ? document.createElement("div") : void 0;
    const containers = vue.shallowReactive({});
    const initialized = vue.shallowReactive({});
    const params = vue.shallowReactive({});
    const isMounted = vue.shallowRef(false);
    const teleportedSlots = () => {
      return isMounted.value && detachedRoot ? vue.h(vue.Teleport, { to: detachedRoot }, Object.entries(slots).filter(([key2]) => isValidSlotName(key2)).map(([key2, slot]) => {
        const slotName = key2;
        return vue.h("div", {
          ref: (el) => {
            if (el instanceof HTMLElement) containers[slotName] = el;
          },
          style: { display: "contents" }
        }, initialized[slotName] ? slot == null ? void 0 : slot(params[slotName]) : void 0);
      })) : void 0;
    };
    function isObject2(val) {
      return val !== null && typeof val === "object" && !Array.isArray(val);
    }
    function patchOption(src) {
      const root = { ...src };
      const ensureChild = (parent, seg) => {
        const next = parent[seg];
        if (Array.isArray(next)) {
          parent[seg] = [...next];
          return parent[seg];
        }
        if (isObject2(next)) {
          parent[seg] = { ...next };
          return parent[seg];
        }
        if (next === void 0) {
          parent[seg] = isValidArrayIndex(seg) ? [] : {};
          return parent[seg];
        }
      };
      Object.keys(slots).filter((key2) => {
        const valid = isValidSlotName(key2);
        if (!valid) warn$1(`Invalid slot name: ${key2}`);
        return valid;
      }).forEach((key2) => {
        const [prefix, ...rest] = key2.split("-");
        const tail = SLOT_OPTION_PATHS[prefix];
        if (!tail) return;
        const path = [...rest, ...tail];
        if (path.length === 0) return;
        let cur = root;
        for (let i = 0; i < path.length - 1; i++) {
          cur = ensureChild(cur, path[i]);
          if (!cur) return;
        }
        cur[path[path.length - 1]] = (p) => {
          initialized[key2] = true;
          params[key2] = p;
          return containers[key2];
        };
      });
      return root;
    }
    let slotNames = [];
    vue.onUpdated(() => {
      const newSlotNames = Object.keys(slots).filter(isValidSlotName);
      if (!isSameSet(newSlotNames, slotNames)) {
        slotNames.forEach((key2) => {
          if (!newSlotNames.includes(key2)) {
            delete params[key2];
            delete initialized[key2];
            delete containers[key2];
          }
        });
        slotNames = newSlotNames;
        onSlotsChange();
      }
    });
    vue.onMounted(() => {
      isMounted.value = true;
    });
    vue.onUnmounted(() => {
      detachedRoot == null ? void 0 : detachedRoot.remove();
    });
    return {
      teleportedSlots,
      patchOption
    };
  }
  let registered = null;
  const TAG_NAME = "x-vue-echarts";
  function register() {
    if (registered != null) return registered;
    const registry = globalThis.customElements;
    if (!isBrowser() || !(registry == null ? void 0 : registry.get)) {
      registered = false;
      return registered;
    }
    if (!registry.get(TAG_NAME)) try {
      class ECElement extends HTMLElement {
        constructor() {
          super(...arguments);
          __publicField(this, "__dispose", null);
        }
        disconnectedCallback() {
          if (this.__dispose) {
            this.__dispose();
            this.__dispose = null;
          }
        }
      }
      registry.define(TAG_NAME, ECElement);
    } catch {
      registered = false;
      return registered;
    }
    registered = true;
    return registered;
  }
  function readId(item) {
    if (!isPlainObject(item)) return;
    const raw = item.id;
    if (typeof raw === "string") return raw;
    if (typeof raw === "number" && Number.isFinite(raw)) return String(raw);
  }
  function buildSignature(option) {
    const opt = option;
    const optionsLength = Array.isArray(opt.options) ? opt.options.length : 0;
    const mediaLength = Array.isArray(opt.media) ? opt.media.length : 0;
    const arrays = /* @__PURE__ */ Object.create(null);
    const objects = [];
    const scalars = [];
    for (const key2 of Object.keys(opt)) {
      if (key2 === "options" || key2 === "media") continue;
      const value = opt[key2];
      if (Array.isArray(value)) {
        const items = value;
        const ids = /* @__PURE__ */ new Set();
        let noIdCount = 0;
        for (let i = 0; i < items.length; i++) {
          const id = readId(items[i]);
          if (id !== void 0) ids.add(id);
          else noIdCount++;
        }
        arrays[key2] = {
          idsSorted: ids.size > 0 ? Array.from(ids).sort() : [],
          noIdCount
        };
      } else if (isPlainObject(value)) objects.push(key2);
      else if (value !== void 0) scalars.push(key2);
    }
    if (objects.length > 1) objects.sort();
    if (scalars.length > 1) scalars.sort();
    return {
      optionsLength,
      mediaLength,
      arrays,
      objects,
      scalars
    };
  }
  function diffKeys(prevKeys, nextKeys) {
    if (prevKeys.length === 0) return [];
    if (nextKeys.length === 0) return prevKeys.slice();
    const nextSet = new Set(nextKeys);
    const missing = [];
    for (let i = 0; i < prevKeys.length; i++) {
      const key2 = prevKeys[i];
      if (!nextSet.has(key2)) missing.push(key2);
    }
    return missing;
  }
  function hasMissingIds(prevIds, nextIds) {
    if (prevIds.length === 0) return false;
    if (nextIds.length === 0) return true;
    const nextSet = new Set(nextIds);
    for (let i = 0; i < prevIds.length; i++) if (!nextSet.has(prevIds[i])) return true;
    return false;
  }
  function planUpdate(prev, option) {
    const next = buildSignature(option);
    if (!prev) return {
      option,
      signature: next,
      plan: { notMerge: false }
    };
    if (next.optionsLength < prev.optionsLength) return {
      option,
      signature: next,
      plan: { notMerge: true }
    };
    if (next.mediaLength < prev.mediaLength) return {
      option,
      signature: next,
      plan: { notMerge: true }
    };
    if (diffKeys(prev.scalars, next.scalars).length > 0) return {
      option,
      signature: next,
      plan: { notMerge: true }
    };
    const replace = /* @__PURE__ */ new Set();
    const overrides = /* @__PURE__ */ new Map();
    const missingObjects = diffKeys(prev.objects, next.objects);
    for (let i = 0; i < missingObjects.length; i++) overrides.set(missingObjects[i], null);
    for (const key2 of Object.keys(prev.arrays)) {
      const prevArray = prev.arrays[key2];
      if (!prevArray) continue;
      const nextArray = next.arrays[key2];
      if (!nextArray) {
        if (prevArray.idsSorted.length > 0 || prevArray.noIdCount > 0) {
          overrides.set(key2, []);
          replace.add(key2);
        }
        continue;
      }
      if (hasMissingIds(prevArray.idsSorted, nextArray.idsSorted)) {
        replace.add(key2);
        continue;
      }
      if (nextArray.noIdCount < prevArray.noIdCount) replace.add(key2);
    }
    let normalizedOption = option;
    let signature = next;
    if (overrides.size > 0) {
      const clone2 = { ...option };
      overrides.forEach((value, key2) => {
        clone2[key2] = value;
      });
      normalizedOption = clone2;
      signature = buildSignature(normalizedOption);
    }
    const replaceMerge = replace.size > 0 ? Array.from(replace).sort() : void 0;
    return {
      option: normalizedOption,
      signature,
      plan: replaceMerge ? {
        notMerge: false,
        replaceMerge
      } : { notMerge: false }
    };
  }
  var style_default = "x-vue-echarts{display:block;width:100%;height:100%;min-width:0;}\nx-vue-echarts>:first-child,x-vue-echarts>:first-child>canvas{border-radius:inherit;}\n";
  if (typeof document !== "undefined") if (Array.isArray(document.adoptedStyleSheets) && "replaceSync" in CSSStyleSheet.prototype) {
    const sheet = new CSSStyleSheet();
    sheet.replaceSync(style_default);
    document.adoptedStyleSheets = [...document.adoptedStyleSheets, sheet];
  } else {
    const styleEl = document.createElement("style");
    styleEl.textContent = style_default;
    document.head.appendChild(styleEl);
  }
  const wcRegistered = register();
  const THEME_KEY = Symbol();
  const INIT_OPTIONS_KEY = Symbol();
  const UPDATE_OPTIONS_KEY = Symbol();
  var ECharts_default = vue.defineComponent({
    name: "Echarts",
    inheritAttrs: false,
    props: {
      option: Object,
      theme: { type: [Object, String] },
      initOptions: Object,
      updateOptions: Object,
      group: String,
      manualUpdate: Boolean,
      ...autoresizeProps,
      ...loadingProps
    },
    emits: {},
    slots: Object,
    setup(props, { attrs, expose, slots }) {
      const root = vue.shallowRef();
      const chart = vue.shallowRef();
      const defaultTheme = vue.inject(THEME_KEY, null);
      const defaultInitOptions = vue.inject(INIT_OPTIONS_KEY, null);
      const defaultUpdateOptions = vue.inject(UPDATE_OPTIONS_KEY, null);
      const { autoresize, manualUpdate, loading, loadingOptions } = vue.toRefs(props);
      const realTheme = vue.computed(() => props.theme || vue.toValue(defaultTheme));
      const realInitOptions = vue.computed(() => props.initOptions || vue.toValue(defaultInitOptions) || void 0);
      const realUpdateOptions = vue.computed(() => props.updateOptions || vue.toValue(defaultUpdateOptions));
      const nonEventAttrs = vue.computed(() => omitOn(attrs));
      const nativeListeners = {};
      const listeners = /* @__PURE__ */ new Map();
      const { teleportedSlots, patchOption } = useSlotOption(slots, () => {
        if (!manualUpdate.value && props.option && chart.value) applyOption(chart.value, props.option);
      });
      let lastSignature;
      function resolveUpdateOptions(plan) {
        const result = {};
        const replacements = ((plan == null ? void 0 : plan.replaceMerge) ?? []).filter((key2) => key2 != null);
        if (replacements.length > 0) result.replaceMerge = [...new Set(replacements)];
        if ((plan == null ? void 0 : plan.notMerge) !== void 0) result.notMerge = plan.notMerge;
        return result;
      }
      function applyOption(instance, option, override, manual = false) {
        const patched = patchOption(option);
        if (manual) {
          instance.setOption(patched, override ?? {});
          lastSignature = void 0;
          return;
        }
        if (realUpdateOptions.value) {
          const updateOptions$1 = override ?? realUpdateOptions.value;
          instance.setOption(patched, updateOptions$1);
          lastSignature = void 0;
          return;
        }
        const planned = planUpdate(lastSignature, patched);
        const updateOptions = resolveUpdateOptions(planned.plan);
        instance.setOption(planned.option, updateOptions);
        lastSignature = planned.signature;
      }
      Object.keys(attrs).filter((key2) => isOn(key2)).forEach((key2) => {
        if (key2.indexOf("Native:") === 2) {
          const nativeKey = `on${key2.charAt(9).toUpperCase()}${key2.slice(10)}`;
          nativeListeners[nativeKey] = attrs[key2];
          return;
        }
        let event = key2.charAt(2).toLowerCase() + key2.slice(3);
        let zr;
        if (event.indexOf("zr:") === 0) {
          zr = true;
          event = event.substring(3);
        }
        let once;
        if (event.substring(event.length - 4) === "Once") {
          once = true;
          event = event.substring(0, event.length - 4);
        }
        listeners.set({
          event,
          zr,
          once
        }, attrs[key2]);
      });
      function init$12() {
        if (!root.value) return;
        const instance = chart.value = init(root.value, realTheme.value, realInitOptions.value);
        if (props.group) instance.group = props.group;
        listeners.forEach((handler, { zr, once, event }) => {
          if (!handler) return;
          const target = zr ? instance.getZr() : instance;
          if (once) {
            const raw = handler;
            let called = false;
            handler = (...args) => {
              if (called) return;
              called = true;
              raw(...args);
              target.off(event, handler);
            };
          }
          target.on(event, handler);
        });
        function resize() {
          if (instance && !instance.isDisposed()) instance.resize();
        }
        function commit() {
          const { option } = props;
          if (manualUpdate.value) {
            if (option) applyOption(instance, option, void 0, true);
            return;
          }
          if (option) applyOption(instance, option);
        }
        if (autoresize.value) vue.nextTick(() => {
          resize();
          commit();
        });
        else commit();
      }
      const setOption = (option, notMerge, lazyUpdate) => {
        if (!props.manualUpdate) {
          warn$1("`setOption` is only available when `manual-update` is `true`.");
          return;
        }
        const updateOptions = typeof notMerge === "boolean" ? {
          notMerge,
          lazyUpdate
        } : notMerge;
        if (!chart.value) return;
        applyOption(chart.value, option, updateOptions ?? void 0, true);
      };
      function cleanup() {
        if (chart.value) {
          chart.value.dispose();
          chart.value = void 0;
        }
        lastSignature = void 0;
      }
      vue.watch(() => props.option, (option) => {
        if (!option) {
          lastSignature = void 0;
          return;
        }
        if (manualUpdate.value) {
          warn$1("`option` prop changes are ignored when `manual-update` is `true`.");
          return;
        }
        if (!chart.value) return;
        applyOption(chart.value, option);
      }, { deep: true });
      vue.watch([manualUpdate, realInitOptions], () => {
        cleanup();
        init$12();
      }, { deep: true });
      vue.watch(realTheme, (theme2) => {
        var _a2;
        (_a2 = chart.value) == null ? void 0 : _a2.setTheme(theme2 || {});
      }, { deep: true });
      vue.watchEffect(() => {
        if (props.group && chart.value) chart.value.group = props.group;
      });
      const publicApi = usePublicAPI(chart);
      useLoading(chart, loading, loadingOptions);
      useAutoresize(chart, autoresize, root);
      vue.onMounted(() => {
        init$12();
      });
      vue.onBeforeUnmount(() => {
        if (wcRegistered && root.value) root.value.__dispose = cleanup;
        else cleanup();
      });
      expose({
        setOption,
        root,
        chart,
        ...publicApi
      });
      return () => vue.h(TAG_NAME, {
        ...nonEventAttrs.value,
        ...nativeListeners,
        ref: root,
        class: ["echarts", nonEventAttrs.value.class]
      }, teleportedSlots());
    }
  });
  var src_default = ECharts_default;
  const _hoisted_1$2 = { class: "plugin-monitor-history" };
  const _hoisted_2$2 = { class: "time-range-selector" };
  const _hoisted_3$2 = {
    key: 0,
    class: "charts-container"
  };
  const _sfc_main$2 = /* @__PURE__ */ vue.defineComponent({
    __name: "PluginMonitorHistory",
    props: {
      pluginId: {}
    },
    setup(__props) {
      use([
        install$d,
        install$c,
        install$a,
        install$6,
        install$7,
        install$8,
        install$3,
        install
      ]);
      const RefreshOutline = useIcon("RefreshOutline");
      const props = __props;
      const historyData = vue.ref([]);
      const selectedTimeRange = vue.ref("1h");
      const loading = vue.ref(false);
      const memoryChartOption = vue.computed(() => {
        const timestamps = historyData.value.map((item) => new Date(item.timestamp));
        const memoryValues = historyData.value.map((item) => {
          return item.memoryUsage ? (item.memoryUsage / (1024 * 1024)).toFixed(2) : 0;
        });
        return {
          tooltip: {
            trigger: "axis",
            formatter: (params) => {
              const param = params[0];
              const date = new Date(param.axisValue);
              const timeStr = date.toLocaleString("zh-CN", {
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit"
              });
              return `${timeStr}<br/>内存使用: ${param.value} MB`;
            }
          },
          grid: {
            left: "3%",
            right: "4%",
            bottom: "15%",
            containLabel: true
          },
          xAxis: {
            type: "category",
            data: timestamps,
            axisLabel: {
              formatter: (value) => {
                const date = value instanceof Date ? value : new Date(value);
                return date.toLocaleTimeString("zh-CN", {
                  hour: "2-digit",
                  minute: "2-digit"
                });
              }
            }
          },
          yAxis: {
            type: "value",
            name: "内存 (MB)",
            axisLabel: {
              formatter: "{value} MB"
            }
          },
          dataZoom: [
            {
              type: "slider",
              start: 0,
              end: 100
            }
          ],
          series: [
            {
              name: "内存使用",
              type: "line",
              data: memoryValues,
              smooth: true,
              lineStyle: {
                color: "#18a058",
                width: 2
              },
              areaStyle: {
                color: {
                  type: "linear",
                  x: 0,
                  y: 0,
                  x2: 0,
                  y2: 1,
                  colorStops: [
                    { offset: 0, color: "rgba(24, 160, 88, 0.3)" },
                    { offset: 1, color: "rgba(24, 160, 88, 0.05)" }
                  ]
                }
              }
            }
          ]
        };
      });
      const stateTimelineOption = vue.computed(() => {
        const stateChanges = [];
        for (let i = 0; i < historyData.value.length; i++) {
          const current = historyData.value[i];
          const prev = i > 0 ? historyData.value[i - 1] : null;
          if (!prev || current.state !== prev.state) {
            stateChanges.push({
              time: new Date(current.timestamp),
              state: current.state,
              index: i
            });
          }
        }
        const timestamps = historyData.value.map((item) => new Date(item.timestamp));
        const stateValues = historyData.value.map((item) => getStateValue(item.state));
        const changePoints = stateChanges.map((change) => ({
          value: [change.time, getStateValue(change.state)],
          itemStyle: {
            color: getStateColor(change.state)
          }
        }));
        return {
          tooltip: {
            trigger: "axis",
            formatter: (params) => {
              const param = params[0];
              const date = new Date(param.axisValue);
              const timeStr = date.toLocaleString("zh-CN", {
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit"
              });
              const state = getStateLabel(param.value);
              return `${timeStr}<br/>状态: ${state}`;
            }
          },
          grid: {
            left: "3%",
            right: "4%",
            bottom: "15%",
            containLabel: true
          },
          xAxis: {
            type: "category",
            data: timestamps,
            axisLabel: {
              formatter: (value) => {
                const date = value instanceof Date ? value : new Date(value);
                return date.toLocaleTimeString("zh-CN", {
                  hour: "2-digit",
                  minute: "2-digit"
                });
              }
            }
          },
          yAxis: {
            type: "value",
            name: "状态",
            min: 0,
            max: 4,
            interval: 1,
            axisLabel: {
              formatter: (value) => getStateLabel(value)
            }
          },
          dataZoom: [
            {
              type: "slider",
              start: 0,
              end: 100
            }
          ],
          series: [
            {
              name: "状态",
              type: "line",
              data: stateValues,
              step: "end",
              lineStyle: {
                color: "#2080f0",
                width: 2
              }
            },
            {
              name: "状态变更",
              type: "scatter",
              data: changePoints,
              symbolSize: 10,
              z: 10
            }
          ]
        };
      });
      function getStateValue(state) {
        const stateMap = {
          "STARTED": 3,
          "STARTING": 2,
          "STOPPED": 1,
          "STOPPING": 2,
          "CREATED": 0,
          "DISABLED": 0
        };
        return stateMap[state] ?? 0;
      }
      function getStateLabel(value) {
        const labelMap = {
          0: "未启动",
          1: "已停止",
          2: "变更中",
          3: "运行中"
        };
        return labelMap[value] ?? "未知";
      }
      function getStateColor(state) {
        const colorMap = {
          "STARTED": "#18a058",
          "STARTING": "#f0a020",
          "STOPPED": "#d03050",
          "STOPPING": "#f0a020",
          "CREATED": "#909399",
          "DISABLED": "#909399"
        };
        return colorMap[state] ?? "#909399";
      }
      async function loadHistory() {
        if (!props.pluginId) {
          return;
        }
        loading.value = true;
        try {
          historyData.value = await pluginMonitorApi.getHistory(
            props.pluginId,
            selectedTimeRange.value
          );
          historyData.value.sort((a, b) => a.timestamp - b.timestamp);
        } catch (error2) {
          console.error("加载历史数据失败:", error2);
          historyData.value = [];
        } finally {
          loading.value = false;
        }
      }
      function refreshHistory() {
        loadHistory();
      }
      function handleTimeRangeChange() {
        loadHistory();
      }
      vue.watch(() => props.pluginId, () => {
        loadHistory();
      }, { immediate: true });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$2, [
          vue.createElementVNode("div", _hoisted_2$2, [
            vue.createVNode(vue.unref(naiveUi.NRadioGroup), {
              value: selectedTimeRange.value,
              "onUpdate:value": [
                _cache[0] || (_cache[0] = ($event) => selectedTimeRange.value = $event),
                handleTimeRangeChange
              ]
            }, {
              default: vue.withCtx(() => [
                vue.createVNode(vue.unref(naiveUi.NRadioButton), { value: "1h" }, {
                  default: vue.withCtx(() => [..._cache[1] || (_cache[1] = [
                    vue.createTextVNode("1小时", -1)
                  ])]),
                  _: 1
                }),
                vue.createVNode(vue.unref(naiveUi.NRadioButton), { value: "24h" }, {
                  default: vue.withCtx(() => [..._cache[2] || (_cache[2] = [
                    vue.createTextVNode("24小时", -1)
                  ])]),
                  _: 1
                }),
                vue.createVNode(vue.unref(naiveUi.NRadioButton), { value: "7d" }, {
                  default: vue.withCtx(() => [..._cache[3] || (_cache[3] = [
                    vue.createTextVNode("7天", -1)
                  ])]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["value"]),
            vue.createVNode(vue.unref(naiveUi.NButton), {
              onClick: refreshHistory,
              loading: loading.value,
              size: "small",
              class: "refresh-btn"
            }, {
              icon: vue.withCtx(() => [
                vue.createVNode(vue.unref(naiveUi.NIcon), null, {
                  default: vue.withCtx(() => [
                    (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(RefreshOutline))))
                  ]),
                  _: 1
                })
              ]),
              default: vue.withCtx(() => [
                _cache[4] || (_cache[4] = vue.createTextVNode(" 刷新 ", -1))
              ]),
              _: 1
            }, 8, ["loading"])
          ]),
          vue.createVNode(vue.unref(naiveUi.NSpin), { show: loading.value }, {
            default: vue.withCtx(() => [
              historyData.value.length > 0 ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_3$2, [
                vue.createVNode(vue.unref(naiveUi.NCard), {
                  title: "内存使用趋势",
                  class: "chart-card",
                  bordered: false
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(vue.unref(src_default), {
                      class: "chart",
                      option: memoryChartOption.value,
                      autoresize: ""
                    }, null, 8, ["option"])
                  ]),
                  _: 1
                }),
                vue.createVNode(vue.unref(naiveUi.NCard), {
                  title: "状态变更时间线",
                  class: "chart-card",
                  bordered: false
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(vue.unref(src_default), {
                      class: "chart timeline-chart",
                      option: stateTimelineOption.value,
                      autoresize: ""
                    }, null, 8, ["option"])
                  ]),
                  _: 1
                })
              ])) : !loading.value ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NEmpty), {
                key: 1,
                description: "暂无历史数据",
                class: "empty-state"
              })) : vue.createCommentVNode("", true)
            ]),
            _: 1
          }, 8, ["show"])
        ]);
      };
    }
  });
  const PluginMonitorHistory = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-2d9dee19"]]);
  const _hoisted_1$1 = { class: "plugin-monitor-detail" };
  const _hoisted_2$1 = { key: 0 };
  const _hoisted_3$1 = ["href"];
  const _hoisted_4$1 = { key: 1 };
  const _hoisted_5 = { key: 0 };
  const _hoisted_6 = { key: 0 };
  const _sfc_main$1 = /* @__PURE__ */ vue.defineComponent({
    __name: "PluginMonitorDetail",
    props: {
      pluginId: {}
    },
    setup(__props) {
      const WarningOutline = useIcon("WarningOutline");
      const props = __props;
      const detail = vue.ref(null);
      const loading = vue.ref(false);
      const hasDependencies = vue.computed(() => {
        var _a2, _b2;
        return ((_b2 = (_a2 = detail.value) == null ? void 0 : _a2.metadata) == null ? void 0 : _b2.dependencies) && Array.isArray(detail.value.metadata.dependencies) && detail.value.metadata.dependencies.length > 0;
      });
      const hasConfiguration = vue.computed(() => {
        var _a2;
        return ((_a2 = detail.value) == null ? void 0 : _a2.configuration) && Object.keys(detail.value.configuration).length > 0;
      });
      function getDependencies2() {
        var _a2, _b2;
        if (!((_b2 = (_a2 = detail.value) == null ? void 0 : _a2.metadata) == null ? void 0 : _b2.dependencies)) {
          return [];
        }
        const deps = detail.value.metadata.dependencies;
        if (Array.isArray(deps)) {
          return deps;
        }
        return [];
      }
      function formatConfiguration() {
        var _a2;
        if (!((_a2 = detail.value) == null ? void 0 : _a2.configuration)) {
          return "{}";
        }
        try {
          return JSON.stringify(detail.value.configuration, null, 2);
        } catch (e2) {
          return "{}";
        }
      }
      function formatMemory(bytes) {
        if (!bytes || bytes === 0) {
          return "不可用";
        }
        if (bytes < 1024) {
          return `${bytes} B`;
        } else if (bytes < 1024 * 1024) {
          return `${(bytes / 1024).toFixed(2)} KB`;
        } else if (bytes < 1024 * 1024 * 1024) {
          return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
        } else {
          return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;
        }
      }
      function formatStartTime(timestamp) {
        if (!timestamp) {
          return "未知";
        }
        const date = new Date(timestamp);
        return date.toLocaleString("zh-CN", {
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit"
        });
      }
      function formatUptime(uptime) {
        if (!uptime || uptime === 0) {
          return "未运行";
        }
        const seconds = Math.floor(uptime / 1e3);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);
        if (days > 0) {
          return `${days} 天 ${hours % 24} 小时`;
        } else if (hours > 0) {
          return `${hours} 小时 ${minutes % 60} 分钟`;
        } else if (minutes > 0) {
          return `${minutes} 分钟 ${seconds % 60} 秒`;
        } else {
          return `${seconds} 秒`;
        }
      }
      function getStateType(state) {
        if (!state) return "info";
        switch (state) {
          case "STARTED":
            return "success";
          case "STOPPED":
            return "error";
          case "STARTING":
          case "STOPPING":
            return "warning";
          default:
            return "info";
        }
      }
      async function loadDetail() {
        if (!props.pluginId) {
          return;
        }
        loading.value = true;
        try {
          detail.value = await pluginMonitorApi.getDetail(props.pluginId);
        } catch (error2) {
          console.error("加载插件详情失败:", error2);
          detail.value = null;
        } finally {
          loading.value = false;
        }
      }
      vue.watch(() => props.pluginId, () => {
        loadDetail();
      }, { immediate: true });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$1, [
          vue.createVNode(vue.unref(naiveUi.NSpin), { show: loading.value }, {
            default: vue.withCtx(() => {
              var _a2, _b2;
              return [
                detail.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$1, [
                  ((_a2 = detail.value.status) == null ? void 0 : _a2.hasError) && ((_b2 = detail.value.status) == null ? void 0 : _b2.errorMessage) ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NAlert), {
                    key: 0,
                    type: "error",
                    "show-icon": true,
                    class: "error-alert"
                  }, {
                    header: vue.withCtx(() => [..._cache[0] || (_cache[0] = [
                      vue.createTextVNode("错误信息", -1)
                    ])]),
                    default: vue.withCtx(() => [
                      vue.createTextVNode(" " + vue.toDisplayString(detail.value.status.errorMessage), 1)
                    ]),
                    _: 1
                  })) : vue.createCommentVNode("", true),
                  vue.createVNode(vue.unref(naiveUi.NTabs), {
                    type: "line",
                    animated: ""
                  }, {
                    default: vue.withCtx(() => [
                      vue.createVNode(vue.unref(naiveUi.NTabPane), {
                        name: "detail",
                        tab: "详细信息"
                      }, {
                        default: vue.withCtx(() => [
                          vue.createVNode(vue.unref(naiveUi.NCard), {
                            title: "基本信息",
                            class: "info-card",
                            bordered: false
                          }, {
                            default: vue.withCtx(() => [
                              vue.createVNode(vue.unref(naiveUi.NDescriptions), {
                                column: 1,
                                "label-placement": "left",
                                bordered: ""
                              }, {
                                default: vue.withCtx(() => [
                                  vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "插件ID" }, {
                                    default: vue.withCtx(() => {
                                      var _a3;
                                      return [
                                        vue.createTextVNode(vue.toDisplayString((_a3 = detail.value.status) == null ? void 0 : _a3.pluginId), 1)
                                      ];
                                    }),
                                    _: 1
                                  }),
                                  vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "插件名称" }, {
                                    default: vue.withCtx(() => {
                                      var _a3;
                                      return [
                                        vue.createTextVNode(vue.toDisplayString((_a3 = detail.value.status) == null ? void 0 : _a3.pluginName), 1)
                                      ];
                                    }),
                                    _: 1
                                  }),
                                  vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "版本" }, {
                                    default: vue.withCtx(() => {
                                      var _a3;
                                      return [
                                        vue.createTextVNode(vue.toDisplayString(((_a3 = detail.value.status) == null ? void 0 : _a3.pluginVersion) || "未知"), 1)
                                      ];
                                    }),
                                    _: 1
                                  }),
                                  vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "运行状态" }, {
                                    default: vue.withCtx(() => {
                                      var _a3;
                                      return [
                                        vue.createVNode(vue.unref(naiveUi.NTag), {
                                          type: getStateType((_a3 = detail.value.status) == null ? void 0 : _a3.state),
                                          size: "small"
                                        }, {
                                          default: vue.withCtx(() => {
                                            var _a4;
                                            return [
                                              vue.createTextVNode(vue.toDisplayString((_a4 = detail.value.status) == null ? void 0 : _a4.state), 1)
                                            ];
                                          }),
                                          _: 1
                                        }, 8, ["type"])
                                      ];
                                    }),
                                    _: 1
                                  }),
                                  vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "加载状态" }, {
                                    default: vue.withCtx(() => {
                                      var _a3;
                                      return [
                                        vue.createVNode(vue.unref(naiveUi.NTag), {
                                          type: ((_a3 = detail.value.status) == null ? void 0 : _a3.loaded) ? "success" : "error",
                                          size: "small"
                                        }, {
                                          default: vue.withCtx(() => {
                                            var _a4;
                                            return [
                                              vue.createTextVNode(vue.toDisplayString(((_a4 = detail.value.status) == null ? void 0 : _a4.loaded) ? "已加载" : "未加载"), 1)
                                            ];
                                          }),
                                          _: 1
                                        }, 8, ["type"])
                                      ];
                                    }),
                                    _: 1
                                  })
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          }),
                          vue.createVNode(vue.unref(naiveUi.NCard), {
                            title: "运行时信息",
                            class: "info-card",
                            bordered: false
                          }, {
                            default: vue.withCtx(() => [
                              vue.createVNode(vue.unref(naiveUi.NDescriptions), {
                                column: 1,
                                "label-placement": "left",
                                bordered: ""
                              }, {
                                default: vue.withCtx(() => [
                                  vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "启动时间" }, {
                                    default: vue.withCtx(() => {
                                      var _a3;
                                      return [
                                        vue.createTextVNode(vue.toDisplayString(formatStartTime((_a3 = detail.value.status) == null ? void 0 : _a3.startTime)), 1)
                                      ];
                                    }),
                                    _: 1
                                  }),
                                  vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "运行时长" }, {
                                    default: vue.withCtx(() => {
                                      var _a3;
                                      return [
                                        vue.createTextVNode(vue.toDisplayString(formatUptime((_a3 = detail.value.status) == null ? void 0 : _a3.uptime)), 1)
                                      ];
                                    }),
                                    _: 1
                                  })
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          }),
                          vue.createVNode(vue.unref(naiveUi.NCard), {
                            title: "内存信息",
                            class: "info-card",
                            bordered: false
                          }, {
                            default: vue.withCtx(() => [
                              vue.createVNode(vue.unref(naiveUi.NDescriptions), {
                                column: 1,
                                "label-placement": "left",
                                bordered: ""
                              }, {
                                default: vue.withCtx(() => [
                                  vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "插件内存使用" }, {
                                    default: vue.withCtx(() => {
                                      var _a3, _b3, _c2;
                                      return [
                                        vue.createElementVNode("span", {
                                          class: vue.normalizeClass({ "memory-warning": (_a3 = detail.value.status) == null ? void 0 : _a3.isMemoryWarning })
                                        }, [
                                          vue.createTextVNode(vue.toDisplayString(((_b3 = detail.value.memoryInfo) == null ? void 0 : _b3.formattedMemory) || "不可用") + " ", 1),
                                          ((_c2 = detail.value.status) == null ? void 0 : _c2.isMemoryWarning) ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NIcon), {
                                            key: 0,
                                            size: "16",
                                            color: "#f0a020"
                                          }, {
                                            default: vue.withCtx(() => [
                                              (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(WarningOutline))))
                                            ]),
                                            _: 1
                                          })) : vue.createCommentVNode("", true)
                                        ], 2)
                                      ];
                                    }),
                                    _: 1
                                  }),
                                  vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "JVM 总内存" }, {
                                    default: vue.withCtx(() => {
                                      var _a3;
                                      return [
                                        vue.createTextVNode(vue.toDisplayString(formatMemory((_a3 = detail.value.memoryInfo) == null ? void 0 : _a3.totalJvmMemory)), 1)
                                      ];
                                    }),
                                    _: 1
                                  }),
                                  vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "JVM 空闲内存" }, {
                                    default: vue.withCtx(() => {
                                      var _a3;
                                      return [
                                        vue.createTextVNode(vue.toDisplayString(formatMemory((_a3 = detail.value.memoryInfo) == null ? void 0 : _a3.freeJvmMemory)), 1)
                                      ];
                                    }),
                                    _: 1
                                  }),
                                  vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "JVM 最大内存" }, {
                                    default: vue.withCtx(() => {
                                      var _a3;
                                      return [
                                        vue.createTextVNode(vue.toDisplayString(formatMemory((_a3 = detail.value.memoryInfo) == null ? void 0 : _a3.maxJvmMemory)), 1)
                                      ];
                                    }),
                                    _: 1
                                  })
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          }),
                          vue.createVNode(vue.unref(naiveUi.NCard), {
                            title: "元数据",
                            class: "info-card",
                            bordered: false
                          }, {
                            default: vue.withCtx(() => [
                              vue.createVNode(vue.unref(naiveUi.NDescriptions), {
                                column: 1,
                                "label-placement": "left",
                                bordered: ""
                              }, {
                                default: vue.withCtx(() => [
                                  vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "作者" }, {
                                    default: vue.withCtx(() => {
                                      var _a3;
                                      return [
                                        vue.createTextVNode(vue.toDisplayString(((_a3 = detail.value.metadata) == null ? void 0 : _a3.author) || "未知"), 1)
                                      ];
                                    }),
                                    _: 1
                                  }),
                                  vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "描述" }, {
                                    default: vue.withCtx(() => {
                                      var _a3;
                                      return [
                                        vue.createTextVNode(vue.toDisplayString(((_a3 = detail.value.metadata) == null ? void 0 : _a3.description) || "无描述"), 1)
                                      ];
                                    }),
                                    _: 1
                                  }),
                                  vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "主页" }, {
                                    default: vue.withCtx(() => {
                                      var _a3;
                                      return [
                                        ((_a3 = detail.value.metadata) == null ? void 0 : _a3.homepage) ? (vue.openBlock(), vue.createElementBlock("a", {
                                          key: 0,
                                          href: detail.value.metadata.homepage,
                                          target: "_blank",
                                          rel: "noopener noreferrer"
                                        }, vue.toDisplayString(detail.value.metadata.homepage), 9, _hoisted_3$1)) : (vue.openBlock(), vue.createElementBlock("span", _hoisted_4$1, "无"))
                                      ];
                                    }),
                                    _: 1
                                  })
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          }),
                          vue.createVNode(vue.unref(naiveUi.NCard), {
                            title: "依赖信息",
                            class: "info-card",
                            bordered: false
                          }, {
                            default: vue.withCtx(() => [
                              hasDependencies.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_5, [
                                (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(getDependencies2(), (dep, index2) => {
                                  return vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NTag), {
                                    key: index2,
                                    type: "info",
                                    size: "small",
                                    class: "dependency-tag"
                                  }, {
                                    default: vue.withCtx(() => [
                                      vue.createTextVNode(vue.toDisplayString(dep), 1)
                                    ]),
                                    _: 2
                                  }, 1024);
                                }), 128))
                              ])) : (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NEmpty), {
                                key: 1,
                                description: "无依赖",
                                size: "small"
                              }))
                            ]),
                            _: 1
                          }),
                          vue.createVNode(vue.unref(naiveUi.NCard), {
                            title: "配置信息",
                            class: "info-card",
                            bordered: false
                          }, {
                            default: vue.withCtx(() => [
                              hasConfiguration.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_6, [
                                vue.createVNode(vue.unref(naiveUi.NCode), {
                                  code: formatConfiguration(),
                                  language: "json",
                                  "word-wrap": true
                                }, null, 8, ["code"])
                              ])) : (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NEmpty), {
                                key: 1,
                                description: "无配置",
                                size: "small"
                              }))
                            ]),
                            _: 1
                          }),
                          vue.createVNode(vue.unref(naiveUi.NCard), {
                            title: "类加载器信息",
                            class: "info-card",
                            bordered: false
                          }, {
                            default: vue.withCtx(() => [
                              vue.createVNode(vue.unref(naiveUi.NDescriptions), {
                                column: 1,
                                "label-placement": "left",
                                bordered: ""
                              }, {
                                default: vue.withCtx(() => [
                                  vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "类加载器" }, {
                                    default: vue.withCtx(() => {
                                      var _a3;
                                      return [
                                        vue.createTextVNode(vue.toDisplayString(((_a3 = detail.value.classLoaderInfo) == null ? void 0 : _a3.className) || "不可用"), 1)
                                      ];
                                    }),
                                    _: 1
                                  }),
                                  vue.createVNode(vue.unref(naiveUi.NDescriptionsItem), { label: "父类加载器" }, {
                                    default: vue.withCtx(() => {
                                      var _a3;
                                      return [
                                        vue.createTextVNode(vue.toDisplayString(((_a3 = detail.value.classLoaderInfo) == null ? void 0 : _a3.parentClassName) || "不可用"), 1)
                                      ];
                                    }),
                                    _: 1
                                  })
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      vue.createVNode(vue.unref(naiveUi.NTabPane), {
                        name: "history",
                        tab: "历史数据"
                      }, {
                        default: vue.withCtx(() => [
                          vue.createVNode(PluginMonitorHistory, { "plugin-id": __props.pluginId }, null, 8, ["plugin-id"])
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ])) : !loading.value ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NEmpty), {
                  key: 1,
                  description: "无法加载插件详情"
                })) : vue.createCommentVNode("", true)
              ];
            }),
            _: 1
          }, 8, ["show"])
        ]);
      };
    }
  });
  const PluginMonitorDetail = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-5b2f9972"]]);
  const _hoisted_1 = { class: "plugin-monitor-dashboard" };
  const _hoisted_2 = {
    key: 0,
    class: "refresh-interval-text"
  };
  const _hoisted_3 = { class: "page-content" };
  const _hoisted_4 = { class: "overview-cards" };
  const _sfc_main = /* @__PURE__ */ vue.defineComponent({
    __name: "PluginMonitorDashboard",
    setup(__props) {
      const CheckmarkCircleOutline = useIcon("CheckmarkCircleOutline");
      const StopCircleOutline = useIcon("StopCircleOutline");
      const WarningOutline = useIcon("WarningOutline");
      const pluginList = vue.ref([]);
      const overview = vue.ref({
        totalPlugins: 0,
        runningPlugins: 0,
        stoppedPlugins: 0,
        errorPlugins: 0,
        totalMemoryUsage: 0
      });
      const loading = vue.ref(false);
      const autoRefresh = vue.ref(false);
      const refreshInterval = vue.ref(5e3);
      let refreshTimer = null;
      const showDetail = vue.ref(false);
      const selectedPluginId = vue.ref("");
      const drawerWidth = vue.ref(600);
      function updateDrawerWidth() {
        const width = window.innerWidth;
        if (width < 768) {
          drawerWidth.value = width;
        } else if (width < 1024) {
          drawerWidth.value = Math.min(500, width * 0.8);
        } else {
          drawerWidth.value = 600;
        }
      }
      const pagination = vue.ref({
        page: 1,
        pageSize: 10,
        showSizePicker: true,
        pageSizes: [10, 20, 50, 100],
        onChange: (page) => {
          pagination.value.page = page;
        },
        onUpdatePageSize: (pageSize) => {
          pagination.value.pageSize = pageSize;
          pagination.value.page = 1;
        }
      });
      function renderPluginId(row) {
        if (row.hasError) {
          return vue.h(
            "span",
            {
              style: {
                display: "flex",
                alignItems: "center",
                gap: "6px"
              }
            },
            [
              vue.h(naiveUi.NIcon, { size: 16, color: "#d03050" }, { default: () => vue.h(WarningOutline) }),
              row.pluginId
            ]
          );
        }
        return vue.h("span", row.pluginId);
      }
      function renderState(row) {
        return vue.h(
          naiveUi.NTag,
          {
            type: getStateType(row.state),
            size: "small"
          },
          { default: () => row.state }
        );
      }
      function renderLoaded(row) {
        return vue.h(
          naiveUi.NTag,
          {
            type: row.loaded ? "success" : "error",
            size: "small"
          },
          { default: () => row.loaded ? "已加载" : "未加载" }
        );
      }
      function renderMemory(row) {
        var _a2;
        const memory = ((_a2 = row.memoryInfo) == null ? void 0 : _a2.formattedMemory) || "不可用";
        const isWarning = row.isMemoryWarning || false;
        if (isWarning) {
          return vue.h(
            "span",
            {
              style: {
                color: "#f0a020",
                fontWeight: "bold",
                display: "flex",
                alignItems: "center",
                gap: "4px"
              }
            },
            [
              vue.h(naiveUi.NIcon, { size: 16 }, { default: () => vue.h(WarningOutline) }),
              memory
            ]
          );
        }
        return vue.h("span", memory);
      }
      function renderActions(row) {
        return vue.h(
          naiveUi.NButton,
          {
            text: true,
            type: "primary",
            size: "small",
            onClick: () => handleViewDetail(row)
          },
          { default: () => "详情" }
        );
      }
      const columns = [
        {
          title: "插件ID",
          key: "pluginId",
          width: 200,
          render: renderPluginId
        },
        {
          title: "插件名称",
          key: "pluginName",
          width: 150
        },
        {
          title: "版本",
          key: "pluginVersion",
          width: 100
        },
        {
          title: "运行状态",
          key: "state",
          width: 120,
          render: renderState
        },
        {
          title: "加载状态",
          key: "loaded",
          width: 120,
          render: renderLoaded
        },
        {
          title: "内存使用",
          key: "memoryInfo",
          width: 120,
          render: renderMemory
        },
        {
          title: "操作",
          key: "actions",
          width: 100,
          render: renderActions
        }
      ];
      function getStateType(state) {
        switch (state) {
          case "STARTED":
            return "success";
          case "STOPPED":
            return "error";
          case "STARTING":
          case "STOPPING":
            return "warning";
          default:
            return "info";
        }
      }
      async function refreshData() {
        loading.value = true;
        try {
          const [statusData, overviewData] = await Promise.all([
            pluginMonitorApi.getAllStatus(),
            pluginMonitorApi.getOverview()
          ]);
          pluginList.value = statusData;
          overview.value = overviewData;
        } catch (error2) {
          console.error("刷新监控数据失败:", error2);
        } finally {
          loading.value = false;
        }
      }
      function toggleAutoRefresh(enabled) {
        if (enabled) {
          refreshTimer = window.setInterval(refreshData, refreshInterval.value);
        } else {
          if (refreshTimer) {
            clearInterval(refreshTimer);
            refreshTimer = null;
          }
        }
      }
      function handleViewDetail(plugin) {
        selectedPluginId.value = plugin.pluginId;
        showDetail.value = true;
      }
      vue.onMounted(() => {
        refreshData();
        updateDrawerWidth();
        window.addEventListener("resize", updateDrawerWidth);
      });
      vue.onUnmounted(() => {
        if (refreshTimer) {
          clearInterval(refreshTimer);
        }
        window.removeEventListener("resize", updateDrawerWidth);
      });
      return (_ctx, _cache) => {
        const _component_n_switch = vue.resolveComponent("n-switch");
        const _component_n_space = vue.resolveComponent("n-space");
        const _component_PageHeader = vue.resolveComponent("PageHeader");
        const _component_n_statistic = vue.resolveComponent("n-statistic");
        const _component_n_card = vue.resolveComponent("n-card");
        const _component_n_data_table = vue.resolveComponent("n-data-table");
        const _component_n_drawer_content = vue.resolveComponent("n-drawer-content");
        const _component_n_drawer = vue.resolveComponent("n-drawer");
        return vue.openBlock(), vue.createElementBlock("div", _hoisted_1, [
          vue.createVNode(_component_PageHeader, {
            title: "插件监控",
            subtitle: "实时监控插件运行状态、内存使用和性能指标"
          }, {
            actions: vue.withCtx(() => [
              vue.createVNode(_component_n_space, { align: "center" }, {
                default: vue.withCtx(() => [
                  vue.createVNode(_component_n_switch, {
                    value: autoRefresh.value,
                    "onUpdate:value": [
                      _cache[0] || (_cache[0] = ($event) => autoRefresh.value = $event),
                      toggleAutoRefresh
                    ]
                  }, {
                    checked: vue.withCtx(() => [..._cache[2] || (_cache[2] = [
                      vue.createTextVNode("自动刷新", -1)
                    ])]),
                    unchecked: vue.withCtx(() => [..._cache[3] || (_cache[3] = [
                      vue.createTextVNode("自动刷新", -1)
                    ])]),
                    _: 1
                  }, 8, ["value"]),
                  autoRefresh.value ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_2, " 每 " + vue.toDisplayString(refreshInterval.value / 1e3) + "s ", 1)) : vue.createCommentVNode("", true),
                  vue.createVNode(vue.unref(naiveUi.NButton), {
                    loading: loading.value,
                    onClick: refreshData
                  }, {
                    default: vue.withCtx(() => [..._cache[4] || (_cache[4] = [
                      vue.createTextVNode("刷新", -1)
                    ])]),
                    _: 1
                  }, 8, ["loading"])
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          vue.createElementVNode("div", _hoisted_3, [
            vue.createElementVNode("div", _hoisted_4, [
              vue.createVNode(_component_n_card, { class: "overview-card" }, {
                default: vue.withCtx(() => [
                  vue.createVNode(_component_n_statistic, {
                    label: "总插件数",
                    value: overview.value.totalPlugins
                  }, null, 8, ["value"])
                ]),
                _: 1
              }),
              vue.createVNode(_component_n_card, { class: "overview-card" }, {
                default: vue.withCtx(() => [
                  vue.createVNode(_component_n_statistic, {
                    label: "运行中",
                    value: overview.value.runningPlugins
                  }, {
                    suffix: vue.withCtx(() => [
                      vue.createVNode(vue.unref(naiveUi.NIcon), {
                        size: "20",
                        color: "#18a058"
                      }, {
                        default: vue.withCtx(() => [
                          (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(CheckmarkCircleOutline))))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["value"])
                ]),
                _: 1
              }),
              vue.createVNode(_component_n_card, { class: "overview-card" }, {
                default: vue.withCtx(() => [
                  vue.createVNode(_component_n_statistic, {
                    label: "已停止",
                    value: overview.value.stoppedPlugins
                  }, {
                    suffix: vue.withCtx(() => [
                      vue.createVNode(vue.unref(naiveUi.NIcon), {
                        size: "20",
                        color: "#d03050"
                      }, {
                        default: vue.withCtx(() => [
                          (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(StopCircleOutline))))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["value"])
                ]),
                _: 1
              }),
              vue.createVNode(_component_n_card, { class: "overview-card" }, {
                default: vue.withCtx(() => [
                  vue.createVNode(_component_n_statistic, {
                    label: "异常",
                    value: overview.value.errorPlugins
                  }, {
                    suffix: vue.withCtx(() => [
                      vue.createVNode(vue.unref(naiveUi.NIcon), {
                        size: "20",
                        color: "#f0a020"
                      }, {
                        default: vue.withCtx(() => [
                          (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(WarningOutline))))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["value"])
                ]),
                _: 1
              })
            ]),
            overview.value.errorPlugins > 0 ? (vue.openBlock(), vue.createBlock(vue.unref(naiveUi.NAlert), {
              key: 0,
              type: "warning",
              closable: "",
              class: "error-alert"
            }, {
              icon: vue.withCtx(() => [
                vue.createVNode(vue.unref(naiveUi.NIcon), null, {
                  default: vue.withCtx(() => [
                    (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(WarningOutline))))
                  ]),
                  _: 1
                })
              ]),
              header: vue.withCtx(() => [
                vue.createTextVNode(" 发现 " + vue.toDisplayString(overview.value.errorPlugins) + " 个异常插件 ", 1)
              ]),
              default: vue.withCtx(() => [
                _cache[5] || (_cache[5] = vue.createTextVNode(" 请检查插件列表中标记为异常的插件，点击详情查看错误信息 ", -1))
              ]),
              _: 1
            })) : vue.createCommentVNode("", true),
            vue.createVNode(_component_n_card, null, {
              default: vue.withCtx(() => [
                vue.createVNode(_component_n_data_table, {
                  columns,
                  data: pluginList.value,
                  loading: loading.value,
                  pagination: pagination.value,
                  "row-key": (row) => row.pluginId,
                  striped: ""
                }, null, 8, ["data", "loading", "pagination", "row-key"])
              ]),
              _: 1
            })
          ]),
          vue.createVNode(_component_n_drawer, {
            show: showDetail.value,
            "onUpdate:show": _cache[1] || (_cache[1] = ($event) => showDetail.value = $event),
            width: drawerWidth.value,
            placement: "right"
          }, {
            default: vue.withCtx(() => [
              vue.createVNode(_component_n_drawer_content, {
                title: "插件详情",
                closable: ""
              }, {
                default: vue.withCtx(() => [
                  selectedPluginId.value ? (vue.openBlock(), vue.createBlock(PluginMonitorDetail, {
                    key: 0,
                    "plugin-id": selectedPluginId.value
                  }, null, 8, ["plugin-id"])) : vue.createCommentVNode("", true)
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["show", "width"])
        ]);
      };
    }
  });
  const PluginMonitorDashboard = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-9372efef"]]);
  const defaultConfig = {
    enabled: true
  };
  const index = (bridge, properties) => {
    console.log("[AppStore] Factory function called with bridge:", bridge);
    console.log("[AppStore] Configuration properties:", properties);
    const config = {
      ...defaultConfig,
      ...properties || {}
    };
    console.log("[AppStore] Merged config:", config);
    return {
      id: "appstore",
      name: "应用商店",
      version: "1.0.0",
      description: "应用商店管理与浏览插件",
      author: {
        name: "Gress Team"
      },
      icon: "appstore",
      permissions: [
        PluginPermission.NETWORK_ACCESS,
        PluginPermission.ROUTER_REGISTER,
        PluginPermission.ROUTER_NAVIGATE,
        PluginPermission.COMPONENT_REGISTER,
        PluginPermission.DATA_READ,
        PluginPermission.DATA_WRITE,
        PluginPermission.STORAGE_READ,
        PluginPermission.STORAGE_WRITE,
        PluginPermission.UI_MENU
      ],
      loadStrategy: "lazy",
      /**
       * 组件注册表（名称 -> 组件实例）
       *
       * - 后端 plugin-ui.yml 中只写组件名称（如 AppStorePage / AppStoreAdminPage）
       * - 宿主通过 PluginRuntime 获取 manifest.components 后按名称查找组件：
       *   const runtime = getPluginRuntime()
       *   const plugin = runtime.get('appstore')
       *   const comp = plugin?.manifest.components?.['AppStorePage']
       */
      components: {
        ApplicationManagement,
        OperationLog,
        MiddlewareManagement,
        NodeManagement,
        PluginMonitorDashboard
      },
      extensions: {
        // 这里不再重复定义 routes，交由后端 yml 管理，避免前后端路由信息重复维护
        routes: [],
        // 组件扩展（可选，保留以兼容旧逻辑）
        components: [],
        menus: []
      },
      lifecycle: {
        async install(context) {
          const { logger } = context;
          const { ui, app } = bridge;
          logger.info("Installing AppStore plugin");
          const naiveComponents = [
            "NButton",
            "NCard",
            "NInput",
            "NPagination",
            "NSpin",
            "NTag",
            "NModal",
            "NSelect",
            "NTable",
            "NSpace",
            "NAlert",
            "NForm",
            "NFormItem",
            "NInputNumber",
            "NDataTable",
            "NDrawer",
            "NDrawerContent",
            "NEmpty",
            "NTabPane",
            "NTabs",
            "NStatistic",
            "NIcon",
            "NSwitch",
            "NDescriptions",
            "NDescriptionsItem"
          ];
          if (ui && ui.components) {
            naiveComponents.forEach((name) => {
              const component = ui.components[name];
              if (component && app) {
                app.component(name, component);
              }
            });
            logger.debug("NaiveUI components registered via bridge");
          } else {
            logger.warn("UI bridge not available, skipping component registration");
          }
        },
        async activate(context) {
          const { logger } = context;
          logger.info("Activating AppStore plugin");
        },
        async deactivate(context) {
          const { logger } = context;
          logger.info("Deactivating AppStore plugin");
        }
      },
      config: {
        default: config
      },
      extra: {
        category: "application",
        tags: ["appstore", "market", "plugin"]
      }
    };
  };
  exports.default = index;
  Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
  return exports;
}({}, Vue, NaiveUI);
